Method Signature,Method Body
.SunflowGUI.usage,"    public static void usage(boolean verbose) {
        System.out.println(""Usage: SunflowGUI [options] scenefile"");
        if (verbose) {
            System.out.println(""Sunflow v"" + SunflowAPI.VERSION + "" textmode"");
            System.out.println(""Renders the specified scene file"");
            System.out.println(""Options:"");
            System.out.println(""  -o filename      Saves the output as the specified filename (png, hdr, tga)"");
            System.out.println(""                   #'s get expanded to the current frame number"");
            System.out.println(""  -nogui           Don't open the frame showing rendering progress"");
            System.out.println(""  -ipr             Render using progressive algorithm"");
            System.out.println(""  -sampler type    Render using the specified algorithm"");
            System.out.println(""  -threads n       Render using n threads"");
            System.out.println(""  -lopri           Set thread priority to low (default)"");
            System.out.println(""  -hipri           Set thread priority to high"");
            System.out.println(""  -smallmesh       Load triangle meshes using triangles optimized for memory use"");
            System.out.println(""  -dumpkd          Dump KDTree to an obj file for visualization"");
            System.out.println(""  -buildonly       Do not call render method after loading the scene"");
            System.out.println(""  -showaa          Display sampling levels per pixel for bucket renderer"");
            System.out.println(""  -nogi            Disable any global illumination engines in the scene"");
            System.out.println(""  -nocaustics      Disable any caustic engine in the scene"");
            System.out.println(""  -pathgi n        Use path tracing with n samples to render global illumination"");
            System.out.println(""  -quick_ambocc d  Applies ambient occlusion to the scene with specified maximum distance"");
            System.out.println(""  -quick_uvs       Applies a surface uv visualization shader to the scene"");
            System.out.println(""  -quick_normals   Applies a surface normal visualization shader to the scene"");
            System.out.println(""  -quick_id        Renders using a unique color for each instance"");
            System.out.println(""  -quick_prims     Renders using a unique color for each primitive"");
            System.out.println(""  -quick_gray      Renders using a plain gray diffuse shader"");
            System.out.println(""  -quick_wire      Renders using a wireframe shader"");
            System.out.println(""  -resolution w h  Changes the render resolution to the specified width and height (in pixels)"");
            System.out.println(""  -aa min max      Overrides the image anti-aliasing depths"");
            System.out.println(""  -bucket n order  Changes the default bucket size to n pixels and the default order"");
            System.out.println(""  -bake name       Bakes a lightmap for the specified instance"");
            System.out.println(""  -bakedir dir     Selects the type of lightmap baking: dir=view or ortho"");
            System.out.println(""  -filter type     Selects the image filter to use"");
            System.out.println(""  -bench           Run several built-in scenes for benchmark purposes"");
            System.out.println(""  -rtbench         Run realtime ray-tracing benchmark"");
            System.out.println(""  -frame n         Set frame number to the specified value"");
            System.out.println(""  -anim n1 n2      Render all frames between the two specified values (inclusive)"");
            System.out.println(""  -v verbosity     Set the verbosity level: 0=none,1=errors,2=warnings,3=info,4=detailed"");
            System.out.println(""  -h               Prints this message"");
        }
        System.exit(1);
    }"
.SunflowGUI.main,"    public static void main(String[] args) {
        if (args.length > 0) {
            boolean showFrame = true;
            String sampler = ""bucket"";
            boolean noRender = false;
            String filename = null;
            String input = null;
            int i = 0;
            int threads = 0;
            boolean lowPriority = true;
            boolean showAA = false;
            boolean noGI = false;
            boolean noCaustics = false;
            int pathGI = 0;
            Shader shaderOverride = null;
            int resolutionW = 0, resolutionH = 0;
            int aaMin = -5, aaMax = -5;
            int bucketSize = 0;
            String bucketOrder = null;
            String bakingName = null;
            boolean bakeViewdep = false;
            String filterType = null;
            boolean runBenchmark = false;
            boolean runRTBenchmark = false;
            int frameStart = 1, frameStop = 1;
            while (i < args.length) {
                if (args[i].equals(""-o"")) {
                    if (i > args.length - 2)
                        usage(false);
                    filename = args[i + 1];
                    i += 2;
                } else if (args[i].equals(""-nogui"")) {
                    showFrame = false;
                    i++;
                } else if (args[i].equals(""-ipr"")) {
                    sampler = ""ipr"";
                    i++;
                } else if (args[i].equals(""-threads"")) {
                    if (i > args.length - 2)
                        usage(false);
                    threads = Integer.parseInt(args[i + 1]);
                    i += 2;
                } else if (args[i].equals(""-lopri"")) {
                    lowPriority = true;
                    i++;
                } else if (args[i].equals(""-hipri"")) {
                    lowPriority = false;
                    i++;
                } else if (args[i].equals(""-sampler"")) {
                    if (i > args.length - 2)
                        usage(false);
                    sampler = args[i + 1];
                    i += 2;
                } else if (args[i].equals(""-smallmesh"")) {
                    TriangleMesh.setSmallTriangles(true);
                    i++;
                } else if (args[i].equals(""-dumpkd"")) {
                    KDTree.setDumpMode(true, ""kdtree"");
                    i++;
                } else if (args[i].equals(""-buildonly"")) {
                    noRender = true;
                    i++;
                } else if (args[i].equals(""-showaa"")) {
                    showAA = true;
                    i++;
                } else if (args[i].equals(""-nogi"")) {
                    noGI = true;
                    i++;
                } else if (args[i].equals(""-nocaustics"")) {
                    noCaustics = true;
                    i++;
                } else if (args[i].equals(""-pathgi"")) {
                    if (i > args.length - 2)
                        usage(false);
                    pathGI = Integer.parseInt(args[i + 1]);
                    i += 2;
                } else if (args[i].equals(""-quick_ambocc"")) {
                    if (i > args.length - 2)
                        usage(false);
                    float d = Float.parseFloat(args[i + 1]);
                    shaderOverride = new AmbientOcclusionShader(Color.WHITE, d);
                    i += 2;
                } else if (args[i].equals(""-quick_uvs"")) {
                    if (i > args.length - 1)
                        usage(false);
                    shaderOverride = new UVShader();
                    i++;
                } else if (args[i].equals(""-quick_normals"")) {
                    if (i > args.length - 1)
                        usage(false);
                    shaderOverride = new NormalShader();
                    i++;
                } else if (args[i].equals(""-quick_id"")) {
                    if (i > args.length - 1)
                        usage(false);
                    shaderOverride = new IDShader();
                    i++;
                } else if (args[i].equals(""-quick_prims"")) {
                    if (i > args.length - 1)
                        usage(false);
                    shaderOverride = new PrimIDShader();
                    i++;
                } else if (args[i].equals(""-quick_gray"")) {
                    if (i > args.length - 1)
                        usage(false);
                    shaderOverride = new QuickGrayShader();
                    i++;
                } else if (args[i].equals(""-quick_wire"")) {
                    if (i > args.length - 1)
                        usage(false);
                    shaderOverride = new WireframeShader();
                    i++;
                } else if (args[i].equals(""-resolution"")) {
                    if (i > args.length - 3)
                        usage(false);
                    resolutionW = Integer.parseInt(args[i + 1]);
                    resolutionH = Integer.parseInt(args[i + 2]);
                    i += 3;
                } else if (args[i].equals(""-aa"")) {
                    if (i > args.length - 3)
                        usage(false);
                    aaMin = Integer.parseInt(args[i + 1]);
                    aaMax = Integer.parseInt(args[i + 2]);
                    i += 3;
                } else if (args[i].equals(""-bucket"")) {
                    if (i > args.length - 3)
                        usage(false);
                    bucketSize = Integer.parseInt(args[i + 1]);
                    bucketOrder = args[i + 2];
                    i += 3;
                } else if (args[i].equals(""-bake"")) {
                    if (i > args.length - 2)
                        usage(false);
                    bakingName = args[i + 1];
                    i += 2;
                } else if (args[i].equals(""-bakedir"")) {
                    if (i > args.length - 2)
                        usage(false);
                    String baketype = args[i + 1];
                    if (baketype.equals(""view""))
                        bakeViewdep = true;
                    else if (baketype.equals(""ortho""))
                        bakeViewdep = false;
                    else
                        usage(false);
                    i += 2;
                } else if (args[i].equals(""-filter"")) {
                    if (i > args.length - 2)
                        usage(false);
                    filterType = args[i + 1];
                    i += 2;
                } else if (args[i].equals(""-bench"")) {
                    runBenchmark = true;
                    i++;
                } else if (args[i].equals(""-rtbench"")) {
                    runRTBenchmark = true;
                    i++;
                } else if (args[i].equals(""-frame"")) {
                    if (i > args.length - 2)
                        usage(false);
                    frameStart = frameStop = Integer.parseInt(args[i + 1]);
                    i += 2;
                } else if (args[i].equals(""-anim"")) {
                    if (i > args.length - 3)
                        usage(false);
                    frameStart = Integer.parseInt(args[i + 1]);
                    frameStop = Integer.parseInt(args[i + 2]);
                    i += 3;
                } else if (args[i].equals(""-v"")) {
                    if (i > args.length - 2)
                        usage(false);
                    UI.verbosity(Integer.parseInt(args[i + 1]));
                    i += 2;
                } else if (args[i].equals(""-h"") || args[i].equals(""-help"")) {
                    usage(true);
                } else {
                    if (input != null)
                        usage(false);
                    input = args[i];
                    i++;
                }
            }
            if (runBenchmark) {
                SunflowAPI.runSystemCheck();
                new Benchmark().execute();
                return;
            }
            if (runRTBenchmark) {
                SunflowAPI.runSystemCheck();
                new RealtimeBenchmark(showFrame, threads);
                return;
            }
            if (input == null)
                usage(false);
            SunflowAPI.runSystemCheck();
            if (frameStart < frameStop && showFrame) {
                UI.printWarning(Module.GUI, ""Animations should not be rendered without -nogui - forcing GUI off anyway"");
                showFrame = false;
            }
            if (frameStart < frameStop && filename == null) {
                filename = ""output.#.png"";
                UI.printWarning(Module.GUI, ""Animation output was not specified - defaulting to: \""%s\"""", filename);
            }
            for (int frameNumber = frameStart; frameNumber <= frameStop; frameNumber++) {
                SunflowAPI api = SunflowAPI.create(input, frameNumber);
                if (api == null)
                    continue;
                if (noRender)
                    continue;
                if (resolutionW > 0 && resolutionH > 0) {
                    api.parameter(""resolutionX"", resolutionW);
                    api.parameter(""resolutionY"", resolutionH);
                }
                if (aaMin != -5 || aaMax != -5) {
                    api.parameter(""aa.min"", aaMin);
                    api.parameter(""aa.max"", aaMax);
                }
                if (bucketSize > 0)
                    api.parameter(""bucket.size"", bucketSize);
                if (bucketOrder != null)
                    api.parameter(""bucket.order"", bucketOrder);
                api.parameter(""aa.display"", showAA);
                api.parameter(""threads"", threads);
                api.parameter(""threads.lowPriority"", lowPriority);
                if (bakingName != null) {
                    api.parameter(""baking.instance"", bakingName);
                    api.parameter(""baking.viewdep"", bakeViewdep);
                }
                if (filterType != null)
                    api.parameter(""filter"", filterType);
                if (noGI)
                    api.parameter(""gi.engine"", ""none"");
                else if (pathGI > 0) {
                    api.parameter(""gi.engine"", ""path"");
                    api.parameter(""gi.path.samples"", pathGI);
                }
                if (noCaustics)
                    api.parameter(""caustics"", ""none"");
                api.parameter(""sampler"", sampler);
                api.options(SunflowAPI.DEFAULT_OPTIONS);
                if (shaderOverride != null) {
                    api.shader(""ambocc"", shaderOverride);
                    api.shaderOverride(""ambocc"", true);
                }
                // create display
                Display display;
                String currentFilename = (filename != null) ? filename.replace(""#"", String.format(""%04d"", frameNumber)) : null;
                if (showFrame) {
                    display = new FrameDisplay(currentFilename);
                } else {
                    if (currentFilename != null && currentFilename.endsWith("".exr"")) {
                        try {
                            display = new OpenExrDisplay(currentFilename, ""zip"", ""float"");
                        } catch (Exception e) {
                            e.printStackTrace();
                            return;
                        }
                    } else if (currentFilename != null && currentFilename.equals(""imgpipe"")) {
                        display = new ImgPipeDisplay();
                    } else
                        display = new FileDisplay(currentFilename);
                }
                api.render(SunflowAPI.DEFAULT_OPTIONS, display);
            }
        } else {
            MetalLookAndFeel.setCurrentTheme(new DefaultMetalTheme());
            SunflowGUI gui = new SunflowGUI();
            gui.setVisible(true);
            Dimension screenRes = Toolkit.getDefaultToolkit().getScreenSize();
            if (screenRes.getWidth() <= DEFAULT_WIDTH || screenRes.getHeight() <= DEFAULT_HEIGHT)
                gui.setExtendedState(MAXIMIZED_BOTH);
            gui.tileWindowMenuItem.doClick();
            SunflowAPI.runSystemCheck();
        }
    }"
.SunflowGUI.initGUI,"    private void initGUI() {
        setTitle(""Sunflow v"" + SunflowAPI.VERSION);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        {
            desktop = new JDesktopPane();
            getContentPane().add(desktop, BorderLayout.CENTER);
            Dimension screenRes = Toolkit.getDefaultToolkit().getScreenSize();
            if (screenRes.getWidth() <= DEFAULT_WIDTH || screenRes.getHeight() <= DEFAULT_HEIGHT)
                desktop.setPreferredSize(new java.awt.Dimension(640, 480));
            else
                desktop.setPreferredSize(new java.awt.Dimension(DEFAULT_WIDTH, DEFAULT_HEIGHT));
            {
                imagePanelFrame = new JInternalFrame();
                desktop.add(imagePanelFrame);
                {
                    jPanel1 = new JPanel();
                    FlowLayout jPanel1Layout = new FlowLayout();
                    jPanel1Layout.setAlignment(FlowLayout.LEFT);
                    jPanel1.setLayout(jPanel1Layout);
                    imagePanelFrame.getContentPane().add(jPanel1, BorderLayout.NORTH);
                    {
                        renderButton = new JButton();
                        jPanel1.add(renderButton);
                        renderButton.setText(""Render"");
                        renderButton.addActionListener(new ActionListener() {
                            public void actionPerformed(ActionEvent evt) {
                                renderMenuItemActionPerformed(evt);
                            }
                        });
                    }
                    {
                        iprButton = new JButton();
                        jPanel1.add(iprButton);
                        iprButton.setText(""IPR"");
                        iprButton.addActionListener(new ActionListener() {
                            public void actionPerformed(ActionEvent evt) {
                                iprMenuItemActionPerformed(evt);
                            }
                        });
                    }
                }
                {
                    imagePanel = new ImagePanel();
                    imagePanelFrame.getContentPane().add(imagePanel, BorderLayout.CENTER);
                }
                imagePanelFrame.pack();
                imagePanelFrame.setResizable(true);
                imagePanelFrame.setMaximizable(true);
                imagePanelFrame.setVisible(true);
                imagePanelFrame.setTitle(""Image"");
                imagePanelFrame.setIconifiable(true);
            }
            {
                editorFrame = new JInternalFrame();
                desktop.add(editorFrame);
                editorFrame.setTitle(""Script Editor"");
                editorFrame.setMaximizable(true);
                editorFrame.setResizable(true);
                editorFrame.setIconifiable(true);
                {
                    jScrollPane1 = new JScrollPane();
                    editorFrame.getContentPane().add(jScrollPane1, BorderLayout.CENTER);
                    jScrollPane1.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
                    jScrollPane1.setPreferredSize(new java.awt.Dimension(360, 280));
                    {
                        editorTextArea = new JTextArea();
                        jScrollPane1.setViewportView(editorTextArea);
                        editorTextArea.setFont(new java.awt.Font(""Monospaced"", 0, 12));
                        // drag and drop
                        editorTextArea.setTransferHandler(new SceneTransferHandler());
                    }
                }
                {
                    jPanel3 = new JPanel();
                    editorFrame.getContentPane().add(jPanel3, BorderLayout.SOUTH);
                    FlowLayout jPanel3Layout = new FlowLayout();
                    jPanel3Layout.setAlignment(FlowLayout.RIGHT);
                    jPanel3.setLayout(jPanel3Layout);
                    {
                        buildButton = new JButton();
                        jPanel3.add(buildButton);
                        buildButton.setText(""Build Scene"");
                        buildButton.addActionListener(new ActionListener() {
                            public void actionPerformed(ActionEvent evt) {
                                buildMenuItemActionPerformed(evt);
                            }
                        });
                    }
                }
                editorFrame.pack();
                editorFrame.setVisible(true);
            }
            {
                consoleFrame = new JInternalFrame();
                desktop.add(consoleFrame);
                consoleFrame.setIconifiable(true);
                consoleFrame.setMaximizable(true);
                consoleFrame.setResizable(true);
                consoleFrame.setTitle(""Console"");
                {
                    jScrollPane2 = new JScrollPane();
                    consoleFrame.getContentPane().add(jScrollPane2, BorderLayout.CENTER);
                    jScrollPane2.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
                    jScrollPane2.setPreferredSize(new java.awt.Dimension(360, 100));
                    {
                        consoleTextArea = new JTextArea();
                        jScrollPane2.setViewportView(consoleTextArea);
                        consoleTextArea.setFont(new java.awt.Font(""Monospaced"", 0, 12));
                        consoleTextArea.setEditable(false);
                    }
                }
                {
                    jPanel4 = new JPanel();
                    consoleFrame.getContentPane().add(jPanel4, BorderLayout.SOUTH);
                    BorderLayout jPanel4Layout = new BorderLayout();
                    jPanel4.setLayout(jPanel4Layout);
                    {
                        jPanel6 = new JPanel();
                        BorderLayout jPanel6Layout = new BorderLayout();
                        jPanel6.setLayout(jPanel6Layout);
                        jPanel4.add(jPanel6, BorderLayout.CENTER);
                        jPanel6.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 0));
                        {
                            taskProgressBar = new JProgressBar();
                            jPanel6.add(taskProgressBar);
                            taskProgressBar.setEnabled(false);
                            taskProgressBar.setString("""");
                            taskProgressBar.setStringPainted(true);
                            taskProgressBar.setOpaque(false);
                        }
                    }
                    {
                        jPanel5 = new JPanel();
                        FlowLayout jPanel5Layout = new FlowLayout();
                        jPanel5Layout.setAlignment(FlowLayout.RIGHT);
                        jPanel5.setLayout(jPanel5Layout);
                        jPanel4.add(jPanel5, BorderLayout.EAST);
                        {
                            taskCancelButton = new JButton();
                            jPanel5.add(taskCancelButton);
                            taskCancelButton.setText(""Cancel"");
                            taskCancelButton.setEnabled(false);
                            taskCancelButton.addActionListener(new ActionListener() {
                                public void actionPerformed(ActionEvent evt) {
                                    UI.taskCancel();
                                }
                            });
                        }
                        {
                            clearConsoleButton = new JButton();
                            jPanel5.add(clearConsoleButton);
                            clearConsoleButton.setText(""Clear"");
                            clearConsoleButton.addActionListener(new ActionListener() {
                                public void actionPerformed(ActionEvent evt) {
                                    clearConsole();
                                }
                            });
                        }
                    }
                }
                consoleFrame.pack();
                consoleFrame.setVisible(true);
            }
        }
        {
            jMenuBar1 = new JMenuBar();
            setJMenuBar(jMenuBar1);
            {
                fileMenu = new JMenu();
                jMenuBar1.add(fileMenu);
                fileMenu.setText(""File"");
                {
                    newFileMenuItem = new JMenuItem();
                    fileMenu.add(newFileMenuItem);
                    newFileMenuItem.setText(""New"");
                    newFileMenuItem.setAccelerator(KeyStroke.getKeyStroke(""ctrl N""));
                    newFileMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            newFileMenuItemActionPerformed(evt);
                        }
                    });
                }
                {
                    openFileMenuItem = new JMenuItem();
                    fileMenu.add(openFileMenuItem);
                    openFileMenuItem.setText(""Open ..."");
                    openFileMenuItem.setAccelerator(KeyStroke.getKeyStroke(""ctrl O""));
                    openFileMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            openFileMenuItemActionPerformed(evt);
                        }
                    });
                }
                {
                    saveMenuItem = new JMenuItem();
                    fileMenu.add(saveMenuItem);
                    saveMenuItem.setText(""Save"");
                    saveMenuItem.setAccelerator(KeyStroke.getKeyStroke(""ctrl S""));
                    saveMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            saveCurrentFile(currentFile);
                        }
                    });
                }
                {
                    saveAsMenuItem = new JMenuItem();
                    fileMenu.add(saveAsMenuItem);
                    saveAsMenuItem.setText(""Save As ..."");
                    saveAsMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            saveAsMenuItemActionPerformed(evt);
                        }
                    });
                }
                {
                    jSeparator2 = new JSeparator();
                    fileMenu.add(jSeparator2);
                }
                {
                    exitMenuItem = new JMenuItem();
                    fileMenu.add(exitMenuItem);
                    exitMenuItem.setText(""Exit"");
                    exitMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            System.exit(0);
                        }
                    });
                }
            }
            {
                sceneMenu = new JMenu();
                jMenuBar1.add(sceneMenu);
                sceneMenu.setText(""Scene"");
                {
                    buildMenuItem = new JMenuItem();
                    sceneMenu.add(buildMenuItem);
                    buildMenuItem.setText(""Build"");
                    buildMenuItem.setAccelerator(KeyStroke.getKeyStroke(""ctrl B""));
                    buildMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            if (sceneMenu.isEnabled())
                                buildMenuItemActionPerformed(evt);
                        }
                    });
                }
                {
                    autoBuildMenuItem = new JCheckBoxMenuItem();
                    sceneMenu.add(autoBuildMenuItem);
                    autoBuildMenuItem.setText(""Build on open"");
                    autoBuildMenuItem.setSelected(true);
                }
                {
                    jSeparator3 = new JSeparator();
                    sceneMenu.add(jSeparator3);
                }
                {
                    renderMenuItem = new JMenuItem();
                    sceneMenu.add(renderMenuItem);
                    renderMenuItem.setText(""Render"");
                    renderMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            renderMenuItemActionPerformed(evt);
                        }
                    });
                }
                {
                    iprMenuItem = new JMenuItem();
                    sceneMenu.add(iprMenuItem);
                    iprMenuItem.setText(""IPR"");
                    iprMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            iprMenuItemActionPerformed(evt);
                        }
                    });
                }
                {
                    clearLogMenuItem = new JCheckBoxMenuItem();
                    sceneMenu.add(clearLogMenuItem);
                    clearLogMenuItem.setText(""Auto Clear Log"");
                    clearLogMenuItem.setToolTipText(""Clears the console before building or rendering"");
                    clearLogMenuItem.setSelected(true);
                }
                {
                    jSeparator4 = new JSeparator();
                    sceneMenu.add(jSeparator4);
                }
                {
                    textureCacheClearMenuItem = new JMenuItem();
                    sceneMenu.add(textureCacheClearMenuItem);
                    textureCacheClearMenuItem.setText(""Clear Texture Cache"");
                    textureCacheClearMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            textureCacheClearMenuItemActionPerformed(evt);
                        }
                    });
                }
                {
                    smallTrianglesMenuItem = new JCheckBoxMenuItem();
                    sceneMenu.add(smallTrianglesMenuItem);
                    smallTrianglesMenuItem.setText(""Low Mem Triangles"");
                    smallTrianglesMenuItem.setToolTipText(""Load future meshes using a low memory footprint triangle representation"");
                    smallTrianglesMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            smallTrianglesMenuItemActionPerformed(evt);
                        }
                    });
                }
            }
            {
                imageMenu = new JMenu();
                jMenuBar1.add(imageMenu);
                imageMenu.setText(""Image"");
                {
                    resetZoomMenuItem = new JMenuItem();
                    imageMenu.add(resetZoomMenuItem);
                    resetZoomMenuItem.setText(""Reset Zoom"");
                    resetZoomMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            imagePanel.reset();
                        }
                    });
                }
                {
                    fitWindowMenuItem = new JMenuItem();
                    imageMenu.add(fitWindowMenuItem);
                    fitWindowMenuItem.setText(""Fit to Window"");
                    fitWindowMenuItem.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            imagePanel.fit();
                        }
                    });
                }
                {
                    jSeparator1 = new JSeparator();
                    imageMenu.add(jSeparator1);
                }
                {
                    jMenuItem4 = new JMenuItem();
                    imageMenu.add(jMenuItem4);
                    jMenuItem4.setText(""Save Image ..."");
                    jMenuItem4.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent evt) {
                            // imagePanel.image;
                            JFileChooser fc = new JFileChooser(""."");
                            fc.setFileFilter(new FileFilter() {
                                @Override
                                public String getDescription() {
                                    return ""Image File"";
                                }

                                @Override
                                public boolean accept(File f) {
                                    return (f.isDirectory() || f.getName().endsWith("".png"") || f.getName().endsWith("".tga""));
                                }
                            });
                            if (fc.showSaveDialog(SunflowGUI.this) == JFileChooser.APPROVE_OPTION) {
                                String filename = fc.getSelectedFile().getAbsolutePath();
                                imagePanel.save(filename);
                            }
                        }
                    });
                }
            }
            {
                windowMenu = new JMenu();
                jMenuBar1.add(windowMenu);
                windowMenu.setText(""Window"");
            }
            {
                imageWindowMenuItem = new JMenuItem();
                windowMenu.add(imageWindowMenuItem);
                imageWindowMenuItem.setText(""Image"");
                imageWindowMenuItem.setAccelerator(KeyStroke.getKeyStroke(""ctrl 1""));
                imageWindowMenuItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent evt) {
                        selectFrame(imagePanelFrame);
                    }
                });
            }
            {
                editorWindowMenuItem = new JMenuItem();
                windowMenu.add(editorWindowMenuItem);
                editorWindowMenuItem.setText(""Script Editor"");
                editorWindowMenuItem.setAccelerator(KeyStroke.getKeyStroke(""ctrl 2""));
                editorWindowMenuItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent evt) {
                        selectFrame(editorFrame);
                    }
                });
            }
            {
                consoleWindowMenuItem = new JMenuItem();
                windowMenu.add(consoleWindowMenuItem);
                consoleWindowMenuItem.setText(""Console"");
                consoleWindowMenuItem.setAccelerator(KeyStroke.getKeyStroke(""ctrl 3""));
                consoleWindowMenuItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent evt) {
                        selectFrame(consoleFrame);
                    }
                });
            }
            {
                jSeparator5 = new JSeparator();
                windowMenu.add(jSeparator5);
            }
            {
                tileWindowMenuItem = new JMenuItem();
                windowMenu.add(tileWindowMenuItem);
                tileWindowMenuItem.setText(""Tile"");
                tileWindowMenuItem.setAccelerator(KeyStroke.getKeyStroke(""ctrl T""));
                tileWindowMenuItem.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent evt) {
                        tileWindowMenuItemActionPerformed(evt);
                    }
                });
            }
        }
    }"
.SunflowGUI.actionPerformed,"                            public void actionPerformed(ActionEvent evt) {
                                renderMenuItemActionPerformed(evt);
                            }
                        "
.SunflowGUI.actionPerformed,"                            public void actionPerformed(ActionEvent evt) {
                                iprMenuItemActionPerformed(evt);
                            }
                        "
.SunflowGUI.actionPerformed,"                            public void actionPerformed(ActionEvent evt) {
                                buildMenuItemActionPerformed(evt);
                            }
                        "
.SunflowGUI.actionPerformed,"                                public void actionPerformed(ActionEvent evt) {
                                    UI.taskCancel();
                                }
                            "
.SunflowGUI.actionPerformed,"                                public void actionPerformed(ActionEvent evt) {
                                    clearConsole();
                                }
                            "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            newFileMenuItemActionPerformed(evt);
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            openFileMenuItemActionPerformed(evt);
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            saveCurrentFile(currentFile);
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            saveAsMenuItemActionPerformed(evt);
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            System.exit(0);
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            if (sceneMenu.isEnabled())
                                buildMenuItemActionPerformed(evt);
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            renderMenuItemActionPerformed(evt);
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            iprMenuItemActionPerformed(evt);
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            textureCacheClearMenuItemActionPerformed(evt);
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            smallTrianglesMenuItemActionPerformed(evt);
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            imagePanel.reset();
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            imagePanel.fit();
                        }
                    "
.SunflowGUI.actionPerformed,"                        public void actionPerformed(ActionEvent evt) {
                            // imagePanel.image;
                            JFileChooser fc = new JFileChooser(""."");
                            fc.setFileFilter(new FileFilter() {
                                @Override
                                public String getDescription() {
                                    return ""Image File"";
                                }

                                @Override
                                public boolean accept(File f) {
                                    return (f.isDirectory() || f.getName().endsWith("".png"") || f.getName().endsWith("".tga""));
                                }
                            });
                            if (fc.showSaveDialog(SunflowGUI.this) == JFileChooser.APPROVE_OPTION) {
                                String filename = fc.getSelectedFile().getAbsolutePath();
                                imagePanel.save(filename);
                            }
                        }
                    "
.SunflowGUI.getDescription,"                                public String getDescription() {
                                    return ""Image File"";
                                }"
.SunflowGUI.accept,"                                public boolean accept(File f) {
                                    return (f.isDirectory() || f.getName().endsWith("".png"") || f.getName().endsWith("".tga""));
                                }
                            "
.SunflowGUI.actionPerformed,"                    public void actionPerformed(ActionEvent evt) {
                        selectFrame(imagePanelFrame);
                    }
                "
.SunflowGUI.actionPerformed,"                    public void actionPerformed(ActionEvent evt) {
                        selectFrame(editorFrame);
                    }
                "
.SunflowGUI.actionPerformed,"                    public void actionPerformed(ActionEvent evt) {
                        selectFrame(consoleFrame);
                    }
                "
.SunflowGUI.actionPerformed,"                    public void actionPerformed(ActionEvent evt) {
                        tileWindowMenuItemActionPerformed(evt);
                    }
                "
.SunflowGUI.newFileMenuItemActionPerformed,"    private void newFileMenuItemActionPerformed(ActionEvent evt) {
        if (evt != null) {
            // check save?
        }
        // put some template code into the editor
        String template = ""import org.sunflow.core.*;\nimport org.sunflow.core.accel.*;\nimport org.sunflow.core.camera.*;\nimport org.sunflow.core.primitive.*;\nimport org.sunflow.core.shader.*;\nimport org.sunflow.image.Color;\nimport org.sunflow.math.*;\n\npublic void build() {\n  // your code goes here\n\n}\n"";
        editorTextArea.setText(template);
    }"
.SunflowGUI.openFileMenuItemActionPerformed,"    private void openFileMenuItemActionPerformed(ActionEvent evt) {
        JFileChooser fc = new JFileChooser(""."");
        fc.setFileFilter(new FileFilter() {
            @Override
            public String getDescription() {
                return ""Scene File"";
            }

            @Override
            public boolean accept(File f) {
                return (f.isDirectory() || f.getName().endsWith("".sc"") || f.getName().endsWith("".java""));
            }
        });

        if (fc.showOpenDialog(SunflowGUI.this) == JFileChooser.APPROVE_OPTION) {
            final String f = fc.getSelectedFile().getAbsolutePath();
            openFile(f);
        }
    }"
.SunflowGUI.getDescription,"            public String getDescription() {
                return ""Scene File"";
            }"
.SunflowGUI.accept,"            public boolean accept(File f) {
                return (f.isDirectory() || f.getName().endsWith("".sc"") || f.getName().endsWith("".java""));
            }
        "
.SunflowGUI.buildMenuItemActionPerformed,"    private void buildMenuItemActionPerformed(ActionEvent evt) {
        new Thread() {
            public void run() {
                setEnableInterface(false);
                if (clearLogMenuItem.isSelected())
                    clearConsole();
                Timer t = new Timer();
                t.start();
                try {
                    api = SunflowAPI.compile(editorTextArea.getText());
                } catch (NoClassDefFoundError e) {
                    UI.printError(Module.GUI, ""Janino library not found. Please check command line."");
                    api = null;
                }
                if (api != null) {
                    try {
                        if (currentFile != null) {
                            String dir = new File(currentFile).getAbsoluteFile().getParent();
                            api.addIncludeSearchPath(dir);
                            api.addIncludeSearchPath(dir);
                        }
                        api.build();
                    } catch (Exception e) {
                        UI.printError(Module.GUI, ""Build terminated abnormally: %s"", e.getMessage());
                        for (StackTraceElement elt : e.getStackTrace()) {
                            UI.printInfo(Module.GUI, ""       at %s"", elt.toString());
                        }
                        e.printStackTrace();
                    }
                    t.end();
                    UI.printInfo(Module.GUI, ""Build time: %s"", t.toString());
                }
                setEnableInterface(true);
            }
        }.start();
    }"
.SunflowGUI.run,"            public void run() {
                setEnableInterface(false);
                if (clearLogMenuItem.isSelected())
                    clearConsole();
                Timer t = new Timer();
                t.start();
                try {
                    api = SunflowAPI.compile(editorTextArea.getText());
                } catch (NoClassDefFoundError e) {
                    UI.printError(Module.GUI, ""Janino library not found. Please check command line."");
                    api = null;
                }
                if (api != null) {
                    try {
                        if (currentFile != null) {
                            String dir = new File(currentFile).getAbsoluteFile().getParent();
                            api.addIncludeSearchPath(dir);
                            api.addIncludeSearchPath(dir);
                        }
                        api.build();
                    } catch (Exception e) {
                        UI.printError(Module.GUI, ""Build terminated abnormally: %s"", e.getMessage());
                        for (StackTraceElement elt : e.getStackTrace()) {
                            UI.printInfo(Module.GUI, ""       at %s"", elt.toString());
                        }
                        e.printStackTrace();
                    }
                    t.end();
                    UI.printInfo(Module.GUI, ""Build time: %s"", t.toString());
                }
                setEnableInterface(true);
            }
        "
.SunflowGUI.clearConsole,"    private void clearConsole() {
        consoleTextArea.setText(null);
    }"
.SunflowGUI.println,"    private void println(final String s) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                consoleTextArea.append(s + ""\n"");
            }
        });
    }"
.SunflowGUI.run,"            public void run() {
                consoleTextArea.append(s + ""\n"");
            }
        "
.SunflowGUI.setEnableInterface,"    private void setEnableInterface(boolean enabled) {
        // lock or unlock options which are unsafe during builds or renders
        newFileMenuItem.setEnabled(enabled);
        openFileMenuItem.setEnabled(enabled);
        saveMenuItem.setEnabled(enabled);
        saveAsMenuItem.setEnabled(enabled);
        sceneMenu.setEnabled(enabled);
        buildButton.setEnabled(enabled);
        renderButton.setEnabled(enabled);
        iprButton.setEnabled(enabled);
    }"
.SunflowGUI.print,"    public void print(Module m, PrintLevel level, String s) {
        if (level == PrintLevel.ERROR)
            JOptionPane.showMessageDialog(SunflowGUI.this, s, String.format(""Error - %s"", m.name()), JOptionPane.ERROR_MESSAGE);
        println(UI.formatOutput(m, level, s));
    }"
.SunflowGUI.taskStart,"    public void taskStart(String s, int min, int max) {
        currentTask = s;
        currentTaskLastP = -1;
        final int taskMin = min;
        final int taskMax = max;
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                taskProgressBar.setEnabled(true);
                taskCancelButton.setEnabled(true);
                taskProgressBar.setMinimum(taskMin);
                taskProgressBar.setMaximum(taskMax);
                taskProgressBar.setValue(taskMin);
                taskProgressBar.setString(currentTask);
            }
        });
    }"
.SunflowGUI.run,"            public void run() {
                taskProgressBar.setEnabled(true);
                taskCancelButton.setEnabled(true);
                taskProgressBar.setMinimum(taskMin);
                taskProgressBar.setMaximum(taskMax);
                taskProgressBar.setValue(taskMin);
                taskProgressBar.setString(currentTask);
            }
        "
.SunflowGUI.taskUpdate,"    public void taskUpdate(int current) {
        final int taskCurrent = current;
        final String taskString = currentTask;
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                taskProgressBar.setValue(taskCurrent);
                int p = (int) (100.0 * taskProgressBar.getPercentComplete());
                if (p > currentTaskLastP) {
                    taskProgressBar.setString(taskString + "" ["" + p + ""%]"");
                    currentTaskLastP = p;
                }
            }
        });
    }"
.SunflowGUI.run,"            public void run() {
                taskProgressBar.setValue(taskCurrent);
                int p = (int) (100.0 * taskProgressBar.getPercentComplete());
                if (p > currentTaskLastP) {
                    taskProgressBar.setString(taskString + "" ["" + p + ""%]"");
                    currentTaskLastP = p;
                }
            }
        "
.SunflowGUI.taskStop,"    public void taskStop() {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                taskProgressBar.setValue(taskProgressBar.getMinimum());
                taskProgressBar.setString("""");
                taskProgressBar.setEnabled(false);
                taskCancelButton.setEnabled(false);
            }
        });
    }"
.SunflowGUI.run,"            public void run() {
                taskProgressBar.setValue(taskProgressBar.getMinimum());
                taskProgressBar.setString("""");
                taskProgressBar.setEnabled(false);
                taskCancelButton.setEnabled(false);
            }
        "
.SunflowGUI.renderMenuItemActionPerformed,"    private void renderMenuItemActionPerformed(ActionEvent evt) {
        new Thread() {
            public void run() {
                setEnableInterface(false);
                if (clearLogMenuItem.isSelected())
                    clearConsole();
                if (api != null) {
                    api.parameter(""sampler"", ""bucket"");
                    api.options(SunflowAPI.DEFAULT_OPTIONS);
                    api.render(SunflowAPI.DEFAULT_OPTIONS, imagePanel);
                } else
                    UI.printError(Module.GUI, ""Nothing to render!"");
                setEnableInterface(true);
            }
        }.start();
    }"
.SunflowGUI.run,"            public void run() {
                setEnableInterface(false);
                if (clearLogMenuItem.isSelected())
                    clearConsole();
                if (api != null) {
                    api.parameter(""sampler"", ""bucket"");
                    api.options(SunflowAPI.DEFAULT_OPTIONS);
                    api.render(SunflowAPI.DEFAULT_OPTIONS, imagePanel);
                } else
                    UI.printError(Module.GUI, ""Nothing to render!"");
                setEnableInterface(true);
            }
        "
.SunflowGUI.iprMenuItemActionPerformed,"    private void iprMenuItemActionPerformed(ActionEvent evt) {
        new Thread() {
            public void run() {
                setEnableInterface(false);
                if (clearLogMenuItem.isSelected())
                    clearConsole();
                if (api != null) {
                    api.parameter(""sampler"", ""ipr"");
                    api.options(SunflowAPI.DEFAULT_OPTIONS);
                    api.render(SunflowAPI.DEFAULT_OPTIONS, imagePanel);
                } else
                    UI.printError(Module.GUI, ""Nothing to IPR!"");
                setEnableInterface(true);
            }
        }.start();
    }"
.SunflowGUI.run,"            public void run() {
                setEnableInterface(false);
                if (clearLogMenuItem.isSelected())
                    clearConsole();
                if (api != null) {
                    api.parameter(""sampler"", ""ipr"");
                    api.options(SunflowAPI.DEFAULT_OPTIONS);
                    api.render(SunflowAPI.DEFAULT_OPTIONS, imagePanel);
                } else
                    UI.printError(Module.GUI, ""Nothing to IPR!"");
                setEnableInterface(true);
            }
        "
.SunflowGUI.textureCacheClearMenuItemActionPerformed,"    private void textureCacheClearMenuItemActionPerformed(ActionEvent evt) {
        TextureCache.flush();
    }"
.SunflowGUI.smallTrianglesMenuItemActionPerformed,"    private void smallTrianglesMenuItemActionPerformed(ActionEvent evt) {
        TriangleMesh.setSmallTriangles(smallTrianglesMenuItem.isSelected());
    }"
.SunflowGUI.saveAsMenuItemActionPerformed,"    private void saveAsMenuItemActionPerformed(ActionEvent evt) {
        JFileChooser fc = new JFileChooser(""."");
        fc.setFileFilter(new FileFilter() {
            @Override
            public String getDescription() {
                return ""Scene File"";
            }

            @Override
            public boolean accept(File f) {
                return (f.isDirectory() || f.getName().endsWith("".java""));
            }
        });

        if (fc.showSaveDialog(SunflowGUI.this) == JFileChooser.APPROVE_OPTION) {
            String f = fc.getSelectedFile().getAbsolutePath();
            if (!f.endsWith("".java""))
                f += "".java"";
            File file = new File(f);
            if (!file.exists() || JOptionPane.showConfirmDialog(SunflowGUI.this, ""This file already exists.\nOverwrite?"", ""Warning"", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) {
                // save file
                saveCurrentFile(f);
            }
        }
    }"
.SunflowGUI.getDescription,"            public String getDescription() {
                return ""Scene File"";
            }"
.SunflowGUI.accept,"            public boolean accept(File f) {
                return (f.isDirectory() || f.getName().endsWith("".java""));
            }
        "
.SunflowGUI.saveCurrentFile,"    private void saveCurrentFile(String filename) {
        if (filename == null) {
            // no filename was picked, go to save as dialog
            saveAsMenuItemActionPerformed(null);
            return;
        }
        FileWriter file;
        try {
            file = new FileWriter(filename);
            // get text from editor pane
            file.write(editorTextArea.getText());
            file.close();
            // update current filename
            currentFile = filename;
            UI.printInfo(Module.GUI, ""Saved current script to \""%s\"""", filename);
        } catch (IOException e) {
            UI.printError(Module.GUI, ""Unable to save: \""%s\"""", filename);
            e.printStackTrace();
        }
    }"
.SunflowGUI.selectFrame,"    private void selectFrame(JInternalFrame frame) {
        try {
            frame.setSelected(true);
            frame.setIcon(false);
        } catch (PropertyVetoException e) {
            // this should never happen
            e.printStackTrace();
        }
    }"
.SunflowGUI.tileWindowMenuItemActionPerformed,"    private void tileWindowMenuItemActionPerformed(ActionEvent evt) {
        try {
            if (imagePanelFrame.isIcon())
                imagePanelFrame.setIcon(false);
            if (editorFrame.isIcon())
                editorFrame.setIcon(false);
            if (consoleFrame.isIcon())
                consoleFrame.setIcon(false);

            int width = desktop.getWidth();
            int height = desktop.getHeight();
            int widthLeft = width * 7 / 12;
            int widthRight = width - widthLeft;
            int pad = 2;
            int pad2 = pad + pad;

            imagePanelFrame.reshape(pad, pad, widthLeft - pad2, height - pad2);
            editorFrame.reshape(pad + widthLeft, pad, widthRight - pad2, height / 2 - pad2);
            consoleFrame.reshape(pad + widthLeft, pad + height / 2, widthRight - pad2, height / 2 - pad2);
        } catch (PropertyVetoException e) {
            e.printStackTrace();
        }
    }"
.SunflowGUI.openFile,"    private void openFile(String filename) {
        if (filename.endsWith("".java"")) {
            // read the file line by line
            String code = """";
            FileReader file;
            try {
                file = new FileReader(filename);
                BufferedReader bf = new BufferedReader(file);
                while (true) {
                    String line;
                    line = bf.readLine();
                    if (line == null)
                        break;
                    code += line;
                    code += ""\n"";
                }
                file.close();
                editorTextArea.setText(code);
            } catch (FileNotFoundException e) {
                UI.printError(Module.GUI, ""Unable to load: \""%s\"""", filename);
                return;
            } catch (IOException e) {
                UI.printError(Module.GUI, ""Unable to load: \""%s\"""", filename);
                return;
            }
            // loade went ok, use filename as current
            currentFile = filename;
            UI.printInfo(Module.GUI, ""Loaded script: \""%s\"""", filename);
        } else if (filename.endsWith("".sc"")) {
            String template = ""import org.sunflow.core.*;\nimport org.sunflow.core.accel.*;\nimport org.sunflow.core.camera.*;\nimport org.sunflow.core.primitive.*;\nimport org.sunflow.core.shader.*;\nimport org.sunflow.image.Color;\nimport org.sunflow.math.*;\n\npublic void build() {\n  parse(\"""" + filename.replace(""\\"", ""\\\\"") + ""\"");\n}\n"";
            editorTextArea.setText(template);
            // no java file associated
            currentFile = null;
            UI.printInfo(Module.GUI, ""Created template for \""%s\"""", filename);
        } else {
            UI.printError(Module.GUI, ""Unknown file format selected"");
            return;
        }
        editorTextArea.setCaretPosition(0);
        if (autoBuildMenuItem.isSelected()) {
            // try to compile the code we just loaded
            buildMenuItemActionPerformed(null);
        }

    }"
.SunflowGUI.importData,"        public boolean importData(JComponent c, Transferable t) {
            if (!sceneMenu.isEnabled())
                return false;
            // can I import it?
            if (!canImport(c, t.getTransferDataFlavors())) {
                return false;
            }
            try {
                // get a List of Files
                List files = (java.util.List) t.getTransferData(DataFlavor.javaFileListFlavor);
                for (int i = 0; i < files.size(); i++) {
                    final File file = (File) files.get(i);
                    String filename = file.getAbsolutePath();
                    // check extension
                    if (filename.endsWith("".sc"") || filename.endsWith("".java"")) {
                        openFile(filename);
                        // load only one file at a time, stop here
                        break;
                    }
                }
            } catch (Exception exp) {
                // debug
                exp.printStackTrace();
            }

            return false;
        }"
.SunflowGUI.canImport,"        public boolean canImport(JComponent c, DataFlavor[] flavors) {
            // Just a quick check to see if a file can be accepted at this time
            // Are there any files around?
            for (int i = 0; i < flavors.length; i++) {
                if (flavors[i].isFlavorJavaFileListType())
                    return true;
            }

            // guess not
            return false;
        }
    "
org.sunflow.RealtimeBenchmark.createGeometry,"    private void createGeometry() {
        // light source
        parameter(""source"", new Point3(-15.5945f, -30.0581f, 45.967f));
        parameter(""dir"", new Vector3(15.5945f, 30.0581f, -45.967f));
        parameter(""radius"", 60.0f);
        parameter(""radiance"", Color.white().mul(3));
        light(""light"", new DirectionalSpotlight());

        // gi-engine
        parameter(""gi.engine"", ""fake"");
        parameter(""gi.fake.sky"", new Color(0.25f, 0.25f, 0.25f));
        parameter(""gi.fake.ground"", new Color(0.01f, 0.01f, 0.5f));
        parameter(""gi.fake.up"", new Vector3(0, 0, 1));
        options(DEFAULT_OPTIONS);

        // shaders
        parameter(""diffuse"", Color.white().mul(0.5f));
        shader(""default"", new DiffuseShader());
        parameter(""diffuse"", Color.white().mul(0.5f));
        parameter(""shiny"", 0.2f);
        shader(""refl"", new ShinyDiffuseShader());
        // objects

        // teapot
        parameter(""subdivs"", 10);
        geometry(""teapot"", (Tesselatable) new Teapot());
        parameter(""shaders"", ""default"");
        Matrix4 m = Matrix4.IDENTITY;
        m = Matrix4.scale(0.075f).multiply(m);
        m = Matrix4.rotateZ((float) Math.toRadians(-45f)).multiply(m);
        m = Matrix4.translation(-7, 0, 0).multiply(m);
        parameter(""transform"", m);
        instance(""teapot.instance"", ""teapot"");

        // gumbo
        parameter(""subdivs"", 10);
        geometry(""gumbo"", (Tesselatable) new Gumbo());
        m = Matrix4.IDENTITY;
        m = Matrix4.scale(0.5f).multiply(m);
        m = Matrix4.rotateZ((float) Math.toRadians(25f)).multiply(m);
        m = Matrix4.translation(3, -7, 0).multiply(m);
        parameter(""shaders"", ""default"");
        parameter(""transform"", m);
        instance(""gumbo.instance"", ""gumbo"");

        // ground plane
        parameter(""center"", new Point3(0, 0, 0));
        parameter(""normal"", new Vector3(0, 0, 1));
        geometry(""ground"", new Plane());
        parameter(""shaders"", ""refl"");
        instance(""ground.instance"", ""ground"");
    }
"
org.sunflow.SunflowAPI.runSystemCheck,"/**
* This is a quick system test which verifies that the user has launched
* Java properly
*
* @return
*/
    public static void runSystemCheck() {
        final long RECOMMENDED_MAX_SIZE = 800;
        long maxMb = Runtime.getRuntime().maxMemory() / 1048576;
        if (maxMb < RECOMMENDED_MAX_SIZE)
            UI.printError(Module.API, ""JVM available memory is below %d MB (found %d MB only).\nPlease make sure you launched the program with the -Xmx command line options."", RECOMMENDED_MAX_SIZE, maxMb);
        String compiler = System.getProperty(""java.vm.name"");
        if (compiler == null || !(compiler.contains(""HotSpot"") && compiler.contains(""Server"")))
            UI.printError(Module.API, ""You do not appear to be running Sun's server JVM\nPerformance may suffer"");
        UI.printDetailed(Module.API, ""Java environment settings:"");
        UI.printDetailed(Module.API, ""  * Max memory available : %d MB"", maxMb);
        UI.printDetailed(Module.API, ""  * Virtual machine name : %s"", compiler == null ? ""<unknown"" : compiler);
        UI.printDetailed(Module.API, ""  * Operating system     : %s"", System.getProperty(""os.name""));
        UI.printDetailed(Module.API, ""  * CPU architecture     : %s"", System.getProperty(""os.arch""));
    }"
org.sunflow.SunflowAPI.reset,"/**
* Reset the state of the API completely. The scene, shader table and all
* rendering options are set back to their default values.
*/
    public final void reset() {
        scene = new Scene();
        bucketRenderer = new BucketRenderer();
        progressiveRenderer = new ProgressiveRenderer();
        includeSearchPath = new SearchPath(""include"");
        textureSearchPath = new SearchPath(""texture"");
        parameterList = new ParameterList();
        renderObjects = new RenderObjectMap();
        currentFrame = 1;
    }"
org.sunflow.SunflowAPI.getUniqueName,"/**
* Returns a name currently not being used by any other object. The returned
* name is of the form ""prefix_n"" where n is an integer starting at 1.
*
* @param prefix name prefix
* @return a unique name not used by any rendering object
*/
    public final String getUniqueName(String prefix) {
        // generate a unique name based on the given prefix
        int counter = 1;
        String name;
        do {
            name = String.format(""%s_%d"", prefix, counter);
            counter++;
        } while (renderObjects.has(name));
        return name;
    }"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name and value. This parameter
* will be added to the currently active parameter list.
*
* @param name parameter name
* @param value parameter value
*/
    public final void parameter(String name, String value) {
        parameterList.addString(name, value);
    }"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name and value. This parameter
* will be added to the currently active parameter list.
*
* @param name parameter name
* @param value parameter value
*/
    public final void parameter(String name, boolean value) {
        parameterList.addBoolean(name, value);
    }"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name and value. This parameter
* will be added to the currently active parameter list.
*
* @param name parameter name
* @param value parameter value
*/
    public final void parameter(String name, int value) {
        parameterList.addInteger(name, value);
    }"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name and value. This parameter
* will be added to the currently active parameter list.
*
* @param name parameter name
* @param value parameter value
*/
    public final void parameter(String name, float value) {
        parameterList.addFloat(name, value);
    }"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name and value. This parameter
* will be added to the currently active parameter list.
*
* @param name parameter name
* @param value parameter value
*/
    public final void parameter(String name, Color value) {
        parameterList.addColor(name, value);
    }"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name and value. This parameter
* will be added to the currently active parameter list.
*
* @param name parameter name
* @param value parameter value
*/
    public final void parameter(String name, Point3 value) {
        parameterList.addPoints(name, InterpolationType.NONE, new float[] {
                value.x, value.y, value.z });
    }"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name and value. This parameter
* will be added to the currently active parameter list.
*
* @param name parameter name
* @param value parameter value
*/
    public final void parameter(String name, Vector3 value) {
        parameterList.addVectors(name, InterpolationType.NONE, new float[] {
                value.x, value.y, value.z });
    }"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name and value. This parameter
* will be added to the currently active parameter list.
*
* @param name parameter name
* @param value parameter value
*/
    public final void parameter(String name, Matrix4 value) {
        parameterList.addMatrices(name, InterpolationType.NONE, value.asRowMajor());
    }"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name and value. This parameter
* will be added to the currently active parameter list.
*
* @param name parameter name
* @param value parameter value
*/
    public final void parameter(String name, int[] value) {
        parameterList.addIntegerArray(name, value);
    }"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name and value. This parameter
* will be added to the currently active parameter list.
*
* @param name parameter name
* @param value parameter value
*/
    public final void parameter(String name, String[] value) {
        parameterList.addStringArray(name, value);
    }

    /**
     * Declare a parameter with the specified name. The type may be one of the
     * follow: ""float"", ""point"", ""vector"", ""texcoord"", ""matrix"". The
     * interpolation determines how the parameter is to be interpreted over
     * surface (see {@link InterpolationType}"
org.sunflow.SunflowAPI.parameter,"/**
* Declare a parameter with the specified name. The type may be one of the
* follow: ""float"", ""point"", ""vector"", ""texcoord"", ""matrix"". The
* interpolation determines how the parameter is to be interpreted over
* surface (see {@link InterpolationType}). The data is specified in a
* flattened float array.
*
* @param name parameter name
* @param type parameter data type
* @param interpolation parameter interpolation mode
* @param data raw floating point data
*/
    public final void parameter(String name, String type, String interpolation, float[] data) {
        InterpolationType interp;
        try {
            interp = InterpolationType.valueOf(interpolation.toUpperCase());
        } catch (IllegalArgumentException e) {
            UI.printError(Module.API, ""Unknown interpolation type: %s -- ignoring parameter \""%s\"""", interpolation, name);
            return;
        }
        if (type.equals(""float""))
            parameterList.addFloats(name, interp, data);
        else if (type.equals(""point""))
            parameterList.addPoints(name, interp, data);
        else if (type.equals(""vector""))
            parameterList.addVectors(name, interp, data);
        else if (type.equals(""texcoord""))
            parameterList.addTexCoords(name, interp, data);
        else if (type.equals(""matrix""))
            parameterList.addMatrices(name, interp, data);
        else
            UI.printError(Module.API, ""Unknown parameter type: %s -- ignoring parameter \""%s\"""", type, name);
    }"
org.sunflow.SunflowAPI.remove,"/**
* Remove the specified render object.
*
* @param name name of the object to remove
*/
    public void remove(String name) {
        renderObjects.remove(name);
    }"
org.sunflow.SunflowAPI.update,"/**
* Update the specfied object using the currently active parameter list. The
* object is removed if the update fails to avoid leaving inconsistently set
* objects in the list.
*
* @param name name of the object to update
* @return <code>true</code> if the update was succesfull, or
*         <code>false</code> if the update failed
*/
    public boolean update(String name) {
        boolean success = renderObjects.update(name, parameterList, this);
        parameterList.clear(success);
        return success;
    }"
org.sunflow.SunflowAPI.addIncludeSearchPath,"/**
* Add the specified path to the list of directories which are searched
* automatically to resolve scene filenames.
*
* @param path
*/
    public final void addIncludeSearchPath(String path) {
        includeSearchPath.addSearchPath(path);
    }"
org.sunflow.SunflowAPI.addTextureSearchPath,"/**
* Adds the specified path to the list of directories which are searched
* automatically to resolve texture filenames.
*/
    public final void addTextureSearchPath(String path) {
        textureSearchPath.addSearchPath(path);
    }"
org.sunflow.SunflowAPI.resolveTextureFilename,"/**
* Attempts to resolve the specified filename by checking it against the
* texture search path.
*
* @param filename filename
* @return a path which matches the filename, or filename if no matches are
*         found
*/
    public final String resolveTextureFilename(String filename) {
        return textureSearchPath.resolvePath(filename);
    }"
org.sunflow.SunflowAPI.resolveIncludeFilename,"/**
* Attempts to resolve the specified filename by checking it against the
* include search path.
*
* @param filename filename
* @return a path which matches the filename, or filename if no matches are
*         found
*/
    public final String resolveIncludeFilename(String filename) {
        return includeSearchPath.resolvePath(filename);
    }"
org.sunflow.SunflowAPI.shader,"/**
* Defines a shader with a given name. If the shader object is
* <code>null</code>, the shader with the given name will be updated (if
* it exists).
*
* @param name a unique name given to the shader
* @param shader a shader object
*/
    public final void shader(String name, Shader shader) {
        if (shader != null) {
            // we are declaring a shader for the first time
            if (renderObjects.has(name)) {
                UI.printError(Module.API, ""Unable to declare shader \""%s\"", name is already in use"", name);
                parameterList.clear(true);
                return;
            }
            renderObjects.put(name, shader);
        }
        // update existing shader (only if it is valid)
        if (lookupShader(name) != null)
            update(name);
        else {
            UI.printError(Module.API, ""Unable to update shader \""%s\"" - shader object was not found"", name);
            parameterList.clear(true);
        }
    }"
org.sunflow.SunflowAPI.modifier,"/**
* Defines a modifier with a given name. If the modifier object is
* <code>null</code>, the modifier with the given name will be updated
* (if it exists).
*
* @param name a unique name given to the modifier
* @param modifier a modifier object
*/
    public final void modifier(String name, Modifier modifier) {
        if (modifier != null) {
            // we are declaring a shader for the first time
            if (renderObjects.has(name)) {
                UI.printError(Module.API, ""Unable to declare modifier \""%s\"", name is already in use"", name);
                parameterList.clear(true);
                return;
            }
            renderObjects.put(name, modifier);
        }
        // update existing shader (only if it is valid)
        if (lookupModifier(name) != null)
            update(name);
        else {
            UI.printError(Module.API, ""Unable to update modifier \""%s\"" - modifier object was not found"", name);
            parameterList.clear(true);
        }
    }

    /**
     * Defines a geometry with a given name. The geometry is built from the
     * specified {@link PrimitiveList}"
org.sunflow.SunflowAPI.geometry,"/**
* Defines a geometry with a given name. The geometry is built from the
* specified {@link PrimitiveList}. If the primitives object is
* <code>null</code>, the geometry with the given name will be updated
* (if it exists).
*
* @param name a unique name given to the geometry
* @param primitives primitives to create the geometry from
*/
    public final void geometry(String name, PrimitiveList primitives) {
        if (primitives != null) {
            // we are declaring a geometry for the first time
            if (renderObjects.has(name)) {
                UI.printError(Module.API, ""Unable to declare geometry \""%s\"", name is already in use"", name);
                parameterList.clear(true);
                return;
            }
            renderObjects.put(name, primitives);
        }
        if (lookupGeometry(name) != null)
            update(name);
        else {
            UI.printError(Module.API, ""Unable to update geometry \""%s\"" - geometry object was not found"", name);
            parameterList.clear(true);
        }
    }

    /**
     * Defines a geometry with a given name. The geometry is built from the
     * specified {@link Tesselatable}"
org.sunflow.SunflowAPI.geometry,"/**
* Defines a geometry with a given name. The geometry is built from the
* specified {@link Tesselatable}. If the object is <code>null</code>,
* the geometry with the given name will be updated (if it exists).
*
* @param name a unique name given to the geometry
* @param tesselatable the tesselatable object to create the geometry from
*/
    public final void geometry(String name, Tesselatable tesselatable) {
        if (tesselatable != null) {
            // we are declaring a geometry for the first time
            if (renderObjects.has(name)) {
                UI.printError(Module.API, ""Unable to declare geometry \""%s\"", name is already in use"", name);
                parameterList.clear(true);
                return;
            }
            renderObjects.put(name, tesselatable);
        }
        if (lookupGeometry(name) != null)
            update(name);
        else {
            UI.printError(Module.API, ""Unable to update geometry \""%s\"" - geometry object was not found"", name);
            parameterList.clear(true);
        }
    }"
org.sunflow.SunflowAPI.instance,"/**
* Instance the specified geometry into the scene. If geoname is
* <code>null</code>, the specified instance object will be updated (if
* it exists).
*
* @param name instance name
* @param geoname name of the geometry to instance
*/
    public final void instance(String name, String geoname) {
        if (geoname != null) {
            // we are declaring this instance for the first time
            if (renderObjects.has(name)) {
                UI.printError(Module.API, ""Unable to declare instance \""%s\"", name is already in use"", name);
                parameterList.clear(true);
                return;
            }
            parameter(""geometry"", geoname);
            renderObjects.put(name, new Instance());
        }
        if (lookupInstance(name) != null)
            update(name);
        else {
            UI.printError(Module.API, ""Unable to update instance \""%s\"" - instance object was not found"", name);
            parameterList.clear(true);
        }
    }"
org.sunflow.SunflowAPI.light,"/**
* Adds the specified light to the scene.
*
* @param light light source object
*/
    public final void light(String name, LightSource light) {
        if (light != null) {
            // we are declaring this light for the first time
            if (renderObjects.has(name)) {
                UI.printError(Module.API, ""Unable to declare light \""%s\"", name is already in use"", name);
                parameterList.clear(true);
                return;
            }
            renderObjects.put(name, light);
        }
        if (lookupLight(name) != null)
            update(name);
        else {
            UI.printError(Module.API, ""Unable to update instance \""%s\"" - instance object was not found"", name);
            parameterList.clear(true);
        }
    }

    /**
     * Defines a camera with a given name. The camera is built from the
     * specified {@link CameraLens}"
org.sunflow.SunflowAPI.camera,"/**
* Defines a camera with a given name. The camera is built from the
* specified {@link CameraLens}. If the lens object is <code>null</code>,
* the camera with the given name will be updated (if it exists).
*
* @param name camera name
* @param lens camera lens to use
*/
    public final void camera(String name, CameraLens lens) {
        if (lens != null) {
            // we are declaring this camera for the first time
            if (renderObjects.has(name)) {
                UI.printError(Module.API, ""Unable to declare camera \""%s\"", name is already in use"", name);
                parameterList.clear(true);
                return;
            }
            renderObjects.put(name, new Camera(lens));
        }
        // update existing shader (only if it is valid)
        if (lookupCamera(name) != null)
            update(name);
        else {
            UI.printError(Module.API, ""Unable to update camera \""%s\"" - camera object was not found"", name);
            parameterList.clear(true);
        }
    }"
org.sunflow.SunflowAPI.options,"/**
* Defines an option object to hold the current parameters. If the object
* already exists, the values will simply override previous ones.
*
* @param name
*/
    public final void options(String name) {
        if (lookupOptions(name) == null) {
            if (renderObjects.has(name)) {
                UI.printError(Module.API, ""Unable to declare options \""%s\"", name is already in use"", name);
                parameterList.clear(true);
                return;
            }
            renderObjects.put(name, new Options());
        }
        assert lookupOptions(name) != null;
        update(name);
    }"
org.sunflow.SunflowAPI.lookupGeometry,"/**
* Retrieve a geometry object by its name, or <code>null</code> if no
* geometry was found, or if the specified object is not a geometry.
*
* @param name geometry name
* @return the geometry object associated with that name
*/
    public final Geometry lookupGeometry(String name) {
        return renderObjects.lookupGeometry(name);
    }"
org.sunflow.SunflowAPI.lookupInstance,"/**
* Retrieve an instance object by its name, or <code>null</code> if no
* instance was found, or if the specified object is not an instance.
*
* @param name instance name
* @return the instance object associated with that name
*/
    private final Instance lookupInstance(String name) {
        return renderObjects.lookupInstance(name);
    }"
org.sunflow.SunflowAPI.lookupCamera,"/**
* Retrieve a shader object by its name, or <code>null</code> if no shader
* was found, or if the specified object is not a shader.
*
* @param name camera name
* @return the camera object associate with that name
*/
    private final Camera lookupCamera(String name) {
        return renderObjects.lookupCamera(name);
    }"
org.sunflow.SunflowAPI.lookupOptions,"    private final Options lookupOptions(String name) {
        return renderObjects.lookupOptions(name);
    }"
org.sunflow.SunflowAPI.lookupShader,"/**
* Retrieve a shader object by its name, or <code>null</code> if no shader
* was found, or if the specified object is not a shader.
*
* @param name shader name
* @return the shader object associated with that name
*/
    public final Shader lookupShader(String name) {
        return renderObjects.lookupShader(name);
    }"
org.sunflow.SunflowAPI.lookupModifier,"/**
* Retrieve a modifier object by its name, or <code>null</code> if no
* modifier was found, or if the specified object is not a modifier.
*
* @param name modifier name
* @return the modifier object associated with that name
*/
    public final Modifier lookupModifier(String name) {
        return renderObjects.lookupModifier(name);
    }"
org.sunflow.SunflowAPI.lookupLight,"/**
* Retrieve a light object by its name, or <code>null</code> if no shader
* was found, or if the specified object is not a light.
*
* @param name light name
* @return the light object associated with that name
*/
    private final LightSource lookupLight(String name) {
        return renderObjects.lookupLight(name);
    }"
org.sunflow.SunflowAPI.shaderOverride,"/**
* Sets a global shader override to the specified shader name. If the shader
* is not found, the overriding is disabled. The second parameter controls
* whether the override applies to the photon tracing process.
*
* @param name shader name
* @param photonOverride apply override to photon tracing phase
*/
    public final void shaderOverride(String name, boolean photonOverride) {
        scene.setShaderOverride(lookupShader(name), photonOverride);
    }"
org.sunflow.SunflowAPI.pointLight,"/**
* Creats a point light with specified power
*
* @param x x coordinate of the point light
* @param y y coordinate of the point light
* @param z z coordinate of the point light
* @param power light power
*/
    public final void pointLight(String name, float x, float y, float z, Color power) {
        parameter(""center"", new Point3(x, y, z));
        parameter(""power"", power);
        light(name, new PointLight());
    }"
org.sunflow.SunflowAPI.render,"/**
* Render using the specified image sampler object and the specified
* display.
*
* @param sampler image sampler
* @param display display object
*/
    public final void render(String optionsName, Display display) {
        renderObjects.updateScene(scene);
        Options opt = lookupOptions(optionsName);
        if (opt == null)
            opt = new Options();
        scene.setCamera(lookupCamera(opt.getString(""camera"", null)));

        // baking
        String bakingInstanceName = opt.getString(""baking.instance"", null);
        if (bakingInstanceName != null) {
            Instance bakingInstance = lookupInstance(bakingInstanceName);
            if (bakingInstance == null) {
                UI.printError(Module.API, ""Unable to bake instance \""%s\"" - not found"", bakingInstanceName);
                return;
            }
            scene.setBakingInstance(bakingInstance);
        } else
            scene.setBakingInstance(null);

        String samplerName = opt.getString(""sampler"", ""bucket"");
        ImageSampler sampler = null;
        if (samplerName.equals(""none"") || samplerName.equals(""null""))
            sampler = null;
        else if (samplerName.equals(""bucket""))
            sampler = bucketRenderer;
        else if (samplerName.equals(""ipr""))
            sampler = progressiveRenderer;
        else if (samplerName.equals(""fast""))
            sampler = new SimpleRenderer();
        else {
            UI.printError(Module.API, ""Unknown sampler type: %s - aborting"", samplerName);
            return;
        }
        scene.render(opt, sampler, display);
    }"
org.sunflow.SunflowAPI.parse,"/**
* Parse the specified filename. The include paths are searched first. The
* contents of the file are simply added to the active scene. This allows to
* break up a scene into parts, even across file formats. The appropriate
* parser is chosen based on file extension.
*
* @param filename filename to load
* @return <code>true</code> upon sucess, <code>false</code> if an error
*         occured.
*/
    public final boolean parse(String filename) {
        if (filename == null)
            return false;
        filename = includeSearchPath.resolvePath(filename);
        SceneParser parser = null;
        if (filename.endsWith("".sc""))
            parser = new SCParser();
        else if (filename.endsWith("".ra2""))
            parser = new RA2Parser();
        else if (filename.endsWith("".ra3""))
            parser = new RA3Parser();
        else if (filename.endsWith("".tri""))
            parser = new TriParser();
        else if (filename.endsWith("".rib""))
            parser = new ShaveRibParser();
        else {
            UI.printError(Module.API, ""Unable to find a suitable parser for: \""%s\"""", filename);
            return false;
        }
        String currentFolder = new File(filename).getAbsoluteFile().getParentFile().getAbsolutePath();
        includeSearchPath.addSearchPath(currentFolder);
        textureSearchPath.addSearchPath(currentFolder);
        return parser.parse(filename, this);
    }"
org.sunflow.SunflowAPI.getBounds,"/**
* Retrieve the bounding box of the scene.
*/
    public final BoundingBox getBounds() {
        return scene.getBounds();
    }"
org.sunflow.SunflowAPI.build,"/**
* This method does nothing, but may be overriden to create scenes
* procedurally.
*/
    public void build() {
    }"
org.sunflow.SunflowAPI.create,"/**
* Create an API object from the specified file. Java files are read by
* Janino and are expected to implement a build method (they implement a
* derived class of SunflowAPI. The build method is called if the code
* compiles succesfully. Other files types are handled by the parse method.
*
* @param filename filename to load
* @return a valid SunflowAPI object or <code>null</code> on failure
*/
    public static SunflowAPI create(String filename, int frameNumber) {
        if (filename == null)
            return new SunflowAPI();
        SunflowAPI api = null;
        if (filename.endsWith("".java"")) {
            Timer t = new Timer();
            UI.printInfo(Module.API, ""Compiling \"""" + filename + ""\"" ..."");
            t.start();
            try {
                FileInputStream stream = new FileInputStream(filename);
                api = (SunflowAPI) ClassBodyEvaluator.createFastClassBodyEvaluator(new Scanner(filename, stream), SunflowAPI.class, ClassLoader.getSystemClassLoader());
                stream.close();
            } catch (CompileException e) {
                UI.printError(Module.API, ""Could not compile: \""%s\"""", filename);
                UI.printError(Module.API, ""%s"", e.getMessage());
                return null;
            } catch (ParseException e) {
                UI.printError(Module.API, ""Could not compile: \""%s\"""", filename);
                UI.printError(Module.API, ""%s"", e.getMessage());
                return null;
            } catch (ScanException e) {
                UI.printError(Module.API, ""Could not compile: \""%s\"""", filename);
                UI.printError(Module.API, ""%s"", e.getMessage());
                return null;
            } catch (IOException e) {
                UI.printError(Module.API, ""Could not compile: \""%s\"""", filename);
                UI.printError(Module.API, ""%s"", e.getMessage());
                return null;
            }
            t.end();
            UI.printInfo(Module.API, ""Compile time: "" + t.toString());
            if (api != null) {
                String currentFolder = new File(filename).getAbsoluteFile().getParentFile().getAbsolutePath();
                api.includeSearchPath.addSearchPath(currentFolder);
                api.textureSearchPath.addSearchPath(currentFolder);
            }
            UI.printInfo(Module.API, ""Build script running ..."");
            t.start();
            api.setCurrentFrame(frameNumber);
            api.build();
            t.end();
            UI.printInfo(Module.API, ""Build script time: %s"", t.toString());
        } else {
            api = new SunflowAPI();
            api = api.parse(filename) ? api : null;
        }
        return api;
    }"
org.sunflow.SunflowAPI.compile,"/**
* Compile the specified code string via Janino. The code must implement a
* build method as described above. The build method is not called on the
* output, it is up the caller to do so.
*
* @param code java code string
* @return a valid SunflowAPI object upon succes, <code>null</code>
*         otherwise.
*/
    public static SunflowAPI compile(String code) {
        try {
            Timer t = new Timer();
            t.start();
            SunflowAPI api = (SunflowAPI) ClassBodyEvaluator.createFastClassBodyEvaluator(new Scanner(null, new StringReader(code)), SunflowAPI.class, (ClassLoader) null);
            t.end();
            UI.printInfo(Module.API, ""Compile time: %s"", t.toString());
            return api;
        } catch (CompileException e) {
            UI.printError(Module.API, ""%s"", e.getMessage());
            return null;
        } catch (ParseException e) {
            UI.printError(Module.API, ""%s"", e.getMessage());
            return null;
        } catch (ScanException e) {
            UI.printError(Module.API, ""%s"", e.getMessage());
            return null;
        } catch (IOException e) {
            UI.printError(Module.API, ""%s"", e.getMessage());
            return null;
        }
    }"
org.sunflow.SunflowAPI.getCurrentFrame,"/**
* Read the value of the current frame. This value is intended only for
* procedural animation creation. It is not used by the Sunflow core in
* anyway. The default value is 1.
*
* @return current frame number
*/
    public int getCurrentFrame() {
        return currentFrame;
    }"
org.sunflow.SunflowAPI.setCurrentFrame,"/**
* Set the value of the current frame. This value is intended only for
* procedural animation creation. It is not used by the Sunflow core in
* anyway. The default value is 1.
*
* @param currentFrame current frame number
*/
    public void setCurrentFrame(int currentFrame) {
        this.currentFrame = currentFrame;
    }
"
org.sunflow.Benchmark.main,"    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println(""Benchmark options:"");
            System.out.println(""  -regen                        Regenerate reference images for a variety of sizes"");
            System.out.println(""  -bench [threads] [resolution] Run a single iteration of the benchmark using the specified thread count and image resolution"");
            System.out.println(""                                Default: threads=0 (auto-detect cpus), resolution=256"");
        } else if (args[0].equals(""-regen"")) {
            int[] sizes = { 32, 64, 96, 128, 256, 384, 512 };
            for (int s : sizes) {
                // run a single iteration to generate the reference image
                Benchmark b = new Benchmark(s, true, false, true);
                b.kernelMain();
            }
        } else if (args[0].equals(""-bench"")) {
            int threads = 0, resolution = 256;
            if (args.length > 1)
                threads = Integer.parseInt(args[1]);
            if (args.length > 2)
                resolution = Integer.parseInt(args[2]);
            Benchmark benchmark = new Benchmark(resolution, false, true, false, threads);
            benchmark.kernelBegin();
            benchmark.kernelMain();
            benchmark.kernelEnd();
        }
    }"
org.sunflow.Benchmark.execute,"    public void execute() {
        // 10 iterations maximum - 10 minute time limit
        BenchmarkFramework framework = new BenchmarkFramework(10, 600);
        framework.execute(this);
    }"
org.sunflow.Benchmark.build,"        public void build() {
            // settings
            parameter(""threads"", threads);
            // spawn regular priority threads
            parameter(""threads.lowPriority"", false);
            parameter(""resolutionX"", resolution);
            parameter(""resolutionY"", resolution);
            parameter(""aa.min"", -1);
            parameter(""aa.max"", 1);
            parameter(""filter"", ""triangle"");
            parameter(""depths.diffuse"", 2);
            parameter(""depths.reflection"", 2);
            parameter(""depths.refraction"", 2);
            parameter(""bucket.order"", ""hilbert"");
            parameter(""bucket.size"", 32);
            // gi options
            parameter(""gi.engine"", ""igi"");
            parameter(""gi.igi.samples"", 90);
            parameter(""gi.igi.c"", 0.000008f);
            options(SunflowAPI.DEFAULT_OPTIONS);
            buildCornellBox();
        }"
org.sunflow.Benchmark.buildCornellBox,"        private void buildCornellBox() {
            // camera
            parameter(""eye"", new Point3(0, 0, -600));
            parameter(""target"", new Point3(0, 0, 0));
            parameter(""up"", new Vector3(0, 1, 0));
            parameter(""fov"", 45.0f);
            camera(""main_camera"", new PinholeLens());
            parameter(""camera"", ""main_camera"");
            options(SunflowAPI.DEFAULT_OPTIONS);
            // cornell box
            Color gray = new Color(0.70f, 0.70f, 0.70f);
            Color blue = new Color(0.25f, 0.25f, 0.80f);
            Color red = new Color(0.80f, 0.25f, 0.25f);
            Color emit = new Color(15, 15, 15);

            float minX = -200;
            float maxX = 200;
            float minY = -160;
            float maxY = minY + 400;
            float minZ = -250;
            float maxZ = 200;

            float[] verts = new float[] { minX, minY, minZ, maxX, minY, minZ,
                    maxX, minY, maxZ, minX, minY, maxZ, minX, maxY, minZ, maxX,
                    maxY, minZ, maxX, maxY, maxZ, minX, maxY, maxZ, };
            int[] indices = new int[] { 0, 1, 2, 2, 3, 0, 4, 5, 6, 6, 7, 4, 1,
                    2, 5, 5, 6, 2, 2, 3, 6, 6, 7, 3, 0, 3, 4, 4, 7, 3 };

            parameter(""diffuse"", gray);
            shader(""gray_shader"", new DiffuseShader());
            parameter(""diffuse"", red);
            shader(""red_shader"", new DiffuseShader());
            parameter(""diffuse"", blue);
            shader(""blue_shader"", new DiffuseShader());

            // build walls
            parameter(""triangles"", indices);
            parameter(""points"", ""point"", ""vertex"", verts);
            parameter(""faceshaders"", new int[] { 0, 0, 0, 0, 1, 1, 0, 0, 2, 2 });
            geometry(""walls"", new TriangleMesh());

            // instance walls
            parameter(""shaders"", new String[] { ""gray_shader"", ""red_shader"",
                    ""blue_shader"" });
            instance(""walls.instance"", ""walls"");

            // create mesh light
            parameter(""points"", ""point"", ""vertex"", new float[] { -50, maxY - 1,
                    -50, 50, maxY - 1, -50, 50, maxY - 1, 50, -50, maxY - 1, 50 });
            parameter(""triangles"", new int[] { 0, 1, 2, 2, 3, 0 });
            parameter(""radiance"", emit);
            parameter(""samples"", 8);
            TriangleMeshLight light = new TriangleMeshLight();
            light.init(""light"", this);

            // spheres
            parameter(""eta"", 1.6f);
            shader(""Glass"", new GlassShader());
            sphere(""glass_sphere"", ""Glass"", -120, minY + 55, -150, 50);
            parameter(""color"", new Color(0.70f, 0.70f, 0.70f));
            shader(""Mirror"", new MirrorShader());
            sphere(""mirror_sphere"", ""Mirror"", 100, minY + 60, -50, 50);

            // scanned model
            geometry(""teapot"", (Tesselatable) new Teapot());
            parameter(""transform"", Matrix4.translation(80, -50, 100).multiply(Matrix4.rotateX((float) -Math.PI / 6)).multiply(Matrix4.rotateY((float) Math.PI / 4)).multiply(Matrix4.rotateX((float) -Math.PI / 2).multiply(Matrix4.scale(1.2f))));
            parameter(""shaders"", ""gray_shader"");
            instance(""teapot.instance1"", ""teapot"");
            parameter(""transform"", Matrix4.translation(-80, -160, 50).multiply(Matrix4.rotateY((float) Math.PI / 4)).multiply(Matrix4.rotateX((float) -Math.PI / 2).multiply(Matrix4.scale(1.2f))));
            parameter(""shaders"", ""gray_shader"");
            instance(""teapot.instance2"", ""teapot"");
        }"
org.sunflow.Benchmark.sphere,"        private void sphere(String name, String shaderName, float x, float y, float z, float radius) {
            geometry(name, new Sphere());
            parameter(""transform"", Matrix4.translation(x, y, z).multiply(Matrix4.scale(radius)));
            parameter(""shaders"", shaderName);
            instance(name + "".instance"", name);
        }
    }

    public void kernelBegin() {
        // allocate a fresh validation target
        validationImage = new int[resolution * resolution];
    }

    public void kernelMain() {
        // this builds and renders the scene
        new BenchmarkScene();
    }

    public void kernelEnd() {
        // make sure the rendered image was correct
        int diff = 0;
        if (referenceImage != null && validationImage.length == referenceImage.length) {
            for (int i = 0; i < validationImage.length; i++) {
                // count absolute RGB differences
                diff += Math.abs((validationImage[i] & 0xFF) - (referenceImage[i] & 0xFF));
                diff += Math.abs(((validationImage[i] >> 8) & 0xFF) - ((referenceImage[i] >> 8) & 0xFF));
                diff += Math.abs(((validationImage[i] >> 16) & 0xFF) - ((referenceImage[i] >> 16) & 0xFF));
            }
            if (diff > errorThreshold)
                UI.printError(Module.BENCH, ""Image check failed! - #errors: %d"", diff);
            else
                UI.printInfo(Module.BENCH, ""Image check passed!"");
        } else
            UI.printError(Module.BENCH, ""Image check failed! - reference is not comparable"");

    }

    public void print(Module m, PrintLevel level, String s) {
        if (showOutput || (showBenchmarkOutput && m == Module.BENCH))
            System.out.println(UI.formatOutput(m, level, s));
        if (level == PrintLevel.ERROR)
            throw new RuntimeException(s);
    }

    public void taskStart(String s, int min, int max) {
        // render progress display not needed
    }

    public void taskStop() {
        // render progress display not needed
    }

    public void taskUpdate(int current) {
        // render progress display not needed
    }

    public void imageBegin(int w, int h, int bucketSize) {
        // we can assume w == h == resolution
    }

    public void imageEnd() {
        // nothing needs to be done - image verification is done externally
    }

    public void imageFill(int x, int y, int w, int h, Color c) {
        // this is not used
    }

    public void imagePrepare(int x, int y, int w, int h, int id) {
        // this is not needed
    }

    public void imageUpdate(int x, int y, int w, int h, Color[] data) {
        // copy bucket data to validation image
        for (int j = 0, index = 0; j < h; j++, y++)
            for (int i = 0, offset = x + resolution * (resolution - 1 - y); i < w; i++, index++, offset++)
                validationImage[offset] = data[index].copy().toNonLinear().toRGB();
    "
org.sunflow.Benchmark.kernelBegin,"    public void kernelBegin() {
        // allocate a fresh validation target
        validationImage = new int[resolution * resolution];
    }"
org.sunflow.Benchmark.kernelMain,"    public void kernelMain() {
        // this builds and renders the scene
        new BenchmarkScene();
    }"
org.sunflow.Benchmark.kernelEnd,"    public void kernelEnd() {
        // make sure the rendered image was correct
        int diff = 0;
        if (referenceImage != null && validationImage.length == referenceImage.length) {
            for (int i = 0; i < validationImage.length; i++) {
                // count absolute RGB differences
                diff += Math.abs((validationImage[i] & 0xFF) - (referenceImage[i] & 0xFF));
                diff += Math.abs(((validationImage[i] >> 8) & 0xFF) - ((referenceImage[i] >> 8) & 0xFF));
                diff += Math.abs(((validationImage[i] >> 16) & 0xFF) - ((referenceImage[i] >> 16) & 0xFF));
            }
            if (diff > errorThreshold)
                UI.printError(Module.BENCH, ""Image check failed! - #errors: %d"", diff);
            else
                UI.printInfo(Module.BENCH, ""Image check passed!"");
        } else
            UI.printError(Module.BENCH, ""Image check failed! - reference is not comparable"");

    }"
org.sunflow.Benchmark.print,"    public void print(Module m, PrintLevel level, String s) {
        if (showOutput || (showBenchmarkOutput && m == Module.BENCH))
            System.out.println(UI.formatOutput(m, level, s));
        if (level == PrintLevel.ERROR)
            throw new RuntimeException(s);
    }"
org.sunflow.Benchmark.taskStart,"    public void taskStart(String s, int min, int max) {
        // render progress display not needed
    }"
org.sunflow.Benchmark.taskStop,"    public void taskStop() {
        // render progress display not needed
    }"
org.sunflow.Benchmark.taskUpdate,"    public void taskUpdate(int current) {
        // render progress display not needed
    }"
org.sunflow.Benchmark.imageBegin,"    public void imageBegin(int w, int h, int bucketSize) {
        // we can assume w == h == resolution
    }"
org.sunflow.Benchmark.imageEnd,"    public void imageEnd() {
        // nothing needs to be done - image verification is done externally
    }"
org.sunflow.Benchmark.imageFill,"    public void imageFill(int x, int y, int w, int h, Color c) {
        // this is not used
    }"
org.sunflow.Benchmark.imagePrepare,"    public void imagePrepare(int x, int y, int w, int h, int id) {
        // this is not needed
    }"
org.sunflow.Benchmark.imageUpdate,"    public void imageUpdate(int x, int y, int w, int h, Color[] data) {
        // copy bucket data to validation image
        for (int j = 0, index = 0; j < h; j++, y++)
            for (int i = 0, offset = x + resolution * (resolution - 1 - y); i < w; i++, index++, offset++)
                validationImage[offset] = data[index].copy().toNonLinear().toRGB();
    }
"
org.sunflow.RenderObjectMap.has,"    final boolean has(String name) {
        return renderObjects.containsKey(name);
    }"
org.sunflow.RenderObjectMap.remove,"    final void remove(String name) {
        RenderObjectHandle obj = renderObjects.get(name);
        if (obj == null) {
            UI.printWarning(Module.API, ""Unable to remove \""%s\"" - object was not defined yet"");
            return;
        }
        UI.printDetailed(Module.API, ""Removing object \""%s\"""", name);
        renderObjects.remove(name);
        // scan through all objects to make sure we don't have any
        // references to the old object still around
        switch (obj.type) {
            case SHADER:
                Shader s = obj.getShader();
                for (FastHashMap.Entry<String, RenderObjectHandle> e : renderObjects) {
                    Instance i = e.getValue().getInstance();
                    if (i != null) {
                        UI.printWarning(Module.API, ""Removing shader \""%s\"" from instance \""%s\"""", name, e.getKey());
                        i.removeShader(s);
                    }
                }
                break;
            case MODIFIER:
                Modifier m = obj.getModifier();
                for (FastHashMap.Entry<String, RenderObjectHandle> e : renderObjects) {
                    Instance i = e.getValue().getInstance();
                    if (i != null) {
                        UI.printWarning(Module.API, ""Removing modifier \""%s\"" from instance \""%s\"""", name, e.getKey());
                        i.removeModifier(m);
                    }
                }
                break;
            case GEOMETRY: {
                Geometry g = obj.getGeometry();
                for (FastHashMap.Entry<String, RenderObjectHandle> e : renderObjects) {
                    Instance i = e.getValue().getInstance();
                    if (i != null && i.hasGeometry(g)) {
                        UI.printWarning(Module.API, ""Removing instance \""%s\"" because it referenced geometry \""%s\"""", e.getKey(), name);
                        remove(e.getKey());
                    }
                }
                break;
            }
            case INSTANCE:
                rebuildInstanceList = true;
                break;
            case LIGHT:
                rebuildLightList = true;
                break;
            default:
                // no dependencies
                break;
        }
    }"
org.sunflow.RenderObjectMap.update,"    final boolean update(String name, ParameterList pl, SunflowAPI api) {
        RenderObjectHandle obj = renderObjects.get(name);
        boolean success;
        if (obj == null) {
            UI.printError(Module.API, ""Unable to update \""%s\"" - object was not defined yet"", name);
            success = false;
        } else {
            UI.printDetailed(Module.API, ""Updating %s object \""%s\"""", obj.typeName(), name);
            success = obj.update(pl, api);
            if (!success) {
                UI.printError(Module.API, ""Unable to update \""%s\"" - removing"", name);
                remove(name);
            } else {
                switch (obj.type) {
                    case GEOMETRY:
                    case INSTANCE:
                        rebuildInstanceList = true;
                        break;
                    case LIGHT:
                        rebuildLightList = true;
                        break;
                    default:
                        break;
                }
            }
        }
        return success;
    }"
org.sunflow.RenderObjectMap.updateScene,"    final void updateScene(Scene scene) {
        if (rebuildInstanceList) {
            UI.printInfo(Module.API, ""Building scene instance list for rendering ..."");
            int numInfinite = 0, numInstance = 0;
            for (FastHashMap.Entry<String, RenderObjectHandle> e : renderObjects) {
                Instance i = e.getValue().getInstance();
                if (i != null) {
                    i.updateBounds();
                    if (i.getBounds() == null)
                        numInfinite++;
                    else
                        numInstance++;
                }
            }
            Instance[] infinite = new Instance[numInfinite];
            Instance[] instance = new Instance[numInstance];
            numInfinite = numInstance = 0;
            for (FastHashMap.Entry<String, RenderObjectHandle> e : renderObjects) {
                Instance i = e.getValue().getInstance();
                if (i != null) {
                    if (i.getBounds() == null) {
                        infinite[numInfinite] = i;
                        numInfinite++;
                    } else {
                        instance[numInstance] = i;
                        numInstance++;
                    }
                }
            }
            scene.setInstanceLists(instance, infinite);
            rebuildInstanceList = false;
        }
        if (rebuildLightList) {
            UI.printInfo(Module.API, ""Building scene light list for rendering ..."");
            ArrayList<LightSource> lightList = new ArrayList<LightSource>();
            for (FastHashMap.Entry<String, RenderObjectHandle> e : renderObjects) {
                LightSource light = e.getValue().getLight();
                if (light != null)
                    lightList.add(light);

            }
            scene.setLightList(lightList.toArray(new LightSource[lightList.size()]));
            rebuildLightList = false;
        }
    }"
org.sunflow.RenderObjectMap.put,"    final void put(String name, Shader shader) {
        renderObjects.put(name, new RenderObjectHandle(shader));
    }"
org.sunflow.RenderObjectMap.put,"    final void put(String name, Modifier modifier) {
        renderObjects.put(name, new RenderObjectHandle(modifier));
    }"
org.sunflow.RenderObjectMap.put,"    final void put(String name, PrimitiveList primitives) {
        renderObjects.put(name, new RenderObjectHandle(primitives));
    }"
org.sunflow.RenderObjectMap.put,"    final void put(String name, Tesselatable tesselatable) {
        renderObjects.put(name, new RenderObjectHandle(tesselatable));
    }"
org.sunflow.RenderObjectMap.put,"    final void put(String name, Instance instance) {
        renderObjects.put(name, new RenderObjectHandle(instance));
    }"
org.sunflow.RenderObjectMap.put,"    final void put(String name, LightSource light) {
        renderObjects.put(name, new RenderObjectHandle(light));
    }"
org.sunflow.RenderObjectMap.put,"    final void put(String name, Camera camera) {
        renderObjects.put(name, new RenderObjectHandle(camera));
    }"
org.sunflow.RenderObjectMap.put,"    final void put(String name, Options options) {
        renderObjects.put(name, new RenderObjectHandle(options));
    }"
org.sunflow.RenderObjectMap.lookupGeometry,"    final Geometry lookupGeometry(String name) {
        if (name == null)
            return null;
        RenderObjectHandle handle = renderObjects.get(name);
        return (handle == null) ? null : handle.getGeometry();
    }"
org.sunflow.RenderObjectMap.lookupInstance,"    final Instance lookupInstance(String name) {
        if (name == null)
            return null;
        RenderObjectHandle handle = renderObjects.get(name);
        return (handle == null) ? null : handle.getInstance();
    }"
org.sunflow.RenderObjectMap.lookupCamera,"    final Camera lookupCamera(String name) {
        if (name == null)
            return null;
        RenderObjectHandle handle = renderObjects.get(name);
        return (handle == null) ? null : handle.getCamera();
    }"
org.sunflow.RenderObjectMap.lookupOptions,"    final Options lookupOptions(String name) {
        if (name == null)
            return null;
        RenderObjectHandle handle = renderObjects.get(name);
        return (handle == null) ? null : handle.getOptions();
    }"
org.sunflow.RenderObjectMap.lookupShader,"    final Shader lookupShader(String name) {
        if (name == null)
            return null;
        RenderObjectHandle handle = renderObjects.get(name);
        return (handle == null) ? null : handle.getShader();
    }"
org.sunflow.RenderObjectMap.lookupModifier,"    final Modifier lookupModifier(String name) {
        if (name == null)
            return null;
        RenderObjectHandle handle = renderObjects.get(name);
        return (handle == null) ? null : handle.getModifier();
    }"
org.sunflow.RenderObjectMap.lookupLight,"    final LightSource lookupLight(String name) {
        if (name == null)
            return null;
        RenderObjectHandle handle = renderObjects.get(name);
        return (handle == null) ? null : handle.getLight();
    }"
org.sunflow.RenderObjectMap.update,"        private boolean update(ParameterList pl, SunflowAPI api) {
            return obj.update(pl, api);
        }"
org.sunflow.RenderObjectMap.typeName,"        private String typeName() {
            return type.name().toLowerCase();
        }"
org.sunflow.RenderObjectMap.getShader,"        private Shader getShader() {
            return (type == RenderObjectType.SHADER) ? (Shader) obj : null;
        }"
org.sunflow.RenderObjectMap.getModifier,"        private Modifier getModifier() {
            return (type == RenderObjectType.MODIFIER) ? (Modifier) obj : null;
        }"
org.sunflow.RenderObjectMap.getGeometry,"        private Geometry getGeometry() {
            return (type == RenderObjectType.GEOMETRY) ? (Geometry) obj : null;
        }"
org.sunflow.RenderObjectMap.getInstance,"        private Instance getInstance() {
            return (type == RenderObjectType.INSTANCE) ? (Instance) obj : null;
        }"
org.sunflow.RenderObjectMap.getLight,"        private LightSource getLight() {
            return (type == RenderObjectType.LIGHT) ? (LightSource) obj : null;
        }"
org.sunflow.RenderObjectMap.getCamera,"        private Camera getCamera() {
            return (type == RenderObjectType.CAMERA) ? (Camera) obj : null;
        }"
org.sunflow.RenderObjectMap.getOptions,"        private Options getOptions() {
            return (type == RenderObjectType.OPTIONS) ? (Options) obj : null;
        }
    "
org.sunflow.DepreactedBenchmark.main,"    public static void main(String[] args) {
        if (args.length > 0 && args[0].equals(""-test""))
            new DepreactedBenchmark(""resources/"", System.out, 0, 512, true, true, true, 4, true, false);
        else {
            // this is used to regenerated the reference frames if needed
            new DepreactedBenchmark(""resources/"", System.out, 0, 128, false, false, true, 4, true, true).build();
            new DepreactedBenchmark(""resources/"", System.out, 0, 256, false, false, true, 4, true, true).build();
            new DepreactedBenchmark(""resources/"", System.out, 0, 384, false, false, true, 4, true, true).build();
            new DepreactedBenchmark(""resources/"", System.out, 0, 512, false, false, true, 4, true, true).build();
        }
    }"
org.sunflow.DepreactedBenchmark.buildCornellBox,"    private void buildCornellBox() {
        // camera
        parameter(""eye"", new Point3(0, 0, -600));
        parameter(""target"", new Point3(0, 0, 0));
        parameter(""up"", new Vector3(0, 1, 0));
        parameter(""fov"", 45.0f);
        String name = getUniqueName(""camera"");
        camera(name, new PinholeLens());
        parameter(""camera"", name);
        options(SunflowAPI.DEFAULT_OPTIONS);
        // cornell box
        Color gray = new Color(0.70f, 0.70f, 0.70f);
        Color blue = new Color(0.25f, 0.25f, 0.80f);
        Color red = new Color(0.80f, 0.25f, 0.25f);
        Color emit = new Color(15, 15, 15);

        float minX = -200;
        float maxX = 200;
        float minY = -160;
        float maxY = minY + 400;
        float minZ = -250;
        float maxZ = 200;

        float[] verts = new float[] { minX, minY, minZ, maxX, minY, minZ, maxX,
                minY, maxZ, minX, minY, maxZ, minX, maxY, minZ, maxX, maxY,
                minZ, maxX, maxY, maxZ, minX, maxY, maxZ, };
        int[] indices = new int[] { 0, 1, 2, 2, 3, 0, 4, 5, 6, 6, 7, 4, 1, 2,
                5, 5, 6, 2, 2, 3, 6, 6, 7, 3, 0, 3, 4, 4, 7, 3 };

        parameter(""diffuse"", gray);
        shader(""gray_shader"", new DiffuseShader());
        parameter(""diffuse"", red);
        shader(""red_shader"", new DiffuseShader());
        parameter(""diffuse"", blue);
        shader(""blue_shader"", new DiffuseShader());

        // build walls
        parameter(""triangles"", indices);
        parameter(""points"", ""point"", ""vertex"", verts);
        parameter(""faceshaders"", new int[] { 0, 0, 0, 0, 1, 1, 0, 0, 2, 2 });
        geometry(""walls"", new TriangleMesh());

        // instance walls
        parameter(""shaders"", new String[] { ""gray_shader"", ""red_shader"",
                ""blue_shader"" });
        instance(""walls.instance"", ""walls"");

        // create mesh light
        parameter(""points"", ""point"", ""vertex"", new float[] { -50, maxY - 1,
                -50, 50, maxY - 1, -50, 50, maxY - 1, 50, -50, maxY - 1, 50 });
        parameter(""triangles"", new int[] { 0, 1, 2, 2, 3, 0 });
        parameter(""radiance"", emit);
        parameter(""samples"", 8);
        TriangleMeshLight light = new TriangleMeshLight();
        light.init(""light"", this);

        // spheres
        parameter(""eta"", 1.6f);
        shader(""Glass"", new GlassShader());
        sphere(""glass_sphere"", ""Glass"", -120, minY + 55, -150, 50);
        parameter(""color"", new Color(0.70f, 0.70f, 0.70f));
        shader(""Mirror"", new MirrorShader());
        sphere(""mirror_sphere"", ""Mirror"", 100, minY + 60, -50, 50);

        // scanned model
        geometry(""teapot"", (Tesselatable) new Teapot());
        parameter(""transform"", Matrix4.translation(80, -50, 100).multiply(Matrix4.rotateX((float) -Math.PI / 6)).multiply(Matrix4.rotateY((float) Math.PI / 4)).multiply(Matrix4.rotateX((float) -Math.PI / 2).multiply(Matrix4.scale(1.2f))));
        parameter(""shaders"", ""gray_shader"");
        instance(""teapot.instance1"", ""teapot"");
        parameter(""transform"", Matrix4.translation(-80, -160, 50).multiply(Matrix4.rotateY((float) Math.PI / 4)).multiply(Matrix4.rotateX((float) -Math.PI / 2).multiply(Matrix4.scale(1.2f))));
        parameter(""shaders"", ""gray_shader"");
        instance(""teapot.instance2"", ""teapot"");
        // gi options
        parameter(""gi.engine"", ""igi"");
        parameter(""gi.igi.samples"", 90);
        parameter(""gi.igi.c"", 0.000008f);
        options(DEFAULT_OPTIONS);
    }"
org.sunflow.DepreactedBenchmark.sphere,"    private void sphere(String name, String shaderName, float x, float y, float z, float radius) {
        geometry(name, new Sphere());
        parameter(""transform"", Matrix4.translation(x, y, z).multiply(Matrix4.scale(radius)));
        parameter(""shaders"", shaderName);
        instance(name + "".instance"", name);
    }"
org.sunflow.DepreactedBenchmark.execute,"    public void execute() {
        if (showGUI)
            render(SunflowAPI.DEFAULT_OPTIONS, new FrameDisplay());
        // prepare the framework
        BenchmarkFramework framework = new BenchmarkFramework(50, 120);
        // run the framework
        framework.execute(this);
    }"
org.sunflow.DepreactedBenchmark.kernelBegin,"    public void kernelBegin() {
        // no per loop setup
    }"
org.sunflow.DepreactedBenchmark.kernelMain,"    public void kernelMain() {
        render(SunflowAPI.DEFAULT_OPTIONS, new ValidatingDisplay(false, errorThreshold));
    }"
org.sunflow.DepreactedBenchmark.kernelEnd,"    public void kernelEnd() {
        // no per loop cleanup
    }"
org.sunflow.DepreactedBenchmark.imageBegin,"        public void imageBegin(int w, int h, int bucketSize) {
            pixels = new int[w * h];
            iw = w;
            ih = h;
        }"
org.sunflow.DepreactedBenchmark.imagePrepare,"        public void imagePrepare(int x, int y, int w, int h, int id) {
        }"
org.sunflow.DepreactedBenchmark.imageUpdate,"        public void imageUpdate(int x, int y, int w, int h, Color[] data) {
            for (int j = 0, index = 0; j < h; j++) {
                for (int i = 0; i < w; i++, index++) {
                    int offset = ((x + i) + iw * (ih - 1 - (y + j)));
                    pixels[offset] = data[index].copy().toNonLinear().toRGB();
                }
            }
        }"
org.sunflow.DepreactedBenchmark.imageFill,"        public void imageFill(int x, int y, int w, int h, Color c) {
        }"
org.sunflow.DepreactedBenchmark.imageEnd,"        public void imageEnd() {
            if (generateReference) {
                reference = pixels;
            } else {
                int diff = 0;
                if (reference != null && pixels.length == reference.length) {
                    for (int i = 0; i < pixels.length; i++) {
                        // count absolute RGB differences
                        diff += Math.abs((pixels[i] & 0xFF) - (reference[i] & 0xFF));
                        diff += Math.abs(((pixels[i] >> 8) & 0xFF) - ((reference[i] >> 8) & 0xFF));
                        diff += Math.abs(((pixels[i] >> 16) & 0xFF) - ((reference[i] >> 16) & 0xFF));
                    }
                    if (diff > errorThreshold)
                        UI.printError(Module.BENCH, ""Image check failed! - #errors: %d"", diff);
                    else
                        UI.printInfo(Module.BENCH, ""Image check passed!"");
                } else
                    UI.printError(Module.BENCH, ""Image check failed! - reference is not comparable"");
            }
        }
    }

    public void print(Module m, PrintLevel level, String s) {
        if (stream != null)
            if (showOutput || (showBenchmarkOutput && m == Module.BENCH))
                stream.println(UI.formatOutput(m, level, s));
        if (level == PrintLevel.ERROR)
            throw new RuntimeException(s);
    }

    public void taskStart(String s, int min, int max) {
    }

    public void taskUpdate(int current) {
    }

    public void taskStop() {
    "
org.sunflow.DepreactedBenchmark.print,"    public void print(Module m, PrintLevel level, String s) {
        if (stream != null)
            if (showOutput || (showBenchmarkOutput && m == Module.BENCH))
                stream.println(UI.formatOutput(m, level, s));
        if (level == PrintLevel.ERROR)
            throw new RuntimeException(s);
    }"
org.sunflow.DepreactedBenchmark.taskStart,"    public void taskStart(String s, int min, int max) {
    }"
org.sunflow.DepreactedBenchmark.taskUpdate,"    public void taskUpdate(int current) {
    }"
org.sunflow.DepreactedBenchmark.taskStop,"    public void taskStop() {
    }
"
org.sunflow.SunskyTest.main,"    public static void main(String[] args) {
        new SunskyTest(true, 0).build();
    }
"
org.sunflow.core.Texture.load,"    private synchronized void load() {
        if (loaded != 0)
            return;
        try {
            UI.printInfo(Module.TEX, ""Reading texture bitmap from: \""%s\"" ..."", filename);
            bitmap = new Bitmap(filename, isLinear);
            if (bitmap.getWidth() == 0 || bitmap.getHeight() == 0)
                bitmap = null;
        } catch (IOException e) {
            UI.printError(Module.TEX, ""%s"", e.getMessage());
        }
        loaded = 1;
    }"
org.sunflow.core.Texture.getBitmap,"    public Bitmap getBitmap() {
        if (loaded == 0)
            load();
        return bitmap;
    }"
org.sunflow.core.Texture.getPixel,"/**
* Gets the color at location (x,y) in the texture. The lookup is performed
* using the fractional component of the coordinates, treating the texture
* as a unit square tiled in both directions. Bicubic filtering is performed
* on the four nearest pixels to the lookup point.
*
* @param x x coordinate into the texture
* @param y y coordinate into the texture
* @return filtered color at location (x,y)
*/
    public Color getPixel(float x, float y) {
        Bitmap bitmap = getBitmap();
        if (bitmap == null)
            return Color.BLACK;
        x = x - (int) x;
        y = y - (int) y;
        if (x < 0)
            x++;
        if (y < 0)
            y++;
        float dx = (float) x * (bitmap.getWidth() - 1);
        float dy = (float) y * (bitmap.getHeight() - 1);
        int ix0 = (int) dx;
        int iy0 = (int) dy;
        int ix1 = (ix0 + 1) % bitmap.getWidth();
        int iy1 = (iy0 + 1) % bitmap.getHeight();
        float u = dx - ix0;
        float v = dy - iy0;
        u = u * u * (3.0f - (2.0f * u));
        v = v * v * (3.0f - (2.0f * v));
        float k00 = (1.0f - u) * (1.0f - v);
        Color c00 = bitmap.getPixel(ix0, iy0);
        float k01 = (1.0f - u) * v;
        Color c01 = bitmap.getPixel(ix0, iy1);
        float k10 = u * (1.0f - v);
        Color c10 = bitmap.getPixel(ix1, iy0);
        float k11 = u * v;
        Color c11 = bitmap.getPixel(ix1, iy1);
        Color c = Color.mul(k00, c00);
        c.madd(k01, c01);
        c.madd(k10, c10);
        c.madd(k11, c11);
        return c;
    }"
org.sunflow.core.Texture.getNormal,"    public Vector3 getNormal(float x, float y, OrthoNormalBasis basis) {
        float[] rgb = getPixel(x, y).getRGB();
        return basis.transform(new Vector3(2 * rgb[0] - 1, 2 * rgb[1] - 1, 2 * rgb[2] - 1)).normalize();
    }"
org.sunflow.core.Texture.getBump,"    public Vector3 getBump(float x, float y, OrthoNormalBasis basis, float scale) {
        Bitmap bitmap = getBitmap();
        if (bitmap == null)
            return basis.transform(new Vector3(0, 0, 1));
        float dx = 1.0f / (bitmap.getWidth() - 1);
        float dy = 1.0f / (bitmap.getHeight() - 1);
        float b0 = getPixel(x, y).getLuminance();
        float bx = getPixel(x + dx, y).getLuminance();
        float by = getPixel(x, y + dy).getLuminance();
        return basis.transform(new Vector3(scale * (bx - b0) / dx, scale * (by - b0) / dy, 1)).normalize();
    }
"
org.sunflow.core.LightServer.setLights,"    void setLights(LightSource[] lights) {
        this.lights = lights;
    }"
org.sunflow.core.LightServer.shadingCache,"    void shadingCache(float shadingRate) {
        shadingCache = shadingRate > 0 ? new CacheEntry[4096] : null;
        shadingCacheResolution = (float) (1 / Math.sqrt(shadingRate));
    }"
org.sunflow.core.LightServer.getScene,"    Scene getScene() {
        return scene;
    }"
org.sunflow.core.LightServer.setShaderOverride,"    void setShaderOverride(Shader shader, boolean photonOverride) {
        shaderOverride = shader;
        shaderOverridePhotons = photonOverride;
    }"
org.sunflow.core.LightServer.build,"    boolean build(Options options) {
        // read options
        maxDiffuseDepth = options.getInt(""depths.diffuse"", maxDiffuseDepth);
        maxReflectionDepth = options.getInt(""depths.reflection"", maxReflectionDepth);
        maxRefractionDepth = options.getInt(""depths.refraction"", maxRefractionDepth);
        giEngine = GIEngineFactory.create(options);
        String caustics = options.getString(""caustics"", null);
        if (caustics == null || caustics.equals(""none""))
            causticPhotonMap = null;
        else if (caustics != null && caustics.equals(""kd""))
            causticPhotonMap = new CausticPhotonMap(options);
        else {
            UI.printWarning(Module.LIGHT, ""Unrecognized caustics photon map engine \""%s\"" - ignoring"", caustics);
            causticPhotonMap = null;
        }

        // validate options
        maxDiffuseDepth = Math.max(0, maxDiffuseDepth);
        maxReflectionDepth = Math.max(0, maxReflectionDepth);
        maxRefractionDepth = Math.max(0, maxRefractionDepth);

        Timer t = new Timer();
        t.start();
        // count total number of light samples
        int numLightSamples = 0;
        for (int i = 0; i < lights.length; i++) {
            assert lights[i].getNumSamples() >= 0;
            numLightSamples += lights[i].getNumSamples();
        }
        // initialize gi engine
        if (giEngine != null) {
            if (!giEngine.init(scene))
                return false;
        }

        if (!calculatePhotons(causticPhotonMap, ""caustic"", 0))
            return false;
        t.end();
        cacheLookups = 0;
        cacheHits = 0;
        cacheEmptyEntryMisses = 0;
        cacheWrongEntryMisses = 0;
        cacheEntryAdditions = 0;
        if (shadingCache != null) {
            // clear shading cache
            for (int i = 0; i < shadingCache.length; i++)
                shadingCache[i] = null;
        }
        UI.printInfo(Module.LIGHT, ""Light Server stats:"");
        UI.printInfo(Module.LIGHT, ""  * Light sources found: %d"", lights.length);
        UI.printInfo(Module.LIGHT, ""  * Light samples:       %d"", numLightSamples);
        UI.printInfo(Module.LIGHT, ""  * Max raytrace depth:"");
        UI.printInfo(Module.LIGHT, ""      - Diffuse          %d"", maxDiffuseDepth);
        UI.printInfo(Module.LIGHT, ""      - Reflection       %d"", maxReflectionDepth);
        UI.printInfo(Module.LIGHT, ""      - Refraction       %d"", maxRefractionDepth);
        UI.printInfo(Module.LIGHT, ""  * GI engine            %s"", options.getString(""gi.engine"", ""none""));
        UI.printInfo(Module.LIGHT, ""  * Caustics:            %s"", caustics == null ? ""none"" : caustics);
        UI.printInfo(Module.LIGHT, ""  * Shader override:     %b"", shaderOverride);
        UI.printInfo(Module.LIGHT, ""  * Photon override:     %b"", shaderOverridePhotons);
        UI.printInfo(Module.LIGHT, ""  * Shading cache:       %s"", shadingCache == null ? ""off"" : ""on"");
        UI.printInfo(Module.LIGHT, ""  * Build time:          %s"", t.toString());
        return true;
    }"
org.sunflow.core.LightServer.showStats,"    void showStats() {
        if (shadingCache == null)
            return;
        int numUsedEntries = 0;
        for (CacheEntry e : shadingCache)
            numUsedEntries += (e != null) ? 1 : 0;
        UI.printInfo(Module.LIGHT, ""Shading cache stats:"");
        UI.printInfo(Module.LIGHT, ""  * Used entries:        %d (%d%%)"", numUsedEntries, (100 * numUsedEntries) / shadingCache.length);
        UI.printInfo(Module.LIGHT, ""  * Lookups:             %d"", cacheLookups);
        UI.printInfo(Module.LIGHT, ""  * Hits:                %d"", cacheHits);
        UI.printInfo(Module.LIGHT, ""  * Hit rate:            %d%%"", (100 * cacheHits) / cacheLookups);
        UI.printInfo(Module.LIGHT, ""  * Empty entry misses:  %d"", cacheEmptyEntryMisses);
        UI.printInfo(Module.LIGHT, ""  * Wrong entry misses:  %d"", cacheWrongEntryMisses);
        UI.printInfo(Module.LIGHT, ""  * Entry adds:          %d"", cacheEntryAdditions);
    }"
org.sunflow.core.LightServer.calculatePhotons,"    boolean calculatePhotons(final PhotonStore map, String type, final int seed) {
        if (map == null)
            return true;
        if (lights.length == 0) {
            UI.printError(Module.LIGHT, ""Unable to trace %s photons, no lights in scene"", type);
            return false;
        }
        final float[] histogram = new float[lights.length];
        histogram[0] = lights[0].getPower();
        for (int i = 1; i < lights.length; i++)
            histogram[i] = histogram[i - 1] + lights[i].getPower();
        UI.printInfo(Module.LIGHT, ""Tracing %s photons ..."", type);
        int numEmittedPhotons = map.numEmit();
        if (numEmittedPhotons <= 0 || histogram[histogram.length - 1] <= 0) {
            UI.printError(Module.LIGHT, ""Photon mapping enabled, but no %s photons to emit"", type);
            return false;
        }
        map.prepare(scene.getBounds());
        UI.taskStart(""Tracing "" + type + "" photons"", 0, numEmittedPhotons);
        Thread[] photonThreads = new Thread[scene.getThreads()];
        final float scale = 1.0f / numEmittedPhotons;
        int delta = numEmittedPhotons / photonThreads.length;
        photonCounter = 0;
        Timer photonTimer = new Timer();
        photonTimer.start();
        for (int i = 0; i < photonThreads.length; i++) {
            final int threadID = i;
            final int start = threadID * delta;
            final int end = (threadID == (photonThreads.length - 1)) ? numEmittedPhotons : (threadID + 1) * delta;
            photonThreads[i] = new Thread(new Runnable() {
                public void run() {
                    IntersectionState istate = new IntersectionState();
                    for (int i = start; i < end; i++) {
                        synchronized (LightServer.this) {
                            UI.taskUpdate(photonCounter);
                            photonCounter++;
                            if (UI.taskCanceled())
                                return;
                        }

                        int qmcI = i + seed;

                        double rand = QMC.halton(0, qmcI) * histogram[histogram.length - 1];
                        int j = 0;
                        while (rand >= histogram[j] && j < histogram.length)
                            j++;
                        // make sure we didn't pick a zero-probability light
                        if (j == histogram.length)
                            continue;

                        double randX1 = (j == 0) ? rand / histogram[0] : (rand - histogram[j]) / (histogram[j] - histogram[j - 1]);
                        double randY1 = QMC.halton(1, qmcI);
                        double randX2 = QMC.halton(2, qmcI);
                        double randY2 = QMC.halton(3, qmcI);
                        Point3 pt = new Point3();
                        Vector3 dir = new Vector3();
                        Color power = new Color();
                        lights[j].getPhoton(randX1, randY1, randX2, randY2, pt, dir, power);
                        power.mul(scale);
                        Ray r = new Ray(pt, dir);
                        scene.trace(r, istate);
                        if (istate.hit())
                            shadePhoton(ShadingState.createPhotonState(r, istate, qmcI, map, LightServer.this), power);
                    }
                }
            });
            photonThreads[i].setPriority(scene.getThreadPriority());
            photonThreads[i].start();
        }
        for (int i = 0; i < photonThreads.length; i++) {
            try {
                photonThreads[i].join();
            } catch (InterruptedException e) {
                UI.printError(Module.LIGHT, ""Photon thread %d of %d was interrupted"", i + 1, photonThreads.length);
                return false;
            }
        }
        if (UI.taskCanceled()) {
            UI.taskStop(); // shut down task cleanly
            return false;
        }
        photonTimer.end();
        UI.taskStop();
        UI.printInfo(Module.LIGHT, ""Tracing time for %s photons: %s"", type, photonTimer.toString());
        map.init();
        return true;
    }"
org.sunflow.core.LightServer.run,"                public void run() {
                    IntersectionState istate = new IntersectionState();
                    for (int i = start; i < end; i++) {
                        synchronized (LightServer.this) {
                            UI.taskUpdate(photonCounter);
                            photonCounter++;
                            if (UI.taskCanceled())
                                return;
                        }

                        int qmcI = i + seed;

                        double rand = QMC.halton(0, qmcI) * histogram[histogram.length - 1];
                        int j = 0;
                        while (rand >= histogram[j] && j < histogram.length)
                            j++;
                        // make sure we didn't pick a zero-probability light
                        if (j == histogram.length)
                            continue;

                        double randX1 = (j == 0) ? rand / histogram[0] : (rand - histogram[j]) / (histogram[j] - histogram[j - 1]);
                        double randY1 = QMC.halton(1, qmcI);
                        double randX2 = QMC.halton(2, qmcI);
                        double randY2 = QMC.halton(3, qmcI);
                        Point3 pt = new Point3();
                        Vector3 dir = new Vector3();
                        Color power = new Color();
                        lights[j].getPhoton(randX1, randY1, randX2, randY2, pt, dir, power);
                        power.mul(scale);
                        Ray r = new Ray(pt, dir);
                        scene.trace(r, istate);
                        if (istate.hit())
                            shadePhoton(ShadingState.createPhotonState(r, istate, qmcI, map, LightServer.this), power);
                    }
                }
            "
org.sunflow.core.LightServer.shadePhoton,"    void shadePhoton(ShadingState state, Color power) {
        state.getInstance().prepareShadingState(state);
        Shader shader = getPhotonShader(state);
        // scatter photon
        if (shader != null)
            shader.scatterPhoton(state, power);
    }"
org.sunflow.core.LightServer.traceDiffusePhoton,"    void traceDiffusePhoton(ShadingState previous, Ray r, Color power) {
        if (previous.getDiffuseDepth() >= maxDiffuseDepth)
            return;
        IntersectionState istate = previous.getIntersectionState();
        scene.trace(r, istate);
        if (previous.getIntersectionState().hit()) {
            // create a new shading context
            ShadingState state = ShadingState.createDiffuseBounceState(previous, r, 0);
            shadePhoton(state, power);
        }
    }"
org.sunflow.core.LightServer.traceReflectionPhoton,"    void traceReflectionPhoton(ShadingState previous, Ray r, Color power) {
        if (previous.getReflectionDepth() >= maxReflectionDepth)
            return;
        IntersectionState istate = previous.getIntersectionState();
        scene.trace(r, istate);
        if (previous.getIntersectionState().hit()) {
            // create a new shading context
            ShadingState state = ShadingState.createReflectionBounceState(previous, r, 0);
            shadePhoton(state, power);
        }
    }"
org.sunflow.core.LightServer.traceRefractionPhoton,"    void traceRefractionPhoton(ShadingState previous, Ray r, Color power) {
        if (previous.getRefractionDepth() >= maxRefractionDepth)
            return;
        IntersectionState istate = previous.getIntersectionState();
        scene.trace(r, istate);
        if (previous.getIntersectionState().hit()) {
            // create a new shading context
            ShadingState state = ShadingState.createRefractionBounceState(previous, r, 0);
            shadePhoton(state, power);
        }
    }"
org.sunflow.core.LightServer.getShader,"    private Shader getShader(ShadingState state) {
        return shaderOverride != null ? shaderOverride : state.getShader();
    }"
org.sunflow.core.LightServer.getPhotonShader,"    private Shader getPhotonShader(ShadingState state) {
        return (shaderOverride != null && shaderOverridePhotons) ? shaderOverride : state.getShader();

    }"
org.sunflow.core.LightServer.getRadiance,"    ShadingState getRadiance(float rx, float ry, int i, Ray r, IntersectionState istate) {
        scene.trace(r, istate);
        if (istate.hit()) {
            ShadingState state = ShadingState.createState(istate, rx, ry, r, i, this);
            state.getInstance().prepareShadingState(state);
            Shader shader = getShader(state);
            if (shader == null) {
                state.setResult(Color.BLACK);
                return state;
            }
            if (shadingCache != null) {
                Color c = lookupShadingCache(state, shader);
                if (c != null) {
                    state.setResult(c);
                    return state;
                }
            }
            state.setResult(shader.getRadiance(state));
            if (shadingCache != null)
                addShadingCache(state, shader, state.getResult());
            return state;
        } else
            return null;
    }"
org.sunflow.core.LightServer.shadeBakeResult,"    void shadeBakeResult(ShadingState state) {
        Shader shader = getShader(state);
        if (shader != null)
            state.setResult(shader.getRadiance(state));
        else
            state.setResult(Color.BLACK);
    }"
org.sunflow.core.LightServer.shadeHit,"    Color shadeHit(ShadingState state) {
        state.getInstance().prepareShadingState(state);
        Shader shader = getShader(state);
        return (shader != null) ? shader.getRadiance(state) : Color.BLACK;
    }"
org.sunflow.core.LightServer.hash,"    private static final int hash(int x, int y) {
        // long bits = java.lang.Double.doubleToLongBits(x);
        // bits ^= java.lang.Double.doubleToLongBits(y) * 31;
        // return (((int) bits) ^ ((int) (bits >> 32)));
        return x ^ y;
    }"
org.sunflow.core.LightServer.lookupShadingCache,"    private synchronized Color lookupShadingCache(ShadingState state, Shader shader) {
        if (state.getNormal() == null)
            return null;
        cacheLookups++;
        int cx = (int) (state.getRasterX() * shadingCacheResolution);
        int cy = (int) (state.getRasterY() * shadingCacheResolution);
        int hash = hash(cx, cy);
        CacheEntry e = shadingCache[hash & (shadingCache.length - 1)];
        if (e == null) {
            cacheEmptyEntryMisses++;
            return null;
        }
        // entry maps to correct pixel
        if (e.cx == cx && e.cy == cy) {
            // search further
            for (Sample s = e.first; s != null; s = s.next) {
                if (s.i != state.getInstance())
                    continue;
                // if (s.prim != state.getPrimitiveID())
                // continue;
                if (s.s != shader)
                    continue;
                if (state.getNormal().dot(s.nx, s.ny, s.nz) < 0.95f)
                    continue;
                // we have a match
                cacheHits++;
                return s.c;
            }
        } else
            cacheWrongEntryMisses++;
        return null;
    }"
org.sunflow.core.LightServer.addShadingCache,"    private synchronized void addShadingCache(ShadingState state, Shader shader, Color c) {
        // don't cache samples with null normals
        if (state.getNormal() == null)
            return;
        cacheEntryAdditions++;
        int cx = (int) (state.getRasterX() * shadingCacheResolution);
        int cy = (int) (state.getRasterY() * shadingCacheResolution);
        int h = hash(cx, cy) & (shadingCache.length - 1);
        CacheEntry e = shadingCache[h];
        // new entry ?
        if (e == null)
            e = shadingCache[h] = new CacheEntry();
        Sample s = new Sample();
        s.i = state.getInstance();
        // s.prim = state.getPrimitiveID();
        s.s = shader;
        s.c = c;
        s.nx = state.getNormal().x;
        s.ny = state.getNormal().y;
        s.nz = state.getNormal().z;
        if (e.cx == cx && e.cy == cy) {
            // same pixel - just add to the front of the list
            s.next = e.first;
            e.first = s;
        } else {
            // different pixel - new list
            e.cx = cx;
            e.cy = cy;
            s.next = null;
            e.first = s;
        }
    }"
org.sunflow.core.LightServer.traceGlossy,"    Color traceGlossy(ShadingState previous, Ray r, int i) {
        // limit path depth and disable caustic paths
        if (previous.getReflectionDepth() >= maxReflectionDepth || previous.getDiffuseDepth() > 0)
            return Color.BLACK;
        IntersectionState istate = previous.getIntersectionState();
        scene.trace(r, istate);
        return istate.hit() ? shadeHit(ShadingState.createGlossyBounceState(previous, r, i)) : Color.BLACK;
    }"
org.sunflow.core.LightServer.traceReflection,"    Color traceReflection(ShadingState previous, Ray r, int i) {
        // limit path depth and disable caustic paths
        if (previous.getReflectionDepth() >= maxReflectionDepth || previous.getDiffuseDepth() > 0)
            return Color.BLACK;
        IntersectionState istate = previous.getIntersectionState();
        scene.trace(r, istate);
        return istate.hit() ? shadeHit(ShadingState.createReflectionBounceState(previous, r, i)) : Color.BLACK;
    }"
org.sunflow.core.LightServer.traceRefraction,"    Color traceRefraction(ShadingState previous, Ray r, int i) {
        // limit path depth and disable caustic paths
        if (previous.getRefractionDepth() >= maxRefractionDepth || previous.getDiffuseDepth() > 0)
            return Color.BLACK;
        IntersectionState istate = previous.getIntersectionState();
        scene.trace(r, istate);
        return istate.hit() ? shadeHit(ShadingState.createRefractionBounceState(previous, r, i)) : Color.BLACK;
    }"
org.sunflow.core.LightServer.traceFinalGather,"    ShadingState traceFinalGather(ShadingState previous, Ray r, int i) {
        if (previous.getDiffuseDepth() >= maxDiffuseDepth)
            return null;
        IntersectionState istate = previous.getIntersectionState();
        scene.trace(r, istate);
        return istate.hit() ? ShadingState.createFinalGatherState(previous, r, i) : null;
    }"
org.sunflow.core.LightServer.getGlobalRadiance,"    Color getGlobalRadiance(ShadingState state) {
        if (giEngine == null)
            return Color.BLACK;
        return giEngine.getGlobalRadiance(state);
    }"
org.sunflow.core.LightServer.getIrradiance,"    Color getIrradiance(ShadingState state, Color diffuseReflectance) {
        // no gi engine, or we have already exceeded number of available bounces
        if (giEngine == null || state.getDiffuseDepth() >= maxDiffuseDepth)
            return Color.BLACK;
        return giEngine.getIrradiance(state, diffuseReflectance);
    }"
org.sunflow.core.LightServer.initLightSamples,"    void initLightSamples(ShadingState state) {
        for (LightSource l : lights)
            l.getSamples(state);
    }"
org.sunflow.core.LightServer.initCausticSamples,"    void initCausticSamples(ShadingState state) {
        if (causticPhotonMap != null)
            causticPhotonMap.getSamples(state);
    }
"
org.sunflow.core.LightSource.getNumSamples,"/**
* Get the maximum number of samples that can be taken from this light
* source.
*
* @return maximum number of samples to be taken from this light source
*/
    public int getNumSamples();

    /**
     * Samples the light source to compute direct illumination. Light samples
     * can be created using the {@link LightSample} class and added to the
     * current {@link ShadingState}. This method is responsible for the
     * shooting of shadow rays which allows for non-physical lights that don't
     * cast shadows. It is recommended that only a single shadow ray be shot if
     * {@link ShadingState#getDiffuseDepth()}"
org.sunflow.core.LightSource.getSamples,"/**
* Samples the light source to compute direct illumination. Light samples
* can be created using the {@link LightSample} class and added to the
* current {@link ShadingState}. This method is responsible for the
* shooting of shadow rays which allows for non-physical lights that don't
* cast shadows. It is recommended that only a single shadow ray be shot if
* {@link ShadingState#getDiffuseDepth()} is greater than 0. This avoids an
* exponential number of shadow rays from being traced.
*
* @param state current state, including point to be shaded
* @see LightSample
*/
"
org.sunflow.core.LightSource.getPhoton,"/**
* Gets a photon to emit from this light source by setting each of the
* arguments. The two sampling parameters are points on the unit square that
* can be used to sample a position and/or direction for the emitted photon.
*
* @param randX1 sampling parameter
* @param randY1 sampling parameter
* @param randX2 sampling parameter
* @param randY2 sampling parameter
* @param p position to shoot the photon from
* @param dir direction to shoot the photon in
* @param power power of the photon
*/
"
org.sunflow.core.LightSource.getPower,"/**
* Get the total power emitted by this light source. Lights that have 0
* power will not emit any photons.
*
* @return light source power
*/
    float getPower();
"
org.sunflow.core.ParameterList.clear,"/**
* Clears the list of all its members. If some members were never used, a
* warning will be printed to remind the user something may be wrong.
*/
    public void clear(boolean showUnused) {
        if (showUnused) {
            for (FastHashMap.Entry<String, Parameter> e : list) {
                if (!e.getValue().checked)
                    UI.printWarning(Module.API, ""Unused parameter: %s - %s"", e.getKey(), e.getValue());
            }
        }
        list.clear();
        numVerts = numFaces = numFaceVerts = 0;
    }"
org.sunflow.core.ParameterList.setFaceCount,"/**
* Setup how many faces should be used to check member count on ""face""
* interpolated parameters.
*
* @param numFaces number of faces
*/
    public void setFaceCount(int numFaces) {
        this.numFaces = numFaces;
    }"
org.sunflow.core.ParameterList.setVertexCount,"/**
* Setup how many vertices should be used to check member count of ""vertex""
* interpolated parameters.
*
* @param numVerts number of vertices
*/
    public void setVertexCount(int numVerts) {
        this.numVerts = numVerts;
    }"
org.sunflow.core.ParameterList.setFaceVertexCount,"/**
* Setup how many ""face-vertices"" should be used to check member count of
* ""facevarying"" interpolated parameters. This should be equal to the sum of
* the number of vertices on each face.
*
* @param numFaceVerts number of ""face-vertices""
*/
    public void setFaceVertexCount(int numFaceVerts) {
        this.numFaceVerts = numFaceVerts;
    }"
org.sunflow.core.ParameterList.addString,"/**
* Add the specified string as a parameter. <code>null</code> values are
* not permitted.
*
* @param name parameter name
* @param value parameter value
*/
    public void addString(String name, String value) {
        add(name, new Parameter(value));
    }"
org.sunflow.core.ParameterList.addInteger,"/**
* Add the specified integer as a parameter. <code>null</code> values are
* not permitted.
*
* @param name parameter name
* @param value parameter value
*/
    public void addInteger(String name, int value) {
        add(name, new Parameter(value));
    }"
org.sunflow.core.ParameterList.addBoolean,"/**
* Add the specified boolean as a parameter. <code>null</code> values are
* not permitted.
*
* @param name parameter name
* @param value parameter value
*/
    public void addBoolean(String name, boolean value) {
        add(name, new Parameter(value));
    }"
org.sunflow.core.ParameterList.addFloat,"/**
* Add the specified float as a parameter. <code>null</code> values are
* not permitted.
*
* @param name parameter name
* @param value parameter value
*/
    public void addFloat(String name, float value) {
        add(name, new Parameter(value));
    }"
org.sunflow.core.ParameterList.addColor,"/**
* Add the specified color as a parameter. <code>null</code> values are
* not permitted.
*
* @param name parameter name
* @param value parameter value
*/
    public void addColor(String name, Color value) {
        if (value == null)
            throw new NullPointerException();
        add(name, new Parameter(value));
    }"
org.sunflow.core.ParameterList.addIntegerArray,"/**
* Add the specified array of integers as a parameter. <code>null</code>
* values are not permitted.
*
* @param name parameter name
* @param value parameter value
*/
    public void addIntegerArray(String name, int[] array) {
        if (array == null)
            throw new NullPointerException();
        add(name, new Parameter(array));
    }"
org.sunflow.core.ParameterList.addStringArray,"/**
* Add the specified array of integers as a parameter. <code>null</code>
* values are not permitted.
*
* @param name parameter name
* @param value parameter value
*/
    public void addStringArray(String name, String[] array) {
        if (array == null)
            throw new NullPointerException();
        add(name, new Parameter(array));
    }"
org.sunflow.core.ParameterList.addFloats,"/**
* Add the specified floats as a parameter. <code>null</code> values are
* not permitted.
*
* @param name parameter name
* @param interp interpolation type
* @param value parameter value
*/
    public void addFloats(String name, InterpolationType interp, float[] data) {
        if (data == null) {
            UI.printError(Module.API, ""Cannot create float parameter %s -- invalid data length"", name);
            return;
        }
        add(name, new Parameter(ParameterType.FLOAT, interp, data));
    }"
org.sunflow.core.ParameterList.addPoints,"/**
* Add the specified points as a parameter. <code>null</code> values are
* not permitted.
*
* @param name parameter name
* @param interp interpolation type
* @param value parameter value
*/
    public void addPoints(String name, InterpolationType interp, float[] data) {
        if (data == null || data.length % 3 != 0) {
            UI.printError(Module.API, ""Cannot create point parameter %s -- invalid data length"", name);
            return;
        }
        add(name, new Parameter(ParameterType.POINT, interp, data));
    }"
org.sunflow.core.ParameterList.addVectors,"    public void addVectors(String name, InterpolationType interp, float[] data) {
        if (data == null || data.length % 3 != 0) {
            UI.printError(Module.API, ""Cannot create vector parameter %s -- invalid data length"", name);
            return;
        }
        add(name, new Parameter(ParameterType.VECTOR, interp, data));
    }"
org.sunflow.core.ParameterList.addTexCoords,"/**
* Add the specified texture coordinates as a parameter. <code>null</code>
* values are not permitted.
*
* @param name parameter name
* @param interp interpolation type
* @param value parameter value
*/
    public void addTexCoords(String name, InterpolationType interp, float[] data) {
        if (data == null || data.length % 2 != 0) {
            UI.printError(Module.API, ""Cannot create texcoord parameter %s -- invalid data length"", name);
            return;
        }
        add(name, new Parameter(ParameterType.TEXCOORD, interp, data));
    }"
org.sunflow.core.ParameterList.addMatrices,"/**
* Add the specified matrices as a parameter. <code>null</code> values are
* not permitted.
*
* @param name parameter name
* @param interp interpolation type
* @param value parameter value
*/
    public void addMatrices(String name, InterpolationType interp, float[] data) {
        if (data == null || data.length % 16 != 0) {
            UI.printError(Module.API, ""Cannot create matrix parameter %s -- invalid data length"", name);
            return;
        }
        add(name, new Parameter(ParameterType.MATRIX, interp, data));
    }"
org.sunflow.core.ParameterList.add,"    private void add(String name, Parameter param) {
        if (name == null)
            UI.printError(Module.API, ""Cannot declare parameter with null name"");
        else if (list.put(name, param) != null)
            UI.printWarning(Module.API, ""Parameter %s was already defined -- overwriting"", name);
    }"
org.sunflow.core.ParameterList.getString,"    public String getString(String name, String defaultValue) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.STRING, InterpolationType.NONE, 1, p))
            return p.getStringValue();
        return defaultValue;
    }"
org.sunflow.core.ParameterList.getStringArray,"    public String[] getStringArray(String name, String[] defaultValue) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.STRING, InterpolationType.NONE, -1, p))
            return p.getStrings();
        return defaultValue;
    }"
org.sunflow.core.ParameterList.getInt,"    public int getInt(String name, int defaultValue) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.INT, InterpolationType.NONE, 1, p))
            return p.getIntValue();
        return defaultValue;
    }"
org.sunflow.core.ParameterList.getIntArray,"    public int[] getIntArray(String name) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.INT, InterpolationType.NONE, -1, p))
            return p.getInts();
        return null;
    }"
org.sunflow.core.ParameterList.getBoolean,"    public boolean getBoolean(String name, boolean defaultValue) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.BOOL, InterpolationType.NONE, 1, p))
            return p.getBoolValue();
        return defaultValue;
    }"
org.sunflow.core.ParameterList.getFloat,"    public float getFloat(String name, float defaultValue) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.FLOAT, InterpolationType.NONE, 1, p))
            return p.getFloatValue();
        return defaultValue;
    }"
org.sunflow.core.ParameterList.getColor,"    public Color getColor(String name, Color defaultValue) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.COLOR, InterpolationType.NONE, 1, p))
            return p.getColor();
        return defaultValue;
    }"
org.sunflow.core.ParameterList.getPoint,"    public Point3 getPoint(String name, Point3 defaultValue) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.POINT, InterpolationType.NONE, 1, p))
            return p.getPoint();
        return defaultValue;
    }"
org.sunflow.core.ParameterList.getVector,"    public Vector3 getVector(String name, Vector3 defaultValue) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.VECTOR, InterpolationType.NONE, 1, p))
            return p.getVector();
        return defaultValue;
    }"
org.sunflow.core.ParameterList.getTexCoord,"    public Point2 getTexCoord(String name, Point2 defaultValue) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.TEXCOORD, InterpolationType.NONE, 1, p))
            return p.getTexCoord();
        return defaultValue;
    }"
org.sunflow.core.ParameterList.getMatrix,"    public Matrix4 getMatrix(String name, Matrix4 defaultValue) {
        Parameter p = list.get(name);
        if (isValidParameter(name, ParameterType.MATRIX, InterpolationType.NONE, 1, p))
            return p.getMatrix();
        return defaultValue;
    }"
org.sunflow.core.ParameterList.getFloatArray,"    public FloatParameter getFloatArray(String name) {
        return getFloatParameter(name, ParameterType.FLOAT, list.get(name));
    }"
org.sunflow.core.ParameterList.getPointArray,"    public FloatParameter getPointArray(String name) {
        return getFloatParameter(name, ParameterType.POINT, list.get(name));
    }"
org.sunflow.core.ParameterList.getVectorArray,"    public FloatParameter getVectorArray(String name) {
        return getFloatParameter(name, ParameterType.VECTOR, list.get(name));
    }"
org.sunflow.core.ParameterList.getTexCoordArray,"    public FloatParameter getTexCoordArray(String name) {
        return getFloatParameter(name, ParameterType.TEXCOORD, list.get(name));
    }"
org.sunflow.core.ParameterList.getMatrixArray,"    public FloatParameter getMatrixArray(String name) {
        return getFloatParameter(name, ParameterType.MATRIX, list.get(name));
    }"
org.sunflow.core.ParameterList.isValidParameter,"    private boolean isValidParameter(String name, ParameterType type, InterpolationType interp, int requestedSize, Parameter p) {
        if (p == null)
            return false;
        if (p.type != type) {
            UI.printWarning(Module.API, ""Parameter %s requested as a %s - declared as %s"", name, type.name().toLowerCase(), p.type.name().toLowerCase());
            return false;
        }
        if (p.interp != interp) {
            UI.printWarning(Module.API, ""Parameter %s requested as a %s - declared as %s"", name, interp.name().toLowerCase(), p.interp.name().toLowerCase());
            return false;
        }
        if (requestedSize > 0 && p.size() != requestedSize) {
            UI.printWarning(Module.API, ""Parameter %s requires %d %s - declared with %d"", name, requestedSize, requestedSize == 1 ? ""value"" : ""values"", p.size());
            return false;
        }
        p.checked = true;
        return true;
    }"
org.sunflow.core.ParameterList.getFloatParameter,"    private FloatParameter getFloatParameter(String name, ParameterType type, Parameter p) {
        if (p == null)
            return null;
        switch (p.interp) {
            case NONE:
                if (!isValidParameter(name, type, p.interp, -1, p))
                    return null;
                break;
            case VERTEX:
                if (!isValidParameter(name, type, p.interp, numVerts, p))
                    return null;
                break;
            case FACE:
                if (!isValidParameter(name, type, p.interp, numFaces, p))
                    return null;
                break;
            case FACEVARYING:
                if (!isValidParameter(name, type, p.interp, numFaceVerts, p))
                    return null;
                break;
            default:
                return null;
        }
        return p.getFloats();
    }"
org.sunflow.core.ParameterList.size,"        private int size() {
            // number of elements
            switch (type) {
                case STRING:
                    return ((String[]) obj).length;
                case INT:
                    return ((int[]) obj).length;
                case BOOL:
                    return 1;
                case FLOAT:
                    return ((float[]) obj).length;
                case POINT:
                    return ((float[]) obj).length / 3;
                case VECTOR:
                    return ((float[]) obj).length / 3;
                case TEXCOORD:
                    return ((float[]) obj).length / 2;
                case MATRIX:
                    return ((float[]) obj).length / 16;
                case COLOR:
                    return 1;
                default:
                    return -1;
            }
        }"
org.sunflow.core.ParameterList.check,"        protected void check() {
            checked = true;
        }"
org.sunflow.core.ParameterList.toString,"        public String toString() {
            return String.format(""%s%s[%d]"", interp == InterpolationType.NONE ? """" : interp.name().toLowerCase() + "" "", type.name().toLowerCase(), size());
        }"
org.sunflow.core.ParameterList.getStringValue,"        private String getStringValue() {
            return ((String[]) obj)[0];
        }"
org.sunflow.core.ParameterList.getBoolValue,"        private boolean getBoolValue() {
            return (Boolean) obj;
        }"
org.sunflow.core.ParameterList.getIntValue,"        private int getIntValue() {
            return ((int[]) obj)[0];
        }"
org.sunflow.core.ParameterList.getInts,"        private int[] getInts() {
            return (int[]) obj;
        }"
org.sunflow.core.ParameterList.getStrings,"        private String[] getStrings() {
            return (String[]) obj;
        }"
org.sunflow.core.ParameterList.getFloatValue,"        private float getFloatValue() {
            return ((float[]) obj)[0];
        }"
org.sunflow.core.ParameterList.getFloats,"        private FloatParameter getFloats() {
            return new FloatParameter(interp, (float[]) obj);
        }"
org.sunflow.core.ParameterList.getPoint,"        private Point3 getPoint() {
            float[] floats = (float[]) obj;
            return new Point3(floats[0], floats[1], floats[2]);
        }"
org.sunflow.core.ParameterList.getVector,"        private Vector3 getVector() {
            float[] floats = (float[]) obj;
            return new Vector3(floats[0], floats[1], floats[2]);
        }"
org.sunflow.core.ParameterList.getTexCoord,"        private Point2 getTexCoord() {
            float[] floats = (float[]) obj;
            return new Point2(floats[0], floats[1]);
        }"
org.sunflow.core.ParameterList.getMatrix,"        private Matrix4 getMatrix() {
            float[] floats = (float[]) obj;
            return new Matrix4(floats, true);
        }"
org.sunflow.core.ParameterList.getColor,"        private Color getColor() {
            return (Color) obj;
        }
    "
org.sunflow.core.Modifier.modify,"    public void modify(ShadingState state);
"
org.sunflow.core.PrimitiveList.getWorldBounds,"/**
* Compute a bounding box of this object in world space, using the specified
* object-to-world transformation matrix. The bounds should be as exact as
* possible, if they are difficult or expensive to compute exactly, you may
* use {@link Matrix4#transform(BoundingBox)}. If the matrix is
* <code>null</code> no transformation is needed, and object space is
* equivalent to world space.
*
* @param o2w object to world transformation matrix
* @return object bounding box in world space
*/
"
org.sunflow.core.PrimitiveList.getNumPrimitives,"/**
* Returns the number of individual primtives in this aggregate object.
*
* @return number of primitives
*/
"
org.sunflow.core.PrimitiveList.getPrimitiveBound,"/**
* Retrieve the bounding box component of a particular primitive in object
* space.
*
* @param primID primitive index
* @param i bounding box side index
* @return value of the request bound
*/
"
org.sunflow.core.PrimitiveList.intersectPrimitive,"/**
* Intersect the specified primitive in local space.
*
* @param r ray in the object's local space
* @param parent instance currently being intersected
* @param primID primitive index to intersect
* @param state intersection state
*/
    public void intersectPrimitive(Ray r, int primID, IntersectionState state);

    /**
     * Prepare the specified {@link ShadingState}"
org.sunflow.core.PrimitiveList.prepareShadingState,"/**
* Prepare the specified {@link ShadingState} by setting all of its internal
* parameters. The provided instance can be used to transform between object
* and world space.
*
* @param parent instance which was hit
* @param primID primitive index which was hit
* @param state shading state to fill in
*/
    public void prepareShadingState(ShadingState state);

    /**
     * Create a new {@link PrimitiveList} object suitable for baking lightmaps.
     * This usually means a set of primitives laid out in the unit square UV
     * space. This method is optional, object which do not support it should
     * simply return <code>null</code>.
     * 
     * @return a baking {@link PrimitiveList}"
org.sunflow.core.PrimitiveList.getBakingPrimitives,"/**
* Create a new {@link PrimitiveList} object suitable for baking lightmaps.
* This usually means a set of primitives laid out in the unit square UV
* space. This method is optional, object which do not support it should
* simply return <code>null</code>.
*
* @return a baking {@link PrimitiveList}
*/
    public PrimitiveList getBakingPrimitives();
"
org.sunflow.core.RenderObject.update,"/**
* Update this object given a list of parameters. This method is guarenteed
* to be called at least once on every object, but it should correctly
* handle empty parameter lists. This means that the object should be in a
* valid state from the time it is constructed. This method should also
* return true or false depending on whether the update was succesfull or
* not.
*
* @param pl list of parameters to read from
* @param api reference to the current scene
* @return <code>true</code> if the update is succesfull,
*         <code>false</code> otherwise
*/
    public boolean update(ParameterList pl, SunflowAPI api);
"
org.sunflow.core.Shader.getRadiance,"/**
* Gets the radiance for a specified rendering state. When this method is
* called, you can assume that a hit has been registered in the state and
* that the hit vertex has been computed.
*
* @param state current render state
* @return color emitted or reflected by the shader
* @see Primitive#prepareShadingState(ShadingState)
*/
"
org.sunflow.core.Shader.scatterPhoton,"/**
* Scatter a photon with the specied power. Incoming photon direction is
* specified by the ray attached to the current render state.
*
* @param state current state
* @param power power of the incoming photon.
*/
    public void scatterPhoton(ShadingState state, Color power);
"
org.sunflow.core.Ray.transform,"/**
* Create a new ray by transforming the supplied one by the given matrix. If
* the matrix is <code>null</code>, the original ray is returned.
*
* @param m matrix to transform the ray by
*/
    public Ray transform(Matrix4 m) {
        if (m == null)
            return this;
        Ray r = new Ray();
        r.ox = m.transformPX(ox, oy, oz);
        r.oy = m.transformPY(ox, oy, oz);
        r.oz = m.transformPZ(ox, oy, oz);
        r.dx = m.transformVX(dx, dy, dz);
        r.dy = m.transformVY(dx, dy, dz);
        r.dz = m.transformVZ(dx, dy, dz);
        r.tMin = tMin;
        r.tMax = tMax;
        return r;
    }"
org.sunflow.core.Ray.normalize,"    public void normalize() {
        float in = 1.0f / (float) Math.sqrt(dx * dx + dy * dy + dz * dz);
        dx *= in;
        dy *= in;
        dz *= in;
    }"
org.sunflow.core.Ray.getMin,"/**
* Gets the minimum distance along the ray. Usually a small epsilon above 0.
*
* @return value of the smallest distance along the ray
*/
    public final float getMin() {
        return tMin;
    }"
org.sunflow.core.Ray.getMax,"/**
* Gets the maximum distance along the ray. May be infinite.
*
* @return value of the largest distance along the ray
*/
    public final float getMax() {
        return tMax;
    }"
org.sunflow.core.Ray.getDirection,"    public final Vector3 getDirection() {
        return new Vector3(dx, dy, dz);
    }"
org.sunflow.core.Ray.isInside,"/**
* Checks to see if the specified distance falls within the valid range on
* this ray. This should always be used before an intersection with the ray
* is detected.
*
* @param t distance to be tested
* @return <code>true</code> if t falls between the minimum and maximum
*         distance of this ray, <code>false</code> otherwise
* @see Primitive
*/
    public final boolean isInside(float t) {
        return (tMin < t) && (t < tMax);
    }"
org.sunflow.core.Ray.getPoint,"/**
* Gets the end point of the ray. A reference to <code>dest</code> is
* returned to support chaining.
*
* @param dest reference to the point to store
* @return reference to <code>dest</code>
*/
    public final Point3 getPoint(Point3 dest) {
        dest.x = ox + (tMax * dx);
        dest.y = oy + (tMax * dy);
        dest.z = oz + (tMax * dz);
        return dest;
    }"
org.sunflow.core.Ray.dot,"/**
* Computes the dot product of an arbitrary vector with the direction of the
* ray. This method avoids having to call getDirection() which would
* instantiate a new Vector object.
*
* @param v vector
* @return dot product of the ray direction and the specified vector
*/
    public final float dot(Vector3 v) {
        return dx * v.x + dy * v.y + dz * v.z;
    }"
org.sunflow.core.Ray.dot,"/**
* Computes the dot product of an arbitrary vector with the direction of the
* ray. This method avoids having to call getDirection() which would
* instantiate a new Vector object.
*
* @param vx vector x coordinate
* @param vy vector y coordinate
* @param vz vector z coordinate
* @return dot product of the ray direction and the specified vector
*/
    public final float dot(float vx, float vy, float vz) {
        return dx * vx + dy * vy + dz * vz;
    }"
org.sunflow.core.Ray.setMax,"/**
* Updates the maximum to the specified distance if and only if the new
* distance is smaller than the current one.
*
* @param t new maximum distance
*/
    public final void setMax(float t) {
        tMax = t;
    }
"
org.sunflow.core.AccelerationStructure.build,"/**
* Construct an acceleration structure for the specified primitive list.
*
* @param primitives
* @return
*/
"
org.sunflow.core.AccelerationStructure.intersect,"/**
* Intersect the specified ray with the geometry in local space. The ray
* will be provided in local space.
*
* @param r ray in local space
* @param istate state to store the intersection into
*/
    public void intersect(Ray r, IntersectionState istate);
"
org.sunflow.core.Scene.getThreads,"/**
* Get number of allowed threads for multi-threaded operations.
*
* @return number of threads that can be started
*/
    public int getThreads() {
        return threads <= 0 ? Runtime.getRuntime().availableProcessors() : threads;
    }"
org.sunflow.core.Scene.getThreadPriority,"/**
* Get the priority level to assign to multi-threaded operations.
*
* @return thread priority
*/
    public int getThreadPriority() {
        return lowPriority ? Thread.MIN_PRIORITY : Thread.NORM_PRIORITY;
    }"
org.sunflow.core.Scene.setCamera,"/**
* Sets the current camera (no support for multiple cameras yet).
*
* @param camera camera to be used as the viewpoint for the scene
*/
    public void setCamera(Camera camera) {
        this.camera = camera;
    }"
org.sunflow.core.Scene.getCamera,"    Camera getCamera() {
        return camera;
    }"
org.sunflow.core.Scene.setInstanceLists,"/**
* Update the instance lists for this scene.
*
* @param instances regular instances
* @param infinite infinite instances (no bounds)
*/
    public void setInstanceLists(Instance[] instances, Instance[] infinite) {
        infiniteInstanceList = new InstanceList(infinite);
        instanceList = new InstanceList(instances);
        rebuildAccel = true;
    }"
org.sunflow.core.Scene.setLightList,"/**
* Update the light list for this scene.
*
* @param lights array of light source objects
*/
    public void setLightList(LightSource[] lights) {
        lightServer.setLights(lights);
    }"
org.sunflow.core.Scene.setShaderOverride,"/**
* Enables shader overiding (set null to disable). The specified shader will
* be used to shade all surfaces
*
* @param shader shader to run over all surfaces, or <code>null</code> to
*            disable overriding
* @param photonOverride <code>true</code> to override photon scattering
*            with this shader or <code>false</code> to run the regular
*            shaders
*/
    public void setShaderOverride(Shader shader, boolean photonOverride) {
        lightServer.setShaderOverride(shader, photonOverride);
    }"
org.sunflow.core.Scene.setBakingInstance,"/**
* The provided instance will be considered for lightmap baking. If the
* specified instance is <code>null</code>, lightmap baking will be
* disabled and normal rendering will occur.
*
* @param instance instance to bake
*/
    public void setBakingInstance(Instance instance) {
        bakingInstance = instance;
    }"
org.sunflow.core.Scene.getRadiance,"    public ShadingState getRadiance(IntersectionState istate, float rx, float ry, double lensU, double lensV, double time, int instance) {
        if (bakingPrimitives == null) {
            Ray r = camera.getRay(rx, ry, imageWidth, imageHeight, lensU, lensV, time);
            return r != null ? lightServer.getRadiance(rx, ry, instance, r, istate) : null;
        } else {
            Ray r = new Ray(rx / imageWidth, ry / imageHeight, -1, 0, 0, 1);
            traceBake(r, istate);
            if (!istate.hit())
                return null;
            ShadingState state = ShadingState.createState(istate, rx, ry, r, instance, lightServer);
            bakingPrimitives.prepareShadingState(state);
            if (bakingViewDependent)
                state.setRay(camera.getRay(state.getPoint()));
            else {
                Point3 p = state.getPoint();
                Vector3 n = state.getNormal();
                // create a ray coming from directly above the point being
                // shaded
                Ray incoming = new Ray(p.x + n.x, p.y + n.y, p.z + n.z, -n.x, -n.y, -n.z);
                incoming.setMax(1);
                state.setRay(incoming);
            }
            lightServer.shadeBakeResult(state);
            return state;
        }
    }"
org.sunflow.core.Scene.getBounds,"    public BoundingBox getBounds() {
        return instanceList.getWorldBounds(null);
    }"
org.sunflow.core.Scene.trace,"    void trace(Ray r, IntersectionState state) {
        // reset object
        state.instance = null;
        state.current = null;
        for (int i = 0; i < infiniteInstanceList.getNumPrimitives(); i++)
            infiniteInstanceList.intersectPrimitive(r, i, state);
        // reset for next accel structure
        state.current = null;
        intAccel.intersect(r, state);
    }"
org.sunflow.core.Scene.traceShadow,"    Color traceShadow(Ray r, IntersectionState state) {
        trace(r, state);
        return state.hit() ? Color.WHITE : Color.BLACK;
    }"
org.sunflow.core.Scene.traceBake,"    void traceBake(Ray r, IntersectionState state) {
        // set the instance as if tracing a regular instanced object
        state.current = bakingInstance;
        // reset object
        state.instance = null;
        bakingAccel.intersect(r, state);
    }"
org.sunflow.core.Scene.render,"    public void render(Options options, ImageSampler sampler, Display display) {
        if (display == null)
            display = new FrameDisplay();

        if (bakingInstance != null) {
            UI.printDetailed(Module.SCENE, ""Creating primitives for lightmapping ..."");
            bakingPrimitives = bakingInstance.getBakingPrimitives();
            if (bakingPrimitives == null) {
                UI.printError(Module.SCENE, ""Lightmap baking is not supported for the given instance."");
                return;
            }
            int n = bakingPrimitives.getNumPrimitives();
            UI.printInfo(Module.SCENE, ""Building acceleration structure for lightmapping (%d num primitives) ..."", n);
            bakingAccel = AccelerationStructureFactory.create(""auto"", n, true);
            bakingAccel.build(bakingPrimitives);
        } else {
            bakingPrimitives = null;
            bakingAccel = null;
        }
        bakingViewDependent = options.getBoolean(""baking.viewdep"", bakingViewDependent);

        if ((bakingInstance != null && bakingViewDependent && camera == null) || (bakingInstance == null && camera == null)) {
            UI.printError(Module.SCENE, ""No camera found"");
            return;
        }

        // read from options
        threads = options.getInt(""threads"", 0);
        lowPriority = options.getBoolean(""threads.lowPriority"", true);
        imageWidth = options.getInt(""resolutionX"", 640);
        imageHeight = options.getInt(""resolutionY"", 480);
        // limit resolution to 16k
        imageWidth = MathUtils.clamp(imageWidth, 1, 1 << 14);
        imageHeight = MathUtils.clamp(imageHeight, 1, 1 << 14);

        // get acceleration structure info
        // count scene primitives
        long numPrimitives = 0;
        for (int i = 0; i < instanceList.getNumPrimitives(); i++)
            numPrimitives += instanceList.getNumPrimitives(i);
        UI.printInfo(Module.SCENE, ""Scene stats:"");
        UI.printInfo(Module.SCENE, ""  * Infinite instances:  %d"", infiniteInstanceList.getNumPrimitives());
        UI.printInfo(Module.SCENE, ""  * Instances:           %d"", instanceList.getNumPrimitives());
        UI.printInfo(Module.SCENE, ""  * Primitives:          %d"", numPrimitives);
        String accelName = options.getString(""accel"", null);
        if (accelName != null) {
            rebuildAccel = rebuildAccel || !acceltype.equals(accelName);
            acceltype = accelName;
        }
        UI.printInfo(Module.SCENE, ""  * Instance accel:      %s"", acceltype);
        if (rebuildAccel) {
            intAccel = AccelerationStructureFactory.create(acceltype, instanceList.getNumPrimitives(), false);
            intAccel.build(instanceList);
            rebuildAccel = false;
        }
        UI.printInfo(Module.SCENE, ""  * Scene bounds:        %s"", getBounds());
        UI.printInfo(Module.SCENE, ""  * Scene center:        %s"", getBounds().getCenter());
        UI.printInfo(Module.SCENE, ""  * Scene diameter:      %.2f"", getBounds().getExtents().length());
        UI.printInfo(Module.SCENE, ""  * Lightmap bake:       %s"", bakingInstance != null ? (bakingViewDependent ? ""view"" : ""ortho"") : ""off"");
        if (sampler == null)
            return;
        if (!lightServer.build(options))
            return;
        // render
        UI.printInfo(Module.SCENE, ""Rendering ..."");
        sampler.prepare(options, this, imageWidth, imageHeight);
        sampler.render(display);
        lightServer.showStats();
        // discard baking tesselation/accel structure
        bakingPrimitives = null;
        bakingAccel = null;
        UI.printInfo(Module.SCENE, ""Done."");
    }"
org.sunflow.core.Scene.calculatePhotons,"    public boolean calculatePhotons(PhotonStore map, String type, int seed) {
        return lightServer.calculatePhotons(map, type, seed);
    }
"
org.sunflow.core.Display.imageBegin,"/**
* This is called before an image is rendered to indicate how large the
* rendered image will be. This allows the display driver to write out image
* headers or allocate surfaces. Bucket size will be 0 when called from a
* non-bucket based source.
*
* @param w width of the rendered image in pixels
* @param h height of the rendered image in pixels
* @param bucketSize size of the buckets in pixels
*/
"
org.sunflow.core.Display.imagePrepare,"/**
* Prepare the specified area to be rendered. This may be used to highlight
* the work in progress area or simply to setup the display driver to
* recieve the specified portion of the image
*
* @param x x coordinate of the bucket within the image
* @param y y coordinate of the bucket within the image
* @param w width of the bucket in pixels
* @param h height of the bucket in pixels
* @param id unique identifier corresponding to the thread which invoked
*            this call
*/
"
org.sunflow.core.Display.imageUpdate,"/**
* Update the current image with a bucket of data. The region is guarenteed
* to be within the bounds created by the call to imageBegin. No clipping is
* necessary. Colors are passed in unprocessed. It is up the display driver
* to do any type of quantization needed. The array of colors will be
* exactly <code>w * h</code> long and in row major order.
*
* @param x x coordinate of the bucket within the image
* @param y y coordinate of the bucket within the image
* @param w width of the bucket in pixels
* @param h height of the bucket in pixels
* @param data bucket data, this array will be exactly <code>w * h</code>
*            long
*/
"
org.sunflow.core.Display.imageFill,"/**
* Update the current image with a region of flat color. This is used by
* progressive rendering to render progressively smaller regions of the
* screen which will overlap. The region is guarenteed to be within the
* bounds created by the call to imageBegin. No clipping is necessary.
* Colors are passed in unprocessed. It is up the display driver to do any
* type of quantization needed.
*
* @param x x coordinate of the region within the image
* @param y y coordinate of the region within the image
* @param w with of the region in pixels
* @param h height of the region in pixels
* @param c color to fill the region with
*/
"
org.sunflow.core.Display.imageEnd,"/**
* This call is made after the image has been rendered. This allows the
* display driver to close any open files, write the image to disk or flush
* any other type of buffers.
*/
    void imageEnd();
"
org.sunflow.core.CameraLens.getRay,"/**
* Create a new {@link Ray ray}to be cast through pixel (x,y) on the image
* plane. Two sampling parameters are provided for lens sampling. They are
* guarenteed to be in the interval [0,1). They can be used to perturb the
* position of the source of the ray on the lens of the camera for DOF
* effects.
*
* @param x x coordinate of the (sub)pixel
* @param y y coordinate of the (sub)pixel
* @param imageWidth image width in (sub)pixels
* @param imageHeight image height in (sub)pixels
* @param lensX x lens sampling parameter
* @param lensY y lens sampling parameter
* @return a new ray passing through the given pixel
*/
    public Ray getRay(float x, float y, int imageWidth, int imageHeight, double lensX, double lensY, double time);
"
org.sunflow.core.PhotonStore.numEmit,
org.sunflow.core.PhotonStore.prepare,
org.sunflow.core.PhotonStore.store,
org.sunflow.core.PhotonStore.init,
org.sunflow.core.PhotonStore.allowDiffuseBounced,
org.sunflow.core.PhotonStore.allowReflectionBounced,
org.sunflow.core.PhotonStore.allowRefractionBounced,"    boolean allowRefractionBounced();
"
org.sunflow.core.BucketOrder.getBucketSequence,"/**
* Computes the order in which each coordinate on the screen should be
* visited.
*
* @param nbw Number of buckets in the X direction
* @param nbh Number of buckets in the Y direction
* @return Array of coordinates with interleaved X, Y of the positions of
*         buckets to be rendered.
*/
    int[] getBucketSequence(int nbw, int nbh);
"
org.sunflow.core.InstanceList.getPrimitiveBound,"    public final float getPrimitiveBound(int primID, int i) {
        return instances[primID].getBounds().getBound(i);
    }"
org.sunflow.core.InstanceList.getWorldBounds,"    public final BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox();
        for (Instance i : instances)
            bounds.include(i.getBounds());
        return bounds;
    }"
org.sunflow.core.InstanceList.intersectPrimitive,"    public final void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        instances[primID].intersect(r, state);
    }"
org.sunflow.core.InstanceList.getNumPrimitives,"    public final int getNumPrimitives() {
        return instances.length;
    }"
org.sunflow.core.InstanceList.getNumPrimitives,"    public final int getNumPrimitives(int primID) {
        return instances[primID].getNumPrimitives();
    }"
org.sunflow.core.InstanceList.prepareShadingState,"    public final void prepareShadingState(ShadingState state) {
        state.getInstance().prepareShadingState(state);
    }"
org.sunflow.core.InstanceList.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        // TODO: build accelstructure into this (?)
        return true;
    }"
org.sunflow.core.InstanceList.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.TextureCache.getTexture,"/**
* Gets a reference to the texture specified by the given filename. If the
* texture has already been loaded the previous reference is returned,
* otherwise, a new texture is created.
*
* @param filename image file to load
* @return texture object
* @see Texture
*/
    public synchronized static Texture getTexture(String filename, boolean isLinear) {
        if (textures.containsKey(filename)) {
            UI.printInfo(Module.TEX, ""Using cached copy for file \""%s\"" ..."", filename);
            return textures.get(filename);
        }
        UI.printInfo(Module.TEX, ""Using file \""%s\"" ..."", filename);
        Texture t = new Texture(filename, isLinear);
        textures.put(filename, t);
        return t;
    }"
org.sunflow.core.TextureCache.flush,"    public synchronized static void flush() {
        UI.printInfo(Module.TEX, ""Flushing texture cache"");
        textures.clear();
    }
"
org.sunflow.core.Instance.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        String geometryName = pl.getString(""geometry"", null);
        if (geometry == null || geometryName != null) {
            if (geometryName == null) {
                UI.printError(Module.GEOM, ""geometry parameter missing - unable to create instance"");
                return false;
            }
            geometry = api.lookupGeometry(geometryName);
            if (geometry == null) {
                UI.printError(Module.GEOM, ""Geometry \""%s\"" was not declared yet - instance is invalid"", geometryName);
                return false;
            }
        }
        String[] shaderNames = pl.getStringArray(""shaders"", null);
        if (shaderNames != null) {
            // new shader names have been provided
            shaders = new Shader[shaderNames.length];
            for (int i = 0; i < shaders.length; i++) {
                shaders[i] = api.lookupShader(shaderNames[i]);
                if (shaders[i] == null)
                    UI.printWarning(Module.GEOM, ""Shader \""%s\"" was not declared yet - ignoring"", shaderNames[i]);
            }
        } else {
            // re-use existing shader array
        }
        String[] modifierNames = pl.getStringArray(""modifiers"", null);
        if (modifierNames != null) {
            // new modifier names have been provided
            modifiers = new Modifier[modifierNames.length];
            for (int i = 0; i < modifiers.length; i++) {
                modifiers[i] = api.lookupModifier(modifierNames[i]);
                if (modifiers[i] == null)
                    UI.printWarning(Module.GEOM, ""Modifier \""%s\"" was not declared yet - ignoring"", modifierNames[i]);
            }
        }
        Matrix4 transform = pl.getMatrix(""transform"", o2w);
        if (transform != o2w) {
            o2w = transform;
            if (o2w != null) {
                w2o = o2w.inverse();
                if (w2o == null) {
                    UI.printError(Module.GEOM, ""Unable to compute transform inverse - determinant is: %g"", o2w.determinant());
                    return false;
                }
            } else
                o2w = w2o = null;
        }
        return true;
    }"
org.sunflow.core.Instance.updateBounds,"    public void updateBounds() {
        bounds = geometry.getWorldBounds(o2w);
    }"
org.sunflow.core.Instance.hasGeometry,"    public boolean hasGeometry(Geometry g) {
        return geometry == g;
    }"
org.sunflow.core.Instance.removeShader,"    public void removeShader(Shader s) {
        if (shaders != null) {
            for (int i = 0; i < shaders.length; i++)
                if (shaders[i] == s)
                    shaders[i] = null;
        }
    }"
org.sunflow.core.Instance.removeModifier,"    public void removeModifier(Modifier m) {
        if (modifiers != null) {
            for (int i = 0; i < modifiers.length; i++)
                if (modifiers[i] == m)
                    modifiers[i] = null;
        }
    }"
org.sunflow.core.Instance.getBounds,"    public BoundingBox getBounds() {
        return bounds;
    }"
org.sunflow.core.Instance.getNumPrimitives,"    public int getNumPrimitives() {
        return geometry.getNumPrimitives();
    }"
org.sunflow.core.Instance.intersect,"    public void intersect(Ray r, IntersectionState state) {
        Ray localRay = r.transform(w2o);
        state.current = this;
        geometry.intersect(localRay, state);
        // FIXME: transfer max distance to current ray
        r.setMax(localRay.getMax());
    }"
org.sunflow.core.Instance.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        geometry.prepareShadingState(state);
        if (state.getNormal() != null && state.getGeoNormal() != null)
            state.correctShadingNormal();
        // run modifier if it was provided
        if (state.getModifier() != null)
            state.getModifier().modify(state);
    }"
org.sunflow.core.Instance.getShader,"    public Shader getShader(int i) {
        if (shaders == null || i < 0 || i >= shaders.length)
            return null;
        return shaders[i];
    }"
org.sunflow.core.Instance.getModifier,"    public Modifier getModifier(int i) {
        if (modifiers == null || i < 0 || i >= modifiers.length)
            return null;
        return modifiers[i];
    }"
org.sunflow.core.Instance.transformObjectToWorld,"    public Point3 transformObjectToWorld(Point3 p) {
        return o2w == null ? new Point3(p) : o2w.transformP(p);
    }"
org.sunflow.core.Instance.transformWorldToObject,"    public Point3 transformWorldToObject(Point3 p) {
        return o2w == null ? new Point3(p) : w2o.transformP(p);
    }"
org.sunflow.core.Instance.transformNormalObjectToWorld,"    public Vector3 transformNormalObjectToWorld(Vector3 n) {
        return o2w == null ? new Vector3(n) : w2o.transformTransposeV(n);
    }"
org.sunflow.core.Instance.transformNormalWorldToObject,"    public Vector3 transformNormalWorldToObject(Vector3 n) {
        return o2w == null ? new Vector3(n) : o2w.transformTransposeV(n);
    }"
org.sunflow.core.Instance.transformVectorObjectToWorld,"    public Vector3 transformVectorObjectToWorld(Vector3 v) {
        return o2w == null ? new Vector3(v) : o2w.transformV(v);
    }"
org.sunflow.core.Instance.transformVectorWorldToObject,"    public Vector3 transformVectorWorldToObject(Vector3 v) {
        return o2w == null ? new Vector3(v) : w2o.transformV(v);
    }"
org.sunflow.core.Instance.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return geometry.getBakingPrimitives();
    }"
org.sunflow.core.Instance.getGeometry,"    Geometry getGeometry() {
        return geometry;
    }
"
org.sunflow.core.LightSample.isValid,"    public boolean isValid() {
        return ldiff != null && lspec != null && shadowRay != null;
    }"
org.sunflow.core.LightSample.setShadowRay,"    public void setShadowRay(Ray shadowRay) {
        this.shadowRay = shadowRay;
    }"
org.sunflow.core.LightSample.traceShadow,"    public final void traceShadow(ShadingState state) {
        Color opacity = state.traceShadow(shadowRay);
        Color.blend(ldiff, Color.BLACK, opacity, ldiff);
        Color.blend(lspec, Color.BLACK, opacity, lspec);
    }"
org.sunflow.core.LightSample.getShadowRay,"    public Ray getShadowRay() {
        return shadowRay;
    }"
org.sunflow.core.LightSample.getDiffuseRadiance,"    public Color getDiffuseRadiance() {
        return ldiff;
    }"
org.sunflow.core.LightSample.getSpecularRadiance,"    public Color getSpecularRadiance() {
        return lspec;
    }"
org.sunflow.core.LightSample.setRadiance,"    public void setRadiance(Color d, Color s) {
        ldiff = d.copy();
        lspec = s.copy();
    }"
org.sunflow.core.LightSample.dot,"    public float dot(Vector3 v) {
        return shadowRay.dx * v.x + shadowRay.dy * v.y + shadowRay.dz * v.z;
    }
"
org.sunflow.core.Options.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        // take all attributes, and update them into the current set
        for (FastHashMap.Entry<String, Parameter> e : pl.list) {
            list.put(e.getKey(), e.getValue());
            e.getValue().check();
        }
        return true;
    }
"
org.sunflow.core.ShadingState.createPhotonState,"    static ShadingState createPhotonState(Ray r, IntersectionState istate, int i, PhotonStore map, LightServer server) {
        ShadingState s = new ShadingState(null, istate, r, i, 4);
        s.server = server;
        s.map = map;
        return s;

    }"
org.sunflow.core.ShadingState.createState,"    static ShadingState createState(IntersectionState istate, float rx, float ry, Ray r, int i, LightServer server) {
        ShadingState s = new ShadingState(null, istate, r, i, 4);
        s.server = server;
        s.rx = rx;
        s.ry = ry;
        return s;
    }"
org.sunflow.core.ShadingState.createDiffuseBounceState,"    static ShadingState createDiffuseBounceState(ShadingState previous, Ray r, int i) {
        ShadingState s = new ShadingState(previous, previous.istate, r, i, 2);
        s.diffuseDepth++;
        return s;
    }"
org.sunflow.core.ShadingState.createGlossyBounceState,"    static ShadingState createGlossyBounceState(ShadingState previous, Ray r, int i) {
        ShadingState s = new ShadingState(previous, previous.istate, r, i, 2);
        s.includeLights = false;
        s.includeSpecular = false;
        s.reflectionDepth++;
        return s;
    }"
org.sunflow.core.ShadingState.createReflectionBounceState,"    static ShadingState createReflectionBounceState(ShadingState previous, Ray r, int i) {
        ShadingState s = new ShadingState(previous, previous.istate, r, i, 2);
        s.reflectionDepth++;
        return s;
    }"
org.sunflow.core.ShadingState.createRefractionBounceState,"    static ShadingState createRefractionBounceState(ShadingState previous, Ray r, int i) {
        ShadingState s = new ShadingState(previous, previous.istate, r, i, 2);
        s.refractionDepth++;
        return s;
    }"
org.sunflow.core.ShadingState.createFinalGatherState,"    static ShadingState createFinalGatherState(ShadingState state, Ray r, int i) {
        ShadingState finalGatherState = new ShadingState(state, state.istate, r, i, 2);
        finalGatherState.diffuseDepth++;
        finalGatherState.includeLights = false;
        finalGatherState.includeSpecular = false;
        return finalGatherState;
    }"
org.sunflow.core.ShadingState.setRay,"    final void setRay(Ray r) {
        this.r = r;
    }"
org.sunflow.core.ShadingState.init,"    public final void init() {
        // prepare variables needed for shading
        p = new Point3();
        n = new Vector3();
        tex = new Point2();
        ng = new Vector3();
        basis = null;
    }"
org.sunflow.core.ShadingState.shade,"    public final Color shade() {
        return server.shadeHit(this);
    }"
org.sunflow.core.ShadingState.correctShadingNormal,"    final void correctShadingNormal() {
        // correct shading normals pointing the wrong way
        if (Vector3.dot(n, ng) < 0) {
            n.negate();
            basis.flipW();
        }
    }"
org.sunflow.core.ShadingState.faceforward,"    public final void faceforward() {
        // make sure we are on the right side of the material
        if (r.dot(ng) < 0) {
        } else {
            // this ensure the ray and the geomtric normal are pointing in the
            // same direction
            ng.negate();
            n.negate();
            basis.flipW();
            behind = true;
        }
        cosND = Math.max(-r.dot(n), 0); // can't be negative
        // offset the shaded point away from the surface to prevent
        // self-intersection errors
        p.x += 0.001f * ng.x;
        p.y += 0.001f * ng.y;
        p.z += 0.001f * ng.z;
    }"
org.sunflow.core.ShadingState.getRasterX,"    public final float getRasterX() {
        return rx;
    }"
org.sunflow.core.ShadingState.getRasterY,"    public final float getRasterY() {
        return ry;
    }"
org.sunflow.core.ShadingState.getCosND,"    public final float getCosND() {
        return cosND;
    }"
org.sunflow.core.ShadingState.isBehind,"    public final boolean isBehind() {
        return behind;
    }"
org.sunflow.core.ShadingState.getIntersectionState,"    final IntersectionState getIntersectionState() {
        return istate;
    }"
org.sunflow.core.ShadingState.getU,"    public final float getU() {
        return hitU;
    }"
org.sunflow.core.ShadingState.getV,"    public final float getV() {
        return hitV;
    }"
org.sunflow.core.ShadingState.getInstance,"    public final Instance getInstance() {
        return instance;
    }"
org.sunflow.core.ShadingState.getPrimitiveID,"    public final int getPrimitiveID() {
        return primitiveID;
    }"
org.sunflow.core.ShadingState.setResult,"    public final void setResult(Color c) {
        result = c;
    }"
org.sunflow.core.ShadingState.getResult,"    public final Color getResult() {
        return result;
    }"
org.sunflow.core.ShadingState.getLightServer,"    final LightServer getLightServer() {
        return server;
    }"
org.sunflow.core.ShadingState.addSample,"    public final void addSample(LightSample sample) {
        // add to list
        sample.next = lightSample;
        lightSample = sample;
    }"
org.sunflow.core.ShadingState.getRandom,"    public final double getRandom(int j, int dim) {
        switch (dim) {
            case 0:
                return QMC.mod1(qmcD0I + QMC.halton(0, j));
            case 1:
                return QMC.mod1(qmcD1I + QMC.halton(1, j));
            default:
                return QMC.mod1(QMC.halton(d + dim, i) + QMC.halton(dim, j));
        }
    }"
org.sunflow.core.ShadingState.getRandom,"    public final double getRandom(int j, int dim, int n) {
        switch (dim) {
            case 0:
                return QMC.mod1(qmcD0I + (double) j / (double) n);
            case 1:
                return QMC.mod1(qmcD1I + QMC.halton(0, j));
            default:
                return QMC.mod1(QMC.halton(d + dim, i) + QMC.halton(dim - 1, j));
        }
    }"
org.sunflow.core.ShadingState.includeLights,"/**
* Checks to see if the shader should include emitted light.
*
* @return <code>true</code> if emitted light should be included,
*         <code>false</code> otherwise
*/
    public final boolean includeLights() {
        return includeLights;
    }"
org.sunflow.core.ShadingState.includeSpecular,"/**
* Checks to see if the shader should include specular terms.
*
* @return <code>true</code> if specular terms should be included,
*         <code>false</code> otherwise
*/
    public final boolean includeSpecular() {
        return includeSpecular;
    }"
org.sunflow.core.ShadingState.getShader,"    public final Shader getShader() {
        return shader;
    }"
org.sunflow.core.ShadingState.setShader,"/**
* Record which shader should be executed for the intersected surface.
*
* @param shader surface shader to use to shade the current intersection
*            point
*/
    public final void setShader(Shader shader) {
        this.shader = shader;
    }"
org.sunflow.core.ShadingState.getModifier,"    final Modifier getModifier() {
        return modifier;
    }"
org.sunflow.core.ShadingState.setModifier,"/**
* Record which modifier should be applied to the intersected surface
*
* @param modifier modifier to use the change this shading state
*/
    public final void setModifier(Modifier modifier) {
        this.modifier = modifier;
    }"
org.sunflow.core.ShadingState.getDepth,"/**
* Get the current total tracing depth. First generation rays have a depth
* of 0.
*
* @return current tracing depth
*/
    public final int getDepth() {
        return diffuseDepth + reflectionDepth + refractionDepth;
    }"
org.sunflow.core.ShadingState.getDiffuseDepth,"/**
* Get the current diffuse tracing depth. This is the number of diffuse
* surfaces reflected from.
*
* @return current diffuse tracing depth
*/
    public final int getDiffuseDepth() {
        return diffuseDepth;
    }"
org.sunflow.core.ShadingState.getReflectionDepth,"/**
* Get the current reflection tracing depth. This is the number of specular
* surfaces reflected from.
*
* @return current reflection tracing depth
*/
    public final int getReflectionDepth() {
        return reflectionDepth;
    }"
org.sunflow.core.ShadingState.getRefractionDepth,"/**
* Get the current refraction tracing depth. This is the number of specular
* surfaces refracted from.
*
* @return current refraction tracing depth
*/
    public final int getRefractionDepth() {
        return refractionDepth;
    }"
org.sunflow.core.ShadingState.getPoint,"/**
* Get hit point.
*
* @return hit point
*/
    public final Point3 getPoint() {
        return p;
    }"
org.sunflow.core.ShadingState.getNormal,"/**
* Get shading normal at the hit point. This may differ from the geometric
* normal
*
* @return shading normal
*/
    public final Vector3 getNormal() {
        return n;
    }"
org.sunflow.core.ShadingState.getUV,"/**
* Get texture coordinates at the hit point.
*
* @return texture coordinate
*/
    public final Point2 getUV() {
        return tex;
    }"
org.sunflow.core.ShadingState.getGeoNormal,"/**
* Gets the geometric normal of the current hit point.
*
* @return geometric normal of the current hit point
*/
    public final Vector3 getGeoNormal() {
        return ng;
    }"
org.sunflow.core.ShadingState.getBasis,"/**
* Gets the local orthonormal basis for the current hit point.
*
* @return local basis or <code>null</code> if undefined
*/
    public final OrthoNormalBasis getBasis() {
        return basis;
    }"
org.sunflow.core.ShadingState.setBasis,"/**
* Define the orthonormal basis for the current hit point.
*
* @param basis
*/
    public final void setBasis(OrthoNormalBasis basis) {
        this.basis = basis;
    }"
org.sunflow.core.ShadingState.getRay,"/**
* Gets the ray that is associated with this state.
*
* @return ray associated with this state.
*/
    public final Ray getRay() {
        return r;
    }"
org.sunflow.core.ShadingState.getCameraToWorld,"/**
* Get a transformation matrix that will transform camera space points into
* world space.
*
* @return camera to world transform
*/
    public final Matrix4 getCameraToWorld() {
        Camera c = server.getScene().getCamera();
        return c != null ? c.getCameraToWorld() : Matrix4.IDENTITY;
    }"
org.sunflow.core.ShadingState.getWorldToCamera,"/**
* Get a transformation matrix that will transform world space points into
* camera space.
*
* @return world to camera transform
*/
    public final Matrix4 getWorldToCamera() {
        Camera c = server.getScene().getCamera();
        return c != null ? c.getWorldToCamera() : Matrix4.IDENTITY;
    }"
org.sunflow.core.ShadingState.getTrianglePoints,"    public final boolean getTrianglePoints(Point3[] p) {
        PrimitiveList prims = instance.getGeometry().getPrimitiveList();
        if (prims instanceof TriangleMesh) {
            TriangleMesh m = (TriangleMesh) prims;
            m.getPoint(primitiveID, 0, p[0] = new Point3());
            m.getPoint(primitiveID, 1, p[1] = new Point3());
            m.getPoint(primitiveID, 2, p[2] = new Point3());
            return true;
        }
        return false;
    }"
org.sunflow.core.ShadingState.initLightSamples,"/**
* Initialize the use of light samples. Prepares a list of visible lights
* from the specified point and normal.
*/
    public final void initLightSamples() {
        server.initLightSamples(this);
    }"
org.sunflow.core.ShadingState.initCausticSamples,"/**
* Add caustic samples to the current light sample set. This method does
* nothing if caustics are not enabled.
*/
    public final void initCausticSamples() {
        server.initCausticSamples(this);
    }"
org.sunflow.core.ShadingState.traceGlossy,"/**
* Returns the color obtained by recursively tracing the specified ray. The
* reflection is assumed to be glossy.
*
* @param r ray to trace
* @return color observed along specified ray.
*/
    public final Color traceGlossy(Ray r, int i) {
        return server.traceGlossy(this, r, i);
    }"
org.sunflow.core.ShadingState.traceReflection,"/**
* Returns the color obtained by recursively tracing the specified ray. The
* reflection is assumed to be specular.
*
* @param r ray to trace
* @return color observed along specified ray.
*/
    public final Color traceReflection(Ray r, int i) {
        return server.traceReflection(this, r, i);
    }"
org.sunflow.core.ShadingState.traceRefraction,"/**
* Returns the color obtained by recursively tracing the specified ray.
*
* @param r ray to trace
* @return color observed along specified ray.
*/
    public final Color traceRefraction(Ray r, int i) {
        // this assumes the refraction ray is pointing away from the normal
        r.ox -= 0.002f * ng.x;
        r.oy -= 0.002f * ng.y;
        r.oz -= 0.002f * ng.z;
        return server.traceRefraction(this, r, i);
    }"
org.sunflow.core.ShadingState.traceTransparency,"    public final Color traceTransparency() {
        return traceRefraction(new Ray(p, r.getDirection()), 0);
    }"
org.sunflow.core.ShadingState.traceShadow,"/**
* Trace a shadow ray against the scene, determine if the ray interestected
* anything.
*
* @param r ray to trace
* @return <code>true</code> if the ray interesected anything,
*         <code>false</code> otherwise
*/
    public final Color traceShadow(Ray r) {
        return server.getScene().traceShadow(r, istate);
    }"
org.sunflow.core.ShadingState.storePhoton,"/**
* Records a photon at the specified location.
*
* @param dir incoming direction of the photon
* @param power photon power
* @param diffuse diffuse reflectance at the given point
*/
    public final void storePhoton(Vector3 dir, Color power, Color diffuse) {
        map.store(this, dir, power, diffuse);
    }"
org.sunflow.core.ShadingState.traceReflectionPhoton,"/**
* Trace a new photon from the current location. This assumes that the
* photon was reflected by a specular surface.
*
* @param r ray to trace photon along
* @param power power of the new photon
*/
    public final void traceReflectionPhoton(Ray r, Color power) {
        if (map.allowReflectionBounced())
            server.traceReflectionPhoton(this, r, power);
    }"
org.sunflow.core.ShadingState.traceRefractionPhoton,"/**
* Trace a new photon from the current location. This assumes that the
* photon was refracted by a specular surface.
*
* @param r ray to trace photon along
* @param power power of the new photon
*/
    public final void traceRefractionPhoton(Ray r, Color power) {
        if (map.allowRefractionBounced()) {
            // this assumes the refraction ray is pointing away from the normal
            r.ox -= 0.002f * ng.x;
            r.oy -= 0.002f * ng.y;
            r.oz -= 0.002f * ng.z;
            server.traceRefractionPhoton(this, r, power);
        }
    }"
org.sunflow.core.ShadingState.traceDiffusePhoton,"/**
* Trace a new photon from the current location. This assumes that the
* photon was reflected by a diffuse surface.
*
* @param r ray to trace photon along
* @param power power of the new photon
*/
    public final void traceDiffusePhoton(Ray r, Color power) {
        if (map.allowDiffuseBounced())
            server.traceDiffusePhoton(this, r, power);
    }"
org.sunflow.core.ShadingState.getGlobalRadiance,"/**
* Returns the radiance estimate given by the global photon map if present
*
* @return global photon map radiance estimate
*/
    public final Color getGlobalRadiance() {
        return server.getGlobalRadiance(this);
    }"
org.sunflow.core.ShadingState.getIrradiance,"/**
* Gets the total irradiance reaching the current point from diffuse
* surfaces. For final gather rays, this returns the total irradiance at the
* intersection point.
*
* @return indirect diffuse irradiance reaching the point
*/
    public final Color getIrradiance(Color diffuseReflectance) {
        return server.getIrradiance(this, diffuseReflectance);
    }"
org.sunflow.core.ShadingState.traceFinalGather,"/**
* Trace a final gather ray and return the intersection result as a new
* render state
*
* @param r ray to shoot
* @param i instance of the ray
* @return new render state object corresponding to the intersection result
*/
    public final ShadingState traceFinalGather(Ray r, int i) {
        return server.traceFinalGather(this, r, i);
    }"
org.sunflow.core.ShadingState.occlusion,"    public final Color occlusion(int samples, float maxDist) {
        return occlusion(samples, maxDist, Color.WHITE, Color.BLACK);
    }"
org.sunflow.core.ShadingState.occlusion,"    public final Color occlusion(int samples, float maxDist, Color bright, Color dark) {
        if (n == null) {
            // in case we got called on a geometry without orientation
            return bright;
        }
        // make sure we are on the right side of the material
        faceforward();
        OrthoNormalBasis onb = getBasis();
        Vector3 w = new Vector3();
        Color result = Color.black();
        for (int i = 0; i < samples; i++) {
            float xi = (float) getRandom(i, 0, samples);
            float xj = (float) getRandom(i, 1, samples);
            float phi = (float) (2 * Math.PI * xi);
            float cosPhi = (float) Math.cos(phi);
            float sinPhi = (float) Math.sin(phi);
            float sinTheta = (float) Math.sqrt(xj);
            float cosTheta = (float) Math.sqrt(1.0f - xj);
            w.x = cosPhi * sinTheta;
            w.y = sinPhi * sinTheta;
            w.z = cosTheta;
            onb.transform(w);
            Ray r = new Ray(p, w);
            r.setMax(maxDist);
            result.add(Color.blend(bright, dark, traceShadow(r)));
        }
        return result.mul(1.0f / samples);
    }"
org.sunflow.core.ShadingState.diffuse,"    public final Color diffuse(Color diff) {
        // integrate a diffuse function
        Color lr = Color.black();
        if (diff.isBlack())
            return lr;
        for (LightSample sample : this)
            lr.madd(sample.dot(n), sample.getDiffuseRadiance());
        lr.add(getIrradiance(diff));
        return lr.mul(diff).mul(1.0f / (float) Math.PI);
    }"
org.sunflow.core.ShadingState.specularPhong,"    public final Color specularPhong(Color spec, float power, int numRays) {
        // integrate a phong specular function
        Color lr = Color.black();
        if (!includeSpecular || spec.isBlack())
            return lr;
        // reflected direction
        float dn = 2 * cosND;
        Vector3 refDir = new Vector3();
        refDir.x = (dn * n.x) + r.dx;
        refDir.y = (dn * n.y) + r.dy;
        refDir.z = (dn * n.z) + r.dz;
        // direct lighting
        for (LightSample sample : this) {
            float cosNL = sample.dot(n);
            float cosLR = sample.dot(refDir);
            if (cosLR > 0)
                lr.madd(cosNL * (float) Math.pow(cosLR, power), sample.getSpecularRadiance());
        }
        // indirect lighting
        if (numRays > 0) {
            int numSamples = getDepth() == 0 ? numRays : 1;
            OrthoNormalBasis onb = OrthoNormalBasis.makeFromW(refDir);
            float mul = (2.0f * (float) Math.PI / (power + 1)) / numSamples;
            for (int i = 0; i < numSamples; i++) {
                // specular indirect lighting
                double r1 = getRandom(i, 0, numSamples);
                double r2 = getRandom(i, 1, numSamples);
                double u = 2 * Math.PI * r1;
                double s = (float) Math.pow(r2, 1 / (power + 1));
                double s1 = (float) Math.sqrt(1 - s * s);
                Vector3 w = new Vector3((float) (Math.cos(u) * s1), (float) (Math.sin(u) * s1), (float) s);
                w = onb.transform(w, new Vector3());
                float wn = Vector3.dot(w, n);
                if (wn > 0)
                    lr.madd(wn * mul, traceGlossy(new Ray(p, w), i));
            }
        }
        lr.mul(spec).mul((power + 2) / (2.0f * (float) Math.PI));
        return lr;
    }"
org.sunflow.core.ShadingState.iterator,"    public Iterator<LightSample> iterator() {
        return new LightSampleIterator(lightSample);
    }"
org.sunflow.core.ShadingState.hasNext,"        public boolean hasNext() {
            return current != null;
        }"
org.sunflow.core.ShadingState.next,"        public LightSample next() {
            LightSample c = current;
            current = current.next;
            return c;
        }"
org.sunflow.core.ShadingState.remove,"        public void remove() {
            throw new UnsupportedOperationException();
        }
    "
org.sunflow.core.GlobalPhotonMapInterface.getRadiance,"    Color getRadiance(Point3 p, Vector3 n);
"
org.sunflow.core.CausticPhotonMapInterface.getSamples,"/**
* Retrieve caustic photons at the specified shading location and add them
* as lights samples.
*
* @param state
*/
    void getSamples(ShadingState state);
"
org.sunflow.core.GIEngine.getGlobalRadiance,"/**
* This is an optional method for engines that contain a secondary
* illumination engine which can return an approximation of the global
* radiance in the scene (like a photon map). Engines can safely return
* <code>Color.BLACK</code> if they can't or don't wish to support this.
*
* @param state shading state
* @return color approximating global radiance
*/
"
org.sunflow.core.GIEngine.init,"/**
* Initialize the engine. This is called before rendering begins.
*
* @return <code>true</code> if the init phase succeeded,
*         <code>false</code> otherwise
*/
"
org.sunflow.core.GIEngine.getIrradiance,"/**
* Return the incomming irradiance due to indirect diffuse illumination at
* the specified surface point.
*
* @param state current render state describing the point to be computed
* @return irradiance from indirect diffuse illumination at the specified
*         point
*/
    public Color getIrradiance(ShadingState state, Color diffuseReflectance);
"
org.sunflow.core.Camera.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        Matrix4 transform = pl.getMatrix(""transform"", null);
        if (transform == null) {
            // no transform was specified, check eye/target/up
            Point3 eye = pl.getPoint(""eye"", null);
            Point3 target = pl.getPoint(""target"", null);
            Vector3 up = pl.getVector(""up"", null);
            if (eye != null && target != null && up != null) {
                c2w = Matrix4.fromBasis(OrthoNormalBasis.makeFromWV(Point3.sub(eye, target, new Vector3()), up));
                c2w = Matrix4.translation(eye.x, eye.y, eye.z).multiply(c2w);
            }
        } else
            c2w = transform;
        if (c2w != null) {
            w2c = c2w.inverse();
            if (w2c == null) {
                UI.printError(Module.CAM, ""Camera matrix is not invertible"");
                return false;
            }
        } else
            w2c = null;
        return lens.update(pl, api);
    }"
org.sunflow.core.Camera.getRay,"    public Ray getRay(float x, float y, int imageWidth, int imageHeight, double lensX, double lensY, double time) {
        Ray r = lens.getRay(x, y, imageWidth, imageHeight, lensX, lensY, time);
        if (r != null && c2w != null) {
            r = r.transform(c2w);
            // renormalize to account for scale factors embeded in the transform
            r.normalize();
        }
        return r;
    }"
org.sunflow.core.Camera.getRay,"/**
* Generate a ray from the origin of camera space toward the specified point
*
* @param p point in world space
* @return ray from the origin of camera space to the specified point
*/
    Ray getRay(Point3 p) {
        return new Ray(c2w.transformP(new Point3(0, 0, 0)), p);
    }"
org.sunflow.core.Camera.getCameraToWorld,"    Matrix4 getCameraToWorld() {
        return c2w == null ? Matrix4.IDENTITY : c2w;
    }"
org.sunflow.core.Camera.getWorldToCamera,"    Matrix4 getWorldToCamera() {
        return w2c == null ? Matrix4.IDENTITY : w2c;
    }
"
org.sunflow.core.IntersectionState.getStack,"    public final StackNode[] getStack() {
        return stack;
    }"
org.sunflow.core.IntersectionState.getStackTop,"    public final int getStackTop() {
        return current == null ? 0 : MAX_STACK_SIZE;
    }"
org.sunflow.core.IntersectionState.getRobustStack,"    public final float[] getRobustStack() {
        return rstack;
    }"
org.sunflow.core.IntersectionState.hit,"/**
* Checks to see if a hit has been recorded.
*
* @return <code>true</code> if a hit has been recorded,
*         <code>false</code> otherwise
* @see #setIntersection(Primitive, float, float)
*/
    public final boolean hit() {
        return instance != null;
    }"
org.sunflow.core.IntersectionState.setIntersection,"/**
* Record an intersection with the specified object.The u and v parameters
* are used to pinpoint the location on the surface if needed.
*
* @param object reference to the object beeing intersected
* @param u u surface parameter of the intersection point
* @param v v surface parameter of the intersection point
* @see Primitive#intersect(Ray, IntersectionState)
*/
    public final void setIntersection(Instance object, float u, float v) {
        instance = object;
        this.u = u;
        this.v = v;
    }"
org.sunflow.core.IntersectionState.setIntersection,"/**
* Record an intersection with the specified primitive id. The parent object
* is assumed to be the current instance. The u and v parameters are used to
* pinpoint the location on the surface if needed.
*
* @param id primitive id of the intersected object
* @param u u surface paramater of the intersection point
* @param v v surface parameter of the intersection point
*/
    public final void setIntersection(int id, float u, float v) {
        instance = current;
        this.id = id;
        this.u = u;
        this.v = v;
    }
"
org.sunflow.core.ImageSampler.prepare,"/**
* Prepare the sampler for rendering an image of w x h pixels
*
* @param w width of the image
* @param h height of the image
*/
"
org.sunflow.core.ImageSampler.render,"/**
* Render the image to the specified display. The sampler can assume the
* display has been opened and that it will be closed after the method
* returns.
*
* @param display Display driver to send image data to
*/
    public void render(Display display);
"
org.sunflow.core.Tesselatable.tesselate,
org.sunflow.core.Tesselatable.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w);
"
org.sunflow.core.Geometry.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        acceltype = pl.getString(""accel"", acceltype);
        // clear up old tesselation if it exists
        if (tesselatable != null) {
            primitives = null;
            builtTess = 0;
        }
        // clear acceleration structure so it will be rebuilt
        accel = null;
        builtAccel = 0;
        if (tesselatable != null)
            return tesselatable.update(pl, api);
        // update primitives
        return primitives.update(pl, api);
    }"
org.sunflow.core.Geometry.getNumPrimitives,"    int getNumPrimitives() {
        return primitives == null ? 0 : primitives.getNumPrimitives();
    }"
org.sunflow.core.Geometry.getWorldBounds,"    BoundingBox getWorldBounds(Matrix4 o2w) {
        if (primitives == null) {

            BoundingBox b = tesselatable.getWorldBounds(o2w);
            if (b != null)
                return b;
            if (builtTess == 0)
                tesselate();
            if (primitives == null)
                return null; // failed tesselation, return infinite bounding
                                // box
        }
        return primitives.getWorldBounds(o2w);
    }"
org.sunflow.core.Geometry.intersect,"    void intersect(Ray r, IntersectionState state) {
        if (builtTess == 0)
            tesselate();
        if (builtAccel == 0)
            build();
        accel.intersect(r, state);
    }"
org.sunflow.core.Geometry.tesselate,"    private synchronized void tesselate() {
        // double check flag
        if (builtTess != 0)
            return;
        if (tesselatable != null && primitives == null) {
            UI.printInfo(Module.GEOM, ""Tesselating geometry ..."");
            primitives = tesselatable.tesselate();
            if (primitives == null)
                UI.printError(Module.GEOM, ""Tesselation failed - geometry will be discarded"");
            else
                UI.printDetailed(Module.GEOM, ""Tesselation produced %d primitives"", primitives.getNumPrimitives());
        }
        builtTess = 1;
    }"
org.sunflow.core.Geometry.build,"    private synchronized void build() {
        // double check flag
        if (builtAccel != 0)
            return;
        if (primitives != null) {
            int n = primitives.getNumPrimitives();
            if (n >= 1000)
                UI.printInfo(Module.GEOM, ""Building acceleration structure for %d primitives ..."", n);
            accel = AccelerationStructureFactory.create(acceltype, n, true);
            accel.build(primitives);
        } else {
            // create an empty accelerator to avoid having to check for null
            // pointers in the intersect method
            accel = new NullAccelerator();
        }
        builtAccel = 1;
    }"
org.sunflow.core.Geometry.prepareShadingState,"    void prepareShadingState(ShadingState state) {
        primitives.prepareShadingState(state);
    }"
org.sunflow.core.Geometry.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        if (builtTess == 0)
            tesselate();
        if (primitives == null)
            return null;
        return primitives.getBakingPrimitives();
    }"
org.sunflow.core.Geometry.getPrimitiveList,"    PrimitiveList getPrimitiveList() {
        return primitives;
    }
"
org.sunflow.core.Filter.getSize,"/**
* Width in pixels of the filter extents. The filter will be applied to the
* range of pixels within a box of <code>+/- getSize() / 2</code> around
* the center of the pixel.
*
* @return width in pixels
*/
"
org.sunflow.core.Filter.get,"/**
* Get value of the filter at offset (x, y). The filter should never be
* called with values beyond its extents but should return 0 in those cases
* anyway.
*
* @param x x offset in pixels
* @param y y offset in pixels
* @return value of the filter at the specified location
*/
    public float get(float x, float y);
"
org.sunflow.core.SceneParser.parse,"    public boolean parse(String filename, SunflowAPI api);
"
org.sunflow.core.AccelerationStructureFactory.create,"    static final AccelerationStructure create(String name, int n, boolean primitives) {
        if (name == null || name.equals(""auto"")) {
            if (primitives) {
                if (n > 20000000)
                    return new UniformGrid();
                else if (n > 2000000)
                    return new BoundingIntervalHierarchy();
                else if (n > 2)
                    return new KDTree();
                else
                    return new NullAccelerator();
            } else {
                if (n > 2)
                    return new BoundingIntervalHierarchy();
                else
                    return new NullAccelerator();
            }
        } else if (name.equals(""uniformgrid""))
            return new UniformGrid();
        else if (name.equals(""null""))
            return new NullAccelerator();
        else if (name.equals(""kdtree""))
            return new KDTree();
        else if (name.equals(""bih""))
            return new BoundingIntervalHierarchy();
        else {
            UI.printWarning(Module.ACCEL, ""Unrecognized intersection accelerator \""%s\"" - using auto"", name);
            return create(null, n, primitives);
        }
    }
"
org.sunflow.core.photonmap.CausticPhotonMap.prepare,"    public void prepare(BoundingBox sceneBounds) {
        photonList = new ArrayList<Photon>();
        photonList.add(null);
        photons = null;
        storedPhotons = halfStoredPhotons = 0;
    }"
org.sunflow.core.photonmap.CausticPhotonMap.locatePhotons,"    private void locatePhotons(NearestPhotons np) {
        float[] dist1d2 = new float[log2n];
        int[] chosen = new int[log2n];
        int i = 1;
        int level = 0;
        int cameFrom;
        while (true) {
            while (i < halfStoredPhotons) {
                float dist1d = photons[i].getDist1(np.px, np.py, np.pz);
                dist1d2[level] = dist1d * dist1d;
                i += i;
                if (dist1d > 0.0f)
                    i++;
                chosen[level++] = i;
            }
            np.checkAddNearest(photons[i]);
            do {
                cameFrom = i;
                i >>= 1;
                level--;
                if (i == 0)
                    return;
            } while ((dist1d2[level] >= np.dist2[0]) || (cameFrom != chosen[level]));
            np.checkAddNearest(photons[i]);
            i = chosen[level++] ^ 1;
        }
    }"
org.sunflow.core.photonmap.CausticPhotonMap.balance,"    private void balance() {
        if (storedPhotons == 0)
            return;
        photons = photonList.toArray(new Photon[photonList.size()]);
        photonList = null;
        Photon[] temp = new Photon[storedPhotons + 1];
        balanceSegment(temp, 1, 1, storedPhotons);
        photons = temp;
        halfStoredPhotons = storedPhotons / 2;
        log2n = (int) Math.ceil(Math.log(storedPhotons) / Math.log(2.0));
    }"
org.sunflow.core.photonmap.CausticPhotonMap.balanceSegment,"    private void balanceSegment(Photon[] temp, int index, int start, int end) {
        int median = 1;
        while ((4 * median) <= (end - start + 1))
            median += median;
        if ((3 * median) <= (end - start + 1)) {
            median += median;
            median += (start - 1);
        } else
            median = end - median + 1;
        int axis = Photon.SPLIT_Z;
        Vector3 extents = bounds.getExtents();
        if ((extents.x > extents.y) && (extents.x > extents.z))
            axis = Photon.SPLIT_X;
        else if (extents.y > extents.z)
            axis = Photon.SPLIT_Y;
        int left = start;
        int right = end;
        while (right > left) {
            double v = photons[right].getCoord(axis);
            int i = left - 1;
            int j = right;
            while (true) {
                while (photons[++i].getCoord(axis) < v) {
                }
                while ((photons[--j].getCoord(axis) > v) && (j > left)) {
                }
                if (i >= j)
                    break;
                swap(i, j);
            }
            swap(i, right);
            if (i >= median)
                right = i - 1;
            if (i <= median)
                left = i + 1;
        }
        temp[index] = photons[median];
        temp[index].setSplitAxis(axis);
        if (median > start) {
            if (start < (median - 1)) {
                float tmp;
                switch (axis) {
                    case Photon.SPLIT_X:
                        tmp = bounds.getMaximum().x;
                        bounds.getMaximum().x = temp[index].x;
                        balanceSegment(temp, 2 * index, start, median - 1);
                        bounds.getMaximum().x = tmp;
                        break;
                    case Photon.SPLIT_Y:
                        tmp = bounds.getMaximum().y;
                        bounds.getMaximum().y = temp[index].y;
                        balanceSegment(temp, 2 * index, start, median - 1);
                        bounds.getMaximum().y = tmp;
                        break;
                    default:
                        tmp = bounds.getMaximum().z;
                        bounds.getMaximum().z = temp[index].z;
                        balanceSegment(temp, 2 * index, start, median - 1);
                        bounds.getMaximum().z = tmp;
                }
            } else
                temp[2 * index] = photons[start];
        }
        if (median < end) {
            if ((median + 1) < end) {
                float tmp;
                switch (axis) {
                    case Photon.SPLIT_X:
                        tmp = bounds.getMinimum().x;
                        bounds.getMinimum().x = temp[index].x;
                        balanceSegment(temp, (2 * index) + 1, median + 1, end);
                        bounds.getMinimum().x = tmp;
                        break;
                    case Photon.SPLIT_Y:
                        tmp = bounds.getMinimum().y;
                        bounds.getMinimum().y = temp[index].y;
                        balanceSegment(temp, (2 * index) + 1, median + 1, end);
                        bounds.getMinimum().y = tmp;
                        break;
                    default:
                        tmp = bounds.getMinimum().z;
                        bounds.getMinimum().z = temp[index].z;
                        balanceSegment(temp, (2 * index) + 1, median + 1, end);
                        bounds.getMinimum().z = tmp;
                }
            } else
                temp[(2 * index) + 1] = photons[end];
        }
    }"
org.sunflow.core.photonmap.CausticPhotonMap.swap,"    private void swap(int i, int j) {
        Photon tmp = photons[i];
        photons[i] = photons[j];
        photons[j] = tmp;
    }"
org.sunflow.core.photonmap.CausticPhotonMap.store,"    public void store(ShadingState state, Vector3 dir, Color power, Color diffuse) {
        if (((state.getDiffuseDepth() == 0) && (state.getReflectionDepth() > 0 || state.getRefractionDepth() > 0))) {
            // this is a caustic photon
            Photon p = new Photon(state.getPoint(), dir, power);
            synchronized (this) {
                storedPhotons++;
                photonList.add(p);
                bounds.include(new Point3(p.x, p.y, p.z));
                maxPower = Math.max(maxPower, power.getMax());
            }
        }
    }"
org.sunflow.core.photonmap.CausticPhotonMap.init,"    public void init() {
        UI.printInfo(Module.LIGHT, ""Balancing caustics photon map ..."");
        Timer t = new Timer();
        t.start();
        balance();
        t.end();
        UI.printInfo(Module.LIGHT, ""Caustic photon map:"");
        UI.printInfo(Module.LIGHT, ""  * Photons stored:   %d"", storedPhotons);
        UI.printInfo(Module.LIGHT, ""  * Photons/estimate: %d"", gatherNum);
        maxRadius = 1.4f * (float) Math.sqrt(maxPower * gatherNum);
        UI.printInfo(Module.LIGHT, ""  * Estimate radius:  %.3f"", gatherRadius);
        UI.printInfo(Module.LIGHT, ""  * Maximum radius:   %.3f"", maxRadius);
        UI.printInfo(Module.LIGHT, ""  * Balancing time:   %s"", t.toString());
        if (gatherRadius > maxRadius)
            gatherRadius = maxRadius;
    }"
org.sunflow.core.photonmap.CausticPhotonMap.getSamples,"    public void getSamples(ShadingState state) {
        if (storedPhotons == 0)
            return;
        NearestPhotons np = new NearestPhotons(state.getPoint(), gatherNum, gatherRadius * gatherRadius);
        locatePhotons(np);
        if (np.found < 8)
            return;
        Point3 ppos = new Point3();
        Vector3 pdir = new Vector3();
        Vector3 pvec = new Vector3();
        float invArea = 1.0f / ((float) Math.PI * np.dist2[0]);
        float maxNDist = np.dist2[0] * 0.05f;
        float f2r2 = 1.0f / (filterValue * filterValue * np.dist2[0]);
        float fInv = 1.0f / (1.0f - 2.0f / (3.0f * filterValue));
        for (int i = 1; i <= np.found; i++) {
            Photon phot = np.index[i];
            Vector3.decode(phot.dir, pdir);
            float cos = -Vector3.dot(pdir, state.getNormal());
            if (cos > 0.001) {
                ppos.set(phot.x, phot.y, phot.z);
                Point3.sub(ppos, state.getPoint(), pvec);
                float pcos = Vector3.dot(pvec, state.getNormal());
                if ((pcos < maxNDist) && (pcos > -maxNDist)) {
                    LightSample sample = new LightSample();
                    sample.setShadowRay(new Ray(state.getPoint(), pdir.negate()));
                    sample.setRadiance(new Color().setRGBE(np.index[i].power).mul(invArea / cos), Color.BLACK);
                    sample.getDiffuseRadiance().mul((1.0f - (float) Math.sqrt(np.dist2[i] * f2r2)) * fInv);
                    state.addSample(sample);
                }
            }
        }
    }"
org.sunflow.core.photonmap.CausticPhotonMap.reset,"        void reset(Point3 p, float maxDist2) {
            found = 0;
            gotHeap = false;
            px = p.x;
            py = p.y;
            pz = p.z;
            dist2[0] = maxDist2;
        }"
org.sunflow.core.photonmap.CausticPhotonMap.checkAddNearest,"        void checkAddNearest(Photon p) {
            float fdist2 = p.getDist2(px, py, pz);
            if (fdist2 < dist2[0]) {
                if (found < max) {
                    found++;
                    dist2[found] = fdist2;
                    index[found] = p;
                } else {
                    int j;
                    int parent;
                    if (!gotHeap) {
                        float dst2;
                        Photon phot;
                        int halfFound = found >> 1;
                        for (int k = halfFound; k >= 1; k--) {
                            parent = k;
                            phot = index[k];
                            dst2 = dist2[k];
                            while (parent <= halfFound) {
                                j = parent + parent;
                                if ((j < found) && (dist2[j] < dist2[j + 1]))
                                    j++;
                                if (dst2 >= dist2[j])
                                    break;
                                dist2[parent] = dist2[j];
                                index[parent] = index[j];
                                parent = j;
                            }
                            dist2[parent] = dst2;
                            index[parent] = phot;
                        }
                        gotHeap = true;
                    }
                    parent = 1;
                    j = 2;
                    while (j <= found) {
                        if ((j < found) && (dist2[j] < dist2[j + 1]))
                            j++;
                        if (fdist2 > dist2[j])
                            break;
                        dist2[parent] = dist2[j];
                        index[parent] = index[j];
                        parent = j;
                        j += j;
                    }
                    dist2[parent] = fdist2;
                    index[parent] = p;
                    dist2[0] = dist2[1];
                }
            }
        }
    "
org.sunflow.core.photonmap.CausticPhotonMap.setSplitAxis,"        void setSplitAxis(int axis) {
            flags &= ~SPLIT_MASK;
            flags |= axis;
        }"
org.sunflow.core.photonmap.CausticPhotonMap.getCoord,"        float getCoord(int axis) {
            switch (axis) {
                case SPLIT_X:
                    return x;
                case SPLIT_Y:
                    return y;
                default:
                    return z;
            }
        }"
org.sunflow.core.photonmap.CausticPhotonMap.getDist1,"        float getDist1(float px, float py, float pz) {
            switch (flags & SPLIT_MASK) {
                case SPLIT_X:
                    return px - x;
                case SPLIT_Y:
                    return py - y;
                default:
                    return pz - z;
            }
        }"
org.sunflow.core.photonmap.CausticPhotonMap.getDist2,"        float getDist2(float px, float py, float pz) {
            float dx = x - px;
            float dy = y - py;
            float dz = z - pz;
            return (dx * dx) + (dy * dy) + (dz * dz);
        }
    "
org.sunflow.core.photonmap.CausticPhotonMap.allowDiffuseBounced,"    public boolean allowDiffuseBounced() {
        return false;
    }"
org.sunflow.core.photonmap.CausticPhotonMap.allowReflectionBounced,"    public boolean allowReflectionBounced() {
        return true;
    }"
org.sunflow.core.photonmap.CausticPhotonMap.allowRefractionBounced,"    public boolean allowRefractionBounced() {
        return true;
    }"
org.sunflow.core.photonmap.CausticPhotonMap.numEmit,"    public int numEmit() {
        return numEmit;
    }
"
org.sunflow.core.photonmap.GlobalPhotonMap.prepare,"    public void prepare(BoundingBox sceneBounds) {
        photonList = new ArrayList<Photon>();
        photonList.add(null);
        photons = null;
        storedPhotons = halfStoredPhotons = 0;
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.store,"    public void store(ShadingState state, Vector3 dir, Color power, Color diffuse) {
        Photon p = new Photon(state.getPoint(), state.getNormal(), dir, power, diffuse);
        synchronized (this) {
            storedPhotons++;
            photonList.add(p);
            bounds.include(new Point3(p.x, p.y, p.z));
            maxPower = Math.max(maxPower, power.getMax());
        }
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.locatePhotons,"    private void locatePhotons(NearestPhotons np) {
        float[] dist1d2 = new float[log2n];
        int[] chosen = new int[log2n];
        int i = 1;
        int level = 0;
        int cameFrom;
        while (true) {
            while (i < halfStoredPhotons) {
                float dist1d = photons[i].getDist1(np.px, np.py, np.pz);
                dist1d2[level] = dist1d * dist1d;
                i += i;
                if (dist1d > 0.0f)
                    i++;
                chosen[level++] = i;
            }
            np.checkAddNearest(photons[i]);
            do {
                cameFrom = i;
                i >>= 1;
                level--;
                if (i == 0)
                    return;
            } while ((dist1d2[level] >= np.dist2[0]) || (cameFrom != chosen[level]));
            np.checkAddNearest(photons[i]);
            i = chosen[level++] ^ 1;
        }
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.balance,"    private void balance() {
        if (storedPhotons == 0)
            return;
        photons = photonList.toArray(new Photon[photonList.size()]);
        photonList = null;
        Photon[] temp = new Photon[storedPhotons + 1];
        balanceSegment(temp, 1, 1, storedPhotons);
        photons = temp;
        halfStoredPhotons = storedPhotons / 2;
        log2n = (int) Math.ceil(Math.log(storedPhotons) / Math.log(2.0));
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.balanceSegment,"    private void balanceSegment(Photon[] temp, int index, int start, int end) {
        int median = 1;
        while ((4 * median) <= (end - start + 1))
            median += median;
        if ((3 * median) <= (end - start + 1)) {
            median += median;
            median += (start - 1);
        } else
            median = end - median + 1;
        int axis = Photon.SPLIT_Z;
        Vector3 extents = bounds.getExtents();
        if ((extents.x > extents.y) && (extents.x > extents.z))
            axis = Photon.SPLIT_X;
        else if (extents.y > extents.z)
            axis = Photon.SPLIT_Y;
        int left = start;
        int right = end;
        while (right > left) {
            double v = photons[right].getCoord(axis);
            int i = left - 1;
            int j = right;
            while (true) {
                while (photons[++i].getCoord(axis) < v) {
                }
                while ((photons[--j].getCoord(axis) > v) && (j > left)) {
                }
                if (i >= j)
                    break;
                swap(i, j);
            }
            swap(i, right);
            if (i >= median)
                right = i - 1;
            if (i <= median)
                left = i + 1;
        }
        temp[index] = photons[median];
        temp[index].setSplitAxis(axis);
        if (median > start) {
            if (start < (median - 1)) {
                float tmp;
                switch (axis) {
                    case Photon.SPLIT_X:
                        tmp = bounds.getMaximum().x;
                        bounds.getMaximum().x = temp[index].x;
                        balanceSegment(temp, 2 * index, start, median - 1);
                        bounds.getMaximum().x = tmp;
                        break;
                    case Photon.SPLIT_Y:
                        tmp = bounds.getMaximum().y;
                        bounds.getMaximum().y = temp[index].y;
                        balanceSegment(temp, 2 * index, start, median - 1);
                        bounds.getMaximum().y = tmp;
                        break;
                    default:
                        tmp = bounds.getMaximum().z;
                        bounds.getMaximum().z = temp[index].z;
                        balanceSegment(temp, 2 * index, start, median - 1);
                        bounds.getMaximum().z = tmp;
                }
            } else
                temp[2 * index] = photons[start];
        }
        if (median < end) {
            if ((median + 1) < end) {
                float tmp;
                switch (axis) {
                    case Photon.SPLIT_X:
                        tmp = bounds.getMinimum().x;
                        bounds.getMinimum().x = temp[index].x;
                        balanceSegment(temp, (2 * index) + 1, median + 1, end);
                        bounds.getMinimum().x = tmp;
                        break;
                    case Photon.SPLIT_Y:
                        tmp = bounds.getMinimum().y;
                        bounds.getMinimum().y = temp[index].y;
                        balanceSegment(temp, (2 * index) + 1, median + 1, end);
                        bounds.getMinimum().y = tmp;
                        break;
                    default:
                        tmp = bounds.getMinimum().z;
                        bounds.getMinimum().z = temp[index].z;
                        balanceSegment(temp, (2 * index) + 1, median + 1, end);
                        bounds.getMinimum().z = tmp;
                }
            } else
                temp[(2 * index) + 1] = photons[end];
        }
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.swap,"    private void swap(int i, int j) {
        Photon tmp = photons[i];
        photons[i] = photons[j];
        photons[j] = tmp;
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.setSplitAxis,"        void setSplitAxis(int axis) {
            flags &= ~SPLIT_MASK;
            flags |= axis;
        }"
org.sunflow.core.photonmap.GlobalPhotonMap.getCoord,"        float getCoord(int axis) {
            switch (axis) {
                case SPLIT_X:
                    return x;
                case SPLIT_Y:
                    return y;
                default:
                    return z;
            }
        }"
org.sunflow.core.photonmap.GlobalPhotonMap.getDist1,"        float getDist1(float px, float py, float pz) {
            switch (flags & SPLIT_MASK) {
                case SPLIT_X:
                    return px - x;
                case SPLIT_Y:
                    return py - y;
                default:
                    return pz - z;
            }
        }"
org.sunflow.core.photonmap.GlobalPhotonMap.getDist2,"        float getDist2(float px, float py, float pz) {
            float dx = x - px;
            float dy = y - py;
            float dz = z - pz;
            return (dx * dx) + (dy * dy) + (dz * dz);
        }
    "
org.sunflow.core.photonmap.GlobalPhotonMap.init,"    public void init() {
        UI.printInfo(Module.LIGHT, ""Balancing global photon map ..."");
        UI.taskStart(""Balancing global photon map"", 0, 1);
        Timer t = new Timer();
        t.start();
        balance();
        t.end();
        UI.taskStop();
        UI.printInfo(Module.LIGHT, ""Global photon map:"");
        UI.printInfo(Module.LIGHT, ""  * Photons stored:   %d"", storedPhotons);
        UI.printInfo(Module.LIGHT, ""  * Photons/estimate: %d"", numGather);
        UI.printInfo(Module.LIGHT, ""  * Estimate radius:  %.3f"", gatherRadius);
        maxRadius = 1.4f * (float) Math.sqrt(maxPower * numGather);
        UI.printInfo(Module.LIGHT, ""  * Maximum radius:   %.3f"", maxRadius);
        UI.printInfo(Module.LIGHT, ""  * Balancing time:   %s"", t.toString());
        if (gatherRadius > maxRadius)
            gatherRadius = maxRadius;
        t.start();
        precomputeRadiance();
        t.end();
        UI.printInfo(Module.LIGHT, ""  * Precompute time:  %s"", t.toString());
        UI.printInfo(Module.LIGHT, ""  * Radiance photons: %d"", storedPhotons);
        UI.printInfo(Module.LIGHT, ""  * Search radius:    %.3f"", gatherRadius);
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.precomputeRadiance,"    public void precomputeRadiance() {
        if (storedPhotons == 0)
            return;
        // precompute the radiance for all photons that are neither
        // leaves nor parents of leaves in the tree.
        int quadStoredPhotons = halfStoredPhotons / 2;
        Point3 p = new Point3();
        Vector3 n = new Vector3();
        Point3 ppos = new Point3();
        Vector3 pdir = new Vector3();
        Vector3 pvec = new Vector3();
        Color irr = new Color();
        Color pow = new Color();
        float maxDist2 = gatherRadius * gatherRadius;
        NearestPhotons np = new NearestPhotons(p, numGather, maxDist2);
        Photon[] temp = new Photon[quadStoredPhotons + 1];
        UI.taskStart(""Precomputing radiance"", 1, quadStoredPhotons);
        for (int i = 1; i <= quadStoredPhotons; i++) {
            UI.taskUpdate(i);
            Photon curr = photons[i];
            p.set(curr.x, curr.y, curr.z);
            Vector3.decode(curr.normal, n);
            irr.set(Color.BLACK);
            np.reset(p, maxDist2);
            locatePhotons(np);
            if (np.found < 8) {
                curr.data = 0;
                temp[i] = curr;
                continue;
            }
            float invArea = 1.0f / ((float) Math.PI * np.dist2[0]);
            float maxNDist = np.dist2[0] * 0.05f;
            for (int j = 1; j <= np.found; j++) {
                Photon phot = np.index[j];
                Vector3.decode(phot.dir, pdir);
                float cos = -Vector3.dot(pdir, n);
                if (cos > 0.01f) {
                    ppos.set(phot.x, phot.y, phot.z);
                    Point3.sub(ppos, p, pvec);
                    float pcos = Vector3.dot(pvec, n);
                    if ((pcos < maxNDist) && (pcos > -maxNDist))
                        irr.add(pow.setRGBE(phot.power));
                }
            }
            irr.mul(invArea);
            // compute radiance
            irr.mul(new Color(curr.data)).mul(1.0f / (float) Math.PI);
            curr.data = irr.toRGBE();
            temp[i] = curr;
        }
        UI.taskStop();

        // resize photon map to only include irradiance photons
        numGather /= 4;
        maxRadius = 1.4f * (float) Math.sqrt(maxPower * numGather);
        if (gatherRadius > maxRadius)
            gatherRadius = maxRadius;
        storedPhotons = quadStoredPhotons;
        halfStoredPhotons = storedPhotons / 2;
        log2n = (int) Math.ceil(Math.log(storedPhotons) / Math.log(2.0));
        photons = temp;
        hasRadiance = true;
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.getRadiance,"    public Color getRadiance(Point3 p, Vector3 n) {
        if (!hasRadiance || (storedPhotons == 0))
            return Color.BLACK;
        float px = p.x;
        float py = p.y;
        float pz = p.z;
        int i = 1;
        int level = 0;
        int cameFrom;
        float dist2;
        float maxDist2 = gatherRadius * gatherRadius;
        Photon nearest = null;
        Photon curr;
        Vector3 photN = new Vector3();
        float[] dist1d2 = new float[log2n];
        int[] chosen = new int[log2n];
        while (true) {
            while (i < halfStoredPhotons) {
                float dist1d = photons[i].getDist1(px, py, pz);
                dist1d2[level] = dist1d * dist1d;
                i += i;
                if (dist1d > 0)
                    i++;
                chosen[level++] = i;
            }
            curr = photons[i];
            dist2 = curr.getDist2(px, py, pz);
            if (dist2 < maxDist2) {
                Vector3.decode(curr.normal, photN);
                float currentDotN = Vector3.dot(photN, n);
                if (currentDotN > 0.9f) {
                    nearest = curr;
                    maxDist2 = dist2;
                }
            }
            do {
                cameFrom = i;
                i >>= 1;
                level--;
                if (i == 0)
                    return (nearest == null) ? Color.BLACK : new Color().setRGBE(nearest.data);
            } while ((dist1d2[level] >= maxDist2) || (cameFrom != chosen[level]));
            curr = photons[i];
            dist2 = curr.getDist2(px, py, pz);
            if (dist2 < maxDist2) {
                Vector3.decode(curr.normal, photN);
                float currentDotN = Vector3.dot(photN, n);
                if (currentDotN > 0.9f) {
                    nearest = curr;
                    maxDist2 = dist2;
                }
            }
            i = chosen[level++] ^ 1;
        }
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.reset,"        void reset(Point3 p, float maxDist2) {
            found = 0;
            gotHeap = false;
            px = p.x;
            py = p.y;
            pz = p.z;
            dist2[0] = maxDist2;
        }"
org.sunflow.core.photonmap.GlobalPhotonMap.checkAddNearest,"        void checkAddNearest(Photon p) {
            float fdist2 = p.getDist2(px, py, pz);
            if (fdist2 < dist2[0]) {
                if (found < max) {
                    found++;
                    dist2[found] = fdist2;
                    index[found] = p;
                } else {
                    int j;
                    int parent;
                    if (!gotHeap) {
                        float dst2;
                        Photon phot;
                        int halfFound = found >> 1;
                        for (int k = halfFound; k >= 1; k--) {
                            parent = k;
                            phot = index[k];
                            dst2 = dist2[k];
                            while (parent <= halfFound) {
                                j = parent + parent;
                                if ((j < found) && (dist2[j] < dist2[j + 1]))
                                    j++;
                                if (dst2 >= dist2[j])
                                    break;
                                dist2[parent] = dist2[j];
                                index[parent] = index[j];
                                parent = j;
                            }
                            dist2[parent] = dst2;
                            index[parent] = phot;
                        }
                        gotHeap = true;
                    }
                    parent = 1;
                    j = 2;
                    while (j <= found) {
                        if ((j < found) && (dist2[j] < dist2[j + 1]))
                            j++;
                        if (fdist2 > dist2[j])
                            break;
                        dist2[parent] = dist2[j];
                        index[parent] = index[j];
                        parent = j;
                        j += j;
                    }
                    dist2[parent] = fdist2;
                    index[parent] = p;
                    dist2[0] = dist2[1];
                }
            }
        }
    "
org.sunflow.core.photonmap.GlobalPhotonMap.allowDiffuseBounced,"    public boolean allowDiffuseBounced() {
        return true;
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.allowReflectionBounced,"    public boolean allowReflectionBounced() {
        return true;
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.allowRefractionBounced,"    public boolean allowRefractionBounced() {
        return true;
    }"
org.sunflow.core.photonmap.GlobalPhotonMap.numEmit,"    public int numEmit() {
        return numEmit;
    }
"
org.sunflow.core.photonmap.GridPhotonMap.prepare,"    public void prepare(BoundingBox sceneBounds) {
        bounds = new BoundingBox(sceneBounds);
        bounds.enlargeUlps();
        Vector3 w = bounds.getExtents();
        nx = (int) Math.max(((w.x / gatherRadius) + 0.5f), 1);
        ny = (int) Math.max(((w.y / gatherRadius) + 0.5f), 1);
        nz = (int) Math.max(((w.z / gatherRadius) + 0.5f), 1);
        int numCells = nx * ny * nz;
        UI.printInfo(Module.LIGHT, ""Initializing grid photon map:"");
        UI.printInfo(Module.LIGHT, ""  * Resolution:  %dx%dx%d"", nx, ny, nz);
        UI.printInfo(Module.LIGHT, ""  * Total cells: %d"", numCells);
        for (hashPrime = 0; hashPrime < PRIMES.length; hashPrime++)
            if (PRIMES[hashPrime] > (numCells / 5))
                break;
        cellHash = new PhotonGroup[PRIMES[hashPrime]];
        UI.printInfo(Module.LIGHT, ""  * Initial hash size: %d"", cellHash.length);
    }"
org.sunflow.core.photonmap.GridPhotonMap.size,"    public int size() {
        return numStoredPhotons;
    }"
org.sunflow.core.photonmap.GridPhotonMap.store,"    public void store(ShadingState state, Vector3 dir, Color power, Color diffuse) {
        // don't store on the wrong side of a surface
        if (Vector3.dot(state.getNormal(), dir) > 0)
            return;
        Point3 pt = state.getPoint();
        // outside grid bounds ?
        if (!bounds.contains(pt))
            return;
        Vector3 ext = bounds.getExtents();
        int ix = (int) (((pt.x - bounds.getMinimum().x) * nx) / ext.x);
        int iy = (int) (((pt.y - bounds.getMinimum().y) * ny) / ext.y);
        int iz = (int) (((pt.z - bounds.getMinimum().z) * nz) / ext.z);
        ix = MathUtils.clamp(ix, 0, nx - 1);
        iy = MathUtils.clamp(iy, 0, ny - 1);
        iz = MathUtils.clamp(iz, 0, nz - 1);
        int id = ix + iy * nx + iz * nx * ny;
        synchronized (this) {
            int hid = id % cellHash.length;
            PhotonGroup g = cellHash[hid];
            PhotonGroup last = null;
            boolean hasID = false;
            while (g != null) {
                if (g.id == id) {
                    hasID = true;
                    if (Vector3.dot(state.getNormal(), g.normal) > NORMAL_THRESHOLD)
                        break;
                }
                last = g;
                g = g.next;
            }
            if (g == null) {
                g = new PhotonGroup(id, state.getNormal());
                if (last == null)
                    cellHash[hid] = g;
                else
                    last.next = g;
                if (!hasID) {
                    hashSize++; // we have not seen this ID before
                    // resize hash if we have grown too large
                    if (hashSize > cellHash.length)
                        growPhotonHash();
                }
            }
            g.count++;
            g.flux.add(power);
            g.diffuse.add(diffuse);
            numStoredPhotons++;
        }
    }"
org.sunflow.core.photonmap.GridPhotonMap.init,"    public void init() {
        UI.printInfo(Module.LIGHT, ""Initializing photon grid ..."");
        UI.printInfo(Module.LIGHT, ""  * Photon hits:      %d"", numStoredPhotons);
        UI.printInfo(Module.LIGHT, ""  * Final hash size:  %d"", cellHash.length);
        int cells = 0;
        for (int i = 0; i < cellHash.length; i++) {
            for (PhotonGroup g = cellHash[i]; g != null; g = g.next) {
                g.diffuse.mul(1.0f / g.count);
                cells++;
            }
        }
        UI.printInfo(Module.LIGHT, ""  * Num photon cells: %d"", cells);
    }"
org.sunflow.core.photonmap.GridPhotonMap.precomputeRadiance,"    public void precomputeRadiance(boolean includeDirect, boolean includeCaustics) {
    }"
org.sunflow.core.photonmap.GridPhotonMap.growPhotonHash,"    private void growPhotonHash() {
        // enlarge the hash size:
        if (hashPrime >= PRIMES.length - 1)
            return;
        PhotonGroup[] temp = new PhotonGroup[PRIMES[++hashPrime]];
        for (int i = 0; i < cellHash.length; i++) {
            PhotonGroup g = cellHash[i];
            while (g != null) {
                // re-hash into the new table
                int hid = g.id % temp.length;
                PhotonGroup last = null;
                for (PhotonGroup gn = temp[hid]; gn != null; gn = gn.next)
                    last = gn;
                if (last == null)
                    temp[hid] = g;
                else
                    last.next = g;
                PhotonGroup next = g.next;
                g.next = null;
                g = next;
            }
        }
        cellHash = temp;
    }"
org.sunflow.core.photonmap.GridPhotonMap.getRadiance,"    public synchronized Color getRadiance(Point3 p, Vector3 n) {
        if (!bounds.contains(p))
            return Color.BLACK;
        Vector3 ext = bounds.getExtents();
        int ix = (int) (((p.x - bounds.getMinimum().x) * nx) / ext.x);
        int iy = (int) (((p.y - bounds.getMinimum().y) * ny) / ext.y);
        int iz = (int) (((p.z - bounds.getMinimum().z) * nz) / ext.z);
        ix = MathUtils.clamp(ix, 0, nx - 1);
        iy = MathUtils.clamp(iy, 0, ny - 1);
        iz = MathUtils.clamp(iz, 0, nz - 1);
        int id = ix + iy * nx + iz * nx * ny;
        rwl.readLock().lock();
        PhotonGroup center = null;
        for (PhotonGroup g = get(ix, iy, iz); g != null; g = g.next) {
            if (g.id == id && Vector3.dot(n, g.normal) > NORMAL_THRESHOLD) {
                if (g.radiance == null) {
                    center = g;
                    break;
                }
                Color r = g.radiance.copy();
                rwl.readLock().unlock();
                return r;
            }
        }
        int vol = 1;
        while (true) {
            int numPhotons = 0;
            int ndiff = 0;
            Color irr = Color.black();
            Color diff = (center == null) ? Color.black() : null;
            for (int z = iz - (vol - 1); z <= iz + (vol - 1); z++) {
                for (int y = iy - (vol - 1); y <= iy + (vol - 1); y++) {
                    for (int x = ix - (vol - 1); x <= ix + (vol - 1); x++) {
                        int vid = x + y * nx + z * nx * ny;
                        for (PhotonGroup g = get(x, y, z); g != null; g = g.next) {
                            if (g.id == vid && Vector3.dot(n, g.normal) > NORMAL_THRESHOLD) {
                                numPhotons += g.count;
                                irr.add(g.flux);
                                if (diff != null) {
                                    diff.add(g.diffuse);
                                    ndiff++;
                                }
                                break; // only one valid group can be found,
                                // skip the others
                            }
                        }
                    }
                }
            }
            if (numPhotons >= numGather || vol >= 3) {
                // we have found enough photons
                // cache irradiance and return
                float area = (2 * vol - 1) / 3.0f * ((ext.x / nx) + (ext.y / ny) + (ext.z / nz));
                area *= area;
                area *= Math.PI;
                irr.mul(1.0f / area);
                // upgrade lock manually
                rwl.readLock().unlock();
                rwl.writeLock().lock();
                if (center == null) {
                    if (ndiff > 0)
                        diff.mul(1.0f / ndiff);
                    center = new PhotonGroup(id, n);
                    center.diffuse.set(diff);
                    center.next = cellHash[id % cellHash.length];
                    cellHash[id % cellHash.length] = center;
                }
                irr.mul(center.diffuse);
                center.radiance = irr.copy();
                rwl.writeLock().unlock(); // unlock write - done
                return irr;
            }
            vol++;
        }
    }"
org.sunflow.core.photonmap.GridPhotonMap.get,"    private PhotonGroup get(int x, int y, int z) {
        // returns the list associated with the specified location
        if (x < 0 || x >= nx)
            return null;
        if (y < 0 || y >= ny)
            return null;
        if (z < 0 || z >= nz)
            return null;
        return cellHash[(x + y * nx + z * nx * ny) % cellHash.length];
    }"
org.sunflow.core.photonmap.GridPhotonMap.allowDiffuseBounced,"    public boolean allowDiffuseBounced() {
        return true;
    }"
org.sunflow.core.photonmap.GridPhotonMap.allowReflectionBounced,"    public boolean allowReflectionBounced() {
        return true;
    }"
org.sunflow.core.photonmap.GridPhotonMap.allowRefractionBounced,"    public boolean allowRefractionBounced() {
        return true;
    }"
org.sunflow.core.photonmap.GridPhotonMap.numEmit,"    public int numEmit() {
        return numEmit;
    }
"
org.sunflow.core.renderer.ProgressiveRenderer.prepare,"    public boolean prepare(Options options, Scene scene, int w, int h) {
        this.scene = scene;
        imageWidth = w;
        imageHeight = h;
        // prepare table used by deterministic anti-aliasing
        sigma = QMC.generateSigmaTable(1 << 7);
        return true;
    }"
org.sunflow.core.renderer.ProgressiveRenderer.render,"    public void render(Display display) {
        this.display = display;
        display.imageBegin(imageWidth, imageHeight, 0);
        // create first bucket
        SmallBucket b = new SmallBucket();
        b.x = b.y = 0;
        int s = Math.max(imageWidth, imageHeight);
        b.size = 1;
        while (b.size < s)
            b.size <<= 1;
        smallBucketQueue = new PriorityBlockingQueue<SmallBucket>();
        smallBucketQueue.add(b);
        UI.taskStart(""Progressive Render"", 0, imageWidth * imageHeight);
        Timer t = new Timer();
        t.start();
        counter = 0;
        counterMax = imageWidth * imageHeight;

        Thread[] renderThreads = new Thread[scene.getThreads()];
        for (int i = 0; i < renderThreads.length; i++) {
            renderThreads[i] = new SmallBucketThread();
            renderThreads[i].start();
        }
        for (int i = 0; i < renderThreads.length; i++) {
            try {
                renderThreads[i].join();
            } catch (InterruptedException e) {
                UI.printError(Module.IPR, ""Thread %d of %d was interrupted"", i + 1, renderThreads.length);
            }
        }
        UI.taskStop();
        t.end();
        UI.printInfo(Module.IPR, ""Rendering time: %s"", t.toString());
        display.imageEnd();
    }"
org.sunflow.core.renderer.ProgressiveRenderer.run,"        public void run() {
            IntersectionState istate = new IntersectionState();
            while (true) {
                int n = progressiveRenderNext(istate);
                synchronized (ProgressiveRenderer.this) {
                    if (counter >= counterMax)
                        return;
                    counter += n;
                    UI.taskUpdate(counter);
                }
                if (UI.taskCanceled())
                    return;
            }
        }
    }

    private int progressiveRenderNext(IntersectionState istate) {
        final int TASK_SIZE = 16;
        SmallBucket first = smallBucketQueue.poll();
        if (first == null)
            return 0;
        int ds = first.size / TASK_SIZE;
        boolean useMask = !smallBucketQueue.isEmpty();
        int mask = 2 * first.size / TASK_SIZE - 1;
        int pixels = 0;
        for (int i = 0, y = first.y; i < TASK_SIZE && y < imageHeight; i++, y += ds) {
            for (int j = 0, x = first.x; j < TASK_SIZE && x < imageWidth; j++, x += ds) {
                // check to see if this is a pixel from a higher level tile
                if (useMask && (x & mask) == 0 && (y & mask) == 0)
                    continue;
                int instance = (x & (sigma.length - 1)) * sigma.length + sigma[y & (sigma.length - 1)];
                double time = QMC.halton(1, instance);
                double lensU = QMC.halton(2, instance);
                double lensV = QMC.halton(3, instance);
                ShadingState state = scene.getRadiance(istate, x, imageHeight - 1 - y, lensU, lensV, time, instance);
                Color c = state != null ? state.getResult() : Color.BLACK;
                pixels++;
                // fill region
                display.imageFill(x, y, Math.min(ds, imageWidth - x), Math.min(ds, imageHeight - y), c);
            }
        }
        if (first.size >= 2 * TASK_SIZE) {
            // generate child buckets
            int size = first.size >>> 1;
            for (int i = 0; i < 2; i++) {
                if (first.y + i * size < imageHeight) {
                    for (int j = 0; j < 2; j++) {
                        if (first.x + j * size < imageWidth) {
                            SmallBucket b = new SmallBucket();
                            b.x = first.x + j * size;
                            b.y = first.y + i * size;
                            b.size = size;
                            b.constrast = 1.0f / size;
                            smallBucketQueue.put(b);
                        }
                    }
                }
            }
        }
        return pixels;
    }

    // progressive rendering
    private static class SmallBucket implements Comparable<SmallBucket> {
        int x, y, size;
        float constrast;

        public int compareTo(SmallBucket o) {
            if (constrast < o.constrast)
                return -1;
            if (constrast == o.constrast)
                return 0;
            return 1;
        }
    "
org.sunflow.core.renderer.ProgressiveRenderer.progressiveRenderNext,"    private int progressiveRenderNext(IntersectionState istate) {
        final int TASK_SIZE = 16;
        SmallBucket first = smallBucketQueue.poll();
        if (first == null)
            return 0;
        int ds = first.size / TASK_SIZE;
        boolean useMask = !smallBucketQueue.isEmpty();
        int mask = 2 * first.size / TASK_SIZE - 1;
        int pixels = 0;
        for (int i = 0, y = first.y; i < TASK_SIZE && y < imageHeight; i++, y += ds) {
            for (int j = 0, x = first.x; j < TASK_SIZE && x < imageWidth; j++, x += ds) {
                // check to see if this is a pixel from a higher level tile
                if (useMask && (x & mask) == 0 && (y & mask) == 0)
                    continue;
                int instance = (x & (sigma.length - 1)) * sigma.length + sigma[y & (sigma.length - 1)];
                double time = QMC.halton(1, instance);
                double lensU = QMC.halton(2, instance);
                double lensV = QMC.halton(3, instance);
                ShadingState state = scene.getRadiance(istate, x, imageHeight - 1 - y, lensU, lensV, time, instance);
                Color c = state != null ? state.getResult() : Color.BLACK;
                pixels++;
                // fill region
                display.imageFill(x, y, Math.min(ds, imageWidth - x), Math.min(ds, imageHeight - y), c);
            }
        }
        if (first.size >= 2 * TASK_SIZE) {
            // generate child buckets
            int size = first.size >>> 1;
            for (int i = 0; i < 2; i++) {
                if (first.y + i * size < imageHeight) {
                    for (int j = 0; j < 2; j++) {
                        if (first.x + j * size < imageWidth) {
                            SmallBucket b = new SmallBucket();
                            b.x = first.x + j * size;
                            b.y = first.y + i * size;
                            b.size = size;
                            b.constrast = 1.0f / size;
                            smallBucketQueue.put(b);
                        }
                    }
                }
            }
        }
        return pixels;
    }"
org.sunflow.core.renderer.ProgressiveRenderer.compareTo,"        public int compareTo(SmallBucket o) {
            if (constrast < o.constrast)
                return -1;
            if (constrast == o.constrast)
                return 0;
            return 1;
        }
    "
org.sunflow.core.renderer.SimpleRenderer.prepare,"    public boolean prepare(Options options, Scene scene, int w, int h) {
        this.scene = scene;
        imageWidth = w;
        imageHeight = h;
        numBucketsX = (imageWidth + 31) >>> 5;
        numBucketsY = (imageHeight + 31) >>> 5;
        numBuckets = numBucketsX * numBucketsY;
        return true;
    }"
org.sunflow.core.renderer.SimpleRenderer.render,"    public void render(Display display) {
        this.display = display;
        display.imageBegin(imageWidth, imageHeight, 32);
        // set members variables
        bucketCounter = 0;
        // start task
        Timer timer = new Timer();
        timer.start();
        Thread[] renderThreads = new Thread[scene.getThreads()];
        for (int i = 0; i < renderThreads.length; i++) {
            renderThreads[i] = new BucketThread();
            renderThreads[i].start();
        }
        for (int i = 0; i < renderThreads.length; i++) {
            try {
                renderThreads[i].join();
            } catch (InterruptedException e) {
                UI.printError(Module.BCKT, ""Bucket processing thread %d of %d was interrupted"", i + 1, renderThreads.length);
            }
        }
        timer.end();
        UI.printInfo(Module.BCKT, ""Render time: %s"", timer.toString());
        display.imageEnd();
    }"
org.sunflow.core.renderer.SimpleRenderer.run,"        public void run() {
            IntersectionState istate = new IntersectionState();
            while (true) {
                int bx, by;
                synchronized (SimpleRenderer.this) {
                    if (bucketCounter >= numBuckets)
                        return;
                    by = bucketCounter / numBucketsX;
                    bx = bucketCounter % numBucketsX;
                    bucketCounter++;
                }
                renderBucket(bx, by, istate);
            }
        }
    }

    public void renderBucket(int bx, int by, IntersectionState istate) {
        // pixel sized extents
        int x0 = bx * 32;
        int y0 = by * 32;
        int bw = Math.min(32, imageWidth - x0);
        int bh = Math.min(32, imageHeight - y0);

        Color[] bucketRGB = new Color[bw * bh];

        for (int y = 0, i = 0; y < bh; y++) {
            for (int x = 0; x < bw; x++, i++) {
                ShadingState state = scene.getRadiance(istate, x0 + x, imageHeight - 1 - (y0 + y), 0.0, 0.0, 0.0, 0);
                bucketRGB[i] = (state != null) ? state.getResult() : Color.BLACK;
            }
        }
        // update pixels
        display.imageUpdate(x0, y0, bw, bh, bucketRGB);
    "
org.sunflow.core.renderer.SimpleRenderer.renderBucket,"    public void renderBucket(int bx, int by, IntersectionState istate) {
        // pixel sized extents
        int x0 = bx * 32;
        int y0 = by * 32;
        int bw = Math.min(32, imageWidth - x0);
        int bh = Math.min(32, imageHeight - y0);

        Color[] bucketRGB = new Color[bw * bh];

        for (int y = 0, i = 0; y < bh; y++) {
            for (int x = 0; x < bw; x++, i++) {
                ShadingState state = scene.getRadiance(istate, x0 + x, imageHeight - 1 - (y0 + y), 0.0, 0.0, 0.0, 0);
                bucketRGB[i] = (state != null) ? state.getResult() : Color.BLACK;
            }
        }
        // update pixels
        display.imageUpdate(x0, y0, bw, bh, bucketRGB);
    }

"
org.sunflow.core.renderer.BucketRenderer.prepare,"    public boolean prepare(Options options, Scene scene, int w, int h) {
        this.scene = scene;
        imageWidth = w;
        imageHeight = h;

        // fetch options
        bucketSize = options.getInt(""bucket.size"", bucketSize);
        bucketOrderName = options.getString(""bucket.order"", bucketOrderName);
        minAADepth = options.getInt(""aa.min"", minAADepth);
        maxAADepth = options.getInt(""aa.max"", maxAADepth);
        superSampling = options.getInt(""aa.samples"", superSampling);
        displayAA = options.getBoolean(""aa.display"", displayAA);
        jitter = options.getBoolean(""aa.jitter"", jitter);
        contrastThreshold = options.getFloat(""aa.contrast"", contrastThreshold);

        // limit bucket size and compute number of buckets in each direction
        bucketSize = MathUtils.clamp(bucketSize, 16, 512);
        int numBucketsX = (imageWidth + bucketSize - 1) / bucketSize;
        int numBucketsY = (imageHeight + bucketSize - 1) / bucketSize;
        bucketOrder = BucketOrderFactory.create(bucketOrderName);
        bucketCoords = bucketOrder.getBucketSequence(numBucketsX, numBucketsY);
        // validate AA options
        minAADepth = MathUtils.clamp(minAADepth, -4, 5);
        maxAADepth = MathUtils.clamp(maxAADepth, minAADepth, 5);
        superSampling = MathUtils.clamp(superSampling, 1, 256);
        invSuperSampling = 1.0 / superSampling;
        // compute AA stepping sizes
        subPixelSize = (maxAADepth > 0) ? (1 << maxAADepth) : 1;
        minStepSize = maxAADepth >= 0 ? 1 : 1 << (-maxAADepth);
        if (minAADepth == maxAADepth)
            maxStepSize = minStepSize;
        else
            maxStepSize = minAADepth > 0 ? 1 << minAADepth : subPixelSize << (-minAADepth);
        useJitter = jitter && maxAADepth > 0;
        // compute anti-aliasing contrast thresholds
        contrastThreshold = MathUtils.clamp(contrastThreshold, 0, 1);
        thresh = contrastThreshold * (float) Math.pow(2.0f, minAADepth);
        // read filter settings from scene
        filterName = options.getString(""filter"", filterName);
        filter = FilterFactory.get(filterName);
        // adjust filter
        if (filter == null) {
            UI.printWarning(Module.BCKT, ""Unrecognized filter type: \""%s\"" - defaulting to box"", filterName);
            filter = new BoxFilter(1);
            filterName = ""box"";
        }
        fhs = filter.getSize() * 0.5f;
        fs = (int) Math.ceil(subPixelSize * (fhs - 0.5f));

        // prepare QMC sampling
        sigma = QMC.generateSigmaTable(subPixelSize << 7);
        UI.printInfo(Module.BCKT, ""Bucket renderer settings:"");
        UI.printInfo(Module.BCKT, ""  * Resolution:         %dx%d"", imageWidth, imageHeight);
        UI.printInfo(Module.BCKT, ""  * Bucket size:        %d"", bucketSize);
        UI.printInfo(Module.BCKT, ""  * Number of buckets:  %dx%d"", numBucketsX, numBucketsY);
        int pixelMinAA = (minAADepth) < 0 ? -(1 << (-minAADepth)) : (1 << minAADepth);
        int pixelMaxAA = (maxAADepth) < 0 ? -(1 << (-maxAADepth)) : (1 << maxAADepth);
        UI.printInfo(Module.BCKT, ""  * Anti-aliasing:      [%dx%d] -> [%dx%d]"", pixelMinAA, pixelMinAA, pixelMaxAA, pixelMaxAA);
        UI.printInfo(Module.BCKT, ""  * Rays per sample:    %d"", superSampling);
        UI.printInfo(Module.BCKT, ""  * Subpixel jitter:    %s"", useJitter ? ""on"" : (jitter ? ""auto-off"" : ""off""));
        UI.printInfo(Module.BCKT, ""  * Contrast threshold: %.2f"", contrastThreshold);
        UI.printInfo(Module.BCKT, ""  * Filter type:        %s"", filterName);
        UI.printInfo(Module.BCKT, ""  * Filter size:        %.2f pixels"", filter.getSize());
        return true;
    }"
org.sunflow.core.renderer.BucketRenderer.render,"    public void render(Display display) {
        this.display = display;
        display.imageBegin(imageWidth, imageHeight, bucketSize);
        // set members variables
        bucketCounter = 0;
        // start task
        UI.taskStart(""Rendering"", 0, bucketCoords.length);
        Timer timer = new Timer();
        timer.start();
        Thread[] renderThreads = new Thread[scene.getThreads()];
        for (int i = 0; i < renderThreads.length; i++) {
            renderThreads[i] = new BucketThread(i);
            renderThreads[i].setPriority(scene.getThreadPriority());
            renderThreads[i].start();
        }
        for (int i = 0; i < renderThreads.length; i++) {
            try {
                renderThreads[i].join();
            } catch (InterruptedException e) {
                UI.printError(Module.BCKT, ""Bucket processing thread %d of %d was interrupted"", i + 1, renderThreads.length);
            }
        }
        UI.taskStop();
        timer.end();
        UI.printInfo(Module.BCKT, ""Render time: %s"", timer.toString());
        display.imageEnd();
    }"
org.sunflow.core.renderer.BucketRenderer.run,"        public void run() {
            IntersectionState istate = new IntersectionState();
            while (true) {
                int bx, by;
                synchronized (BucketRenderer.this) {
                    if (bucketCounter >= bucketCoords.length)
                        return;
                    UI.taskUpdate(bucketCounter);
                    bx = bucketCoords[bucketCounter + 0];
                    by = bucketCoords[bucketCounter + 1];
                    bucketCounter += 2;
                }
                renderBucket(display, bx, by, threadID, istate);
                if (UI.taskCanceled())
                    return;
            }
        }
    }

    private void renderBucket(Display display, int bx, int by, int threadID, IntersectionState istate) {
        // pixel sized extents
        int x0 = bx * bucketSize;
        int y0 = by * bucketSize;
        int bw = Math.min(bucketSize, imageWidth - x0);
        int bh = Math.min(bucketSize, imageHeight - y0);

        // prepare bucket
        display.imagePrepare(x0, y0, bw, bh, threadID);

        Color[] bucketRGB = new Color[bw * bh];

        // subpixel extents
        int sx0 = x0 * subPixelSize - fs;
        int sy0 = y0 * subPixelSize - fs;
        int sbw = bw * subPixelSize + fs * 2;
        int sbh = bh * subPixelSize + fs * 2;

        // round up to align with maximum step size
        sbw = (sbw + (maxStepSize - 1)) & (~(maxStepSize - 1));
        sbh = (sbh + (maxStepSize - 1)) & (~(maxStepSize - 1));
        // extra padding as needed
        if (maxStepSize > 1) {
            sbw++;
            sbh++;
        }
        // allocate bucket memory
        ImageSample[] samples = new ImageSample[sbw * sbh];
        // allocate samples and compute jitter offsets
        float invSubPixelSize = 1.0f / subPixelSize;
        for (int y = 0, index = 0; y < sbh; y++) {
            for (int x = 0; x < sbw; x++, index++) {
                int sx = sx0 + x;
                int sy = sy0 + y;
                int j = sx & (sigma.length - 1);
                int k = sy & (sigma.length - 1);
                int i = j * sigma.length + sigma[k];
                float dx = useJitter ? (float) sigma[k] / (float) sigma.length : 0.5f;
                float dy = useJitter ? (float) sigma[j] / (float) sigma.length : 0.5f;
                float rx = (sx + dx) * invSubPixelSize;
                float ry = (sy + dy) * invSubPixelSize;
                ry = imageHeight - ry - 1;
                samples[index] = new ImageSample(rx, ry, i);
            }
        }
        for (int x = 0; x < sbw - 1; x += maxStepSize)
            for (int y = 0; y < sbh - 1; y += maxStepSize)
                refineSamples(samples, sbw, x, y, maxStepSize, thresh, istate);
        if (dumpBuckets) {
            UI.printInfo(Module.BCKT, ""Dumping bucket [%d, %d] to file ..."", bx, by);
            Bitmap bitmap = new Bitmap(sbw, sbh, true);
            for (int y = sbh - 1, index = 0; y >= 0; y--)
                for (int x = 0; x < sbw; x++, index++)
                    bitmap.setPixel(x, y, samples[index].c.copy().toNonLinear());
            bitmap.save(String.format(""bucket_%04d_%04d.png"", bx, by));
        }
        if (displayAA) {
            // color coded image of what is visible
            float invArea = invSubPixelSize * invSubPixelSize;
            for (int y = 0, index = 0; y < bh; y++) {
                for (int x = 0; x < bw; x++, index++) {
                    int sampled = 0;
                    for (int i = 0; i < subPixelSize; i++) {
                        for (int j = 0; j < subPixelSize; j++) {
                            int sx = x * subPixelSize + fs + i;
                            int sy = y * subPixelSize + fs + j;
                            int s = sx + sy * sbw;
                            sampled += samples[s].sampled ? 1 : 0;
                        }
                    }
                    bucketRGB[index] = new Color(sampled * invArea);
                }
            }
        } else {
            // filter samples into pixels
            float cy = imageHeight - 1 - (y0 + 0.5f);
            for (int y = 0, index = 0; y < bh; y++, cy--) {
                float cx = x0 + 0.5f;
                for (int x = 0; x < bw; x++, index++, cx++) {
                    Color c = Color.black();
                    float weight = 0.0f;
                    for (int j = -fs, sy = y * subPixelSize; j <= fs; j++, sy++) {
                        for (int i = -fs, sx = x * subPixelSize, s = sx + sy * sbw; i <= fs; i++, sx++, s++) {
                            float dx = samples[s].rx - cx;
                            if (Math.abs(dx) > fhs)
                                continue;
                            float dy = samples[s].ry - cy;
                            if (Math.abs(dy) > fhs)
                                continue;
                            float f = filter.get(dx, dy);
                            c.madd(f, samples[s].c);
                            weight += f;
                        }
                    }
                    c.mul(1.0f / weight);
                    bucketRGB[index] = c;
                }
            }
        }
        // update pixels
        display.imageUpdate(x0, y0, bw, bh, bucketRGB);
    }

    private void computeSubPixel(ImageSample sample, IntersectionState istate) {
        float x = sample.rx;
        float y = sample.ry;
        double q0 = QMC.halton(1, sample.i);
        double q1 = QMC.halton(2, sample.i);
        double q2 = QMC.halton(3, sample.i);
        if (superSampling > 1) {
            // multiple sampling
            sample.add(scene.getRadiance(istate, x, y, q1, q2, q0, sample.i));
            for (int i = 1; i < superSampling; i++) {
                double time = QMC.mod1(q0 + i * invSuperSampling);
                double lensU = QMC.mod1(q1 + QMC.halton(0, i));
                double lensV = QMC.mod1(q2 + QMC.halton(1, i));
                sample.add(scene.getRadiance(istate, x, y, lensU, lensV, time, sample.i + i));
            }
            sample.scale((float) invSuperSampling);
        } else {
            // single sample
            sample.set(scene.getRadiance(istate, x, y, q1, q2, q0, sample.i));
        }
    }

    private void refineSamples(ImageSample[] samples, int sbw, int x, int y, int stepSize, float thresh, IntersectionState istate) {
        int dx = stepSize;
        int dy = stepSize * sbw;
        int i00 = x + y * sbw;
        ImageSample s00 = samples[i00];
        ImageSample s01 = samples[i00 + dy];
        ImageSample s10 = samples[i00 + dx];
        ImageSample s11 = samples[i00 + dx + dy];
        if (!s00.sampled)
            computeSubPixel(s00, istate);
        if (!s01.sampled)
            computeSubPixel(s01, istate);
        if (!s10.sampled)
            computeSubPixel(s10, istate);
        if (!s11.sampled)
            computeSubPixel(s11, istate);
        if (stepSize > minStepSize) {
            if (s00.isDifferent(s01, thresh) || s00.isDifferent(s10, thresh) || s00.isDifferent(s11, thresh) || s01.isDifferent(s11, thresh) || s10.isDifferent(s11, thresh) || s01.isDifferent(s10, thresh)) {
                stepSize >>= 1;
                thresh *= 2;
                refineSamples(samples, sbw, x, y, stepSize, thresh, istate);
                refineSamples(samples, sbw, x + stepSize, y, stepSize, thresh, istate);
                refineSamples(samples, sbw, x, y + stepSize, stepSize, thresh, istate);
                refineSamples(samples, sbw, x + stepSize, y + stepSize, stepSize, thresh, istate);
                return;
            }
        }

        // interpolate remaining samples
        float ds = 1.0f / stepSize;
        for (int i = 0; i <= stepSize; i++)
            for (int j = 0; j <= stepSize; j++)
                if (!samples[x + i + (y + j) * sbw].processed())
                    ImageSample.bilerp(samples[x + i + (y + j) * sbw], s00, s01, s10, s11, i * ds, j * ds);
    }

    private static class ImageSample {
        float rx, ry;
        int i, n;
        Color c;
        Instance instance;
        Shader shader;
        float nx, ny, nz;
        boolean sampled;

        ImageSample(float rx, float ry, int i) {
            this.rx = rx;
            this.ry = ry;
            this.i = i;
            n = 0;
            c = null;
            instance = null;
            shader = null;
            nx = ny = nz = 0;
            sampled = false;
        }

        void set(ShadingState state) {
            if (state == null)
                c = Color.BLACK;
            else {
                c = state.getResult();
                if (c.isNan())
                    UI.printError(Module.BCKT, ""NaN shading sample!"");
                else if (c.isInf())
                    UI.printError(Module.BCKT, ""Inf shading sample!"");
                shader = state.getShader();
                instance = state.getInstance();
                if (state.getNormal() != null) {
                    nx = state.getNormal().x;
                    ny = state.getNormal().y;
                    nz = state.getNormal().z;
                }
            }
            sampled = true;
        }

        void add(ShadingState state) {
            if (n == 0) {
                c = Color.black();
                sampled = true;
            }
            if (state != null) {
                c.add(state.getResult());
                if (state.getResult().isNan())
                    UI.printError(Module.BCKT, ""NaN shading sample!"");
                else if (state.getResult().isInf())
                    UI.printError(Module.BCKT, ""Inf shading sample!"");
            }
            n++;
        }

        void scale(float s) {
            c.mul(s);
        }

        boolean processed() {
            return c != null;
        }

        boolean isDifferent(ImageSample sample, float thresh) {
            if (instance != sample.instance)
                return true;
            if (shader != sample.shader)
                return true;
            if (shader == null)
                return false;
            if (Color.hasContrast(c, sample.c, thresh))
                return true;
            float dot = (nx * sample.nx + ny * sample.ny + nz * sample.nz);
            return dot < 0.9f;
        }

        static ImageSample bilerp(ImageSample result, ImageSample i00, ImageSample i01, ImageSample i10, ImageSample i11, float dx, float dy) {
            float k00 = (1.0f - dx) * (1.0f - dy);
            float k01 = (1.0f - dx) * dy;
            float k10 = dx * (1.0f - dy);
            float k11 = dx * dy;
            Color c00 = i00.c;
            Color c01 = i01.c;
            Color c10 = i10.c;
            Color c11 = i11.c;
            Color c = Color.mul(k00, c00);
            c.madd(k01, c01);
            c.madd(k10, c10);
            c.madd(k11, c11);
            result.c = c;
            return result;
        }
    "
org.sunflow.core.renderer.BucketRenderer.renderBucket,"    private void renderBucket(Display display, int bx, int by, int threadID, IntersectionState istate) {
        // pixel sized extents
        int x0 = bx * bucketSize;
        int y0 = by * bucketSize;
        int bw = Math.min(bucketSize, imageWidth - x0);
        int bh = Math.min(bucketSize, imageHeight - y0);

        // prepare bucket
        display.imagePrepare(x0, y0, bw, bh, threadID);

        Color[] bucketRGB = new Color[bw * bh];

        // subpixel extents
        int sx0 = x0 * subPixelSize - fs;
        int sy0 = y0 * subPixelSize - fs;
        int sbw = bw * subPixelSize + fs * 2;
        int sbh = bh * subPixelSize + fs * 2;

        // round up to align with maximum step size
        sbw = (sbw + (maxStepSize - 1)) & (~(maxStepSize - 1));
        sbh = (sbh + (maxStepSize - 1)) & (~(maxStepSize - 1));
        // extra padding as needed
        if (maxStepSize > 1) {
            sbw++;
            sbh++;
        }
        // allocate bucket memory
        ImageSample[] samples = new ImageSample[sbw * sbh];
        // allocate samples and compute jitter offsets
        float invSubPixelSize = 1.0f / subPixelSize;
        for (int y = 0, index = 0; y < sbh; y++) {
            for (int x = 0; x < sbw; x++, index++) {
                int sx = sx0 + x;
                int sy = sy0 + y;
                int j = sx & (sigma.length - 1);
                int k = sy & (sigma.length - 1);
                int i = j * sigma.length + sigma[k];
                float dx = useJitter ? (float) sigma[k] / (float) sigma.length : 0.5f;
                float dy = useJitter ? (float) sigma[j] / (float) sigma.length : 0.5f;
                float rx = (sx + dx) * invSubPixelSize;
                float ry = (sy + dy) * invSubPixelSize;
                ry = imageHeight - ry - 1;
                samples[index] = new ImageSample(rx, ry, i);
            }
        }
        for (int x = 0; x < sbw - 1; x += maxStepSize)
            for (int y = 0; y < sbh - 1; y += maxStepSize)
                refineSamples(samples, sbw, x, y, maxStepSize, thresh, istate);
        if (dumpBuckets) {
            UI.printInfo(Module.BCKT, ""Dumping bucket [%d, %d] to file ..."", bx, by);
            Bitmap bitmap = new Bitmap(sbw, sbh, true);
            for (int y = sbh - 1, index = 0; y >= 0; y--)
                for (int x = 0; x < sbw; x++, index++)
                    bitmap.setPixel(x, y, samples[index].c.copy().toNonLinear());
            bitmap.save(String.format(""bucket_%04d_%04d.png"", bx, by));
        }
        if (displayAA) {
            // color coded image of what is visible
            float invArea = invSubPixelSize * invSubPixelSize;
            for (int y = 0, index = 0; y < bh; y++) {
                for (int x = 0; x < bw; x++, index++) {
                    int sampled = 0;
                    for (int i = 0; i < subPixelSize; i++) {
                        for (int j = 0; j < subPixelSize; j++) {
                            int sx = x * subPixelSize + fs + i;
                            int sy = y * subPixelSize + fs + j;
                            int s = sx + sy * sbw;
                            sampled += samples[s].sampled ? 1 : 0;
                        }
                    }
                    bucketRGB[index] = new Color(sampled * invArea);
                }
            }
        } else {
            // filter samples into pixels
            float cy = imageHeight - 1 - (y0 + 0.5f);
            for (int y = 0, index = 0; y < bh; y++, cy--) {
                float cx = x0 + 0.5f;
                for (int x = 0; x < bw; x++, index++, cx++) {
                    Color c = Color.black();
                    float weight = 0.0f;
                    for (int j = -fs, sy = y * subPixelSize; j <= fs; j++, sy++) {
                        for (int i = -fs, sx = x * subPixelSize, s = sx + sy * sbw; i <= fs; i++, sx++, s++) {
                            float dx = samples[s].rx - cx;
                            if (Math.abs(dx) > fhs)
                                continue;
                            float dy = samples[s].ry - cy;
                            if (Math.abs(dy) > fhs)
                                continue;
                            float f = filter.get(dx, dy);
                            c.madd(f, samples[s].c);
                            weight += f;
                        }
                    }
                    c.mul(1.0f / weight);
                    bucketRGB[index] = c;
                }
            }
        }
        // update pixels
        display.imageUpdate(x0, y0, bw, bh, bucketRGB);
    }"
org.sunflow.core.renderer.BucketRenderer.computeSubPixel,"    private void computeSubPixel(ImageSample sample, IntersectionState istate) {
        float x = sample.rx;
        float y = sample.ry;
        double q0 = QMC.halton(1, sample.i);
        double q1 = QMC.halton(2, sample.i);
        double q2 = QMC.halton(3, sample.i);
        if (superSampling > 1) {
            // multiple sampling
            sample.add(scene.getRadiance(istate, x, y, q1, q2, q0, sample.i));
            for (int i = 1; i < superSampling; i++) {
                double time = QMC.mod1(q0 + i * invSuperSampling);
                double lensU = QMC.mod1(q1 + QMC.halton(0, i));
                double lensV = QMC.mod1(q2 + QMC.halton(1, i));
                sample.add(scene.getRadiance(istate, x, y, lensU, lensV, time, sample.i + i));
            }
            sample.scale((float) invSuperSampling);
        } else {
            // single sample
            sample.set(scene.getRadiance(istate, x, y, q1, q2, q0, sample.i));
        }
    }"
org.sunflow.core.renderer.BucketRenderer.refineSamples,"    private void refineSamples(ImageSample[] samples, int sbw, int x, int y, int stepSize, float thresh, IntersectionState istate) {
        int dx = stepSize;
        int dy = stepSize * sbw;
        int i00 = x + y * sbw;
        ImageSample s00 = samples[i00];
        ImageSample s01 = samples[i00 + dy];
        ImageSample s10 = samples[i00 + dx];
        ImageSample s11 = samples[i00 + dx + dy];
        if (!s00.sampled)
            computeSubPixel(s00, istate);
        if (!s01.sampled)
            computeSubPixel(s01, istate);
        if (!s10.sampled)
            computeSubPixel(s10, istate);
        if (!s11.sampled)
            computeSubPixel(s11, istate);
        if (stepSize > minStepSize) {
            if (s00.isDifferent(s01, thresh) || s00.isDifferent(s10, thresh) || s00.isDifferent(s11, thresh) || s01.isDifferent(s11, thresh) || s10.isDifferent(s11, thresh) || s01.isDifferent(s10, thresh)) {
                stepSize >>= 1;
                thresh *= 2;
                refineSamples(samples, sbw, x, y, stepSize, thresh, istate);
                refineSamples(samples, sbw, x + stepSize, y, stepSize, thresh, istate);
                refineSamples(samples, sbw, x, y + stepSize, stepSize, thresh, istate);
                refineSamples(samples, sbw, x + stepSize, y + stepSize, stepSize, thresh, istate);
                return;
            }
        }

        // interpolate remaining samples
        float ds = 1.0f / stepSize;
        for (int i = 0; i <= stepSize; i++)
            for (int j = 0; j <= stepSize; j++)
                if (!samples[x + i + (y + j) * sbw].processed())
                    ImageSample.bilerp(samples[x + i + (y + j) * sbw], s00, s01, s10, s11, i * ds, j * ds);
    }"
org.sunflow.core.renderer.BucketRenderer.set,"        void set(ShadingState state) {
            if (state == null)
                c = Color.BLACK;
            else {
                c = state.getResult();
                if (c.isNan())
                    UI.printError(Module.BCKT, ""NaN shading sample!"");
                else if (c.isInf())
                    UI.printError(Module.BCKT, ""Inf shading sample!"");
                shader = state.getShader();
                instance = state.getInstance();
                if (state.getNormal() != null) {
                    nx = state.getNormal().x;
                    ny = state.getNormal().y;
                    nz = state.getNormal().z;
                }
            }
            sampled = true;
        }"
org.sunflow.core.renderer.BucketRenderer.add,"        void add(ShadingState state) {
            if (n == 0) {
                c = Color.black();
                sampled = true;
            }
            if (state != null) {
                c.add(state.getResult());
                if (state.getResult().isNan())
                    UI.printError(Module.BCKT, ""NaN shading sample!"");
                else if (state.getResult().isInf())
                    UI.printError(Module.BCKT, ""Inf shading sample!"");
            }
            n++;
        }"
org.sunflow.core.renderer.BucketRenderer.scale,"        void scale(float s) {
            c.mul(s);
        }"
org.sunflow.core.renderer.BucketRenderer.processed,"        boolean processed() {
            return c != null;
        }"
org.sunflow.core.renderer.BucketRenderer.isDifferent,"        boolean isDifferent(ImageSample sample, float thresh) {
            if (instance != sample.instance)
                return true;
            if (shader != sample.shader)
                return true;
            if (shader == null)
                return false;
            if (Color.hasContrast(c, sample.c, thresh))
                return true;
            float dot = (nx * sample.nx + ny * sample.ny + nz * sample.nz);
            return dot < 0.9f;
        }"
org.sunflow.core.renderer.BucketRenderer.bilerp,"        static ImageSample bilerp(ImageSample result, ImageSample i00, ImageSample i01, ImageSample i10, ImageSample i11, float dx, float dy) {
            float k00 = (1.0f - dx) * (1.0f - dy);
            float k01 = (1.0f - dx) * dy;
            float k10 = dx * (1.0f - dy);
            float k11 = dx * dy;
            Color c00 = i00.c;
            Color c01 = i01.c;
            Color c10 = i10.c;
            Color c11 = i11.c;
            Color c = Color.mul(k00, c00);
            c.madd(k01, c01);
            c.madd(k10, c10);
            c.madd(k11, c11);
            result.c = c;
            return result;
        }
    "
org.sunflow.core.modifiers.NormalMapModifier.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        String filename = pl.getString(""texture"", null);
        if (filename != null)
            normalMap = TextureCache.getTexture(api.resolveTextureFilename(filename), true);
        return normalMap != null;
    }"
org.sunflow.core.modifiers.NormalMapModifier.modify,"    public void modify(ShadingState state) {
        // apply normal map
        state.getNormal().set(normalMap.getNormal(state.getUV().x, state.getUV().y, state.getBasis()));
        state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
    }
"
org.sunflow.core.modifiers.BumpMappingModifier.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        String filename = pl.getString(""texture"", null);
        if (filename != null)
            bumpTexture = TextureCache.getTexture(api.resolveTextureFilename(filename), true);
        scale = pl.getFloat(""scale"", scale);
        return bumpTexture != null;
    }"
org.sunflow.core.modifiers.BumpMappingModifier.modify,"    public void modify(ShadingState state) {
        // apply bump
        state.getNormal().set(bumpTexture.getBump(state.getUV().x, state.getUV().y, state.getBasis(), scale));
        state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
    }
"
org.sunflow.core.gi.IrradianceCacheGIEngine.init,"    public boolean init(Scene scene) {
        // check settings
        samples = Math.max(0, samples);
        minSpacing = Math.max(0.001f, minSpacing);
        maxSpacing = Math.max(0.001f, maxSpacing);
        // display settings
        UI.printInfo(Module.LIGHT, ""Irradiance cache settings:"");
        UI.printInfo(Module.LIGHT, ""  * Samples: %d"", samples);
        if (tolerance <= 0)
            UI.printInfo(Module.LIGHT, ""  * Tolerance: off"");
        else
            UI.printInfo(Module.LIGHT, ""  * Tolerance: %.3f"", tolerance);
        UI.printInfo(Module.LIGHT, ""  * Spacing: %.3f to %.3f"", minSpacing, maxSpacing);
        // prepare root node
        Vector3 ext = scene.getBounds().getExtents();
        root = new Node(scene.getBounds().getCenter(), 1.0001f * MathUtils.max(ext.x, ext.y, ext.z));
        // init global photon map
        return (globalPhotonMap != null) ? scene.calculatePhotons(globalPhotonMap, ""global"", 0) : true;
    }"
org.sunflow.core.gi.IrradianceCacheGIEngine.getGlobalRadiance,"    public Color getGlobalRadiance(ShadingState state) {
        if (globalPhotonMap == null) {
            if (state.getShader() != null)
                return state.getShader().getRadiance(state);
            else
                return Color.BLACK;
        } else
            return globalPhotonMap.getRadiance(state.getPoint(), state.getNormal());
    }"
org.sunflow.core.gi.IrradianceCacheGIEngine.getIrradiance,"    public Color getIrradiance(ShadingState state, Color diffuseReflectance) {
        if (samples <= 0)
            return Color.BLACK;
        if (state.getDiffuseDepth() > 0) {
            // do simple path tracing for additional bounces (single ray)
            float xi = (float) state.getRandom(0, 0, 1);
            float xj = (float) state.getRandom(0, 1, 1);
            float phi = (float) (xi * 2 * Math.PI);
            float cosPhi = (float) Math.cos(phi);
            float sinPhi = (float) Math.sin(phi);
            float sinTheta = (float) Math.sqrt(xj);
            float cosTheta = (float) Math.sqrt(1.0f - xj);
            Vector3 w = new Vector3();
            w.x = cosPhi * sinTheta;
            w.y = sinPhi * sinTheta;
            w.z = cosTheta;
            OrthoNormalBasis onb = state.getBasis();
            onb.transform(w);
            Ray r = new Ray(state.getPoint(), w);
            ShadingState temp = state.traceFinalGather(r, 0);
            return temp != null ? getGlobalRadiance(temp).copy().mul((float) Math.PI) : Color.BLACK;
        }
        rwl.readLock().lock();
        Color irr = getIrradiance(state.getPoint(), state.getNormal());
        rwl.readLock().unlock();
        if (irr == null) {
            // compute new sample
            irr = Color.black();
            OrthoNormalBasis onb = state.getBasis();
            float invR = 0;
            float minR = Float.POSITIVE_INFINITY;
            Vector3 w = new Vector3();
            for (int i = 0; i < samples; i++) {
                float xi = (float) state.getRandom(i, 0, samples);
                float xj = (float) state.getRandom(i, 1, samples);
                float phi = (float) (xi * 2 * Math.PI);
                float cosPhi = (float) Math.cos(phi);
                float sinPhi = (float) Math.sin(phi);
                float sinTheta = (float) Math.sqrt(xj);
                float cosTheta = (float) Math.sqrt(1.0f - xj);
                w.x = cosPhi * sinTheta;
                w.y = sinPhi * sinTheta;
                w.z = cosTheta;
                onb.transform(w);
                Ray r = new Ray(state.getPoint(), w);
                ShadingState temp = state.traceFinalGather(r, i);
                if (temp != null) {
                    minR = Math.min(r.getMax(), minR);
                    invR += 1.0f / r.getMax();
                    temp.getInstance().prepareShadingState(temp);
                    irr.add(getGlobalRadiance(temp));
                }
            }
            irr.mul((float) Math.PI / samples);
            invR = samples / invR;
            rwl.writeLock().lock();
            insert(state.getPoint(), state.getNormal(), invR, irr);
            rwl.writeLock().unlock();
            // view irr-cache points
            // irr = Color.YELLOW.copy().mul(1e6f);
        }
        return irr;
    }"
org.sunflow.core.gi.IrradianceCacheGIEngine.insert,"    private void insert(Point3 p, Vector3 n, float r0, Color irr) {
        if (tolerance <= 0)
            return;
        Node node = root;
        r0 = MathUtils.clamp(r0 * tolerance, minSpacing, maxSpacing) * invTolerance;
        if (root.isInside(p)) {
            while (node.sideLength >= (4.0 * r0 * tolerance)) {
                int k = 0;
                k |= (p.x > node.center.x) ? 1 : 0;
                k |= (p.y > node.center.y) ? 2 : 0;
                k |= (p.z > node.center.z) ? 4 : 0;
                if (node.children[k] == null) {
                    Point3 c = new Point3(node.center);
                    c.x += ((k & 1) == 0) ? -node.quadSideLength : node.quadSideLength;
                    c.y += ((k & 2) == 0) ? -node.quadSideLength : node.quadSideLength;
                    c.z += ((k & 4) == 0) ? -node.quadSideLength : node.quadSideLength;
                    node.children[k] = new Node(c, node.halfSideLength);
                }
                node = node.children[k];
            }
        }
        Sample s = new Sample(p, n, r0, irr);
        s.next = node.first;
        node.first = s;
    }"
org.sunflow.core.gi.IrradianceCacheGIEngine.getIrradiance,"    private Color getIrradiance(Point3 p, Vector3 n) {
        if (tolerance <= 0)
            return null;
        Sample x = new Sample(p, n);
        float w = root.find(x);
        return (x.irr == null) ? null : x.irr.mul(1.0f / w);
    }"
org.sunflow.core.gi.IrradianceCacheGIEngine.isInside,"        final boolean isInside(Point3 p) {
            return (Math.abs(p.x - center.x) < halfSideLength) && (Math.abs(p.y - center.y) < halfSideLength) && (Math.abs(p.z - center.z) < halfSideLength);
        }"
org.sunflow.core.gi.IrradianceCacheGIEngine.find,"        final float find(Sample x) {
            float weight = 0;
            for (Sample s = first; s != null; s = s.next) {
                float c2 = 1.0f - (x.nix * s.nix + x.niy * s.niy + x.niz * s.niz);
                float d2 = (x.pix - s.pix) * (x.pix - s.pix) + (x.piy - s.piy) * (x.piy - s.piy) + (x.piz - s.piz) * (x.piz - s.piz);
                if (c2 > tolerance * tolerance || d2 > maxSpacing * maxSpacing)
                    continue;
                float invWi = (float) (Math.sqrt(d2) * s.invR0 + Math.sqrt(Math.max(c2, 0)));
                if (invWi < tolerance || d2 < minSpacing * minSpacing) {
                    float wi = Math.min(1e10f, 1.0f / invWi);
                    if (x.irr != null)
                        x.irr.madd(wi, s.irr);
                    else
                        x.irr = s.irr.copy().mul(wi);
                    weight += wi;
                }
            }
            for (int i = 0; i < 8; i++)
                if ((children[i] != null) && (Math.abs(children[i].center.x - x.pix) <= halfSideLength) && (Math.abs(children[i].center.y - x.piy) <= halfSideLength) && (Math.abs(children[i].center.z - x.piz) <= halfSideLength))
                    weight += children[i].find(x);
            return weight;
        }
    "
org.sunflow.core.gi.InstantGI.getGlobalRadiance,"    public Color getGlobalRadiance(ShadingState state) {
        Point3 p = state.getPoint();
        Vector3 n = state.getNormal();
        int set = (int) (state.getRandom(0, 1, 1) * numSets);
        float maxAvgPow = 0;
        float minDist = 1;
        Color pow = null;
        for (PointLight vpl : virtualLights[set]) {
            maxAvgPow = Math.max(maxAvgPow, vpl.power.getAverage());
            if (Vector3.dot(n, vpl.n) > 0.9f) {
                float d = vpl.p.distanceToSquared(p);
                if (d < minDist) {
                    pow = vpl.power;
                    minDist = d;
                }
            }
        }
        return pow == null ? Color.BLACK : pow.copy().mul(1.0f / maxAvgPow);
    }"
org.sunflow.core.gi.InstantGI.init,"    public boolean init(Scene scene) {
        if (numSets < 1)
            numSets = 1;
        UI.printInfo(Module.LIGHT, ""Instant Global Illumination settings:"");
        UI.printInfo(Module.LIGHT, ""  * Samples:     %d"", numPhotons);
        UI.printInfo(Module.LIGHT, ""  * Sets:        %d"", numSets);
        UI.printInfo(Module.LIGHT, ""  * Bias bound:  %f"", c);
        UI.printInfo(Module.LIGHT, ""  * Bias rays:   %d"", numBias);
        virtualLights = new PointLight[numSets][];
        if (numPhotons > 0) {
            for (int i = 0, seed = 0; i < virtualLights.length; i++, seed += numPhotons) {
                PointLightStore map = new PointLightStore();
                if (!scene.calculatePhotons(map, ""virtual"", seed))
                    return false;
                virtualLights[i] = map.virtualLights.toArray(new PointLight[map.virtualLights.size()]);
                UI.printInfo(Module.LIGHT, ""Stored %d virtual point lights for set %d of %d"", virtualLights[i].length, i + 1, numSets);
            }
        } else {
            // create an empty array
            for (int i = 0; i < virtualLights.length; i++)
                virtualLights[i] = new PointLight[0];
        }
        return true;
    }"
org.sunflow.core.gi.InstantGI.getIrradiance,"    public Color getIrradiance(ShadingState state, Color diffuseReflectance) {
        float b = (float) Math.PI * c / diffuseReflectance.getMax();
        Color irr = Color.black();
        Point3 p = state.getPoint();
        Vector3 n = state.getNormal();
        int set = (int) (state.getRandom(0, 1, 1) * numSets);
        for (PointLight vpl : virtualLights[set]) {
            Ray r = new Ray(p, vpl.p);
            float dotNlD = -(r.dx * vpl.n.x + r.dy * vpl.n.y + r.dz * vpl.n.z);
            float dotND = r.dx * n.x + r.dy * n.y + r.dz * n.z;
            if (dotNlD > 0 && dotND > 0) {
                float r2 = r.getMax() * r.getMax();
                Color opacity = state.traceShadow(r);
                Color power = Color.blend(vpl.power, Color.BLACK, opacity);
                float g = (dotND * dotNlD) / r2;
                irr.madd(0.25f * Math.min(g, b), power);
            }
        }
        // bias compensation
        int nb = (state.getDiffuseDepth() == 0 || numBias <= 0) ? numBias : 1;
        if (nb <= 0)
            return irr;
        OrthoNormalBasis onb = state.getBasis();
        Vector3 w = new Vector3();
        float scale = (float) Math.PI / nb;
        for (int i = 0; i < nb; i++) {
            float xi = (float) state.getRandom(i, 0, nb);
            float xj = (float) state.getRandom(i, 1, nb);
            float phi = (float) (xi * 2 * Math.PI);
            float cosPhi = (float) Math.cos(phi);
            float sinPhi = (float) Math.sin(phi);
            float sinTheta = (float) Math.sqrt(xj);
            float cosTheta = (float) Math.sqrt(1.0f - xj);
            w.x = cosPhi * sinTheta;
            w.y = sinPhi * sinTheta;
            w.z = cosTheta;
            onb.transform(w);
            Ray r = new Ray(state.getPoint(), w);
            r.setMax((float) Math.sqrt(cosTheta / b));
            ShadingState temp = state.traceFinalGather(r, i);
            if (temp != null) {
                temp.getInstance().prepareShadingState(temp);
                if (temp.getShader() != null) {
                    float dist = temp.getRay().getMax();
                    float r2 = dist * dist;
                    float cosThetaY = -Vector3.dot(w, temp.getNormal());
                    if (cosThetaY > 0) {
                        float g = (cosTheta * cosThetaY) / r2;
                        // was this path accounted for yet?
                        if (g > b)
                            irr.madd(scale * (g - b) / g, temp.getShader().getRadiance(temp));
                    }
                }
            }
        }
        return irr;
    }"
org.sunflow.core.gi.InstantGI.numEmit,"        public int numEmit() {
            return numPhotons;
        }"
org.sunflow.core.gi.InstantGI.prepare,"        public void prepare(BoundingBox sceneBounds) {
        }"
org.sunflow.core.gi.InstantGI.store,"        public void store(ShadingState state, Vector3 dir, Color power, Color diffuse) {
            state.faceforward();
            PointLight vpl = new PointLight();
            vpl.p = state.getPoint();
            vpl.n = state.getNormal();
            vpl.power = power;
            synchronized (this) {
                virtualLights.add(vpl);
            }
        }"
org.sunflow.core.gi.InstantGI.init,"        public void init() {
        }"
org.sunflow.core.gi.InstantGI.allowDiffuseBounced,"        public boolean allowDiffuseBounced() {
            return true;
        }"
org.sunflow.core.gi.InstantGI.allowReflectionBounced,"        public boolean allowReflectionBounced() {
            return true;
        }"
org.sunflow.core.gi.InstantGI.allowRefractionBounced,"        public boolean allowRefractionBounced() {
            return true;
        }
    "
org.sunflow.core.gi.PathTracingGIEngine.requiresPhotons,"    public boolean requiresPhotons() {
        return false;
    }"
org.sunflow.core.gi.PathTracingGIEngine.init,"    public boolean init(Scene scene) {
        samples = Math.max(0, samples);
        UI.printInfo(Module.LIGHT, ""Path tracer settings:"");
        UI.printInfo(Module.LIGHT, ""  * Samples: %d"", samples);
        return true;
    }"
org.sunflow.core.gi.PathTracingGIEngine.getIrradiance,"    public Color getIrradiance(ShadingState state, Color diffuseReflectance) {
        if (samples <= 0)
            return Color.BLACK;
        // compute new sample
        Color irr = Color.black();
        OrthoNormalBasis onb = state.getBasis();
        Vector3 w = new Vector3();
        int n = state.getDiffuseDepth() == 0 ? samples : 1;
        for (int i = 0; i < n; i++) {
            float xi = (float) state.getRandom(i, 0, n);
            float xj = (float) state.getRandom(i, 1, n);
            float phi = (float) (xi * 2 * Math.PI);
            float cosPhi = (float) Math.cos(phi);
            float sinPhi = (float) Math.sin(phi);
            float sinTheta = (float) Math.sqrt(xj);
            float cosTheta = (float) Math.sqrt(1.0f - xj);
            w.x = cosPhi * sinTheta;
            w.y = sinPhi * sinTheta;
            w.z = cosTheta;
            onb.transform(w);
            ShadingState temp = state.traceFinalGather(new Ray(state.getPoint(), w), i);
            if (temp != null) {
                temp.getInstance().prepareShadingState(temp);
                if (temp.getShader() != null)
                    irr.add(temp.getShader().getRadiance(temp));
            }
        }
        irr.mul((float) Math.PI / n);
        return irr;
    }"
org.sunflow.core.gi.PathTracingGIEngine.getGlobalRadiance,"    public Color getGlobalRadiance(ShadingState state) {
        return Color.BLACK;
    }
"
org.sunflow.core.gi.AmbientOcclusionGIEngine.getGlobalRadiance,"    public Color getGlobalRadiance(ShadingState state) {
        return Color.BLACK;
    }"
org.sunflow.core.gi.AmbientOcclusionGIEngine.init,"    public boolean init(Scene scene) {
        return true;
    }"
org.sunflow.core.gi.AmbientOcclusionGIEngine.getIrradiance,"    public Color getIrradiance(ShadingState state, Color diffuseReflectance) {
        OrthoNormalBasis onb = state.getBasis();
        Vector3 w = new Vector3();
        Color result = Color.black();
        for (int i = 0; i < samples; i++) {
            float xi = (float) state.getRandom(i, 0, samples);
            float xj = (float) state.getRandom(i, 1, samples);
            float phi = (float) (2 * Math.PI * xi);
            float cosPhi = (float) Math.cos(phi);
            float sinPhi = (float) Math.sin(phi);
            float sinTheta = (float) Math.sqrt(xj);
            float cosTheta = (float) Math.sqrt(1.0f - xj);
            w.x = cosPhi * sinTheta;
            w.y = sinPhi * sinTheta;
            w.z = cosTheta;
            onb.transform(w);
            Ray r = new Ray(state.getPoint(), w);
            r.setMax(maxDist);
            result.add(Color.blend(bright, dark, state.traceShadow(r)));
        }
        return result.mul((float) Math.PI / samples);
    }
"
org.sunflow.core.gi.FakeGIEngine.getIrradiance,"    public Color getIrradiance(ShadingState state, Color diffuseReflectance) {
        float cosTheta = Vector3.dot(up, state.getNormal());
        float sin2 = (1 - cosTheta * cosTheta);
        float sine = sin2 > 0 ? (float) Math.sqrt(sin2) * 0.5f : 0;
        if (cosTheta > 0)
            return Color.blend(sky, ground, sine);
        else
            return Color.blend(ground, sky, sine);
    }"
org.sunflow.core.gi.FakeGIEngine.getGlobalRadiance,"    public Color getGlobalRadiance(ShadingState state) {
        return Color.BLACK;
    }"
org.sunflow.core.gi.FakeGIEngine.init,"    public boolean init(Scene scene) {
        return true;
    }
"
org.sunflow.core.gi.GIEngineFactory.create,"    public static final GIEngine create(Options options) {
        String type = options.getString(""gi.engine"", null);
        if (type == null || type.equals(""null"") || type.equals(""none""))
            return null;
        else if (type.equals(""ambocc""))
            return new AmbientOcclusionGIEngine(options);
        else if (type.equals(""fake""))
            return new FakeGIEngine(options);
        else if (type.equals(""igi""))
            return new InstantGI(options);
        else if (type.equals(""irr-cache""))
            return new IrradianceCacheGIEngine(options);
        else if (type.equals(""path""))
            return new PathTracingGIEngine(options);
        else {
            UI.printWarning(Module.LIGHT, ""Unrecognized GI engine type \""%s\"" - ignoring"", type);
            return null;
        }
    }
"
org.sunflow.core.camera.PinholeLens.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        // get parameters
        fov = pl.getFloat(""fov"", fov);
        aspect = pl.getFloat(""aspect"", aspect);
        update();
        return true;
    }"
org.sunflow.core.camera.PinholeLens.update,"    private void update() {
        au = (float) Math.tan(Math.toRadians(fov * 0.5f));
        av = au / aspect;
    }"
org.sunflow.core.camera.PinholeLens.getRay,"    public Ray getRay(float x, float y, int imageWidth, int imageHeight, double lensX, double lensY, double time) {
        float du = -au + ((2.0f * au * x) / (imageWidth - 1.0f));
        float dv = -av + ((2.0f * av * y) / (imageHeight - 1.0f));
        return new Ray(0, 0, 0, du, dv, -1);
    }
"
org.sunflow.core.camera.FisheyeLens.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.camera.FisheyeLens.getRay,"    public Ray getRay(float x, float y, int imageWidth, int imageHeight, double lensX, double lensY, double time) {
        float cx = 2.0f * x / imageWidth - 1.0f;
        float cy = 2.0f * y / imageHeight - 1.0f;
        float r2 = cx * cx + cy * cy;
        if (r2 > 1)
            return null; // outside the fisheye
        return new Ray(0, 0, 0, cx, cy, (float) -Math.sqrt(1 - r2));
    }
"
org.sunflow.core.camera.ThinLens.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        // get parameters
        fov = pl.getFloat(""fov"", fov);
        aspect = pl.getFloat(""aspect"", aspect);
        focusDistance = pl.getFloat(""focus.distance"", focusDistance);
        lensRadius = pl.getFloat(""lens.radius"", lensRadius);
        lensSides = pl.getInt(""lens.sides"", lensSides);
        lensRotation = pl.getFloat(""lens.rotation"", lensRotation);
        update();
        return true;
    }"
org.sunflow.core.camera.ThinLens.update,"    private void update() {
        au = (float) Math.tan(Math.toRadians(fov * 0.5f)) * focusDistance;
        av = au / aspect;
        lensRotationRadians = (float) Math.toRadians(lensRotation);
    }"
org.sunflow.core.camera.ThinLens.getRay,"    public Ray getRay(float x, float y, int imageWidth, int imageHeight, double lensX, double lensY, double time) {
        float du = -au + ((2.0f * au * x) / (imageWidth - 1.0f));
        float dv = -av + ((2.0f * av * y) / (imageHeight - 1.0f));

        float eyeX, eyeY;
        if (lensSides < 3) {
            double angle, r;
            // concentric map sampling
            double r1 = 2 * lensX - 1;
            double r2 = 2 * lensY - 1;
            if (r1 > -r2) {
                if (r1 > r2) {
                    r = r1;
                    angle = 0.25 * Math.PI * r2 / r1;
                } else {
                    r = r2;
                    angle = 0.25 * Math.PI * (2 - r1 / r2);
                }
            } else {
                if (r1 < r2) {
                    r = -r1;
                    angle = 0.25 * Math.PI * (4 + r2 / r1);
                } else {
                    r = -r2;
                    if (r2 != 0)
                        angle = 0.25 * Math.PI * (6 - r1 / r2);
                    else
                        angle = 0;
                }
            }
            r *= lensRadius;
            // point on the lens
            eyeX = (float) (Math.cos(angle) * r);
            eyeY = (float) (Math.sin(angle) * r);
        } else {
            // sample N-gon
            // FIXME: this could use concentric sampling
            lensY *= lensSides;
            float side = (int) lensY;
            float offs = (float) lensY - side;
            float dist = (float) Math.sqrt(lensX);
            float a0 = (float) (side * Math.PI * 2.0f / lensSides + lensRotationRadians);
            float a1 = (float) ((side + 1.0f) * Math.PI * 2.0f / lensSides + lensRotationRadians);
            eyeX = (float) ((Math.cos(a0) * (1.0f - offs) + Math.cos(a1) * offs) * dist);
            eyeY = (float) ((Math.sin(a0) * (1.0f - offs) + Math.sin(a1) * offs) * dist);
            eyeX *= lensRadius;
            eyeY *= lensRadius;
        }
        float eyeZ = 0;
        // point on the image plane
        float dirX = du;
        float dirY = dv;
        float dirZ = -focusDistance;
        // ray
        return new Ray(eyeX, eyeY, eyeZ, dirX - eyeX, dirY - eyeY, dirZ - eyeZ);
    }
"
org.sunflow.core.camera.SphericalLens.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.camera.SphericalLens.getRay,"    public Ray getRay(float x, float y, int imageWidth, int imageHeight, double lensX, double lensY, double time) {
        // Generate environment camera ray direction
        double theta = 2 * Math.PI * x / imageWidth + Math.PI / 2;
        double phi = Math.PI * (imageHeight - 1 - y) / imageHeight;
        return new Ray(0, 0, 0, (float) (Math.cos(theta) * Math.sin(phi)), (float) (Math.cos(phi)), (float) (Math.sin(theta) * Math.sin(phi)));
    }
"
org.sunflow.core.primitive.BanchoffSurface.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.primitive.BanchoffSurface.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox(1.5f);
        if (o2w != null)
            bounds = o2w.transform(bounds);
        return bounds;
    }"
org.sunflow.core.primitive.BanchoffSurface.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        return (i & 1) == 0 ? -1.5f : 1.5f;
    }"
org.sunflow.core.primitive.BanchoffSurface.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.primitive.BanchoffSurface.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        state.getRay().getPoint(state.getPoint());
        Instance parent = state.getInstance();
        Point3 n = parent.transformWorldToObject(state.getPoint());
        state.getNormal().set(n.x * (2 * n.x * n.x - 1), n.y * (2 * n.y * n.y - 1), n.z * (2 * n.z * n.z - 1));
        state.getNormal().normalize();
        state.setShader(parent.getShader(0));
        state.setModifier(parent.getModifier(0));
        // into world space
        Vector3 worldNormal = parent.transformNormalObjectToWorld(state.getNormal());
        state.getNormal().set(worldNormal);
        state.getNormal().normalize();
        state.getGeoNormal().set(state.getNormal());
        // create basis in world space
        state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
    }"
org.sunflow.core.primitive.BanchoffSurface.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        // intersect in local space
        float rd2x = r.dx * r.dx;
        float rd2y = r.dy * r.dy;
        float rd2z = r.dz * r.dz;
        float ro2x = r.ox * r.ox;
        float ro2y = r.oy * r.oy;
        float ro2z = r.oz * r.oz;
        // setup the quartic coefficients
        // some common terms could probably be shared across these
        double A = (rd2y * rd2y + rd2z * rd2z + rd2x * rd2x);
        double B = 4 * (r.oy * rd2y * r.dy + r.oz * r.dz * rd2z + r.ox * r.dx * rd2x);
        double C = (-rd2x - rd2y - rd2z + 6 * (ro2y * rd2y + ro2z * rd2z + ro2x * rd2x));
        double D = 2 * (2 * ro2z * r.oz * r.dz - r.oz * r.dz + 2 * ro2x * r.ox * r.dx + 2 * ro2y * r.oy * r.dy - r.ox * r.dx - r.oy * r.dy);
        double E = 3.0f / 8.0f + (-ro2z + ro2z * ro2z - ro2y + ro2y * ro2y - ro2x + ro2x * ro2x);
        // solve equation
        double[] t = Solvers.solveQuartic(A, B, C, D, E);
        if (t != null) {
            // early rejection
            if (t[0] >= r.getMax() || t[t.length - 1] <= r.getMin())
                return;
            // find first intersection in front of the ray
            for (int i = 0; i < t.length; i++) {
                if (t[i] > r.getMin()) {
                    r.setMax((float) t[i]);
                    state.setIntersection(0, 0, 0);
                    return;
                }
            }
        }
    }"
org.sunflow.core.primitive.BanchoffSurface.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.primitive.Torus.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        ri = pl.getFloat(""radiusInner"", ri);
        ro = pl.getFloat(""radiusOuter"", ro);
        ri2 = ri * ri;
        ro2 = ro * ro;
        return true;
    }"
org.sunflow.core.primitive.Torus.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox(-ro - ri, -ro - ri, -ri);
        bounds.include(ro + ri, ro + ri, ri);
        if (o2w != null)
            bounds = o2w.transform(bounds);
        return bounds;
    }"
org.sunflow.core.primitive.Torus.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        switch (i) {
            case 0:
            case 2:
                return -ro - ri;
            case 1:
            case 3:
                return ro + ri;
            case 4:
                return -ri;
            case 5:
                return ri;
            default:
                return 0;
        }
    }"
org.sunflow.core.primitive.Torus.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.primitive.Torus.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        state.getRay().getPoint(state.getPoint());
        Instance parent = state.getInstance();
        // get local point
        Point3 p = parent.transformWorldToObject(state.getPoint());
        // compute local normal
        float deriv = p.x * p.x + p.y * p.y + p.z * p.z - ri2 - ro2;
        state.getNormal().set(p.x * deriv, p.y * deriv, p.z * deriv + 2 * ro2 * p.z);
        state.getNormal().normalize();

        double phi = Math.asin(MathUtils.clamp(p.z / ri, -1, 1));
        double theta = Math.atan2(p.y, p.x);
        if (theta < 0)
            theta += 2 * Math.PI;
        state.getUV().x = (float) (theta / (2 * Math.PI));
        state.getUV().y = (float) ((phi + Math.PI / 2) / Math.PI);
        state.setShader(parent.getShader(0));
        state.setModifier(parent.getModifier(0));
        // into world space
        Vector3 worldNormal = parent.transformNormalObjectToWorld(state.getNormal());
        state.getNormal().set(worldNormal);
        state.getNormal().normalize();
        state.getGeoNormal().set(state.getNormal());
        // make basis in world space
        state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));

    }"
org.sunflow.core.primitive.Torus.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        // intersect in local space
        float rd2x = r.dx * r.dx;
        float rd2y = r.dy * r.dy;
        float rd2z = r.dz * r.dz;
        float ro2x = r.ox * r.ox;
        float ro2y = r.oy * r.oy;
        float ro2z = r.oz * r.oz;
        // compute some common factors
        double alpha = rd2x + rd2y + rd2z;
        double beta = 2 * (r.ox * r.dx + r.oy * r.dy + r.oz * r.dz);
        double gamma = (ro2x + ro2y + ro2z) - ri2 - ro2;
        // setup quartic coefficients
        double A = alpha * alpha;
        double B = 2 * alpha * beta;
        double C = beta * beta + 2 * alpha * gamma + 4 * ro2 * rd2z;
        double D = 2 * beta * gamma + 8 * ro2 * r.oz * r.dz;
        double E = gamma * gamma + 4 * ro2 * ro2z - 4 * ro2 * ri2;
        // solve equation
        double[] t = Solvers.solveQuartic(A, B, C, D, E);
        if (t != null) {
            // early rejection
            if (t[0] >= r.getMax() || t[t.length - 1] <= r.getMin())
                return;
            // find first intersection in front of the ray
            for (int i = 0; i < t.length; i++) {
                if (t[i] > r.getMin()) {
                    r.setMax((float) t[i]);
                    state.setIntersection(0, 0, 0);
                    return;
                }
            }
        }
    }"
org.sunflow.core.primitive.Torus.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.primitive.TriangleMesh.setSmallTriangles,"    public static void setSmallTriangles(boolean smallTriangles) {
        if (smallTriangles)
            UI.printInfo(Module.GEOM, ""Small trimesh mode: enabled"");
        else
            UI.printInfo(Module.GEOM, ""Small trimesh mode: disabled"");
        TriangleMesh.smallTriangles = smallTriangles;
    }"
org.sunflow.core.primitive.TriangleMesh.writeObj,"    public void writeObj(String filename) {
        try {
            FileWriter file = new FileWriter(filename);
            file.write(String.format(""o object\n""));
            for (int i = 0; i < points.length; i += 3)
                file.write(String.format(""v %g %g %g\n"", points[i], points[i + 1], points[i + 2]));
            file.write(""s off\n"");
            for (int i = 0; i < triangles.length; i += 3)
                file.write(String.format(""f %d %d %d\n"", triangles[i] + 1, triangles[i + 1] + 1, triangles[i + 2] + 1));
            file.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }"
org.sunflow.core.primitive.TriangleMesh.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        boolean updatedTopology = false;
        {
            int[] triangles = pl.getIntArray(""triangles"");
            if (triangles != null) {
                this.triangles = triangles;
                updatedTopology = true;
            }
        }
        if (triangles == null) {
            UI.printError(Module.GEOM, ""Unable to update mesh - triangle indices are missing"");
            return false;
        }
        if (triangles.length % 3 != 0)
            UI.printWarning(Module.GEOM, ""Triangle index data is not a multiple of 3 - triangles may be missing"");
        pl.setFaceCount(triangles.length / 3);
        {
            FloatParameter pointsP = pl.getPointArray(""points"");
            if (pointsP != null)
                if (pointsP.interp != InterpolationType.VERTEX)
                    UI.printError(Module.GEOM, ""Point interpolation type must be set to \""vertex\"" - was \""%s\"""", pointsP.interp.name().toLowerCase());
                else {
                    points = pointsP.data;
                    updatedTopology = true;
                }
        }
        if (points == null) {
            UI.printError(Module.GEOM, ""Unable to update mesh - vertices are missing"");
            return false;
        }
        pl.setVertexCount(points.length / 3);
        pl.setFaceVertexCount(3 * (triangles.length / 3));
        FloatParameter normals = pl.getVectorArray(""normals"");
        if (normals != null)
            this.normals = normals;
        FloatParameter uvs = pl.getTexCoordArray(""uvs"");
        if (uvs != null)
            this.uvs = uvs;
        int[] faceShaders = pl.getIntArray(""faceshaders"");
        if (faceShaders != null && faceShaders.length == triangles.length / 3) {
            this.faceShaders = new byte[faceShaders.length];
            for (int i = 0; i < faceShaders.length; i++) {
                int v = faceShaders[i];
                if (v > 255)
                    UI.printWarning(Module.GEOM, ""Shader index too large on triangle %d"", i);
                this.faceShaders[i] = (byte) (v & 0xFF);
            }
        }
        if (updatedTopology) {
            // create triangle acceleration structure
            init();
        }
        return true;
    }"
org.sunflow.core.primitive.TriangleMesh.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        int tri = 3 * primID;
        int a = 3 * triangles[tri + 0];
        int b = 3 * triangles[tri + 1];
        int c = 3 * triangles[tri + 2];
        int axis = i >>> 1;
        if ((i & 1) == 0)
            return MathUtils.min(points[a + axis], points[b + axis], points[c + axis]);
        else
            return MathUtils.max(points[a + axis], points[b + axis], points[c + axis]);
    }"
org.sunflow.core.primitive.TriangleMesh.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox();
        if (o2w == null) {
            for (int i = 0; i < points.length; i += 3)
                bounds.include(points[i], points[i + 1], points[i + 2]);
        } else {
            // transform vertices first
            for (int i = 0; i < points.length; i += 3) {
                float x = points[i];
                float y = points[i + 1];
                float z = points[i + 2];
                float wx = o2w.transformPX(x, y, z);
                float wy = o2w.transformPY(x, y, z);
                float wz = o2w.transformPZ(x, y, z);
                bounds.include(wx, wy, wz);
            }
        }
        return bounds;
    }"
org.sunflow.core.primitive.TriangleMesh.intersectPrimitiveRobust,"    public void intersectPrimitiveRobust(Ray r, int primID, IntersectionState state) {
        // ray-triangle intersection here
        int tri = 3 * primID;
        int a = 3 * triangles[tri + 0];
        int b = 3 * triangles[tri + 1];
        int c = 3 * triangles[tri + 2];
        final float[] stack = state.getRobustStack();
        for (int i = 0, i3 = 0; i < 3; i++, i3 += 3) {
            stack[i3 + 0] = points[a + i];
            stack[i3 + 1] = points[b + i];
            stack[i3 + 2] = points[c + i];
        }
        stack[9] = Float.POSITIVE_INFINITY;
        int stackpos = 0;
        float orgX = r.ox;
        float dirX = r.dx, invDirX = 1 / dirX;
        float orgY = r.oy;
        float dirY = r.dy, invDirY = 1 / dirY;
        float orgZ = r.oz;
        float dirZ = r.dz, invDirZ = 1 / dirZ;
        float t1, t2;
        float minx, maxx;
        float miny, maxy;
        float minz, maxz;
        float mint = r.getMin();
        float maxt = r.getMax();
        while (stackpos >= 0) {
            float intervalMin = mint;
            float intervalMax = maxt;
            float p0x = stack[stackpos + 0];
            float p1x = stack[stackpos + 1];
            float p2x = stack[stackpos + 2];
            t1 = ((minx = MathUtils.min(p0x, p1x, p2x)) - orgX) * invDirX;
            t2 = ((maxx = MathUtils.max(p0x, p1x, p2x)) - orgX) * invDirX;
            if (invDirX > 0) {
                if (t1 > intervalMin)
                    intervalMin = t1;
                if (t2 < intervalMax)
                    intervalMax = t2;
            } else {
                if (t2 > intervalMin)
                    intervalMin = t2;
                if (t1 < intervalMax)
                    intervalMax = t1;
            }
            if (intervalMin > intervalMax) {
                stackpos -= 10;
                continue;
            }
            float p0y = stack[stackpos + 3];
            float p1y = stack[stackpos + 4];
            float p2y = stack[stackpos + 5];
            t1 = ((miny = MathUtils.min(p0y, p1y, p2y)) - orgY) * invDirY;
            t2 = ((maxy = MathUtils.max(p0y, p1y, p2y)) - orgY) * invDirY;
            if (invDirY > 0) {
                if (t1 > intervalMin)
                    intervalMin = t1;
                if (t2 < intervalMax)
                    intervalMax = t2;
            } else {
                if (t2 > intervalMin)
                    intervalMin = t2;
                if (t1 < intervalMax)
                    intervalMax = t1;
            }
            if (intervalMin > intervalMax) {
                stackpos -= 10;
                continue;
            }
            float p0z = stack[stackpos + 6];
            float p1z = stack[stackpos + 7];
            float p2z = stack[stackpos + 8];
            t1 = ((minz = MathUtils.min(p0z, p1z, p2z)) - orgZ) * invDirZ;
            t2 = ((maxz = MathUtils.max(p0z, p1z, p2z)) - orgZ) * invDirZ;
            if (invDirZ > 0) {
                if (t1 > intervalMin)
                    intervalMin = t1;
                if (t2 < intervalMax)
                    intervalMax = t2;
            } else {
                if (t2 > intervalMin)
                    intervalMin = t2;
                if (t1 < intervalMax)
                    intervalMax = t1;
            }
            if (intervalMin > intervalMax) {
                stackpos -= 10;
                continue;
            }
            // intersection was found - keep going
            float size = (maxx - minx) + (maxy - miny) + (maxz - minz);
            if (Float.floatToRawIntBits(stack[stackpos + 9]) == Float.floatToRawIntBits(size)) {
                // L1 norm is 0, we are done
                r.setMax(intervalMin);
                triaccel[primID].intersectBox(r, p0x, p0y, p0z, primID, state);
                return; // safe to return, only one intersection per primitive
            }
            // not small enough yet - subdivide
            float p01x = (p0x + p1x) * 0.5f;
            float p01y = (p0y + p1y) * 0.5f;
            float p01z = (p0z + p1z) * 0.5f;

            float p12x = (p1x + p2x) * 0.5f;
            float p12y = (p1y + p2y) * 0.5f;
            float p12z = (p1z + p2z) * 0.5f;

            float p20x = (p2x + p0x) * 0.5f;
            float p20y = (p2y + p0y) * 0.5f;
            float p20z = (p2z + p0z) * 0.5f;

            // triangle 0
            stack[stackpos + 0] = p0x;
            stack[stackpos + 1] = p01x;
            stack[stackpos + 2] = p20x;
            stack[stackpos + 3] = p0y;
            stack[stackpos + 4] = p01y;
            stack[stackpos + 5] = p20y;
            stack[stackpos + 6] = p0z;
            stack[stackpos + 7] = p01z;
            stack[stackpos + 8] = p20z;
            stack[stackpos + 9] = size;
            stackpos += 10;
            // triangle 1
            stack[stackpos + 0] = p1x;
            stack[stackpos + 1] = p12x;
            stack[stackpos + 2] = p01x;
            stack[stackpos + 3] = p1y;
            stack[stackpos + 4] = p12y;
            stack[stackpos + 5] = p01y;
            stack[stackpos + 6] = p1z;
            stack[stackpos + 7] = p12z;
            stack[stackpos + 8] = p01z;
            stack[stackpos + 9] = size;
            stackpos += 10;
            // triangle 2
            stack[stackpos + 0] = p2x;
            stack[stackpos + 1] = p20x;
            stack[stackpos + 2] = p12x;
            stack[stackpos + 3] = p2y;
            stack[stackpos + 4] = p20y;
            stack[stackpos + 5] = p12y;
            stack[stackpos + 6] = p2z;
            stack[stackpos + 7] = p20z;
            stack[stackpos + 8] = p12z;
            stack[stackpos + 9] = size;
            stackpos += 10;
            // triangle 4
            stack[stackpos + 0] = p20x;
            stack[stackpos + 1] = p12x;
            stack[stackpos + 2] = p01x;
            stack[stackpos + 3] = p20y;
            stack[stackpos + 4] = p12y;
            stack[stackpos + 5] = p01y;
            stack[stackpos + 6] = p20z;
            stack[stackpos + 7] = p12z;
            stack[stackpos + 8] = p01z;
            stack[stackpos + 9] = size;
        }
    }"
org.sunflow.core.primitive.TriangleMesh.intersectTriangleKensler,"    private final void intersectTriangleKensler(Ray r, int primID, IntersectionState state) {
        int tri = 3 * primID;
        int a = 3 * triangles[tri + 0];
        int b = 3 * triangles[tri + 1];
        int c = 3 * triangles[tri + 2];
        float edge0x = points[b + 0] - points[a + 0];
        float edge0y = points[b + 1] - points[a + 1];
        float edge0z = points[b + 2] - points[a + 2];
        float edge1x = points[a + 0] - points[c + 0];
        float edge1y = points[a + 1] - points[c + 1];
        float edge1z = points[a + 2] - points[c + 2];
        float nx = edge0y * edge1z - edge0z * edge1y;
        float ny = edge0z * edge1x - edge0x * edge1z;
        float nz = edge0x * edge1y - edge0y * edge1x;
        float v = r.dot(nx, ny, nz);
        float iv = 1 / v;
        float edge2x = points[a + 0] - r.ox;
        float edge2y = points[a + 1] - r.oy;
        float edge2z = points[a + 2] - r.oz;
        float va = nx * edge2x + ny * edge2y + nz * edge2z;
        float t = iv * va;
        if (!r.isInside(t))
            return;
        float ix = edge2y * r.dz - edge2z * r.dy;
        float iy = edge2z * r.dx - edge2x * r.dz;
        float iz = edge2x * r.dy - edge2y * r.dx;
        float v1 = ix * edge1x + iy * edge1y + iz * edge1z;
        float beta = iv * v1;
        if (beta < 0)
            return;
        float v2 = ix * edge0x + iy * edge0y + iz * edge0z;
        if ((v1 + v2) * v > v * v)
            return;
        float gamma = iv * v2;
        if (gamma < 0)
            return;
        r.setMax(t);
        state.setIntersection(primID, beta, gamma);
    }"
org.sunflow.core.primitive.TriangleMesh.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        // alternative test -- disabled for now
        // intersectPrimitiveRobust(r, primID, state);

        if (triaccel != null) {
            // optional fast intersection method
            triaccel[primID].intersect(r, primID, state);
            return;
        }
        intersectTriangleKensler(r, primID, state);
    }"
org.sunflow.core.primitive.TriangleMesh.getNumPrimitives,"    public int getNumPrimitives() {
        return triangles.length / 3;
    }"
org.sunflow.core.primitive.TriangleMesh.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        Instance parent = state.getInstance();
        int primID = state.getPrimitiveID();
        float u = state.getU();
        float v = state.getV();
        float w = 1 - u - v;
        state.getRay().getPoint(state.getPoint());
        int tri = 3 * primID;
        int index0 = triangles[tri + 0];
        int index1 = triangles[tri + 1];
        int index2 = triangles[tri + 2];
        Point3 v0p = getPoint(index0);
        Point3 v1p = getPoint(index1);
        Point3 v2p = getPoint(index2);
        Vector3 ng = Point3.normal(v0p, v1p, v2p);
        ng = parent.transformNormalObjectToWorld(ng);
        ng.normalize();
        state.getGeoNormal().set(ng);
        switch (normals.interp) {
            case NONE:
            case FACE: {
                state.getNormal().set(ng);
                break;
            }
            case VERTEX: {
                int i30 = 3 * index0;
                int i31 = 3 * index1;
                int i32 = 3 * index2;
                float[] normals = this.normals.data;
                state.getNormal().x = w * normals[i30 + 0] + u * normals[i31 + 0] + v * normals[i32 + 0];
                state.getNormal().y = w * normals[i30 + 1] + u * normals[i31 + 1] + v * normals[i32 + 1];
                state.getNormal().z = w * normals[i30 + 2] + u * normals[i31 + 2] + v * normals[i32 + 2];
                state.getNormal().set(parent.transformNormalObjectToWorld(state.getNormal()));
                state.getNormal().normalize();
                break;
            }
            case FACEVARYING: {
                int idx = 3 * tri;
                float[] normals = this.normals.data;
                state.getNormal().x = w * normals[idx + 0] + u * normals[idx + 3] + v * normals[idx + 6];
                state.getNormal().y = w * normals[idx + 1] + u * normals[idx + 4] + v * normals[idx + 7];
                state.getNormal().z = w * normals[idx + 2] + u * normals[idx + 5] + v * normals[idx + 8];
                state.getNormal().set(parent.transformNormalObjectToWorld(state.getNormal()));
                state.getNormal().normalize();
                break;
            }
        }
        float uv00 = 0, uv01 = 0, uv10 = 0, uv11 = 0, uv20 = 0, uv21 = 0;
        switch (uvs.interp) {
            case NONE:
            case FACE: {
                state.getUV().x = 0;
                state.getUV().y = 0;
                break;
            }
            case VERTEX: {
                int i20 = 2 * index0;
                int i21 = 2 * index1;
                int i22 = 2 * index2;
                float[] uvs = this.uvs.data;
                uv00 = uvs[i20 + 0];
                uv01 = uvs[i20 + 1];
                uv10 = uvs[i21 + 0];
                uv11 = uvs[i21 + 1];
                uv20 = uvs[i22 + 0];
                uv21 = uvs[i22 + 1];
                break;
            }
            case FACEVARYING: {
                int idx = tri << 1;
                float[] uvs = this.uvs.data;
                uv00 = uvs[idx + 0];
                uv01 = uvs[idx + 1];
                uv10 = uvs[idx + 2];
                uv11 = uvs[idx + 3];
                uv20 = uvs[idx + 4];
                uv21 = uvs[idx + 5];
                break;
            }
        }
        if (uvs.interp != InterpolationType.NONE) {
            // get exact uv coords and compute tangent vectors
            state.getUV().x = w * uv00 + u * uv10 + v * uv20;
            state.getUV().y = w * uv01 + u * uv11 + v * uv21;
            float du1 = uv00 - uv20;
            float du2 = uv10 - uv20;
            float dv1 = uv01 - uv21;
            float dv2 = uv11 - uv21;
            Vector3 dp1 = Point3.sub(v0p, v2p, new Vector3()), dp2 = Point3.sub(v1p, v2p, new Vector3());
            float determinant = du1 * dv2 - dv1 * du2;
            if (determinant == 0.0f) {
                // create basis in world space
                state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
            } else {
                float invdet = 1.f / determinant;
                // Vector3 dpdu = new Vector3();
                // dpdu.x = (dv2 * dp1.x - dv1 * dp2.x) * invdet;
                // dpdu.y = (dv2 * dp1.y - dv1 * dp2.y) * invdet;
                // dpdu.z = (dv2 * dp1.z - dv1 * dp2.z) * invdet;
                Vector3 dpdv = new Vector3();
                dpdv.x = (-du2 * dp1.x + du1 * dp2.x) * invdet;
                dpdv.y = (-du2 * dp1.y + du1 * dp2.y) * invdet;
                dpdv.z = (-du2 * dp1.z + du1 * dp2.z) * invdet;
                dpdv = parent.transformVectorObjectToWorld(dpdv);
                // create basis in world space
                state.setBasis(OrthoNormalBasis.makeFromWV(state.getNormal(), dpdv));
            }
        } else
            state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
        int shaderIndex = faceShaders == null ? 0 : (faceShaders[primID] & 0xFF);
        state.setShader(parent.getShader(shaderIndex));
        state.setModifier(parent.getModifier(shaderIndex));
    }"
org.sunflow.core.primitive.TriangleMesh.init,"    public void init() {
        triaccel = null;
        int nt = getNumPrimitives();
        if (!smallTriangles) {
            // too many triangles? -- don't generate triaccel to save memory
            if (nt > 2000000) {
                UI.printWarning(Module.GEOM, ""TRI - Too many triangles -- triaccel generation skipped"");
                return;
            }
            triaccel = new WaldTriangle[nt];
            for (int i = 0; i < nt; i++)
                triaccel[i] = new WaldTriangle(this, i);
        }
    }"
org.sunflow.core.primitive.TriangleMesh.getPoint,"    protected Point3 getPoint(int i) {
        i *= 3;
        return new Point3(points[i], points[i + 1], points[i + 2]);
    }"
org.sunflow.core.primitive.TriangleMesh.getPoint,"    public void getPoint(int tri, int i, Point3 p) {
        int index = 3 * triangles[3 * tri + i];
        p.set(points[index], points[index + 1], points[index + 2]);
    }"
org.sunflow.core.primitive.TriangleMesh.intersectBox,"        void intersectBox(Ray r, float hx, float hy, float hz, int primID, IntersectionState state) {
            switch (k) {
                case 0: {
                    float hu = hy;
                    float hv = hz;
                    float u = hu * bnu + hv * bnv + bnd;
                    if (u < 0.0f)
                        u = 0;
                    float v = hu * cnu + hv * cnv + cnd;
                    if (v < 0.0f)
                        v = 0;
                    state.setIntersection(primID, u, v);
                    return;
                }
                case 1: {
                    float hu = hz;
                    float hv = hx;
                    float u = hu * bnu + hv * bnv + bnd;
                    if (u < 0.0f)
                        u = 0;
                    float v = hu * cnu + hv * cnv + cnd;
                    if (v < 0.0f)
                        v = 0;
                    state.setIntersection(primID, u, v);
                    return;
                }
                case 2: {
                    float hu = hx;
                    float hv = hy;
                    float u = hu * bnu + hv * bnv + bnd;
                    if (u < 0.0f)
                        u = 0;
                    float v = hu * cnu + hv * cnv + cnd;
                    if (v < 0.0f)
                        v = 0;
                    state.setIntersection(primID, u, v);
                    return;
                }
            }
        }"
org.sunflow.core.primitive.TriangleMesh.intersect,"        void intersect(Ray r, int primID, IntersectionState state) {
            switch (k) {
                case 0: {
                    float det = 1.0f / (r.dx + nu * r.dy + nv * r.dz);
                    float t = (nd - r.ox - nu * r.oy - nv * r.oz) * det;
                    if (!r.isInside(t))
                        return;
                    float hu = r.oy + t * r.dy;
                    float hv = r.oz + t * r.dz;
                    float u = hu * bnu + hv * bnv + bnd;
                    if (u < 0.0f)
                        return;
                    float v = hu * cnu + hv * cnv + cnd;
                    if (v < 0.0f)
                        return;
                    if (u + v > 1.0f)
                        return;
                    r.setMax(t);
                    state.setIntersection(primID, u, v);
                    return;
                }
                case 1: {
                    float det = 1.0f / (r.dy + nu * r.dz + nv * r.dx);
                    float t = (nd - r.oy - nu * r.oz - nv * r.ox) * det;
                    if (!r.isInside(t))
                        return;
                    float hu = r.oz + t * r.dz;
                    float hv = r.ox + t * r.dx;
                    float u = hu * bnu + hv * bnv + bnd;
                    if (u < 0.0f)
                        return;
                    float v = hu * cnu + hv * cnv + cnd;
                    if (v < 0.0f)
                        return;
                    if (u + v > 1.0f)
                        return;
                    r.setMax(t);
                    state.setIntersection(primID, u, v);
                    return;
                }
                case 2: {
                    float det = 1.0f / (r.dz + nu * r.dx + nv * r.dy);
                    float t = (nd - r.oz - nu * r.ox - nv * r.oy) * det;
                    if (!r.isInside(t))
                        return;
                    float hu = r.ox + t * r.dx;
                    float hv = r.oy + t * r.dy;
                    float u = hu * bnu + hv * bnv + bnd;
                    if (u < 0.0f)
                        return;
                    float v = hu * cnu + hv * cnv + cnd;
                    if (v < 0.0f)
                        return;
                    if (u + v > 1.0f)
                        return;
                    r.setMax(t);
                    state.setIntersection(primID, u, v);
                    return;
                }
            }
        }
    "
org.sunflow.core.primitive.TriangleMesh.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        switch (uvs.interp) {
            case NONE:
            case FACE:
                UI.printError(Module.GEOM, ""Cannot generate baking surface without texture coordinate data"");
                return null;
            default:
                return new BakingSurface();
        }
    }"
org.sunflow.core.primitive.TriangleMesh.getBakingPrimitives,"        public PrimitiveList getBakingPrimitives() {
            return null;
        }"
org.sunflow.core.primitive.TriangleMesh.getNumPrimitives,"        public int getNumPrimitives() {
            return TriangleMesh.this.getNumPrimitives();
        }"
org.sunflow.core.primitive.TriangleMesh.getPrimitiveBound,"        public float getPrimitiveBound(int primID, int i) {
            if (i > 3)
                return 0;
            switch (uvs.interp) {
                case NONE:
                case FACE:
                default: {
                    return 0;
                }
                case VERTEX: {
                    int tri = 3 * primID;
                    int index0 = triangles[tri + 0];
                    int index1 = triangles[tri + 1];
                    int index2 = triangles[tri + 2];
                    int i20 = 2 * index0;
                    int i21 = 2 * index1;
                    int i22 = 2 * index2;
                    float[] uvs = TriangleMesh.this.uvs.data;
                    switch (i) {
                        case 0:
                            return MathUtils.min(uvs[i20 + 0], uvs[i21 + 0], uvs[i22 + 0]);
                        case 1:
                            return MathUtils.max(uvs[i20 + 0], uvs[i21 + 0], uvs[i22 + 0]);
                        case 2:
                            return MathUtils.min(uvs[i20 + 1], uvs[i21 + 1], uvs[i22 + 1]);
                        case 3:
                            return MathUtils.max(uvs[i20 + 1], uvs[i21 + 1], uvs[i22 + 1]);
                        default:
                            return 0;
                    }
                }
                case FACEVARYING: {
                    int idx = 6 * primID;
                    float[] uvs = TriangleMesh.this.uvs.data;
                    switch (i) {
                        case 0:
                            return MathUtils.min(uvs[idx + 0], uvs[idx + 2], uvs[idx + 4]);
                        case 1:
                            return MathUtils.max(uvs[idx + 0], uvs[idx + 2], uvs[idx + 4]);
                        case 2:
                            return MathUtils.min(uvs[idx + 1], uvs[idx + 3], uvs[idx + 5]);
                        case 3:
                            return MathUtils.max(uvs[idx + 1], uvs[idx + 3], uvs[idx + 5]);
                        default:
                            return 0;
                    }
                }
            }
        }"
org.sunflow.core.primitive.TriangleMesh.getWorldBounds,"        public BoundingBox getWorldBounds(Matrix4 o2w) {
            BoundingBox bounds = new BoundingBox();
            if (o2w == null) {
                for (int i = 0; i < uvs.data.length; i += 2)
                    bounds.include(uvs.data[i], uvs.data[i + 1], 0);
            } else {
                // transform vertices first
                for (int i = 0; i < uvs.data.length; i += 2) {
                    float x = uvs.data[i];
                    float y = uvs.data[i + 1];
                    float wx = o2w.transformPX(x, y, 0);
                    float wy = o2w.transformPY(x, y, 0);
                    float wz = o2w.transformPZ(x, y, 0);
                    bounds.include(wx, wy, wz);
                }
            }
            return bounds;
        }"
org.sunflow.core.primitive.TriangleMesh.intersectPrimitive,"        public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
            float uv00 = 0, uv01 = 0, uv10 = 0, uv11 = 0, uv20 = 0, uv21 = 0;
            switch (uvs.interp) {
                case NONE:
                case FACE:
                default:
                    return;
                case VERTEX: {
                    int tri = 3 * primID;
                    int index0 = triangles[tri + 0];
                    int index1 = triangles[tri + 1];
                    int index2 = triangles[tri + 2];
                    int i20 = 2 * index0;
                    int i21 = 2 * index1;
                    int i22 = 2 * index2;
                    float[] uvs = TriangleMesh.this.uvs.data;
                    uv00 = uvs[i20 + 0];
                    uv01 = uvs[i20 + 1];
                    uv10 = uvs[i21 + 0];
                    uv11 = uvs[i21 + 1];
                    uv20 = uvs[i22 + 0];
                    uv21 = uvs[i22 + 1];
                    break;

                }
                case FACEVARYING: {
                    int idx = (3 * primID) << 1;
                    float[] uvs = TriangleMesh.this.uvs.data;
                    uv00 = uvs[idx + 0];
                    uv01 = uvs[idx + 1];
                    uv10 = uvs[idx + 2];
                    uv11 = uvs[idx + 3];
                    uv20 = uvs[idx + 4];
                    uv21 = uvs[idx + 5];
                    break;
                }
            }

            double edge1x = uv10 - uv00;
            double edge1y = uv11 - uv01;
            double edge2x = uv20 - uv00;
            double edge2y = uv21 - uv01;
            double pvecx = r.dy * 0 - r.dz * edge2y;
            double pvecy = r.dz * edge2x - r.dx * 0;
            double pvecz = r.dx * edge2y - r.dy * edge2x;
            double qvecx, qvecy, qvecz;
            double u, v;
            double det = edge1x * pvecx + edge1y * pvecy + 0 * pvecz;
            if (det > 0) {
                double tvecx = r.ox - uv00;
                double tvecy = r.oy - uv01;
                double tvecz = r.oz;
                u = (tvecx * pvecx + tvecy * pvecy + tvecz * pvecz);
                if (u < 0.0 || u > det)
                    return;
                qvecx = tvecy * 0 - tvecz * edge1y;
                qvecy = tvecz * edge1x - tvecx * 0;
                qvecz = tvecx * edge1y - tvecy * edge1x;
                v = (r.dx * qvecx + r.dy * qvecy + r.dz * qvecz);
                if (v < 0.0 || u + v > det)
                    return;
            } else if (det < 0) {
                double tvecx = r.ox - uv00;
                double tvecy = r.oy - uv01;
                double tvecz = r.oz;
                u = (tvecx * pvecx + tvecy * pvecy + tvecz * pvecz);
                if (u > 0.0 || u < det)
                    return;
                qvecx = tvecy * 0 - tvecz * edge1y;
                qvecy = tvecz * edge1x - tvecx * 0;
                qvecz = tvecx * edge1y - tvecy * edge1x;
                v = (r.dx * qvecx + r.dy * qvecy + r.dz * qvecz);
                if (v > 0.0 || u + v < det)
                    return;
            } else
                return;
            double inv_det = 1.0 / det;
            float t = (float) ((edge2x * qvecx + edge2y * qvecy + 0 * qvecz) * inv_det);
            if (r.isInside(t)) {
                r.setMax(t);
                state.setIntersection(primID, (float) (u * inv_det), (float) (v * inv_det));
            }
        }"
org.sunflow.core.primitive.TriangleMesh.prepareShadingState,"        public void prepareShadingState(ShadingState state) {
            state.init();
            Instance parent = state.getInstance();
            int primID = state.getPrimitiveID();
            float u = state.getU();
            float v = state.getV();
            float w = 1 - u - v;
            // state.getRay().getPoint(state.getPoint());
            int tri = 3 * primID;
            int index0 = triangles[tri + 0];
            int index1 = triangles[tri + 1];
            int index2 = triangles[tri + 2];
            Point3 v0p = getPoint(index0);
            Point3 v1p = getPoint(index1);
            Point3 v2p = getPoint(index2);

            // get object space point from barycentric coordinates
            state.getPoint().x = w * v0p.x + u * v1p.x + v * v2p.x;
            state.getPoint().y = w * v0p.y + u * v1p.y + v * v2p.y;
            state.getPoint().z = w * v0p.z + u * v1p.z + v * v2p.z;
            // move into world space
            state.getPoint().set(parent.transformObjectToWorld(state.getPoint()));

            Vector3 ng = Point3.normal(v0p, v1p, v2p);
            if (parent != null)
                ng = parent.transformNormalObjectToWorld(ng);
            ng.normalize();
            state.getGeoNormal().set(ng);
            switch (normals.interp) {
                case NONE:
                case FACE: {
                    state.getNormal().set(ng);
                    break;
                }
                case VERTEX: {
                    int i30 = 3 * index0;
                    int i31 = 3 * index1;
                    int i32 = 3 * index2;
                    float[] normals = TriangleMesh.this.normals.data;
                    state.getNormal().x = w * normals[i30 + 0] + u * normals[i31 + 0] + v * normals[i32 + 0];
                    state.getNormal().y = w * normals[i30 + 1] + u * normals[i31 + 1] + v * normals[i32 + 1];
                    state.getNormal().z = w * normals[i30 + 2] + u * normals[i31 + 2] + v * normals[i32 + 2];
                    if (parent != null)
                        state.getNormal().set(parent.transformNormalObjectToWorld(state.getNormal()));
                    state.getNormal().normalize();
                    break;
                }
                case FACEVARYING: {
                    int idx = 3 * tri;
                    float[] normals = TriangleMesh.this.normals.data;
                    state.getNormal().x = w * normals[idx + 0] + u * normals[idx + 3] + v * normals[idx + 6];
                    state.getNormal().y = w * normals[idx + 1] + u * normals[idx + 4] + v * normals[idx + 7];
                    state.getNormal().z = w * normals[idx + 2] + u * normals[idx + 5] + v * normals[idx + 8];
                    if (parent != null)
                        state.getNormal().set(parent.transformNormalObjectToWorld(state.getNormal()));
                    state.getNormal().normalize();
                    break;
                }
            }
            float uv00 = 0, uv01 = 0, uv10 = 0, uv11 = 0, uv20 = 0, uv21 = 0;
            switch (uvs.interp) {
                case NONE:
                case FACE: {
                    state.getUV().x = 0;
                    state.getUV().y = 0;
                    break;
                }
                case VERTEX: {
                    int i20 = 2 * index0;
                    int i21 = 2 * index1;
                    int i22 = 2 * index2;
                    float[] uvs = TriangleMesh.this.uvs.data;
                    uv00 = uvs[i20 + 0];
                    uv01 = uvs[i20 + 1];
                    uv10 = uvs[i21 + 0];
                    uv11 = uvs[i21 + 1];
                    uv20 = uvs[i22 + 0];
                    uv21 = uvs[i22 + 1];
                    break;
                }
                case FACEVARYING: {
                    int idx = tri << 1;
                    float[] uvs = TriangleMesh.this.uvs.data;
                    uv00 = uvs[idx + 0];
                    uv01 = uvs[idx + 1];
                    uv10 = uvs[idx + 2];
                    uv11 = uvs[idx + 3];
                    uv20 = uvs[idx + 4];
                    uv21 = uvs[idx + 5];
                    break;
                }
            }
            if (uvs.interp != InterpolationType.NONE) {
                // get exact uv coords and compute tangent vectors
                state.getUV().x = w * uv00 + u * uv10 + v * uv20;
                state.getUV().y = w * uv01 + u * uv11 + v * uv21;
                float du1 = uv00 - uv20;
                float du2 = uv10 - uv20;
                float dv1 = uv01 - uv21;
                float dv2 = uv11 - uv21;
                Vector3 dp1 = Point3.sub(v0p, v2p, new Vector3()), dp2 = Point3.sub(v1p, v2p, new Vector3());
                float determinant = du1 * dv2 - dv1 * du2;
                if (determinant == 0.0f) {
                    // create basis in world space
                    state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
                } else {
                    float invdet = 1.f / determinant;
                    // Vector3 dpdu = new Vector3();
                    // dpdu.x = (dv2 * dp1.x - dv1 * dp2.x) * invdet;
                    // dpdu.y = (dv2 * dp1.y - dv1 * dp2.y) * invdet;
                    // dpdu.z = (dv2 * dp1.z - dv1 * dp2.z) * invdet;
                    Vector3 dpdv = new Vector3();
                    dpdv.x = (-du2 * dp1.x + du1 * dp2.x) * invdet;
                    dpdv.y = (-du2 * dp1.y + du1 * dp2.y) * invdet;
                    dpdv.z = (-du2 * dp1.z + du1 * dp2.z) * invdet;
                    if (parent != null)
                        dpdv = parent.transformVectorObjectToWorld(dpdv);
                    // create basis in world space
                    state.setBasis(OrthoNormalBasis.makeFromWV(state.getNormal(), dpdv));
                }
            } else
                state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
            int shaderIndex = faceShaders == null ? 0 : (faceShaders[primID] & 0xFF);
            state.setShader(parent.getShader(shaderIndex));
        }"
org.sunflow.core.primitive.TriangleMesh.update,"        public boolean update(ParameterList pl, SunflowAPI api) {
            return true;
        }
    "
org.sunflow.core.primitive.QuadMesh.writeObj,"    public void writeObj(String filename) {
        try {
            FileWriter file = new FileWriter(filename);
            file.write(String.format(""o object\n""));
            for (int i = 0; i < points.length; i += 3)
                file.write(String.format(""v %g %g %g\n"", points[i], points[i + 1], points[i + 2]));
            file.write(""s off\n"");
            for (int i = 0; i < quads.length; i += 4)
                file.write(String.format(""f %d %d %d %d\n"", quads[i] + 1, quads[i + 1] + 1, quads[i + 2] + 1, quads[i + 3] + 1));
            file.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }"
org.sunflow.core.primitive.QuadMesh.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        {
            int[] quads = pl.getIntArray(""quads"");
            if (quads != null) {
                this.quads = quads;
            }
        }
        if (quads == null) {
            UI.printError(Module.GEOM, ""Unable to update mesh - quad indices are missing"");
            return false;
        }
        if (quads.length % 4 != 0)
            UI.printWarning(Module.GEOM, ""Quad index data is not a multiple of 4 - some quads may be missing"");
        pl.setFaceCount(quads.length / 4);
        {
            FloatParameter pointsP = pl.getPointArray(""points"");
            if (pointsP != null)
                if (pointsP.interp != InterpolationType.VERTEX)
                    UI.printError(Module.GEOM, ""Point interpolation type must be set to \""vertex\"" - was \""%s\"""", pointsP.interp.name().toLowerCase());
                else {
                    points = pointsP.data;
                }
        }
        if (points == null) {
            UI.printError(Module.GEOM, ""Unabled to update mesh - vertices are missing"");
            return false;
        }
        pl.setVertexCount(points.length / 3);
        pl.setFaceVertexCount(4 * (quads.length / 4));
        FloatParameter normals = pl.getVectorArray(""normals"");
        if (normals != null)
            this.normals = normals;
        FloatParameter uvs = pl.getTexCoordArray(""uvs"");
        if (uvs != null)
            this.uvs = uvs;
        int[] faceShaders = pl.getIntArray(""faceshaders"");
        if (faceShaders != null && faceShaders.length == quads.length / 4) {
            this.faceShaders = new byte[faceShaders.length];
            for (int i = 0; i < faceShaders.length; i++) {
                int v = faceShaders[i];
                if (v > 255)
                    UI.printWarning(Module.GEOM, ""Shader index too large on quad %d"", i);
                this.faceShaders[i] = (byte) (v & 0xFF);
            }
        }
        return true;
    }"
org.sunflow.core.primitive.QuadMesh.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        int quad = 4 * primID;
        int a = 3 * quads[quad + 0];
        int b = 3 * quads[quad + 1];
        int c = 3 * quads[quad + 2];
        int d = 3 * quads[quad + 3];
        int axis = i >>> 1;
        if ((i & 1) == 0)
            return MathUtils.min(points[a + axis], points[b + axis], points[c + axis], points[d + axis]);
        else
            return MathUtils.max(points[a + axis], points[b + axis], points[c + axis], points[d + axis]);
    }"
org.sunflow.core.primitive.QuadMesh.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox();
        if (o2w == null) {
            for (int i = 0; i < points.length; i += 3)
                bounds.include(points[i], points[i + 1], points[i + 2]);
        } else {
            // transform vertices first
            for (int i = 0; i < points.length; i += 3) {
                float x = points[i];
                float y = points[i + 1];
                float z = points[i + 2];
                float wx = o2w.transformPX(x, y, z);
                float wy = o2w.transformPY(x, y, z);
                float wz = o2w.transformPZ(x, y, z);
                bounds.include(wx, wy, wz);
            }
        }
        return bounds;
    }"
org.sunflow.core.primitive.QuadMesh.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        // ray/bilinear patch intersection adapted from ""Production Rendering:
        // Design and Implementation"" by Ian Stephenson (Ed.)
        int quad = 4 * primID;
        int p0 = 3 * quads[quad + 0];
        int p1 = 3 * quads[quad + 1];
        int p2 = 3 * quads[quad + 2];
        int p3 = 3 * quads[quad + 3];
        // transform patch into Hilbert space
        final float A[] = {
                points[p2 + 0] - points[p3 + 0] - points[p1 + 0] + points[p0 + 0],
                points[p2 + 1] - points[p3 + 1] - points[p1 + 1] + points[p0 + 1],
                points[p2 + 2] - points[p3 + 2] - points[p1 + 2] + points[p0 + 2] };
        final float B[] = { points[p1 + 0] - points[p0 + 0],
                points[p1 + 1] - points[p0 + 1],
                points[p1 + 2] - points[p0 + 2] };
        final float C[] = { points[p3 + 0] - points[p0 + 0],
                points[p3 + 1] - points[p0 + 1],
                points[p3 + 2] - points[p0 + 2] };
        final float R[] = { r.ox - points[p0 + 0], r.oy - points[p0 + 1],
                r.oz - points[p0 + 2] };
        final float Q[] = { r.dx, r.dy, r.dz };

        // pick major direction
        float absqx = Math.abs(r.dx);
        float absqy = Math.abs(r.dy);
        float absqz = Math.abs(r.dz);

        int X = 0, Y = 1, Z = 2;
        if (absqx > absqy && absqx > absqz) {
            // X = 0, Y = 1, Z = 2
        } else if (absqy > absqz) {
            // X = 1, Y = 0, Z = 2
            X = 1;
            Y = 0;
        } else {
            // X = 2, Y = 1, Z = 0
            X = 2;
            Z = 0;
        }

        float Cxz = C[X] * Q[Z] - C[Z] * Q[X];
        float Cyx = C[Y] * Q[X] - C[X] * Q[Y];
        float Czy = C[Z] * Q[Y] - C[Y] * Q[Z];
        float Rxz = R[X] * Q[Z] - R[Z] * Q[X];
        float Ryx = R[Y] * Q[X] - R[X] * Q[Y];
        float Rzy = R[Z] * Q[Y] - R[Y] * Q[Z];
        float Bxy = B[X] * Q[Y] - B[Y] * Q[X];
        float Byz = B[Y] * Q[Z] - B[Z] * Q[Y];
        float Bzx = B[Z] * Q[X] - B[X] * Q[Z];
        float a = A[X] * Byz + A[Y] * Bzx + A[Z] * Bxy;
        if (a == 0) {
            // setup for linear equation
            float b = B[X] * Czy + B[Y] * Cxz + B[Z] * Cyx;
            float c = C[X] * Rzy + C[Y] * Rxz + C[Z] * Ryx;
            float u = -c / b;
            if (u >= 0 && u <= 1) {
                float v = (u * Bxy + Ryx) / Cyx;
                if (v >= 0 && v <= 1) {
                    float t = (B[X] * u + C[X] * v - R[X]) / Q[X];
                    if (r.isInside(t)) {
                        r.setMax(t);
                        state.setIntersection(primID, u, v);
                    }
                }
            }
        } else {
            // setup for quadratic equation
            float b = A[X] * Rzy + A[Y] * Rxz + A[Z] * Ryx + B[X] * Czy + B[Y] * Cxz + B[Z] * Cyx;
            float c = C[X] * Rzy + C[Y] * Rxz + C[Z] * Ryx;
            float discrim = b * b - 4 * a * c;
            // reject trivial cases
            if (c * (a + b + c) > 0 && (discrim < 0 || a * c < 0 || b / a > 0 || b / a < -2))
                return;
            // solve quadratic
            float q = b > 0 ? -0.5f * (b + (float) Math.sqrt(discrim)) : -0.5f * (b - (float) Math.sqrt(discrim));
            // check first solution
            float Axy = A[X] * Q[Y] - A[Y] * Q[X];
            float u = q / a;
            if (u >= 0 && u <= 1) {
                float d = u * Axy - Cyx;
                float v = -(u * Bxy + Ryx) / d;
                if (v >= 0 && v <= 1) {
                    float t = (A[X] * u * v + B[X] * u + C[X] * v - R[X]) / Q[X];
                    if (r.isInside(t)) {
                        r.setMax(t);
                        state.setIntersection(primID, u, v);
                    }
                }
            }
            u = c / q;
            if (u >= 0 && u <= 1) {
                float d = u * Axy - Cyx;
                float v = -(u * Bxy + Ryx) / d;
                if (v >= 0 && v <= 1) {
                    float t = (A[X] * u * v + B[X] * u + C[X] * v - R[X]) / Q[X];
                    if (r.isInside(t)) {
                        r.setMax(t);
                        state.setIntersection(primID, u, v);
                    }
                }
            }
        }
    }"
org.sunflow.core.primitive.QuadMesh.getNumPrimitives,"    public int getNumPrimitives() {
        return quads.length / 4;
    }"
org.sunflow.core.primitive.QuadMesh.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        Instance parent = state.getInstance();
        int primID = state.getPrimitiveID();
        float u = state.getU();
        float v = state.getV();
        state.getRay().getPoint(state.getPoint());
        int quad = 4 * primID;
        int index0 = quads[quad + 0];
        int index1 = quads[quad + 1];
        int index2 = quads[quad + 2];
        int index3 = quads[quad + 3];
        Point3 v0p = getPoint(index0);
        Point3 v1p = getPoint(index1);
        Point3 v2p = getPoint(index2);
        Point3 v3p = getPoint(index2);
        float tanux = (1 - v) * (v1p.x - v0p.x) + v * (v2p.x - v3p.x);
        float tanuy = (1 - v) * (v1p.y - v0p.y) + v * (v2p.y - v3p.y);
        float tanuz = (1 - v) * (v1p.z - v0p.z) + v * (v2p.z - v3p.z);

        float tanvx = (1 - u) * (v3p.x - v0p.x) + u * (v2p.x - v1p.x);
        float tanvy = (1 - u) * (v3p.y - v0p.y) + u * (v2p.y - v1p.y);
        float tanvz = (1 - u) * (v3p.z - v0p.z) + u * (v2p.z - v1p.z);

        float nx = tanuy * tanvz - tanuz * tanvy;
        float ny = tanuz * tanvx - tanux * tanvz;
        float nz = tanux * tanvy - tanuy * tanvx;

        Vector3 ng = new Vector3(nx, ny, nz);
        ng = parent.transformNormalObjectToWorld(ng);
        ng.normalize();
        state.getGeoNormal().set(ng);

        float k00 = (1 - u) * (1 - v);
        float k10 = u * (1 - v);
        float k01 = (1 - u) * v;
        float k11 = u * v;

        switch (normals.interp) {
            case NONE:
            case FACE: {
                state.getNormal().set(ng);
                break;
            }
            case VERTEX: {
                int i30 = 3 * index0;
                int i31 = 3 * index1;
                int i32 = 3 * index2;
                int i33 = 3 * index3;
                float[] normals = this.normals.data;
                state.getNormal().x = k00 * normals[i30 + 0] + k10 * normals[i31 + 0] + k11 * normals[i32 + 0] + k01 * normals[i33 + 0];
                state.getNormal().y = k00 * normals[i30 + 1] + k10 * normals[i31 + 1] + k11 * normals[i32 + 1] + k01 * normals[i33 + 1];
                state.getNormal().z = k00 * normals[i30 + 2] + k10 * normals[i31 + 2] + k11 * normals[i32 + 2] + k01 * normals[i33 + 2];
                state.getNormal().set(parent.transformNormalObjectToWorld(state.getNormal()));
                state.getNormal().normalize();
                break;
            }
            case FACEVARYING: {
                int idx = 3 * quad;
                float[] normals = this.normals.data;
                state.getNormal().x = k00 * normals[idx + 0] + k10 * normals[idx + 3] + k11 * normals[idx + 6] + k01 * normals[idx + 9];
                state.getNormal().y = k00 * normals[idx + 1] + k10 * normals[idx + 4] + k11 * normals[idx + 7] + k01 * normals[idx + 10];
                state.getNormal().z = k00 * normals[idx + 2] + k10 * normals[idx + 5] + k11 * normals[idx + 8] + k01 * normals[idx + 11];
                state.getNormal().set(parent.transformNormalObjectToWorld(state.getNormal()));
                state.getNormal().normalize();
                break;
            }
        }
        float uv00 = 0, uv01 = 0, uv10 = 0, uv11 = 0, uv20 = 0, uv21 = 0, uv30 = 0, uv31 = 0;
        switch (uvs.interp) {
            case NONE:
            case FACE: {
                state.getUV().x = 0;
                state.getUV().y = 0;
                break;
            }
            case VERTEX: {
                int i20 = 2 * index0;
                int i21 = 2 * index1;
                int i22 = 2 * index2;
                int i23 = 2 * index3;
                float[] uvs = this.uvs.data;
                uv00 = uvs[i20 + 0];
                uv01 = uvs[i20 + 1];
                uv10 = uvs[i21 + 0];
                uv11 = uvs[i21 + 1];
                uv20 = uvs[i22 + 0];
                uv21 = uvs[i22 + 1];
                uv20 = uvs[i23 + 0];
                uv21 = uvs[i23 + 1];
                break;
            }
            case FACEVARYING: {
                int idx = quad << 1;
                float[] uvs = this.uvs.data;
                uv00 = uvs[idx + 0];
                uv01 = uvs[idx + 1];
                uv10 = uvs[idx + 2];
                uv11 = uvs[idx + 3];
                uv20 = uvs[idx + 4];
                uv21 = uvs[idx + 5];
                uv30 = uvs[idx + 6];
                uv31 = uvs[idx + 7];
                break;
            }
        }
        if (uvs.interp != InterpolationType.NONE) {
            // get exact uv coords and compute tangent vectors
            state.getUV().x = k00 * uv00 + k10 * uv10 + k11 * uv20 + k01 * uv30;
            state.getUV().y = k00 * uv01 + k10 * uv11 + k11 * uv21 + k01 * uv31;
            float du1 = uv00 - uv20;
            float du2 = uv10 - uv20;
            float dv1 = uv01 - uv21;
            float dv2 = uv11 - uv21;
            Vector3 dp1 = Point3.sub(v0p, v2p, new Vector3()), dp2 = Point3.sub(v1p, v2p, new Vector3());
            float determinant = du1 * dv2 - dv1 * du2;
            if (determinant == 0.0f) {
                // create basis in world space
                state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
            } else {
                float invdet = 1.f / determinant;
                // Vector3 dpdu = new Vector3();
                // dpdu.x = (dv2 * dp1.x - dv1 * dp2.x) * invdet;
                // dpdu.y = (dv2 * dp1.y - dv1 * dp2.y) * invdet;
                // dpdu.z = (dv2 * dp1.z - dv1 * dp2.z) * invdet;
                Vector3 dpdv = new Vector3();
                dpdv.x = (-du2 * dp1.x + du1 * dp2.x) * invdet;
                dpdv.y = (-du2 * dp1.y + du1 * dp2.y) * invdet;
                dpdv.z = (-du2 * dp1.z + du1 * dp2.z) * invdet;
                dpdv = parent.transformVectorObjectToWorld(dpdv);
                // create basis in world space
                state.setBasis(OrthoNormalBasis.makeFromWV(state.getNormal(), dpdv));
            }
        } else
            state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
        int shaderIndex = faceShaders == null ? 0 : (faceShaders[primID] & 0xFF);
        state.setShader(parent.getShader(shaderIndex));
        state.setModifier(parent.getModifier(shaderIndex));
    }"
org.sunflow.core.primitive.QuadMesh.getPoint,"    protected Point3 getPoint(int i) {
        i *= 3;
        return new Point3(points[i], points[i + 1], points[i + 2]);
    }"
org.sunflow.core.primitive.QuadMesh.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.primitive.CubeGrid.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        nx = pl.getInt(""resolutionX"", nx);
        ny = pl.getInt(""resolutionY"", ny);
        nz = pl.getInt(""resolutionZ"", nz);
        voxelwx = 2.0f / nx;
        voxelwy = 2.0f / ny;
        voxelwz = 2.0f / nz;
        invVoxelwx = 1 / voxelwx;
        invVoxelwy = 1 / voxelwy;
        invVoxelwz = 1 / voxelwz;
        return true;
    }"
org.sunflow.core.primitive.CubeGrid.inside,
org.sunflow.core.primitive.CubeGrid.getBounds,"    public BoundingBox getBounds() {
        return bounds;
    }"
org.sunflow.core.primitive.CubeGrid.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        state.getRay().getPoint(state.getPoint());
        Instance parent = state.getInstance();
        Vector3 normal;
        switch (state.getPrimitiveID()) {
            case 0:
                normal = new Vector3(-1, 0, 0);
                break;
            case 1:
                normal = new Vector3(1, 0, 0);
                break;
            case 2:
                normal = new Vector3(0, -1, 0);
                break;
            case 3:
                normal = new Vector3(0, 1, 0);
                break;
            case 4:
                normal = new Vector3(0, 0, -1);
                break;
            case 5:
                normal = new Vector3(0, 0, 1);
                break;
            default:
                normal = new Vector3(0, 0, 0);
                break;
        }
        state.getNormal().set(parent.transformNormalObjectToWorld(normal));
        state.getGeoNormal().set(state.getNormal());
        state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
        state.setShader(parent.getShader(0));
        state.setModifier(parent.getModifier(0));
    }"
org.sunflow.core.primitive.CubeGrid.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        float intervalMin = r.getMin();
        float intervalMax = r.getMax();
        float orgX = r.ox;
        float orgY = r.oy;
        float orgZ = r.oz;
        float dirX = r.dx, invDirX = 1 / dirX;
        float dirY = r.dy, invDirY = 1 / dirY;
        float dirZ = r.dz, invDirZ = 1 / dirZ;
        float t1, t2;
        t1 = (-1 - orgX) * invDirX;
        t2 = (+1 - orgX) * invDirX;
        int curr = -1;
        if (invDirX > 0) {
            if (t1 > intervalMin) {
                intervalMin = t1;
                curr = 0;
            }
            if (t2 < intervalMax)
                intervalMax = t2;
            if (intervalMin > intervalMax)
                return;
        } else {
            if (t2 > intervalMin) {
                intervalMin = t2;
                curr = 1;
            }
            if (t1 < intervalMax)
                intervalMax = t1;
            if (intervalMin > intervalMax)
                return;
        }
        t1 = (-1 - orgY) * invDirY;
        t2 = (+1 - orgY) * invDirY;
        if (invDirY > 0) {
            if (t1 > intervalMin) {
                intervalMin = t1;
                curr = 2;
            }
            if (t2 < intervalMax)
                intervalMax = t2;
            if (intervalMin > intervalMax)
                return;
        } else {
            if (t2 > intervalMin) {
                intervalMin = t2;
                curr = 3;
            }
            if (t1 < intervalMax)
                intervalMax = t1;
            if (intervalMin > intervalMax)
                return;
        }
        t1 = (-1 - orgZ) * invDirZ;
        t2 = (+1 - orgZ) * invDirZ;
        if (invDirZ > 0) {
            if (t1 > intervalMin) {
                intervalMin = t1;
                curr = 4;
            }
            if (t2 < intervalMax)
                intervalMax = t2;
            if (intervalMin > intervalMax)
                return;
        } else {
            if (t2 > intervalMin) {
                intervalMin = t2;
                curr = 5;
            }
            if (t1 < intervalMax)
                intervalMax = t1;
            if (intervalMin > intervalMax)
                return;
        }
        // box is hit at [intervalMin, intervalMax]
        orgX += intervalMin * dirX;
        orgY += intervalMin * dirY;
        orgZ += intervalMin * dirZ;
        // locate starting point inside the grid
        // and set up 3D-DDA vars
        int indxX, indxY, indxZ;
        int stepX, stepY, stepZ;
        int stopX, stopY, stopZ;
        float deltaX, deltaY, deltaZ;
        float tnextX, tnextY, tnextZ;
        // stepping factors along X
        indxX = (int) ((orgX + 1) * invVoxelwx);
        if (indxX < 0)
            indxX = 0;
        else if (indxX >= nx)
            indxX = nx - 1;
        if (Math.abs(dirX) < 1e-6f) {
            stepX = 0;
            stopX = indxX;
            deltaX = 0;
            tnextX = Float.POSITIVE_INFINITY;
        } else if (dirX > 0) {
            stepX = 1;
            stopX = nx;
            deltaX = voxelwx * invDirX;
            tnextX = intervalMin + ((indxX + 1) * voxelwx - 1 - orgX) * invDirX;
        } else {
            stepX = -1;
            stopX = -1;
            deltaX = -voxelwx * invDirX;
            tnextX = intervalMin + (indxX * voxelwx - 1 - orgX) * invDirX;
        }
        // stepping factors along Y
        indxY = (int) ((orgY + 1) * invVoxelwy);
        if (indxY < 0)
            indxY = 0;
        else if (indxY >= ny)
            indxY = ny - 1;
        if (Math.abs(dirY) < 1e-6f) {
            stepY = 0;
            stopY = indxY;
            deltaY = 0;
            tnextY = Float.POSITIVE_INFINITY;
        } else if (dirY > 0) {
            stepY = 1;
            stopY = ny;
            deltaY = voxelwy * invDirY;
            tnextY = intervalMin + ((indxY + 1) * voxelwy - 1 - orgY) * invDirY;
        } else {
            stepY = -1;
            stopY = -1;
            deltaY = -voxelwy * invDirY;
            tnextY = intervalMin + (indxY * voxelwy - 1 - orgY) * invDirY;
        }
        // stepping factors along Z
        indxZ = (int) ((orgZ + 1) * invVoxelwz);
        if (indxZ < 0)
            indxZ = 0;
        else if (indxZ >= nz)
            indxZ = nz - 1;
        if (Math.abs(dirZ) < 1e-6f) {
            stepZ = 0;
            stopZ = indxZ;
            deltaZ = 0;
            tnextZ = Float.POSITIVE_INFINITY;
        } else if (dirZ > 0) {
            stepZ = 1;
            stopZ = nz;
            deltaZ = voxelwz * invDirZ;
            tnextZ = intervalMin + ((indxZ + 1) * voxelwz - 1 - orgZ) * invDirZ;
        } else {
            stepZ = -1;
            stopZ = -1;
            deltaZ = -voxelwz * invDirZ;
            tnextZ = intervalMin + (indxZ * voxelwz - 1 - orgZ) * invDirZ;
        }
        // are we starting inside the cube
        boolean isInside = inside(indxX, indxY, indxZ) && bounds.contains(r.ox, r.oy, r.oz);
        // trace through the grid
        for (;;) {
            if (inside(indxX, indxY, indxZ) != isInside) {
                // we hit a boundary
                r.setMax(intervalMin);
                // if we are inside, the last bit needs to be flipped
                if (isInside)
                    curr ^= 1;
                state.setIntersection(curr, 0, 0);
                return;
            }
            if (tnextX < tnextY && tnextX < tnextZ) {
                curr = dirX > 0 ? 0 : 1;
                intervalMin = tnextX;
                if (intervalMin > intervalMax)
                    return;
                indxX += stepX;
                if (indxX == stopX)
                    return;
                tnextX += deltaX;
            } else if (tnextY < tnextZ) {
                curr = dirY > 0 ? 2 : 3;
                intervalMin = tnextY;
                if (intervalMin > intervalMax)
                    return;
                indxY += stepY;
                if (indxY == stopY)
                    return;
                tnextY += deltaY;
            } else {
                curr = dirZ > 0 ? 4 : 5;
                intervalMin = tnextZ;
                if (intervalMin > intervalMax)
                    return;
                indxZ += stepZ;
                if (indxZ == stopZ)
                    return;
                tnextZ += deltaZ;
            }
        }
    }"
org.sunflow.core.primitive.CubeGrid.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.primitive.CubeGrid.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        return ((i & 1) == 0) ? -1 : 1;
    }"
org.sunflow.core.primitive.CubeGrid.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        if (o2w == null)
            return bounds;
        return o2w.transform(bounds);
    }
"
org.sunflow.core.primitive.Sphere.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.primitive.Sphere.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox(1);
        if (o2w != null)
            bounds = o2w.transform(bounds);
        return bounds;
    }"
org.sunflow.core.primitive.Sphere.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        return (i & 1) == 0 ? -1 : 1;
    }"
org.sunflow.core.primitive.Sphere.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.primitive.Sphere.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        state.getRay().getPoint(state.getPoint());
        Instance parent = state.getInstance();
        Point3 localPoint = parent.transformWorldToObject(state.getPoint());
        state.getNormal().set(localPoint.x, localPoint.y, localPoint.z);
        state.getNormal().normalize();

        float phi = (float) Math.atan2(state.getNormal().y, state.getNormal().x);
        if (phi < 0)
            phi += 2 * Math.PI;
        float theta = (float) Math.acos(state.getNormal().z);
        state.getUV().y = theta / (float) Math.PI;
        state.getUV().x = phi / (float) (2 * Math.PI);
        Vector3 v = new Vector3();
        v.x = -2 * (float) Math.PI * state.getNormal().y;
        v.y = 2 * (float) Math.PI * state.getNormal().x;
        v.z = 0;
        state.setShader(parent.getShader(0));
        state.setModifier(parent.getModifier(0));
        // into world space
        Vector3 worldNormal = parent.transformNormalObjectToWorld(state.getNormal());
        v = parent.transformVectorObjectToWorld(v);
        state.getNormal().set(worldNormal);
        state.getNormal().normalize();
        state.getGeoNormal().set(state.getNormal());
        // compute basis in world space
        state.setBasis(OrthoNormalBasis.makeFromWV(state.getNormal(), v));

    }"
org.sunflow.core.primitive.Sphere.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        // intersect in local space
        float qa = r.dx * r.dx + r.dy * r.dy + r.dz * r.dz;
        float qb = 2 * ((r.dx * r.ox) + (r.dy * r.oy) + (r.dz * r.oz));
        float qc = ((r.ox * r.ox) + (r.oy * r.oy) + (r.oz * r.oz)) - 1;
        double[] t = Solvers.solveQuadric(qa, qb, qc);
        if (t != null) {
            // early rejection
            if (t[0] >= r.getMax() || t[1] <= r.getMin())
                return;
            if (t[0] > r.getMin())
                r.setMax((float) t[0]);
            else
                r.setMax((float) t[1]);
            state.setIntersection(0, 0, 0);
        }
    }"
org.sunflow.core.primitive.Sphere.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.primitive.Background.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.primitive.Background.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        if (state.getDepth() == 0)
            state.setShader(state.getInstance().getShader(0));
    }"
org.sunflow.core.primitive.Background.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.primitive.Background.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        return 0;
    }"
org.sunflow.core.primitive.Background.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        return null;
    }"
org.sunflow.core.primitive.Background.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        if (r.getMax() == Float.POSITIVE_INFINITY)
            state.setIntersection(0, 0, 0);
    }"
org.sunflow.core.primitive.Background.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.primitive.Box.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        FloatParameter pts = pl.getPointArray(""points"");
        if (pts != null) {
            BoundingBox bounds = new BoundingBox();
            for (int i = 0; i < pts.data.length; i += 3)
                bounds.include(pts.data[i], pts.data[i + 1], pts.data[i + 2]);
            // cube extents
            minX = bounds.getMinimum().x;
            minY = bounds.getMinimum().y;
            minZ = bounds.getMinimum().z;
            maxX = bounds.getMaximum().x;
            maxY = bounds.getMaximum().y;
            maxZ = bounds.getMaximum().z;
        }
        return true;
    }"
org.sunflow.core.primitive.Box.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        state.getRay().getPoint(state.getPoint());
        int n = state.getPrimitiveID();
        switch (n) {
            case 0:
                state.getNormal().set(new Vector3(1, 0, 0));
                break;
            case 1:
                state.getNormal().set(new Vector3(-1, 0, 0));
                break;
            case 2:
                state.getNormal().set(new Vector3(0, 1, 0));
                break;
            case 3:
                state.getNormal().set(new Vector3(0, -1, 0));
                break;
            case 4:
                state.getNormal().set(new Vector3(0, 0, 1));
                break;
            case 5:
                state.getNormal().set(new Vector3(0, 0, -1));
                break;
            default:
                state.getNormal().set(new Vector3(0, 0, 0));
                break;
        }
        state.getGeoNormal().set(state.getNormal());
        state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
        state.setShader(state.getInstance().getShader(0));
        state.setModifier(state.getInstance().getModifier(0));
    }"
org.sunflow.core.primitive.Box.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        float intervalMin = Float.NEGATIVE_INFINITY;
        float intervalMax = Float.POSITIVE_INFINITY;
        float orgX = r.ox;
        float invDirX = 1 / r.dx;
        float t1, t2;
        t1 = (minX - orgX) * invDirX;
        t2 = (maxX - orgX) * invDirX;
        int sideIn = -1, sideOut = -1;
        if (invDirX > 0) {
            if (t1 > intervalMin) {
                intervalMin = t1;
                sideIn = 0;
            }
            if (t2 < intervalMax) {
                intervalMax = t2;
                sideOut = 1;
            }
        } else {
            if (t2 > intervalMin) {
                intervalMin = t2;
                sideIn = 1;
            }
            if (t1 < intervalMax) {
                intervalMax = t1;
                sideOut = 0;
            }
        }
        if (intervalMin > intervalMax)
            return;
        float orgY = r.oy;
        float invDirY = 1 / r.dy;
        t1 = (minY - orgY) * invDirY;
        t2 = (maxY - orgY) * invDirY;
        if (invDirY > 0) {
            if (t1 > intervalMin) {
                intervalMin = t1;
                sideIn = 2;
            }
            if (t2 < intervalMax) {
                intervalMax = t2;
                sideOut = 3;
            }
        } else {
            if (t2 > intervalMin) {
                intervalMin = t2;
                sideIn = 3;
            }
            if (t1 < intervalMax) {
                intervalMax = t1;
                sideOut = 2;
            }
        }
        if (intervalMin > intervalMax)
            return;
        float orgZ = r.oz;
        float invDirZ = 1 / r.dz;
        t1 = (minZ - orgZ) * invDirZ; // no front wall
        t2 = (maxZ - orgZ) * invDirZ;
        if (invDirZ > 0) {
            if (t1 > intervalMin) {
                intervalMin = t1;
                sideIn = 4;
            }
            if (t2 < intervalMax) {
                intervalMax = t2;
                sideOut = 5;
            }
        } else {
            if (t2 > intervalMin) {
                intervalMin = t2;
                sideIn = 5;
            }
            if (t1 < intervalMax) {
                intervalMax = t1;
                sideOut = 4;
            }
        }
        if (intervalMin > intervalMax)
            return;
        if (r.isInside(intervalMin)) {
            r.setMax(intervalMin);
            state.setIntersection(sideIn, 0, 0);
        } else if (r.isInside(intervalMax)) {
            r.setMax(intervalMax);
            state.setIntersection(sideOut, 0, 0);
        }
    }"
org.sunflow.core.primitive.Box.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.primitive.Box.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        switch (i) {
            case 0:
                return minX;
            case 1:
                return maxX;
            case 2:
                return minY;
            case 3:
                return maxY;
            case 4:
                return minZ;
            case 5:
                return maxZ;
            default:
                return 0;
        }
    }"
org.sunflow.core.primitive.Box.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox(minX, minY, minZ);
        bounds.include(maxX, maxY, maxZ);
        if (o2w == null)
            return bounds;
        return o2w.transform(bounds);
    }"
org.sunflow.core.primitive.Box.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.primitive.CornellBox.updateGeometry,"    private void updateGeometry(Point3 c0, Point3 c1) {
        // figure out cube extents
        lightBounds = new BoundingBox(c0);
        lightBounds.include(c1);

        // cube extents
        minX = lightBounds.getMinimum().x;
        minY = lightBounds.getMinimum().y;
        minZ = lightBounds.getMinimum().z;
        maxX = lightBounds.getMaximum().x;
        maxY = lightBounds.getMaximum().y;
        maxZ = lightBounds.getMaximum().z;

        // work around epsilon problems for light test
        lightBounds.enlargeUlps();

        // light source geometry
        lxmin = maxX / 3 + 2 * minX / 3;
        lxmax = minX / 3 + 2 * maxX / 3;
        lymin = maxY / 3 + 2 * minY / 3;
        lymax = minY / 3 + 2 * maxY / 3;
        area = (lxmax - lxmin) * (lymax - lymin);
    }"
org.sunflow.core.primitive.CornellBox.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        Point3 corner0 = pl.getPoint(""corner0"", null);
        Point3 corner1 = pl.getPoint(""corner1"", null);
        if (corner0 != null && corner1 != null) {
            updateGeometry(corner0, corner1);
        }

        // shader colors
        left = pl.getColor(""leftColor"", left);
        right = pl.getColor(""rightColor"", right);
        top = pl.getColor(""topColor"", top);
        bottom = pl.getColor(""bottomColor"", bottom);
        back = pl.getColor(""backColor"", back);

        // light
        radiance = pl.getColor(""radiance"", radiance);
        samples = pl.getInt(""samples"", samples);
        return true;
    }"
org.sunflow.core.primitive.CornellBox.init,"    public void init(String name, SunflowAPI api) {
        // register with the api properly
        api.geometry(name, this);
        api.shader(name + "".shader"", this);
        api.parameter(""shaders"", name + "".shader"");
        api.instance(name + "".instance"", name);
        api.light(name + "".light"", this);
    }"
org.sunflow.core.primitive.CornellBox.getBounds,"    public BoundingBox getBounds() {
        return lightBounds;
    }"
org.sunflow.core.primitive.CornellBox.getBound,"    public float getBound(int i) {
        switch (i) {
            case 0:
                return minX;
            case 1:
                return maxX;
            case 2:
                return minY;
            case 3:
                return maxY;
            case 4:
                return minZ;
            case 5:
                return maxZ;
            default:
                return 0;
        }
    }"
org.sunflow.core.primitive.CornellBox.intersects,"    public boolean intersects(BoundingBox box) {
        // this could be optimized
        BoundingBox b = new BoundingBox();
        b.include(new Point3(minX, minY, minZ));
        b.include(new Point3(maxX, maxY, maxZ));
        if (b.intersects(box)) {
            // the box is overlapping or enclosed
            if (!b.contains(new Point3(box.getMinimum().x, box.getMinimum().y, box.getMinimum().z)))
                return true;
            if (!b.contains(new Point3(box.getMinimum().x, box.getMinimum().y, box.getMaximum().z)))
                return true;
            if (!b.contains(new Point3(box.getMinimum().x, box.getMaximum().y, box.getMinimum().z)))
                return true;
            if (!b.contains(new Point3(box.getMinimum().x, box.getMaximum().y, box.getMaximum().z)))
                return true;
            if (!b.contains(new Point3(box.getMaximum().x, box.getMinimum().y, box.getMinimum().z)))
                return true;
            if (!b.contains(new Point3(box.getMaximum().x, box.getMinimum().y, box.getMaximum().z)))
                return true;
            if (!b.contains(new Point3(box.getMaximum().x, box.getMaximum().y, box.getMinimum().z)))
                return true;
            if (!b.contains(new Point3(box.getMaximum().x, box.getMaximum().y, box.getMaximum().z)))
                return true;
            // all vertices of the box are inside - the surface of the box is
            // not intersected
        }
        return false;
    }"
org.sunflow.core.primitive.CornellBox.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        state.getRay().getPoint(state.getPoint());
        int n = state.getPrimitiveID();
        switch (n) {
            case 0:
                state.getNormal().set(new Vector3(1, 0, 0));
                break;
            case 1:
                state.getNormal().set(new Vector3(-1, 0, 0));
                break;
            case 2:
                state.getNormal().set(new Vector3(0, 1, 0));
                break;
            case 3:
                state.getNormal().set(new Vector3(0, -1, 0));
                break;
            case 4:
                state.getNormal().set(new Vector3(0, 0, 1));
                break;
            case 5:
                state.getNormal().set(new Vector3(0, 0, -1));
                break;
            default:
                state.getNormal().set(new Vector3(0, 0, 0));
                break;
        }
        state.getGeoNormal().set(state.getNormal());
        state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
        state.setShader(this);
    }"
org.sunflow.core.primitive.CornellBox.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        float intervalMin = Float.NEGATIVE_INFINITY;
        float intervalMax = Float.POSITIVE_INFINITY;
        float orgX = r.ox;
        float invDirX = 1 / r.dx;
        float t1, t2;
        t1 = (minX - orgX) * invDirX;
        t2 = (maxX - orgX) * invDirX;
        int sideIn = -1, sideOut = -1;
        if (invDirX > 0) {
            if (t1 > intervalMin) {
                intervalMin = t1;
                sideIn = 0;
            }
            if (t2 < intervalMax) {
                intervalMax = t2;
                sideOut = 1;
            }
        } else {
            if (t2 > intervalMin) {
                intervalMin = t2;
                sideIn = 1;
            }
            if (t1 < intervalMax) {
                intervalMax = t1;
                sideOut = 0;
            }
        }
        if (intervalMin > intervalMax)
            return;
        float orgY = r.oy;
        float invDirY = 1 / r.dy;
        t1 = (minY - orgY) * invDirY;
        t2 = (maxY - orgY) * invDirY;
        if (invDirY > 0) {
            if (t1 > intervalMin) {
                intervalMin = t1;
                sideIn = 2;
            }
            if (t2 < intervalMax) {
                intervalMax = t2;
                sideOut = 3;
            }
        } else {
            if (t2 > intervalMin) {
                intervalMin = t2;
                sideIn = 3;
            }
            if (t1 < intervalMax) {
                intervalMax = t1;
                sideOut = 2;
            }
        }
        if (intervalMin > intervalMax)
            return;
        float orgZ = r.oz;
        float invDirZ = 1 / r.dz;
        t1 = (minZ - orgZ) * invDirZ; // no front wall
        t2 = (maxZ - orgZ) * invDirZ;
        if (invDirZ > 0) {
            if (t1 > intervalMin) {
                intervalMin = t1;
                sideIn = 4;
            }
            if (t2 < intervalMax) {
                intervalMax = t2;
                sideOut = 5;
            }
        } else {
            if (t2 > intervalMin) {
                intervalMin = t2;
                sideIn = 5;
            }
            if (t1 < intervalMax) {
                intervalMax = t1;
                sideOut = 4;
            }
        }
        if (intervalMin > intervalMax)
            return;
        assert sideIn != -1;
        assert sideOut != -1;
        // can't hit minY wall, there is none
        if (sideIn != 2 && r.isInside(intervalMin)) {
            r.setMax(intervalMin);
            state.setIntersection(sideIn, 0, 0);
        } else if (sideOut != 2 && r.isInside(intervalMax)) {
            r.setMax(intervalMax);
            state.setIntersection(sideOut, 0, 0);
        }
    }"
org.sunflow.core.primitive.CornellBox.getRadiance,"    public Color getRadiance(ShadingState state) {
        int side = state.getPrimitiveID();
        Color kd = null;
        switch (side) {
            case 0:
                kd = left;
                break;
            case 1:
                kd = right;
                break;
            case 3:
                kd = back;
                break;
            case 4:
                kd = bottom;
                break;
            case 5:
                float lx = state.getPoint().x;
                float ly = state.getPoint().y;
                if (lx >= lxmin && lx < lxmax && ly >= lymin && ly < lymax && state.getRay().dz > 0)
                    return state.includeLights() ? radiance : Color.BLACK;
                kd = top;
                break;
            default:
                assert false;
        }
        // make sure we are on the right side of the material
        state.faceforward();
        // setup lighting
        state.initLightSamples();
        state.initCausticSamples();
        return state.diffuse(kd);
    }"
org.sunflow.core.primitive.CornellBox.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        int side = state.getPrimitiveID();
        Color kd = null;
        switch (side) {
            case 0:
                kd = left;
                break;
            case 1:
                kd = right;
                break;
            case 3:
                kd = back;
                break;
            case 4:
                kd = bottom;
                break;
            case 5:
                float lx = state.getPoint().x;
                float ly = state.getPoint().y;
                if (lx >= lxmin && lx < lxmax && ly >= lymin && ly < lymax && state.getRay().dz > 0)
                    return;
                kd = top;
                break;
            default:
                assert false;
        }
        // make sure we are on the right side of the material
        if (Vector3.dot(state.getNormal(), state.getRay().getDirection()) > 0) {
            state.getNormal().negate();
            state.getGeoNormal().negate();
        }
        state.storePhoton(state.getRay().getDirection(), power, kd);
        double avg = kd.getAverage();
        double rnd = state.getRandom(0, 0, 1);
        if (rnd < avg) {
            // photon is scattered
            power.mul(kd).mul(1 / (float) avg);
            OrthoNormalBasis onb = OrthoNormalBasis.makeFromW(state.getNormal());
            double u = 2 * Math.PI * rnd / avg;
            double v = state.getRandom(0, 1, 1);
            float s = (float) Math.sqrt(v);
            float s1 = (float) Math.sqrt(1.0 - v);
            Vector3 w = new Vector3((float) Math.cos(u) * s, (float) Math.sin(u) * s, s1);
            w = onb.transform(w, new Vector3());
            state.traceDiffusePhoton(new Ray(state.getPoint(), w), power);
        }
    }"
org.sunflow.core.primitive.CornellBox.getNumSamples,"    public int getNumSamples() {
        return samples;
    }"
org.sunflow.core.primitive.CornellBox.getSamples,"    public void getSamples(ShadingState state) {
        if (lightBounds.contains(state.getPoint()) && state.getPoint().z < maxZ) {
            int n = state.getDiffuseDepth() > 0 ? 1 : samples;
            float a = area / n;
            for (int i = 0; i < n; i++) {
                // random offset on unit square, we use the infinite version of
                // getRandom
                // because the light sampling is adaptive
                double randX = state.getRandom(i, 0);
                double randY = state.getRandom(i, 1);

                Point3 p = new Point3();
                p.x = (float) (lxmin * (1 - randX) + lxmax * randX);
                p.y = (float) (lymin * (1 - randY) + lymax * randY);
                p.z = maxZ - 0.001f;

                LightSample dest = new LightSample();
                // prepare shadow ray to sampled point
                dest.setShadowRay(new Ray(state.getPoint(), p));

                // check that the direction of the sample is the same as the
                // normal
                float cosNx = dest.dot(state.getNormal());
                if (cosNx <= 0)
                    return;

                // light source facing point ?
                // (need to check with light source's normal)
                float cosNy = dest.getShadowRay().dz;
                if (cosNy > 0) {
                    // compute geometric attenuation and probability scale
                    // factor
                    float r = dest.getShadowRay().getMax();
                    float g = cosNy / (r * r);
                    float scale = g * a;
                    // set final sample radiance
                    dest.setRadiance(radiance, radiance);
                    dest.getDiffuseRadiance().mul(scale);
                    dest.getSpecularRadiance().mul(scale);
                    dest.traceShadow(state);
                    state.addSample(dest);
                }
            }
        }
    }"
org.sunflow.core.primitive.CornellBox.getPhoton,"    public void getPhoton(double randX1, double randY1, double randX2, double randY2, Point3 p, Vector3 dir, Color power) {
        p.x = (float) (lxmin * (1 - randX2) + lxmax * randX2);
        p.y = (float) (lymin * (1 - randY2) + lymax * randY2);
        p.z = maxZ - 0.001f;

        double u = 2 * Math.PI * randX1;
        double s = Math.sqrt(randY1);
        dir.set((float) (Math.cos(u) * s), (float) (Math.sin(u) * s), (float) -Math.sqrt(1.0f - randY1));
        Color.mul((float) Math.PI * area, radiance, power);
    }"
org.sunflow.core.primitive.CornellBox.getPower,"    public float getPower() {
        return radiance.copy().mul((float) Math.PI * area).getLuminance();
    }"
org.sunflow.core.primitive.CornellBox.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.primitive.CornellBox.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        switch (i) {
            case 0:
                return minX;
            case 1:
                return maxX;
            case 2:
                return minY;
            case 3:
                return maxY;
            case 4:
                return minZ;
            case 5:
                return maxZ;
            default:
                return 0;
        }
    }"
org.sunflow.core.primitive.CornellBox.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox(minX, minY, minZ);
        bounds.include(maxX, maxY, maxZ);
        if (o2w == null)
            return bounds;
        return o2w.transform(bounds);
    }"
org.sunflow.core.primitive.CornellBox.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.primitive.JuliaFractal.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.primitive.JuliaFractal.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        return ((i & 1) == 0) ? -BOUNDING_RADIUS : BOUNDING_RADIUS;
    }"
org.sunflow.core.primitive.JuliaFractal.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox(BOUNDING_RADIUS);
        if (o2w != null)
            bounds = o2w.transform(bounds);
        return bounds;
    }"
org.sunflow.core.primitive.JuliaFractal.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        // intersect with bounding sphere
        float qc = ((r.ox * r.ox) + (r.oy * r.oy) + (r.oz * r.oz)) - BOUNDING_RADIUS2;
        float qt = r.getMin();
        if (qc > 0) {
            // we are starting outside the sphere, find intersection on the
            // sphere
            float qa = r.dx * r.dx + r.dy * r.dy + r.dz * r.dz;
            float qb = 2 * ((r.dx * r.ox) + (r.dy * r.oy) + (r.dz * r.oz));
            double[] t = Solvers.solveQuadric(qa, qb, qc);
            // early rejection
            if (t == null || t[0] >= r.getMax() || t[1] <= r.getMin())
                return;
            qt = (float) t[0];
        }
        float dist = Float.POSITIVE_INFINITY;
        float rox = r.ox + qt * r.dx;
        float roy = r.oy + qt * r.dy;
        float roz = r.oz + qt * r.dz;
        float invRayLength = (float) (1 / Math.sqrt(r.dx * r.dx + r.dy * r.dy + r.dz * r.dz));
        // now we can start intersection
        while (true) {
            float zw = rox;
            float zx = roy;
            float zy = roz;
            float zz = 0;

            float zpw = 1;
            float zpx = 0;
            float zpy = 0;
            float zpz = 0;

            // run several iterations
            float dotz = 0;
            for (int i = 0; i < maxIterations; i++) {
                {
                    // zp = 2 * (z * zp)
                    float nw = zw * zpw - zx * zpx - zy * zpy - zz * zpz;
                    float nx = zw * zpx + zx * zpw + zy * zpz - zz * zpy;
                    float ny = zw * zpy + zy * zpw + zz * zpx - zx * zpz;
                    zpz = 2 * (zw * zpz + zz * zpw + zx * zpy - zy * zpx);
                    zpw = 2 * nw;
                    zpx = 2 * nx;
                    zpy = 2 * ny;
                }
                {
                    // z = z*z + c
                    float nw = zw * zw - zx * zx - zy * zy - zz * zz + cw;
                    zx = 2 * zw * zx + cx;
                    zy = 2 * zw * zy + cy;
                    zz = 2 * zw * zz + cz;
                    zw = nw;
                }
                dotz = zw * zw + zx * zx + zy * zy + zz * zz;
                if (dotz > ESCAPE_THRESHOLD)
                    break;

            }
            float normZ = (float) Math.sqrt(dotz);
            dist = 0.5f * normZ * (float) Math.log(normZ) / length(zpw, zpx, zpy, zpz);
            rox += dist * r.dx;
            roy += dist * r.dy;
            roz += dist * r.dz;
            qt += dist;
            if (dist * invRayLength < epsilon)
                break;
            if (rox * rox + roy * roy + roz * roz > BOUNDING_RADIUS2)
                return;
        }
        // now test t value again
        if (!r.isInside(qt))
            return;
        if (dist * invRayLength < epsilon) {
            // valid hit
            r.setMax(qt);
            state.setIntersection(0, 0, 0);
        }
    }"
org.sunflow.core.primitive.JuliaFractal.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        state.getRay().getPoint(state.getPoint());
        Instance parent = state.getInstance();
        // compute local normal
        Point3 p = parent.transformWorldToObject(state.getPoint());
        float gx1w = p.x - DELTA;
        float gx1x = p.y;
        float gx1y = p.z;
        float gx1z = 0;
        float gx2w = p.x + DELTA;
        float gx2x = p.y;
        float gx2y = p.z;
        float gx2z = 0;

        float gy1w = p.x;
        float gy1x = p.y - DELTA;
        float gy1y = p.z;
        float gy1z = 0;
        float gy2w = p.x;
        float gy2x = p.y + DELTA;
        float gy2y = p.z;
        float gy2z = 0;

        float gz1w = p.x;
        float gz1x = p.y;
        float gz1y = p.z - DELTA;
        float gz1z = 0;
        float gz2w = p.x;
        float gz2x = p.y;
        float gz2y = p.z + DELTA;
        float gz2z = 0;

        for (int i = 0; i < maxIterations; i++) {
            {
                // z = z*z + c
                float nw = gx1w * gx1w - gx1x * gx1x - gx1y * gx1y - gx1z * gx1z + cw;
                gx1x = 2 * gx1w * gx1x + cx;
                gx1y = 2 * gx1w * gx1y + cy;
                gx1z = 2 * gx1w * gx1z + cz;
                gx1w = nw;
            }
            {
                // z = z*z + c
                float nw = gx2w * gx2w - gx2x * gx2x - gx2y * gx2y - gx2z * gx2z + cw;
                gx2x = 2 * gx2w * gx2x + cx;
                gx2y = 2 * gx2w * gx2y + cy;
                gx2z = 2 * gx2w * gx2z + cz;
                gx2w = nw;
            }
            {
                // z = z*z + c
                float nw = gy1w * gy1w - gy1x * gy1x - gy1y * gy1y - gy1z * gy1z + cw;
                gy1x = 2 * gy1w * gy1x + cx;
                gy1y = 2 * gy1w * gy1y + cy;
                gy1z = 2 * gy1w * gy1z + cz;
                gy1w = nw;
            }
            {
                // z = z*z + c
                float nw = gy2w * gy2w - gy2x * gy2x - gy2y * gy2y - gy2z * gy2z + cw;
                gy2x = 2 * gy2w * gy2x + cx;
                gy2y = 2 * gy2w * gy2y + cy;
                gy2z = 2 * gy2w * gy2z + cz;
                gy2w = nw;
            }
            {
                // z = z*z + c
                float nw = gz1w * gz1w - gz1x * gz1x - gz1y * gz1y - gz1z * gz1z + cw;
                gz1x = 2 * gz1w * gz1x + cx;
                gz1y = 2 * gz1w * gz1y + cy;
                gz1z = 2 * gz1w * gz1z + cz;
                gz1w = nw;
            }
            {
                // z = z*z + c
                float nw = gz2w * gz2w - gz2x * gz2x - gz2y * gz2y - gz2z * gz2z + cw;
                gz2x = 2 * gz2w * gz2x + cx;
                gz2y = 2 * gz2w * gz2y + cy;
                gz2z = 2 * gz2w * gz2z + cz;
                gz2w = nw;
            }
        }
        float gradX = length(gx2w, gx2x, gx2y, gx2z) - length(gx1w, gx1x, gx1y, gx1z);
        float gradY = length(gy2w, gy2x, gy2y, gy2z) - length(gy1w, gy1x, gy1y, gy1z);
        float gradZ = length(gz2w, gz2x, gz2y, gz2z) - length(gz1w, gz1x, gz1y, gz1z);
        Vector3 n = new Vector3((float) gradX, (float) gradY, (float) gradZ);
        state.getNormal().set(parent.transformNormalObjectToWorld(n));
        state.getNormal().normalize();
        state.getGeoNormal().set(state.getNormal());
        state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));

        state.getPoint().x += state.getNormal().x * epsilon * 20;
        state.getPoint().y += state.getNormal().y * epsilon * 20;
        state.getPoint().z += state.getNormal().z * epsilon * 20;

        state.setShader(parent.getShader(0));
        state.setModifier(parent.getModifier(0));
    }"
org.sunflow.core.primitive.JuliaFractal.length,"    private static float length(float w, float x, float y, float z) {
        return (float) Math.sqrt(w * w + x * x + y * y + z * z);
    }"
org.sunflow.core.primitive.JuliaFractal.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        maxIterations = pl.getInt(""iterations"", maxIterations);
        epsilon = pl.getFloat(""epsilon"", epsilon);
        cw = pl.getFloat(""cw"", cw);
        cx = pl.getFloat(""cx"", cx);
        cy = pl.getFloat(""cy"", cy);
        cz = pl.getFloat(""cz"", cz);
        return true;
    }"
org.sunflow.core.primitive.JuliaFractal.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.primitive.Plane.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        center = pl.getPoint(""center"", center);
        Point3 b = pl.getPoint(""point1"", null);
        Point3 c = pl.getPoint(""point2"", null);
        if (b != null && c != null) {
            Point3 v0 = center;
            Point3 v1 = b;
            Point3 v2 = c;
            Vector3 ng = normal = Vector3.cross(Point3.sub(v1, v0, new Vector3()), Point3.sub(v2, v0, new Vector3()), new Vector3()).normalize();
            if (Math.abs(ng.x) > Math.abs(ng.y) && Math.abs(ng.x) > Math.abs(ng.z))
                k = 0;
            else if (Math.abs(ng.y) > Math.abs(ng.z))
                k = 1;
            else
                k = 2;
            float ax, ay, bx, by, cx, cy;
            switch (k) {
                case 0: {
                    ax = v0.y;
                    ay = v0.z;
                    bx = v2.y - ax;
                    by = v2.z - ay;
                    cx = v1.y - ax;
                    cy = v1.z - ay;
                    break;
                }
                case 1: {
                    ax = v0.z;
                    ay = v0.x;
                    bx = v2.z - ax;
                    by = v2.x - ay;
                    cx = v1.z - ax;
                    cy = v1.x - ay;
                    break;
                }
                case 2:
                default: {
                    ax = v0.x;
                    ay = v0.y;
                    bx = v2.x - ax;
                    by = v2.y - ay;
                    cx = v1.x - ax;
                    cy = v1.y - ay;
                }
            }
            float det = bx * cy - by * cx;
            bnu = -by / det;
            bnv = bx / det;
            bnd = (by * ax - bx * ay) / det;
            cnu = cy / det;
            cnv = -cx / det;
            cnd = (cx * ay - cy * ax) / det;
        } else {
            normal = pl.getVector(""normal"", normal);
            k = 3;
            bnu = bnv = bnd = 0;
            cnu = cnv = cnd = 0;
        }
        return true;
    }"
org.sunflow.core.primitive.Plane.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        state.getRay().getPoint(state.getPoint());
        Instance parent = state.getInstance();
        Vector3 worldNormal = parent.transformNormalObjectToWorld(normal);
        state.getNormal().set(worldNormal);
        state.getGeoNormal().set(worldNormal);
        state.setShader(parent.getShader(0));
        state.setModifier(parent.getModifier(0));
        Point3 p = parent.transformWorldToObject(state.getPoint());
        float hu, hv;
        switch (k) {
            case 0: {
                hu = p.y;
                hv = p.z;
                break;
            }
            case 1: {
                hu = p.z;
                hv = p.x;
                break;
            }
            case 2: {
                hu = p.x;
                hv = p.y;
                break;
            }
            default:
                hu = hv = 0;
        }
        state.getUV().x = hu * bnu + hv * bnv + bnd;
        state.getUV().y = hu * cnu + hv * cnv + cnd;
        state.setBasis(OrthoNormalBasis.makeFromW(normal));
    }"
org.sunflow.core.primitive.Plane.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        float dn = normal.x * r.dx + normal.y * r.dy + normal.z * r.dz;
        if (dn == 0.0)
            return;
        float t = (((center.x - r.ox) * normal.x) + ((center.y - r.oy) * normal.y) + ((center.z - r.oz) * normal.z)) / dn;
        if (r.isInside(t)) {
            r.setMax(t);
            state.setIntersection(0, 0, 0);
        }
    }"
org.sunflow.core.primitive.Plane.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.primitive.Plane.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        return 0;
    }"
org.sunflow.core.primitive.Plane.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        return null;
    }"
org.sunflow.core.primitive.Plane.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.primitive.Hair.getNumPrimitives,"    public int getNumPrimitives() {
        return numSegments * (points.length / (3 * (numSegments + 1)));
    }"
org.sunflow.core.primitive.Hair.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        int hair = primID / numSegments;
        int line = primID % numSegments;
        int vn = hair * (numSegments + 1) + line;
        int vRoot = hair * 3 * (numSegments + 1);
        int v0 = vRoot + line * 3;
        int v1 = v0 + 3;
        int axis = i >>> 1;
        if ((i & 1) == 0) {
            return Math.min(points[v0 + axis] - 0.5f * getWidth(vn), points[v1 + axis] - 0.5f * getWidth(vn + 1));
        } else {
            return Math.max(points[v0 + axis] + 0.5f * getWidth(vn), points[v1 + axis] + 0.5f * getWidth(vn + 1));
        }
    }"
org.sunflow.core.primitive.Hair.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox();
        for (int i = 0, j = 0; i < points.length; i += 3, j++) {
            float w = 0.5f * getWidth(j);
            bounds.include(points[i] - w, points[i + 1] - w, points[i + 2] - w);
            bounds.include(points[i] + w, points[i + 1] + w, points[i + 2] + w);
        }
        if (o2w != null)
            bounds = o2w.transform(bounds);
        return bounds;
    }"
org.sunflow.core.primitive.Hair.getWidth,"    private float getWidth(int i) {
        switch (widths.interp) {
            case NONE:
                return widths.data[0];
            case VERTEX:
                return widths.data[i];
            default:
                return 0;
        }
    }"
org.sunflow.core.primitive.Hair.getTangent,"    private Vector3 getTangent(int line, int v0, float v) {
        Vector3 vcurr = new Vector3(points[v0 + 3] - points[v0 + 0], points[v0 + 4] - points[v0 + 1], points[v0 + 5] - points[v0 + 2]);
        vcurr.normalize();
        if (line == 0 || line == numSegments - 1)
            return vcurr;
        if (v <= 0.5f) {
            // get previous segment
            Vector3 vprev = new Vector3(points[v0 + 0] - points[v0 - 3], points[v0 + 1] - points[v0 - 2], points[v0 + 2] - points[v0 - 1]);
            vprev.normalize();
            float t = v + 0.5f;
            float s = 1 - t;
            float vx = vprev.x * s + vcurr.x * t;
            float vy = vprev.y * s + vcurr.y * t;
            float vz = vprev.z * s + vcurr.z * t;
            return new Vector3(vx, vy, vz);
        } else {
            // get next segment
            v0 += 3;
            Vector3 vnext = new Vector3(points[v0 + 3] - points[v0 + 0], points[v0 + 4] - points[v0 + 1], points[v0 + 5] - points[v0 + 2]);
            vnext.normalize();
            float t = 1.5f - v;
            float s = 1 - t;
            float vx = vnext.x * s + vcurr.x * t;
            float vy = vnext.y * s + vcurr.y * t;
            float vz = vnext.z * s + vcurr.z * t;
            return new Vector3(vx, vy, vz);
        }
    }"
org.sunflow.core.primitive.Hair.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        int hair = primID / numSegments;
        int line = primID % numSegments;
        int vRoot = hair * 3 * (numSegments + 1);
        int v0 = vRoot + line * 3;
        int v1 = v0 + 3;
        float vx = points[v1 + 0] - points[v0 + 0];
        float vy = points[v1 + 1] - points[v0 + 1];
        float vz = points[v1 + 2] - points[v0 + 2];
        float ux = r.dy * vz - r.dz * vy;
        float uy = r.dz * vx - r.dx * vz;
        float uz = r.dx * vy - r.dy * vx;
        float nx = uy * vz - uz * vy;
        float ny = uz * vx - ux * vz;
        float nz = ux * vy - uy * vx;
        float tden = 1 / (nx * r.dx + ny * r.dy + nz * r.dz);
        float tnum = nx * (points[v0 + 0] - r.ox) + ny * (points[v0 + 1] - r.oy) + nz * (points[v0 + 2] - r.oz);
        float t = tnum * tden;
        if (r.isInside(t)) {
            int vn = hair * (numSegments + 1) + line;
            float px = r.ox + t * r.dx;
            float py = r.oy + t * r.dy;
            float pz = r.oz + t * r.dz;
            float qx = px - points[v0 + 0];
            float qy = py - points[v0 + 1];
            float qz = pz - points[v0 + 2];
            float q = (vx * qx + vy * qy + vz * qz) / (vx * vx + vy * vy + vz * vz);
            if (q <= 0) {
                // don't included rounded tip at root
                if (line == 0)
                    return;
                float dx = points[v0 + 0] - px;
                float dy = points[v0 + 1] - py;
                float dz = points[v0 + 2] - pz;
                float d2 = dx * dx + dy * dy + dz * dz;
                float width = getWidth(vn);
                if (d2 < (width * width * 0.25f)) {
                    r.setMax(t);
                    state.setIntersection(primID, 0, 0);
                }
            } else if (q >= 1) {
                float dx = points[v1 + 0] - px;
                float dy = points[v1 + 1] - py;
                float dz = points[v1 + 2] - pz;
                float d2 = dx * dx + dy * dy + dz * dz;
                float width = getWidth(vn + 1);
                if (d2 < (width * width * 0.25f)) {
                    r.setMax(t);
                    state.setIntersection(primID, 0, 1);
                }
            } else {
                float dx = points[v0 + 0] + q * vx - px;
                float dy = points[v0 + 1] + q * vy - py;
                float dz = points[v0 + 2] + q * vz - pz;
                float d2 = dx * dx + dy * dy + dz * dz;
                float width = (1 - q) * getWidth(vn) + q * getWidth(vn + 1);
                if (d2 < (width * width * 0.25f)) {
                    r.setMax(t);
                    state.setIntersection(primID, 0, q);
                }
            }
        }
    }"
org.sunflow.core.primitive.Hair.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        Instance i = state.getInstance();
        state.getRay().getPoint(state.getPoint());
        Ray r = state.getRay();
        Shader s = i.getShader(0);
        state.setShader(s != null ? s : this);
        int primID = state.getPrimitiveID();
        int hair = primID / numSegments;
        int line = primID % numSegments;
        int vRoot = hair * 3 * (numSegments + 1);
        int v0 = vRoot + line * 3;

        // tangent vector
        Vector3 v = getTangent(line, v0, state.getV());
        v = i.transformVectorObjectToWorld(v);
        state.setBasis(OrthoNormalBasis.makeFromWV(v, new Vector3(-r.dx, -r.dy, -r.dz)));
        state.getBasis().swapVW();
        // normal
        state.getNormal().set(0, 0, 1);
        state.getBasis().transform(state.getNormal());
        state.getGeoNormal().set(state.getNormal());

        state.getUV().set(0, (line + state.getV()) / numSegments);
    }"
org.sunflow.core.primitive.Hair.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        numSegments = pl.getInt(""segments"", numSegments);
        if (numSegments < 1) {
            UI.printError(Module.HAIR, ""Invalid number of segments: %d"", numSegments);
            return false;
        }
        FloatParameter pointsP = pl.getPointArray(""points"");
        if (pointsP != null) {
            if (pointsP.interp != InterpolationType.VERTEX)
                UI.printError(Module.HAIR, ""Point interpolation type must be set to \""vertex\"" - was \""%s\"""", pointsP.interp.name().toLowerCase());
            else {
                points = pointsP.data;
            }
        }
        if (points == null) {
            UI.printError(Module.HAIR, ""Unabled to update hair - vertices are missing"");
            return false;
        }

        pl.setVertexCount(points.length / 3);
        FloatParameter widthsP = pl.getFloatArray(""widths"");
        if (widthsP != null) {
            if (widthsP.interp == InterpolationType.NONE || widthsP.interp == InterpolationType.VERTEX)
                widths = widthsP;
            else
                UI.printWarning(Module.HAIR, ""Width interpolation type %s is not supported -- ignoring"", widthsP.interp.name().toLowerCase());
        }
        return true;
    }"
org.sunflow.core.primitive.Hair.getRadiance,"    public Color getRadiance(ShadingState state) {
        // don't use these - gather lights for sphere of directions
        // gather lights
        state.initLightSamples();
        state.initCausticSamples();
        Vector3 v = state.getRay().getDirection();
        v.negate();
        Vector3 h = new Vector3();
        Vector3 t = state.getBasis().transform(new Vector3(0, 1, 0));
        Color diff = Color.black();
        Color spec = Color.black();
        for (LightSample ls : state) {
            Vector3 l = ls.getShadowRay().getDirection();
            float dotTL = Vector3.dot(t, l);
            float sinTL = (float) Math.sqrt(1 - dotTL * dotTL);
            // float dotVL = Vector3.dot(v, l);
            diff.madd(sinTL, ls.getDiffuseRadiance());
            Vector3.add(v, l, h);
            h.normalize();
            float dotTH = Vector3.dot(t, h);
            float sinTH = (float) Math.sqrt(1 - dotTH * dotTH);
            float s = (float) Math.pow(sinTH, 10.0f);
            spec.madd(s, ls.getSpecularRadiance());
        }
        Color c = Color.add(diff, spec, new Color());
        // transparency
        return Color.blend(c, state.traceTransparency(), state.getV(), new Color());
    }"
org.sunflow.core.primitive.Hair.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }"
org.sunflow.core.primitive.Hair.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.primitive.ParticleSurface.getNumPrimitives,"    public int getNumPrimitives() {
        return n;
    }"
org.sunflow.core.primitive.ParticleSurface.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        float c = particles[primID * 3 + (i >>> 1)];
        return (i & 1) == 0 ? c - r : c + r;
    }"
org.sunflow.core.primitive.ParticleSurface.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox();
        for (int i = 0, i3 = 0; i < n; i++, i3 += 3)
            bounds.include(particles[i3], particles[i3 + 1], particles[i3 + 2]);
        bounds.include(bounds.getMinimum().x - r, bounds.getMinimum().y - r, bounds.getMinimum().z - r);
        bounds.include(bounds.getMaximum().x + r, bounds.getMaximum().y + r, bounds.getMaximum().z + r);
        return o2w == null ? bounds : o2w.transform(bounds);
    }"
org.sunflow.core.primitive.ParticleSurface.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        int i3 = primID * 3;
        float ocx = r.ox - particles[i3 + 0];
        float ocy = r.oy - particles[i3 + 1];
        float ocz = r.oz - particles[i3 + 2];
        float qa = r.dx * r.dx + r.dy * r.dy + r.dz * r.dz;
        float qb = 2 * ((r.dx * ocx) + (r.dy * ocy) + (r.dz * ocz));
        float qc = ((ocx * ocx) + (ocy * ocy) + (ocz * ocz)) - r2;
        double[] t = Solvers.solveQuadric(qa, qb, qc);
        if (t != null) {
            // early rejection
            if (t[0] >= r.getMax() || t[1] <= r.getMin())
                return;
            if (t[0] > r.getMin())
                r.setMax((float) t[0]);
            else
                r.setMax((float) t[1]);
            state.setIntersection(primID, 0, 0);
        }
    }"
org.sunflow.core.primitive.ParticleSurface.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        state.getRay().getPoint(state.getPoint());
        Point3 localPoint = state.getInstance().transformWorldToObject(state.getPoint());

        localPoint.x -= particles[3 * state.getPrimitiveID() + 0];
        localPoint.y -= particles[3 * state.getPrimitiveID() + 1];
        localPoint.z -= particles[3 * state.getPrimitiveID() + 2];

        state.getNormal().set(localPoint.x, localPoint.y, localPoint.z);
        state.getNormal().normalize();

        state.setShader(state.getInstance().getShader(0));
        state.setModifier(state.getInstance().getModifier(0));
        // into object space
        Vector3 worldNormal = state.getInstance().transformNormalObjectToWorld(state.getNormal());
        state.getNormal().set(worldNormal);
        state.getNormal().normalize();
        state.getGeoNormal().set(state.getNormal());
        state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
    }"
org.sunflow.core.primitive.ParticleSurface.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        FloatParameter p = pl.getPointArray(""particles"");
        if (p != null)
            particles = p.data;
        r = pl.getFloat(""radius"", r);
        r2 = r * r;
        n = pl.getInt(""num"", n);
        return particles != null && n <= (particles.length / 3);
    }"
org.sunflow.core.primitive.ParticleSurface.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.parser.RA3Parser.parse,"    public boolean parse(String filename, SunflowAPI api) {
        try {
            UI.printInfo(Module.USER, ""RA3 - Reading geometry: \""%s\"" ..."", filename);
            File file = new File(filename);
            FileInputStream stream = new FileInputStream(filename);
            MappedByteBuffer map = stream.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length());
            map.order(ByteOrder.LITTLE_ENDIAN);
            IntBuffer ints = map.asIntBuffer();
            FloatBuffer buffer = map.asFloatBuffer();
            int numVerts = ints.get(0);
            int numTris = ints.get(1);
            UI.printInfo(Module.USER, ""RA3 -   * Reading %d vertices ..."", numVerts);
            float[] verts = new float[3 * numVerts];
            for (int i = 0; i < verts.length; i++)
                verts[i] = buffer.get(2 + i);
            UI.printInfo(Module.USER, ""RA3 -   * Reading %d triangles ..."", numTris);
            int[] tris = new int[3 * numTris];
            for (int i = 0; i < tris.length; i++)
                tris[i] = ints.get(2 + verts.length + i);
            stream.close();
            UI.printInfo(Module.USER, ""RA3 -   * Creating mesh ..."");

            // create geometry
            api.parameter(""triangles"", tris);
            api.parameter(""points"", ""point"", ""vertex"", verts);
            api.geometry(filename, new TriangleMesh());

            // create shader
            Shader s = api.lookupShader(""ra3shader"");
            if (s == null) {
                // create default shader
                api.shader(filename + "".shader"", new SimpleShader());
                api.parameter(""shaders"", filename + "".shader"");
            } else {
                // reuse existing shader
                api.parameter(""shaders"", ""ra3shader"");
            }

            // create instance
            api.instance(filename + "".instance"", filename);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }
"
org.sunflow.core.parser.ShaveRibParser.parse,"    public boolean parse(String filename, SunflowAPI api) {
        try {
            Parser p = new Parser(filename);
            p.checkNextToken(""version"");
            p.checkNextToken(""3.04"");
            p.checkNextToken(""TransformBegin"");

            if (p.peekNextToken(""Procedural"")) {
                // read procedural shave rib
                boolean done = false;
                while (!done) {
                    p.checkNextToken(""DelayedReadArchive"");
                    p.checkNextToken(""["");
                    String f = p.getNextToken();
                    UI.printInfo(Module.USER, ""RIB - Reading voxel: \""%s\"" ..."", f);
                    api.parse(f);
                    p.checkNextToken(""]"");
                    while (true) {
                        String t = p.getNextToken();
                        if (t == null || t.equals(""TransformEnd"")) {
                            done = true;
                            break;
                        } else if (t.equals(""Procedural""))
                            break;
                    }
                }
                return true;
            }

            boolean cubic = false;
            if (p.peekNextToken(""Basis"")) {
                cubic = true;
                // u basis
                p.checkNextToken(""catmull-rom"");
                p.checkNextToken(""1"");
                // v basis
                p.checkNextToken(""catmull-rom"");
                p.checkNextToken(""1"");
            }
            while (p.peekNextToken(""Declare"")) {
                p.getNextToken(); // name
                p.getNextToken(); // interpolation & type
            }
            int index = 0;
            boolean done = false;
            p.checkNextToken(""Curves"");
            do {
                if (cubic)
                    p.checkNextToken(""cubic"");
                else
                    p.checkNextToken(""linear"");
                int[] nverts = parseIntArray(p);
                for (int i = 1; i < nverts.length; i++) {
                    if (nverts[0] != nverts[i]) {
                        UI.printError(Module.USER, ""RIB - Found variable number of hair segments"");
                        return false;
                    }
                }
                int nhairs = nverts.length;

                UI.printInfo(Module.USER, ""RIB - Parsed %d hair curves"", nhairs);

                api.parameter(""segments"", nverts[0] - 1);

                p.checkNextToken(""nonperiodic"");
                p.checkNextToken(""P"");
                float[] points = parseFloatArray(p);
                if (points.length != 3 * nhairs * nverts[0]) {
                    UI.printError(Module.USER, ""RIB - Invalid number of points - expecting %d - found %d"", nhairs * nverts[0], points.length / 3);
                    return false;
                }
                api.parameter(""points"", ""point"", ""vertex"", points);

                UI.printInfo(Module.USER, ""RIB - Parsed %d hair vertices"", points.length / 3);

                p.checkNextToken(""width"");
                float[] w = parseFloatArray(p);
                if (w.length != nhairs * nverts[0]) {
                    UI.printError(Module.USER, ""RIB - Invalid number of hair widths - expecting %d - found %d"", nhairs * nverts[0], w.length);
                    return false;
                }
                api.parameter(""widths"", ""float"", ""vertex"", w);

                UI.printInfo(Module.USER, ""RIB - Parsed %d hair widths"", w.length);

                String name = String.format(""%s[%d]"", filename, index);
                UI.printInfo(Module.USER, ""RIB - Creating hair object \""%s\"""", name);
                api.geometry(name, new Hair());
                api.instance(name + "".instance"", name);

                UI.printInfo(Module.USER, ""RIB - Searching for next curve group ..."");
                while (true) {
                    String t = p.getNextToken();
                    if (t == null || t.equals(""TransformEnd"")) {
                        done = true;
                        break;
                    } else if (t.equals(""Curves""))
                        break;
                }
                index++;
            } while (!done);
            UI.printInfo(Module.USER, ""RIB - Finished reading rib file"");
        } catch (FileNotFoundException e) {
            UI.printError(Module.USER, ""RIB - File not found: %s"", filename);
            e.printStackTrace();
            return false;
        } catch (ParserException e) {
            UI.printError(Module.USER, ""RIB - Parser exception: %s"", e);
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            UI.printError(Module.USER, ""RIB - I/O exception: %s"", e);
            e.printStackTrace();
            return false;
        }
        return true;
    }"
org.sunflow.core.parser.ShaveRibParser.parseIntArray,"    private int[] parseIntArray(Parser p) throws IOException {
        IntArray array = new IntArray();
        boolean done = false;
        do {
            String s = p.getNextToken();
            if (s.startsWith(""[""))
                s = s.substring(1);
            if (s.endsWith(""]"")) {
                s = s.substring(0, s.length() - 1);
                done = true;
            }
            array.add(Integer.parseInt(s));
        } while (!done);
        return array.trim();
    }"
org.sunflow.core.parser.ShaveRibParser.parseFloatArray,"    private float[] parseFloatArray(Parser p) throws IOException {
        FloatArray array = new FloatArray();
        boolean done = false;
        do {
            String s = p.getNextToken();
            if (s.startsWith(""[""))
                s = s.substring(1);
            if (s.endsWith(""]"")) {
                s = s.substring(0, s.length() - 1);
                done = true;
            }
            array.add(Float.parseFloat(s));
        } while (!done);
        return array.trim();
    }
"
org.sunflow.core.parser.TriParser.parse,"    public boolean parse(String filename, SunflowAPI api) {
        try {
            UI.printInfo(Module.USER, ""TRI - Reading geometry: \""%s\"" ..."", filename);
            Parser p = new Parser(filename);
            float[] verts = new float[3 * p.getNextInt()];
            for (int v = 0; v < verts.length; v += 3) {
                verts[v + 0] = p.getNextFloat();
                verts[v + 1] = p.getNextFloat();
                verts[v + 2] = p.getNextFloat();
                p.getNextToken();
                p.getNextToken();
            }
            int[] triangles = new int[p.getNextInt() * 3];
            for (int t = 0; t < triangles.length; t += 3) {
                triangles[t + 0] = p.getNextInt();
                triangles[t + 1] = p.getNextInt();
                triangles[t + 2] = p.getNextInt();
            }

            // create geometry
            api.parameter(""triangles"", triangles);
            api.parameter(""points"", ""point"", ""vertex"", verts);
            api.geometry(filename, new TriangleMesh());

            // create shader
            api.shader(filename + "".shader"", new SimpleShader());
            api.parameter(""shaders"", filename + "".shader"");

            // create instance
            api.instance(filename + "".instance"", filename);

            p.close();
            // output to ra3 format
            RandomAccessFile stream = new RandomAccessFile(filename.replace("".tri"", "".ra3""), ""rw"");
            MappedByteBuffer map = stream.getChannel().map(MapMode.READ_WRITE, 0, 8 + 4 * (verts.length + triangles.length));
            map.order(ByteOrder.LITTLE_ENDIAN);
            IntBuffer ints = map.asIntBuffer();
            FloatBuffer floats = map.asFloatBuffer();
            ints.put(0, verts.length / 3);
            ints.put(1, triangles.length / 3);
            for (int i = 0; i < verts.length; i++)
                floats.put(2 + i, verts[i]);
            for (int i = 0; i < triangles.length; i++)
                ints.put(2 + verts.length + i, triangles[i]);
            stream.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }
"
org.sunflow.core.parser.RA2Parser.parse,"    public boolean parse(String filename, SunflowAPI api) {
        try {
            UI.printInfo(Module.USER, ""RA2 - Reading geometry: \""%s\"" ..."", filename);
            File file = new File(filename);
            FileInputStream stream = new FileInputStream(filename);
            MappedByteBuffer map = stream.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length());
            map.order(ByteOrder.LITTLE_ENDIAN);
            FloatBuffer buffer = map.asFloatBuffer();
            float[] data = new float[buffer.capacity()];
            for (int i = 0; i < data.length; i++)
                data[i] = buffer.get(i);
            stream.close();
            api.parameter(""points"", ""point"", ""vertex"", data);
            int[] triangles = new int[3 * (data.length / 9)];
            for (int i = 0; i < triangles.length; i++)
                triangles[i] = i;
            // create geo
            api.parameter(""triangles"", triangles);
            api.geometry(filename, new TriangleMesh());
            // create shader
            api.shader(filename + "".shader"", new SimpleShader());
            // create instance
            api.parameter(""shaders"", filename + "".shader"");
            api.instance(filename + "".instance"", filename);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        try {
            filename = filename.replace("".ra2"", "".txt"");
            UI.printInfo(Module.USER, ""RA2 - Reading camera  : \""%s\"" ..."", filename);
            Parser p = new Parser(filename);
            Point3 eye = new Point3();
            eye.x = p.getNextFloat();
            eye.y = p.getNextFloat();
            eye.z = p.getNextFloat();
            Point3 to = new Point3();
            to.x = p.getNextFloat();
            to.y = p.getNextFloat();
            to.z = p.getNextFloat();
            Vector3 up = new Vector3();
            switch (p.getNextInt()) {
                case 0:
                    up.set(1, 0, 0);
                    break;
                case 1:
                    up.set(0, 1, 0);
                    break;
                case 2:
                    up.set(0, 0, 1);
                    break;
                default:
                    UI.printWarning(Module.USER, ""RA2 - Invalid up vector specification - using Z axis"");
                    up.set(0, 0, 1);
                    break;
            }
            api.parameter(""eye"", eye);
            api.parameter(""target"", to);
            api.parameter(""up"", up);
            String name = api.getUniqueName(""camera"");
            api.parameter(""fov"", 80f);
            api.camera(name, new PinholeLens());
            api.parameter(""camera"", name);
            api.parameter(""resolutionX"", 1024);
            api.parameter(""resolutionY"", 1024);
            api.options(SunflowAPI.DEFAULT_OPTIONS);
            p.close();
        } catch (FileNotFoundException e) {
            UI.printWarning(Module.USER, ""RA2 - Camera file not found"");
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }
"
org.sunflow.core.parser.SCParser.parse,"    public boolean parse(String filename, SunflowAPI api) {
        String localDir = new File(filename).getAbsoluteFile().getParentFile().getAbsolutePath();
        numLightSamples = 1;
        Timer timer = new Timer();
        timer.start();
        UI.printInfo(Module.API, ""Parsing \""%s\"" ..."", filename);
        try {
            p = new Parser(filename);
            while (true) {
                String token = p.getNextToken();
                if (token == null)
                    break;
                if (token.equals(""image"")) {
                    UI.printInfo(Module.API, ""Reading image settings ..."");
                    parseImageBlock(api);
                } else if (token.equals(""background"")) {
                    UI.printInfo(Module.API, ""Reading background ..."");
                    parseBackgroundBlock(api);
                } else if (token.equals(""accel"")) {
                    UI.printInfo(Module.API, ""Reading accelerator type ..."");
                    p.getNextToken();
                    UI.printWarning(Module.API, ""Setting accelerator type is not recommended - ignoring"");
                } else if (token.equals(""filter"")) {
                    UI.printInfo(Module.API, ""Reading image filter type ..."");
                    parseFilter(api);
                } else if (token.equals(""bucket"")) {
                    UI.printInfo(Module.API, ""Reading bucket settings ..."");
                    api.parameter(""bucket.size"", p.getNextInt());
                    api.parameter(""bucket.order"", p.getNextToken());
                    api.options(SunflowAPI.DEFAULT_OPTIONS);
                } else if (token.equals(""photons"")) {
                    UI.printInfo(Module.API, ""Reading photon settings ..."");
                    parsePhotonBlock(api);
                } else if (token.equals(""gi"")) {
                    UI.printInfo(Module.API, ""Reading global illumination settings ..."");
                    parseGIBlock(api);
                } else if (token.equals(""lightserver"")) {
                    UI.printInfo(Module.API, ""Reading light server settings ..."");
                    parseLightserverBlock(api);
                } else if (token.equals(""trace-depths"")) {
                    UI.printInfo(Module.API, ""Reading trace depths ..."");
                    parseTraceBlock(api);
                } else if (token.equals(""camera"")) {
                    UI.printInfo(Module.API, ""Reading camera ..."");
                    parseCamera(api);
                } else if (token.equals(""shader"")) {
                    if (!parseShader(api))
                        return false;
                } else if (token.equals(""modifier"")) {
                    if (!parseModifier(api))
                        return false;
                } else if (token.equals(""override"")) {
                    api.shaderOverride(p.getNextToken(), p.getNextBoolean());
                } else if (token.equals(""object"")) {
                    parseObjectBlock(api);
                } else if (token.equals(""instance"")) {
                    parseInstanceBlock(api);
                } else if (token.equals(""light"")) {
                    parseLightBlock(api);
                } else if (token.equals(""texturepath"")) {
                    String path = p.getNextToken();
                    if (!new File(path).isAbsolute())
                        path = localDir + File.separator + path;
                    api.addTextureSearchPath(path);
                } else if (token.equals(""includepath"")) {
                    String path = p.getNextToken();
                    if (!new File(path).isAbsolute())
                        path = localDir + File.separator + path;
                    api.addIncludeSearchPath(path);
                } else if (token.equals(""include"")) {
                    String file = p.getNextToken();
                    UI.printInfo(Module.API, ""Including: \""%s\"" ..."", file);
                    api.parse(file);
                } else
                    UI.printWarning(Module.API, ""Unrecognized token %s"", token);
            }
            p.close();
        } catch (ParserException e) {
            UI.printError(Module.API, ""%s"", e.getMessage());
            e.printStackTrace();
            return false;
        } catch (FileNotFoundException e) {
            UI.printError(Module.API, ""%s"", e.getMessage());
            return false;
        } catch (IOException e) {
            UI.printError(Module.API, ""%s"", e.getMessage());
            return false;
        }
        timer.end();
        UI.printInfo(Module.API, ""Done parsing."");
        UI.printInfo(Module.API, ""Parsing time: %s"", timer.toString());
        return true;
    }"
org.sunflow.core.parser.SCParser.parseImageBlock,"    private void parseImageBlock(SunflowAPI api) throws IOException, ParserException {
        p.checkNextToken(""{"");
        if (p.peekNextToken(""resolution"")) {
            api.parameter(""resolutionX"", p.getNextInt());
            api.parameter(""resolutionY"", p.getNextInt());
        }
        if (p.peekNextToken(""aa"")) {
            api.parameter(""aa.min"", p.getNextInt());
            api.parameter(""aa.max"", p.getNextInt());
        }
        if (p.peekNextToken(""samples""))
            api.parameter(""aa.samples"", p.getNextInt());
        if (p.peekNextToken(""contrast""))
            api.parameter(""aa.contrast"", p.getNextFloat());
        if (p.peekNextToken(""filter""))
            api.parameter(""filter"", p.getNextToken());
        if (p.peekNextToken(""jitter""))
            api.parameter(""aa.jitter"", p.getNextBoolean());
        if (p.peekNextToken(""show-aa"")) {
            UI.printWarning(Module.API, ""Deprecated: show-aa ignored"");
            p.getNextBoolean();
        }
        if (p.peekNextToken(""output"")) {
            UI.printWarning(Module.API, ""Deprecated: output statement ignored"");
            p.getNextToken();
        }
        api.options(SunflowAPI.DEFAULT_OPTIONS);
        p.checkNextToken(""}"");
    }"
org.sunflow.core.parser.SCParser.parseBackgroundBlock,"    private void parseBackgroundBlock(SunflowAPI api) throws IOException, ParserException {
        p.checkNextToken(""{"");
        p.checkNextToken(""color"");
        api.parameter(""color"", parseColor());
        api.shader(""background.shader"", new ConstantShader());
        api.geometry(""background"", new Background());
        api.parameter(""shaders"", ""background.shader"");
        api.instance(""background.instance"", ""background"");
        p.checkNextToken(""}"");
    }"
org.sunflow.core.parser.SCParser.parseFilter,"    private void parseFilter(SunflowAPI api) throws IOException, ParserException {
        UI.printWarning(Module.API, ""Deprecated keyword \""filter\"" - set this option in the image block"");
        String name = p.getNextToken();
        api.parameter(""filter"", name);
        api.options(SunflowAPI.DEFAULT_OPTIONS);
        boolean hasSizeParams = name.equals(""box"") || name.equals(""gaussian"") || name.equals(""blackman-harris"") || name.equals(""sinc"") || name.equals(""triangle"");
        if (hasSizeParams) {
            p.getNextFloat();
            p.getNextFloat();
        }
    }"
org.sunflow.core.parser.SCParser.parsePhotonBlock,"    private void parsePhotonBlock(SunflowAPI api) throws ParserException, IOException {
        int numEmit = 0;
        boolean globalEmit = false;
        p.checkNextToken(""{"");
        if (p.peekNextToken(""emit"")) {
            UI.printWarning(Module.API, ""Shared photon emit values are deprectated - specify number of photons to emit per map"");
            numEmit = p.getNextInt();
            globalEmit = true;
        }
        if (p.peekNextToken(""global"")) {
            UI.printWarning(Module.API, ""Global photon map setting belonds inside the gi block - ignoring"");
            if (!globalEmit)
                p.getNextInt();
            p.getNextToken();
            p.getNextInt();
            p.getNextFloat();
        }
        p.checkNextToken(""caustics"");
        if (!globalEmit)
            numEmit = p.getNextInt();
        api.parameter(""caustics.emit"", numEmit);
        api.parameter(""caustics"", p.getNextToken());
        api.parameter(""caustics.gather"", p.getNextInt());
        api.parameter(""caustics.radius"", p.getNextFloat());
        api.options(SunflowAPI.DEFAULT_OPTIONS);
        p.checkNextToken(""}"");
    }"
org.sunflow.core.parser.SCParser.parseGIBlock,"    private void parseGIBlock(SunflowAPI api) throws ParserException, IOException {
        p.checkNextToken(""{"");
        p.checkNextToken(""type"");
        if (p.peekNextToken(""irr-cache"")) {
            api.parameter(""gi.engine"", ""irr-cache"");
            p.checkNextToken(""samples"");
            api.parameter(""gi.irr-cache.samples"", p.getNextInt());
            p.checkNextToken(""tolerance"");
            api.parameter(""gi.irr-cache.tolerance"", p.getNextFloat());
            p.checkNextToken(""spacing"");
            api.parameter(""gi.irr-cache.min_spacing"", p.getNextFloat());
            api.parameter(""gi.irr-cache.max_spacing"", p.getNextFloat());
            // parse global photon map info
            if (p.peekNextToken(""global"")) {
                api.parameter(""gi.irr-cache.gmap.emit"", p.getNextInt());
                api.parameter(""gi.irr-cache.gmap"", p.getNextToken());
                api.parameter(""gi.irr-cache.gmap.gather"", p.getNextInt());
                api.parameter(""gi.irr-cache.gmap.radius"", p.getNextFloat());
            }
        } else if (p.peekNextToken(""path"")) {
            api.parameter(""gi.engine"", ""path"");
            p.checkNextToken(""samples"");
            api.parameter(""gi.path.samples"", p.getNextInt());
            if (p.peekNextToken(""bounces"")) {
                UI.printWarning(Module.API, ""Deprecated setting: bounces - use diffuse trace depth instead"");
                p.getNextInt();
            }
        } else if (p.peekNextToken(""fake"")) {
            api.parameter(""gi.engine"", ""fake"");
            p.checkNextToken(""up"");
            api.parameter(""gi.fake.up"", parseVector());
            p.checkNextToken(""sky"");
            api.parameter(""gi.fake.sky"", parseColor());
            p.checkNextToken(""ground"");
            api.parameter(""gi.fake.ground"", parseColor());
        } else if (p.peekNextToken(""igi"")) {
            api.parameter(""gi.engine"", ""igi"");
            p.checkNextToken(""samples"");
            api.parameter(""gi.igi.samples"", p.getNextInt());
            p.checkNextToken(""sets"");
            api.parameter(""gi.igi.sets"", p.getNextInt());
            if (!p.peekNextToken(""b""))
                p.checkNextToken(""c"");
            api.parameter(""gi.igi.c"", p.getNextFloat());
            p.checkNextToken(""bias-samples"");
            api.parameter(""gi.igi.bias_samples"", p.getNextInt());
        } else if (p.peekNextToken(""ambocc"")) {
            api.parameter(""gi.engine"", ""ambocc"");
            p.checkNextToken(""bright"");
            api.parameter(""gi.ambocc.bright"", parseColor());
            p.checkNextToken(""dark"");
            api.parameter(""gi.ambocc.dark"", parseColor());
            p.checkNextToken(""samples"");
            api.parameter(""gi.ambocc.samples"", p.getNextInt());
            if (p.peekNextToken(""maxdist""))
                api.parameter(""gi.ambocc.maxdist"", p.getNextFloat());
        } else if (p.peekNextToken(""none"") || p.peekNextToken(""null"")) {
            // disable GI
            api.parameter(""gi.engine"", ""none"");
        } else
            UI.printWarning(Module.API, ""Unrecognized gi engine type \""%s\"" - ignoring"", p.getNextToken());
        api.options(SunflowAPI.DEFAULT_OPTIONS);
        p.checkNextToken(""}"");
    }"
org.sunflow.core.parser.SCParser.parseLightserverBlock,"    private void parseLightserverBlock(SunflowAPI api) throws ParserException, IOException {
        p.checkNextToken(""{"");
        if (p.peekNextToken(""shadows"")) {
            UI.printWarning(Module.API, ""Deprecated: shadows setting ignored"");
            p.getNextBoolean();
        }
        if (p.peekNextToken(""direct-samples"")) {
            UI.printWarning(Module.API, ""Deprecated: use samples keyword in area light definitions"");
            numLightSamples = p.getNextInt();
        }
        if (p.peekNextToken(""glossy-samples"")) {
            UI.printWarning(Module.API, ""Deprecated: use samples keyword in glossy shader definitions"");
            p.getNextInt();
        }
        if (p.peekNextToken(""max-depth"")) {
            UI.printWarning(Module.API, ""Deprecated: max-depth setting - use trace-depths block instead"");
            int d = p.getNextInt();
            api.parameter(""depths.diffuse"", 1);
            api.parameter(""depths.reflection"", d - 1);
            api.parameter(""depths.refraction"", 0);
            api.options(SunflowAPI.DEFAULT_OPTIONS);
        }
        if (p.peekNextToken(""global"")) {
            UI.printWarning(Module.API, ""Deprecated: global settings ignored - use photons block instead"");
            p.getNextBoolean();
            p.getNextInt();
            p.getNextInt();
            p.getNextInt();
            p.getNextFloat();
        }
        if (p.peekNextToken(""caustics"")) {
            UI.printWarning(Module.API, ""Deprecated: caustics settings ignored - use photons block instead"");
            p.getNextBoolean();
            p.getNextInt();
            p.getNextFloat();
            p.getNextInt();
            p.getNextFloat();
        }
        if (p.peekNextToken(""irr-cache"")) {
            UI.printWarning(Module.API, ""Deprecated: irradiance cache settings ignored - use gi block instead"");
            p.getNextInt();
            p.getNextFloat();
            p.getNextFloat();
            p.getNextFloat();
        }
        p.checkNextToken(""}"");
    }"
org.sunflow.core.parser.SCParser.parseTraceBlock,"    private void parseTraceBlock(SunflowAPI api) throws ParserException, IOException {
        p.checkNextToken(""{"");
        if (p.peekNextToken(""diff""))
            api.parameter(""depths.diffuse"", p.getNextInt());
        if (p.peekNextToken(""refl""))
            api.parameter(""depths.reflection"", p.getNextInt());
        if (p.peekNextToken(""refr""))
            api.parameter(""depths.refraction"", p.getNextInt());
        p.checkNextToken(""}"");
        api.options(SunflowAPI.DEFAULT_OPTIONS);
    }"
org.sunflow.core.parser.SCParser.parseCamera,"    private void parseCamera(SunflowAPI api) throws ParserException, IOException {
        p.checkNextToken(""{"");
        p.checkNextToken(""type"");
        String name = null;
        if (p.peekNextToken(""pinhole"")) {
            UI.printInfo(Module.API, ""Reading pinhole camera ..."");
            p.checkNextToken(""eye"");
            api.parameter(""eye"", parsePoint());
            p.checkNextToken(""target"");
            api.parameter(""target"", parsePoint());
            p.checkNextToken(""up"");
            api.parameter(""up"", parseVector());
            p.checkNextToken(""fov"");
            api.parameter(""fov"", p.getNextFloat());
            p.checkNextToken(""aspect"");
            api.parameter(""aspect"", p.getNextFloat());
            name = api.getUniqueName(""camera"");
            api.camera(name, new PinholeLens());
        } else if (p.peekNextToken(""thinlens"")) {
            UI.printInfo(Module.API, ""Reading thinlens camera ..."");
            p.checkNextToken(""eye"");
            api.parameter(""eye"", parsePoint());
            p.checkNextToken(""target"");
            api.parameter(""target"", parsePoint());
            p.checkNextToken(""up"");
            api.parameter(""up"", parseVector());
            p.checkNextToken(""fov"");
            api.parameter(""fov"", p.getNextFloat());
            p.checkNextToken(""aspect"");
            api.parameter(""aspect"", p.getNextFloat());
            p.checkNextToken(""fdist"");
            api.parameter(""focus.distance"", p.getNextFloat());
            p.checkNextToken(""lensr"");
            api.parameter(""lens.radius"", p.getNextFloat());
            if (p.peekNextToken(""sides""))
                api.parameter(""lens.sides"", p.getNextInt());
            if (p.peekNextToken(""rotation""))
                api.parameter(""lens.rotation"", p.getNextFloat());
            name = api.getUniqueName(""camera"");
            api.camera(name, new ThinLens());
        } else if (p.peekNextToken(""spherical"")) {
            UI.printInfo(Module.API, ""Reading spherical camera ..."");
            p.checkNextToken(""eye"");
            api.parameter(""eye"", parsePoint());
            p.checkNextToken(""target"");
            api.parameter(""target"", parsePoint());
            p.checkNextToken(""up"");
            api.parameter(""up"", parseVector());
            name = api.getUniqueName(""camera"");
            api.camera(name, new SphericalLens());
        } else if (p.peekNextToken(""fisheye"")) {
            UI.printInfo(Module.API, ""Reading spherical camera ..."");
            p.checkNextToken(""eye"");
            api.parameter(""eye"", parsePoint());
            p.checkNextToken(""target"");
            api.parameter(""target"", parsePoint());
            p.checkNextToken(""up"");
            api.parameter(""up"", parseVector());
            name = api.getUniqueName(""camera"");
            api.camera(name, new FisheyeLens());
        } else
            UI.printWarning(Module.API, ""Unrecognized camera type: %s"", p.getNextToken());
        p.checkNextToken(""}"");
        if (name != null) {
            api.parameter(""camera"", name);
            api.options(SunflowAPI.DEFAULT_OPTIONS);
        }
    }"
org.sunflow.core.parser.SCParser.parseShader,"    private boolean parseShader(SunflowAPI api) throws ParserException, IOException {
        p.checkNextToken(""{"");
        p.checkNextToken(""name"");
        String name = p.getNextToken();
        UI.printInfo(Module.API, ""Reading shader: %s ..."", name);
        p.checkNextToken(""type"");
        if (p.peekNextToken(""diffuse"")) {
            if (p.peekNextToken(""diff"")) {
                api.parameter(""diffuse"", parseColor());
                api.shader(name, new DiffuseShader());
            } else if (p.peekNextToken(""texture"")) {
                api.parameter(""texture"", p.getNextToken());
                api.shader(name, new TexturedDiffuseShader());
            } else
                UI.printWarning(Module.API, ""Unrecognized option in diffuse shader block: %s"", p.getNextToken());
        } else if (p.peekNextToken(""phong"")) {
            String tex = null;
            if (p.peekNextToken(""texture""))
                api.parameter(""texture"", tex = p.getNextToken());
            else {
                p.checkNextToken(""diff"");
                api.parameter(""diffuse"", parseColor());
            }
            p.checkNextToken(""spec"");
            api.parameter(""specular"", parseColor());
            api.parameter(""power"", p.getNextFloat());
            if (p.peekNextToken(""samples""))
                api.parameter(""samples"", p.getNextInt());
            if (tex != null)
                api.shader(name, new TexturedPhongShader());
            else
                api.shader(name, new PhongShader());
        } else if (p.peekNextToken(""amb-occ"") || p.peekNextToken(""amb-occ2"")) {
            String tex = null;
            if (p.peekNextToken(""diff"") || p.peekNextToken(""bright""))
                api.parameter(""bright"", parseColor());
            else if (p.peekNextToken(""texture""))
                api.parameter(""texture"", tex = p.getNextToken());
            if (p.peekNextToken(""dark"")) {
                api.parameter(""dark"", parseColor());
                p.checkNextToken(""samples"");
                api.parameter(""samples"", p.getNextInt());
                p.checkNextToken(""dist"");
                api.parameter(""maxdist"", p.getNextFloat());
            }
            if (tex == null)
                api.shader(name, new AmbientOcclusionShader());
            else
                api.shader(name, new TexturedAmbientOcclusionShader());
        } else if (p.peekNextToken(""mirror"")) {
            p.checkNextToken(""refl"");
            api.parameter(""color"", parseColor());
            api.shader(name, new MirrorShader());
        } else if (p.peekNextToken(""glass"")) {
            p.checkNextToken(""eta"");
            api.parameter(""eta"", p.getNextFloat());
            p.checkNextToken(""color"");
            api.parameter(""color"", parseColor());
            if (p.peekNextToken(""absorbtion.distance""))
                api.parameter(""absorbtion.distance"", p.getNextFloat());
            if (p.peekNextToken(""absorbtion.color""))
                api.parameter(""absorbtion.color"", parseColor());
            api.shader(name, new GlassShader());
        } else if (p.peekNextToken(""shiny"")) {
            String tex = null;
            if (p.peekNextToken(""texture""))
                api.parameter(""texture"", tex = p.getNextToken());
            else {
                p.checkNextToken(""diff"");
                api.parameter(""diffuse"", parseColor());
            }
            p.checkNextToken(""refl"");
            api.parameter(""shiny"", p.getNextFloat());
            if (tex == null)
                api.shader(name, new ShinyDiffuseShader());
            else
                api.shader(name, new TexturedShinyDiffuseShader());
        } else if (p.peekNextToken(""ward"")) {
            String tex = null;
            if (p.peekNextToken(""texture""))
                api.parameter(""texture"", tex = p.getNextToken());
            else {
                p.checkNextToken(""diff"");
                api.parameter(""diffuse"", parseColor());
            }
            p.checkNextToken(""spec"");
            api.parameter(""specular"", parseColor());
            p.checkNextToken(""rough"");
            api.parameter(""roughnessX"", p.getNextFloat());
            api.parameter(""roughnessY"", p.getNextFloat());
            if (p.peekNextToken(""samples""))
                api.parameter(""samples"", p.getNextInt());
            if (tex != null)
                api.shader(name, new TexturedWardShader());
            else
                api.shader(name, new AnisotropicWardShader());
        } else if (p.peekNextToken(""view-caustics"")) {
            api.shader(name, new ViewCausticsShader());
        } else if (p.peekNextToken(""view-irradiance"")) {
            api.shader(name, new ViewIrradianceShader());
        } else if (p.peekNextToken(""view-global"")) {
            api.shader(name, new ViewGlobalPhotonsShader());
        } else if (p.peekNextToken(""constant"")) {
            // backwards compatibility -- peek only
            p.peekNextToken(""color"");
            api.parameter(""color"", parseColor());
            api.shader(name, new ConstantShader());
        } else if (p.peekNextToken(""janino"")) {
            String code = p.getNextCodeBlock();
            try {
                Shader shader = (Shader) ClassBodyEvaluator.createFastClassBodyEvaluator(new Scanner(null, new StringReader(code)), Shader.class, ClassLoader.getSystemClassLoader());
                api.shader(name, shader);
            } catch (CompileException e) {
                UI.printDetailed(Module.API, ""Compiling: %s"", code);
                UI.printError(Module.API, ""%s"", e.getMessage());
                e.printStackTrace();
                return false;
            } catch (ParseException e) {
                UI.printDetailed(Module.API, ""Compiling: %s"", code);
                UI.printError(Module.API, ""%s"", e.getMessage());
                e.printStackTrace();
                return false;
            } catch (ScanException e) {
                UI.printDetailed(Module.API, ""Compiling: %s"", code);
                UI.printError(Module.API, ""%s"", e.getMessage());
                e.printStackTrace();
                return false;
            } catch (IOException e) {
                UI.printDetailed(Module.API, ""Compiling: %s"", code);
                UI.printError(Module.API, ""%s"", e.getMessage());
                e.printStackTrace();
                return false;
            }
        } else if (p.peekNextToken(""id"")) {
            api.shader(name, new IDShader());
        } else if (p.peekNextToken(""uber"")) {
            if (p.peekNextToken(""diff""))
                api.parameter(""diffuse"", parseColor());
            if (p.peekNextToken(""diff.texture""))
                api.parameter(""diffuse.texture"", p.getNextToken());
            if (p.peekNextToken(""diff.blend""))
                api.parameter(""diffuse.blend"", p.getNextFloat());
            if (p.peekNextToken(""refl"") || p.peekNextToken(""spec""))
                api.parameter(""specular"", parseColor());
            if (p.peekNextToken(""texture"")) {
                // deprecated
                UI.printWarning(Module.API, ""Deprecated uber shader parameter \""texture\"" - please use \""diffuse.texture\"" and \""diffuse.blend\"" instead"");
                api.parameter(""diffuse.texture"", p.getNextToken());
                api.parameter(""diffuse.blend"", p.getNextFloat());
            }
            if (p.peekNextToken(""spec.texture""))
                api.parameter(""specular.texture"", p.getNextToken());
            if (p.peekNextToken(""spec.blend""))
                api.parameter(""specular.blend"", p.getNextFloat());
            if (p.peekNextToken(""glossy""))
                api.parameter(""glossyness"", p.getNextFloat());
            if (p.peekNextToken(""samples""))
                api.parameter(""samples"", p.getNextInt());
            api.shader(name, new UberShader());
        } else
            UI.printWarning(Module.API, ""Unrecognized shader type: %s"", p.getNextToken());
        p.checkNextToken(""}"");
        return true;
    }"
org.sunflow.core.parser.SCParser.parseModifier,"    private boolean parseModifier(SunflowAPI api) throws ParserException, IOException {
        p.checkNextToken(""{"");
        p.checkNextToken(""name"");
        String name = p.getNextToken();
        UI.printInfo(Module.API, ""Reading shader: %s ..."", name);
        p.checkNextToken(""type"");
        if (p.peekNextToken(""bump"")) {
            p.checkNextToken(""texture"");
            api.parameter(""texture"", p.getNextToken());
            p.checkNextToken(""scale"");
            api.parameter(""scale"", p.getNextFloat());
            api.modifier(name, new BumpMappingModifier());
        } else if (p.peekNextToken(""normalmap"")) {
            p.checkNextToken(""texture"");
            api.parameter(""texture"", p.getNextToken());
            api.modifier(name, new NormalMapModifier());
        } else {
            UI.printWarning(Module.API, ""Unrecognized modifier type: %s"", p.getNextToken());
        }
        p.checkNextToken(""}"");
        return true;
    }"
org.sunflow.core.parser.SCParser.parseObjectBlock,"    private void parseObjectBlock(SunflowAPI api) throws ParserException, IOException {
        p.checkNextToken(""{"");
        boolean noInstance = false;
        Matrix4 transform = null;
        String name = null;
        String[] shaders = null;
        String[] modifiers = null;
        if (p.peekNextToken(""noinstance"")) {
            // this indicates that the geometry is to be created, but not
            // instanced into the scene
            noInstance = true;
        } else {
            // these are the parameters to be passed to the instance
            if (p.peekNextToken(""shaders"")) {
                int n = p.getNextInt();
                shaders = new String[n];
                for (int i = 0; i < n; i++)
                    shaders[i] = p.getNextToken();
            } else {
                p.checkNextToken(""shader"");
                shaders = new String[] { p.getNextToken() };
            }
            if (p.peekNextToken(""modifiers"")) {
                int n = p.getNextInt();
                modifiers = new String[n];
                for (int i = 0; i < n; i++)
                    modifiers[i] = p.getNextToken();
            } else if (p.peekNextToken(""modifier""))
                modifiers = new String[] { p.getNextToken() };
            if (p.peekNextToken(""transform""))
                transform = parseMatrix();
        }
        if (p.peekNextToken(""accel""))
            api.parameter(""accel"", p.getNextToken());
        p.checkNextToken(""type"");
        String type = p.getNextToken();
        if (p.peekNextToken(""name""))
            name = p.getNextToken();
        else
            name = api.getUniqueName(type);
        if (type.equals(""mesh"")) {
            UI.printWarning(Module.API, ""Deprecated object type: mesh"");
            UI.printInfo(Module.API, ""Reading mesh: %s ..."", name);
            int numVertices = p.getNextInt();
            int numTriangles = p.getNextInt();
            float[] points = new float[numVertices * 3];
            float[] normals = new float[numVertices * 3];
            float[] uvs = new float[numVertices * 2];
            for (int i = 0; i < numVertices; i++) {
                p.checkNextToken(""v"");
                points[3 * i + 0] = p.getNextFloat();
                points[3 * i + 1] = p.getNextFloat();
                points[3 * i + 2] = p.getNextFloat();
                normals[3 * i + 0] = p.getNextFloat();
                normals[3 * i + 1] = p.getNextFloat();
                normals[3 * i + 2] = p.getNextFloat();
                uvs[2 * i + 0] = p.getNextFloat();
                uvs[2 * i + 1] = p.getNextFloat();
            }
            int[] triangles = new int[numTriangles * 3];
            for (int i = 0; i < numTriangles; i++) {
                p.checkNextToken(""t"");
                triangles[i * 3 + 0] = p.getNextInt();
                triangles[i * 3 + 1] = p.getNextInt();
                triangles[i * 3 + 2] = p.getNextInt();
            }
            // create geometry
            api.parameter(""triangles"", triangles);
            api.parameter(""points"", ""point"", ""vertex"", points);
            api.parameter(""normals"", ""vector"", ""vertex"", normals);
            api.parameter(""uvs"", ""texcoord"", ""vertex"", uvs);
            api.geometry(name, new TriangleMesh());
        } else if (type.equals(""flat-mesh"")) {
            UI.printWarning(Module.API, ""Deprecated object type: flat-mesh"");
            UI.printInfo(Module.API, ""Reading flat mesh: %s ..."", name);
            int numVertices = p.getNextInt();
            int numTriangles = p.getNextInt();
            float[] points = new float[numVertices * 3];
            float[] uvs = new float[numVertices * 2];
            for (int i = 0; i < numVertices; i++) {
                p.checkNextToken(""v"");
                points[3 * i + 0] = p.getNextFloat();
                points[3 * i + 1] = p.getNextFloat();
                points[3 * i + 2] = p.getNextFloat();
                p.getNextFloat();
                p.getNextFloat();
                p.getNextFloat();
                uvs[2 * i + 0] = p.getNextFloat();
                uvs[2 * i + 1] = p.getNextFloat();
            }
            int[] triangles = new int[numTriangles * 3];
            for (int i = 0; i < numTriangles; i++) {
                p.checkNextToken(""t"");
                triangles[i * 3 + 0] = p.getNextInt();
                triangles[i * 3 + 1] = p.getNextInt();
                triangles[i * 3 + 2] = p.getNextInt();
            }
            // create geometry
            api.parameter(""triangles"", triangles);
            api.parameter(""points"", ""point"", ""vertex"", points);
            api.parameter(""uvs"", ""texcoord"", ""vertex"", uvs);
            api.geometry(name, new TriangleMesh());
        } else if (type.equals(""sphere"")) {
            UI.printInfo(Module.API, ""Reading sphere ..."");
            api.geometry(name, new Sphere());
            if (transform == null && !noInstance) {
                // legacy method of specifying transformation for spheres
                p.checkNextToken(""c"");
                float x = p.getNextFloat();
                float y = p.getNextFloat();
                float z = p.getNextFloat();
                p.checkNextToken(""r"");
                float radius = p.getNextFloat();
                api.parameter(""transform"", Matrix4.translation(x, y, z).multiply(Matrix4.scale(radius)));
                api.parameter(""shaders"", shaders);
                if (modifiers != null)
                    api.parameter(""modifiers"", modifiers);
                api.instance(name + "".instance"", name);
                noInstance = true; // disable future auto-instancing because
                // instance has already been created
            }
        } else if (type.equals(""banchoff"")) {
            UI.printInfo(Module.API, ""Reading banchoff ..."");
            api.geometry(name, new BanchoffSurface());
        } else if (type.equals(""torus"")) {
            UI.printInfo(Module.API, ""Reading torus ..."");
            p.checkNextToken(""r"");
            api.parameter(""radiusInner"", p.getNextFloat());
            api.parameter(""radiusOuter"", p.getNextFloat());
            api.geometry(name, new Torus());
        } else if (type.equals(""plane"")) {
            UI.printInfo(Module.API, ""Reading plane ..."");
            p.checkNextToken(""p"");
            api.parameter(""center"", parsePoint());
            if (p.peekNextToken(""n"")) {
                api.parameter(""normal"", parseVector());
            } else {
                p.checkNextToken(""p"");
                api.parameter(""point1"", parsePoint());
                p.checkNextToken(""p"");
                api.parameter(""point2"", parsePoint());
            }
            api.geometry(name, new Plane());
        } else if (type.equals(""cornellbox"")) {
            UI.printInfo(Module.API, ""Reading cornell box ..."");
            if (transform != null)
                UI.printWarning(Module.API, ""Instancing is not supported on cornell box -- ignoring transform"");
            p.checkNextToken(""corner0"");
            api.parameter(""corner0"", parsePoint());
            p.checkNextToken(""corner1"");
            api.parameter(""corner1"", parsePoint());
            p.checkNextToken(""left"");
            api.parameter(""leftColor"", parseColor());
            p.checkNextToken(""right"");
            api.parameter(""rightColor"", parseColor());
            p.checkNextToken(""top"");
            api.parameter(""topColor"", parseColor());
            p.checkNextToken(""bottom"");
            api.parameter(""bottomColor"", parseColor());
            p.checkNextToken(""back"");
            api.parameter(""backColor"", parseColor());
            p.checkNextToken(""emit"");
            api.parameter(""radiance"", parseColor());
            if (p.peekNextToken(""samples""))
                api.parameter(""samples"", p.getNextInt());
            new CornellBox().init(name, api);
            noInstance = true; // instancing is handled natively by the init
            // method
        } else if (type.equals(""generic-mesh"")) {
            UI.printInfo(Module.API, ""Reading generic mesh: %s ... "", name);
            // parse vertices
            p.checkNextToken(""points"");
            int np = p.getNextInt();
            api.parameter(""points"", ""point"", ""vertex"", parseFloatArray(np * 3));
            // parse triangle indices
            p.checkNextToken(""triangles"");
            int nt = p.getNextInt();
            api.parameter(""triangles"", parseIntArray(nt * 3));
            // parse normals
            p.checkNextToken(""normals"");
            if (p.peekNextToken(""vertex""))
                api.parameter(""normals"", ""vector"", ""vertex"", parseFloatArray(np * 3));
            else if (p.peekNextToken(""facevarying""))
                api.parameter(""normals"", ""vector"", ""facevarying"", parseFloatArray(nt * 9));
            else
                p.checkNextToken(""none"");
            // parse texture coordinates
            p.checkNextToken(""uvs"");
            if (p.peekNextToken(""vertex""))
                api.parameter(""uvs"", ""texcoord"", ""vertex"", parseFloatArray(np * 2));
            else if (p.peekNextToken(""facevarying""))
                api.parameter(""uvs"", ""texcoord"", ""facevarying"", parseFloatArray(nt * 6));
            else
                p.checkNextToken(""none"");
            if (p.peekNextToken(""face_shaders""))
                api.parameter(""faceshaders"", parseIntArray(nt));
            api.geometry(name, new TriangleMesh());
        } else if (type.equals(""hair"")) {
            UI.printInfo(Module.API, ""Reading hair curves: %s ... "", name);
            p.checkNextToken(""segments"");
            api.parameter(""segments"", p.getNextInt());
            p.checkNextToken(""width"");
            api.parameter(""widths"", p.getNextFloat());
            p.checkNextToken(""points"");
            api.parameter(""points"", ""point"", ""vertex"", parseFloatArray(p.getNextInt()));
            api.geometry(name, new Hair());
        } else if (type.equals(""janino-tesselatable"")) {
            UI.printInfo(Module.API, ""Reading procedural primitive: %s ... "", name);
            String code = p.getNextCodeBlock();
            try {
                Tesselatable tess = (Tesselatable) ClassBodyEvaluator.createFastClassBodyEvaluator(new Scanner(null, new StringReader(code)), Tesselatable.class, ClassLoader.getSystemClassLoader());
                api.geometry(name, tess);
            } catch (CompileException e) {
                UI.printDetailed(Module.API, ""Compiling: %s"", code);
                UI.printError(Module.API, ""%s"", e.getMessage());
                e.printStackTrace();
                noInstance = true;
            } catch (ParseException e) {
                UI.printDetailed(Module.API, ""Compiling: %s"", code);
                UI.printError(Module.API, ""%s"", e.getMessage());
                e.printStackTrace();
                noInstance = true;
            } catch (ScanException e) {
                UI.printDetailed(Module.API, ""Compiling: %s"", code);
                UI.printError(Module.API, ""%s"", e.getMessage());
                e.printStackTrace();
                noInstance = true;
            } catch (IOException e) {
                UI.printDetailed(Module.API, ""Compiling: %s"", code);
                UI.printError(Module.API, ""%s"", e.getMessage());
                e.printStackTrace();
                noInstance = true;
            }
        } else if (type.equals(""teapot"")) {
            UI.printInfo(Module.API, ""Reading teapot: %s ... "", name);
            boolean hasTesselationArguments = false;
            if (p.peekNextToken(""subdivs"")) {
                api.parameter(""subdivs"", p.getNextInt());
                hasTesselationArguments = true;
            }
            if (p.peekNextToken(""smooth"")) {
                api.parameter(""smooth"", p.getNextBoolean());
                hasTesselationArguments = true;
            }
            if (hasTesselationArguments)
                api.geometry(name, (Tesselatable) new Teapot());
            else
                api.geometry(name, (PrimitiveList) new Teapot());
        } else if (type.equals(""gumbo"")) {
            UI.printInfo(Module.API, ""Reading gumbo: %s ... "", name);
            boolean hasTesselationArguments = false;
            if (p.peekNextToken(""subdivs"")) {
                api.parameter(""subdivs"", p.getNextInt());
                hasTesselationArguments = true;
            }
            if (p.peekNextToken(""smooth"")) {
                api.parameter(""smooth"", p.getNextBoolean());
                hasTesselationArguments = true;
            }
            if (hasTesselationArguments)
                api.geometry(name, (Tesselatable) new Gumbo());
            else
                api.geometry(name, (PrimitiveList) new Gumbo());
        } else if (type.equals(""julia"")) {
            UI.printInfo(Module.API, ""Reading julia fractal: %s ... "", name);
            if (p.peekNextToken(""q"")) {
                api.parameter(""cw"", p.getNextFloat());
                api.parameter(""cx"", p.getNextFloat());
                api.parameter(""cy"", p.getNextFloat());
                api.parameter(""cz"", p.getNextFloat());
            }
            if (p.peekNextToken(""iterations""))
                api.parameter(""iterations"", p.getNextInt());
            if (p.peekNextToken(""epsilon""))
                api.parameter(""epsilon"", p.getNextFloat());
            api.geometry(name, new JuliaFractal());
        } else if (type.equals(""particles"") || type.equals(""dlasurface"")) {
            if (type.equals(""dlasurface""))
                UI.printWarning(Module.API, ""Deprecated object type: \""dlasurface\"" - please use \""particles\"" instead"");
            p.checkNextToken(""filename"");
            String filename = p.getNextToken();
            boolean littleEndian = false;
            if (p.peekNextToken(""little_endian""))
                littleEndian = true;
            UI.printInfo(Module.USER, ""Loading particle file: %s"", filename);
            File file = new File(filename);
            FileInputStream stream = new FileInputStream(filename);
            MappedByteBuffer map = stream.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length());
            if (littleEndian)
                map.order(ByteOrder.LITTLE_ENDIAN);
            FloatBuffer buffer = map.asFloatBuffer();
            float[] data = new float[buffer.capacity()];
            for (int i = 0; i < data.length; i++)
                data[i] = buffer.get(i);
            stream.close();
            api.parameter(""particles"", ""point"", ""vertex"", data);
            if (p.peekNextToken(""num""))
                api.parameter(""num"", p.getNextInt());
            else
                api.parameter(""num"", data.length / 3);
            p.checkNextToken(""radius"");
            api.parameter(""radius"", p.getNextFloat());
            api.geometry(name, new ParticleSurface());
        } else if (type.equals(""file-mesh"")) {
            UI.printInfo(Module.API, ""Reading file mesh: %s ... "", name);
            p.checkNextToken(""filename"");
            api.parameter(""filename"", p.getNextToken());
            api.geometry(name, new FileMesh());
        } else {
            UI.printWarning(Module.API, ""Unrecognized object type: %s"", p.getNextToken());
            noInstance = true;
        }
        if (!noInstance) {
            // create instance
            api.parameter(""shaders"", shaders);
            if (modifiers != null)
                api.parameter(""modifiers"", modifiers);
            if (transform != null)
                api.parameter(""transform"", transform);
            api.instance(name + "".instance"", name);
        }
        p.checkNextToken(""}"");
    }"
org.sunflow.core.parser.SCParser.parseInstanceBlock,"    private void parseInstanceBlock(SunflowAPI api) throws ParserException, IOException {
        p.checkNextToken(""{"");
        p.checkNextToken(""name"");
        String name = p.getNextToken();
        UI.printInfo(Module.API, ""Reading instance: %s ..."", name);
        p.checkNextToken(""geometry"");
        String geoname = p.getNextToken();
        p.checkNextToken(""transform"");
        api.parameter(""transform"", parseMatrix());
        String[] shaders;
        if (p.peekNextToken(""shaders"")) {
            int n = p.getNextInt();
            shaders = new String[n];
            for (int i = 0; i < n; i++)
                shaders[i] = p.getNextToken();
        } else {
            p.checkNextToken(""shader"");
            shaders = new String[] { p.getNextToken() };
        }
        api.parameter(""shaders"", shaders);
        String[] modifiers = null;
        if (p.peekNextToken(""modifiers"")) {
            int n = p.getNextInt();
            modifiers = new String[n];
            for (int i = 0; i < n; i++)
                modifiers[i] = p.getNextToken();
        } else if (p.peekNextToken(""modifier""))
            modifiers = new String[] { p.getNextToken() };
        if (modifiers != null)
            api.parameter(""modifiers"", modifiers);
        api.instance(name, geoname);
        p.checkNextToken(""}"");
    }"
org.sunflow.core.parser.SCParser.parseLightBlock,"    private void parseLightBlock(SunflowAPI api) throws ParserException, IOException {
        p.checkNextToken(""{"");
        p.checkNextToken(""type"");
        if (p.peekNextToken(""mesh"")) {
            UI.printWarning(Module.API, ""Deprecated light type: mesh"");
            p.checkNextToken(""name"");
            String name = p.getNextToken();
            UI.printInfo(Module.API, ""Reading light mesh: %s ..."", name);
            p.checkNextToken(""emit"");
            api.parameter(""radiance"", parseColor());
            int samples = numLightSamples;
            if (p.peekNextToken(""samples""))
                samples = p.getNextInt();
            else
                UI.printWarning(Module.API, ""Samples keyword not found - defaulting to %d"", samples);
            api.parameter(""samples"", samples);
            int numVertices = p.getNextInt();
            int numTriangles = p.getNextInt();
            float[] points = new float[3 * numVertices];
            int[] triangles = new int[3 * numTriangles];
            for (int i = 0; i < numVertices; i++) {
                p.checkNextToken(""v"");
                points[3 * i + 0] = p.getNextFloat();
                points[3 * i + 1] = p.getNextFloat();
                points[3 * i + 2] = p.getNextFloat();
                // ignored
                p.getNextFloat();
                p.getNextFloat();
                p.getNextFloat();
                p.getNextFloat();
                p.getNextFloat();
            }
            for (int i = 0; i < numTriangles; i++) {
                p.checkNextToken(""t"");
                triangles[3 * i + 0] = p.getNextInt();
                triangles[3 * i + 1] = p.getNextInt();
                triangles[3 * i + 2] = p.getNextInt();
            }
            api.parameter(""points"", ""point"", ""vertex"", points);
            api.parameter(""triangles"", triangles);
            TriangleMeshLight mesh = new TriangleMeshLight();
            mesh.init(name, api);
        } else if (p.peekNextToken(""point"")) {
            UI.printInfo(Module.API, ""Reading point light ..."");
            Color pow;
            if (p.peekNextToken(""color"")) {
                pow = parseColor();
                p.checkNextToken(""power"");
                float po = p.getNextFloat();
                pow.mul(po);
            } else {
                UI.printWarning(Module.API, ""Deprecated color specification - please use color and power instead"");
                p.checkNextToken(""power"");
                pow = parseColor();
            }
            p.checkNextToken(""p"");
            float px = p.getNextFloat();
            float py = p.getNextFloat();
            float pz = p.getNextFloat();
            api.pointLight(api.getUniqueName(""pointLight""), px, py, pz, pow);
        } else if (p.peekNextToken(""spherical"")) {
            UI.printInfo(Module.API, ""Reading spherical light ..."");
            p.checkNextToken(""color"");
            Color pow = parseColor();
            p.checkNextToken(""radiance"");
            pow.mul(p.getNextFloat());
            api.parameter(""radiance"", pow);
            p.checkNextToken(""center"");
            api.parameter(""center"", parsePoint());
            p.checkNextToken(""radius"");
            api.parameter(""radius"", p.getNextFloat());
            p.checkNextToken(""samples"");
            api.parameter(""samples"", p.getNextInt());
            SphereLight light = new SphereLight();
            light.init(api.getUniqueName(""spherelight""), api);
        } else if (p.peekNextToken(""directional"")) {
            UI.printInfo(Module.API, ""Reading directional light ..."");
            p.checkNextToken(""source"");
            Point3 s = parsePoint();
            api.parameter(""source"", s);
            p.checkNextToken(""target"");
            Point3 t = parsePoint();
            api.parameter(""dir"", Point3.sub(t, s, new Vector3()));
            p.checkNextToken(""radius"");
            api.parameter(""radius"", p.getNextFloat());
            p.checkNextToken(""emit"");
            Color e = parseColor();
            if (p.peekNextToken(""intensity"")) {
                float i = p.getNextFloat();
                e.mul(i);
            } else
                UI.printWarning(Module.API, ""Deprecated color specification - please use emit and intensity instead"");
            api.parameter(""radiance"", e);
            api.light(api.getUniqueName(""dirlight""), new DirectionalSpotlight());
        } else if (p.peekNextToken(""ibl"")) {
            UI.printInfo(Module.API, ""Reading image based light ..."");
            p.checkNextToken(""image"");
            api.parameter(""texture"", p.getNextToken());
            p.checkNextToken(""center"");
            api.parameter(""center"", parseVector());
            p.checkNextToken(""up"");
            api.parameter(""up"", parseVector());
            p.checkNextToken(""lock"");
            api.parameter(""fixed"", p.getNextBoolean());
            int samples = numLightSamples;
            if (p.peekNextToken(""samples""))
                samples = p.getNextInt();
            else
                UI.printWarning(Module.API, ""Samples keyword not found - defaulting to %d"", samples);
            api.parameter(""samples"", samples);
            ImageBasedLight ibl = new ImageBasedLight();
            ibl.init(api.getUniqueName(""ibl""), api);
        } else if (p.peekNextToken(""meshlight"")) {
            p.checkNextToken(""name"");
            String name = p.getNextToken();
            UI.printInfo(Module.API, ""Reading meshlight: %s ..."", name);
            p.checkNextToken(""emit"");
            Color e = parseColor();
            if (p.peekNextToken(""radiance"")) {
                float r = p.getNextFloat();
                e.mul(r);
            } else
                UI.printWarning(Module.API, ""Deprecated color specification - please use emit and radiance instead"");
            api.parameter(""radiance"", e);
            int samples = numLightSamples;
            if (p.peekNextToken(""samples""))
                samples = p.getNextInt();
            else
                UI.printWarning(Module.API, ""Samples keyword not found - defaulting to %d"", samples);
            api.parameter(""samples"", samples);
            // parse vertices
            p.checkNextToken(""points"");
            int np = p.getNextInt();
            api.parameter(""points"", ""point"", ""vertex"", parseFloatArray(np * 3));
            // parse triangle indices
            p.checkNextToken(""triangles"");
            int nt = p.getNextInt();
            api.parameter(""triangles"", parseIntArray(nt * 3));
            TriangleMeshLight mesh = new TriangleMeshLight();
            mesh.init(name, api);
        } else if (p.peekNextToken(""sunsky"")) {
            p.checkNextToken(""up"");
            api.parameter(""up"", parseVector());
            p.checkNextToken(""east"");
            api.parameter(""east"", parseVector());
            p.checkNextToken(""sundir"");
            api.parameter(""sundir"", parseVector());
            p.checkNextToken(""turbidity"");
            api.parameter(""turbidity"", p.getNextFloat());
            if (p.peekNextToken(""samples""))
                api.parameter(""samples"", p.getNextInt());
            SunSkyLight sunsky = new SunSkyLight();
            sunsky.init(api.getUniqueName(""sunsky""), api);
        } else
            UI.printWarning(Module.API, ""Unrecognized object type: %s"", p.getNextToken());
        p.checkNextToken(""}"");
    }"
org.sunflow.core.parser.SCParser.parseColor,"    private Color parseColor() throws IOException, ParserException {
        if (p.peekNextToken(""{"")) {
            String space = p.getNextToken();
            Color c = null;
            if (space.equals(""sRGB nonlinear"")) {
                float r = p.getNextFloat();
                float g = p.getNextFloat();
                float b = p.getNextFloat();
                c = new Color(r, g, b);
                c.toLinear();
            } else if (space.equals(""sRGB linear"")) {
                float r = p.getNextFloat();
                float g = p.getNextFloat();
                float b = p.getNextFloat();
                c = new Color(r, g, b);
            } else
                UI.printWarning(Module.API, ""Unrecognized color space: %s"", space);
            p.checkNextToken(""}"");
            return c;
        } else {
            float r = p.getNextFloat();
            float g = p.getNextFloat();
            float b = p.getNextFloat();
            return new Color(r, g, b);
        }
    }"
org.sunflow.core.parser.SCParser.parsePoint,"    private Point3 parsePoint() throws IOException {
        float x = p.getNextFloat();
        float y = p.getNextFloat();
        float z = p.getNextFloat();
        return new Point3(x, y, z);
    }"
org.sunflow.core.parser.SCParser.parseVector,"    private Vector3 parseVector() throws IOException {
        float x = p.getNextFloat();
        float y = p.getNextFloat();
        float z = p.getNextFloat();
        return new Vector3(x, y, z);
    }"
org.sunflow.core.parser.SCParser.parseIntArray,"    private int[] parseIntArray(int size) throws IOException {
        int[] data = new int[size];
        for (int i = 0; i < size; i++)
            data[i] = p.getNextInt();
        return data;
    }"
org.sunflow.core.parser.SCParser.parseFloatArray,"    private float[] parseFloatArray(int size) throws IOException {
        float[] data = new float[size];
        for (int i = 0; i < size; i++)
            data[i] = p.getNextFloat();
        return data;
    }"
org.sunflow.core.parser.SCParser.parseMatrix,"    private Matrix4 parseMatrix() throws IOException, ParserException {
        if (p.peekNextToken(""row"")) {
            return new Matrix4(parseFloatArray(16), true);
        } else if (p.peekNextToken(""col"")) {
            return new Matrix4(parseFloatArray(16), false);
        } else {
            Matrix4 m = Matrix4.IDENTITY;
            p.checkNextToken(""{"");
            while (!p.peekNextToken(""}"")) {
                Matrix4 t = null;
                if (p.peekNextToken(""translate"")) {
                    float x = p.getNextFloat();
                    float y = p.getNextFloat();
                    float z = p.getNextFloat();
                    t = Matrix4.translation(x, y, z);
                } else if (p.peekNextToken(""scaleu"")) {
                    float s = p.getNextFloat();
                    t = Matrix4.scale(s);
                } else if (p.peekNextToken(""scale"")) {
                    float x = p.getNextFloat();
                    float y = p.getNextFloat();
                    float z = p.getNextFloat();
                    t = Matrix4.scale(x, y, z);
                } else if (p.peekNextToken(""rotatex"")) {
                    float angle = p.getNextFloat();
                    t = Matrix4.rotateX((float) Math.toRadians(angle));
                } else if (p.peekNextToken(""rotatey"")) {
                    float angle = p.getNextFloat();
                    t = Matrix4.rotateY((float) Math.toRadians(angle));
                } else if (p.peekNextToken(""rotatez"")) {
                    float angle = p.getNextFloat();
                    t = Matrix4.rotateZ((float) Math.toRadians(angle));
                } else if (p.peekNextToken(""rotate"")) {
                    float x = p.getNextFloat();
                    float y = p.getNextFloat();
                    float z = p.getNextFloat();
                    float angle = p.getNextFloat();
                    t = Matrix4.rotate(x, y, z, (float) Math.toRadians(angle));
                } else
                    UI.printWarning(Module.API, ""Unrecognized transformation type: %s"", p.getNextToken());
                if (t != null)
                    m = t.multiply(m);
            }
            return m;
        }
    }
"
org.sunflow.core.accel.UniformGrid.build,"    public void build(PrimitiveList primitives) {
        Timer t = new Timer();
        t.start();
        this.primitives = primitives;
        int n = primitives.getNumPrimitives();
        // compute bounds
        bounds = primitives.getWorldBounds(null);
        // create grid from number of objects
        bounds.enlargeUlps();
        Vector3 w = bounds.getExtents();
        double s = Math.pow((w.x * w.y * w.z) / n, 1 / 3.0);
        nx = MathUtils.clamp((int) ((w.x / s) + 0.5), 1, 128);
        ny = MathUtils.clamp((int) ((w.y / s) + 0.5), 1, 128);
        nz = MathUtils.clamp((int) ((w.z / s) + 0.5), 1, 128);
        voxelwx = w.x / nx;
        voxelwy = w.y / ny;
        voxelwz = w.z / nz;
        invVoxelwx = 1 / voxelwx;
        invVoxelwy = 1 / voxelwy;
        invVoxelwz = 1 / voxelwz;
        UI.printDetailed(Module.ACCEL, ""Creating grid: %dx%dx%d ..."", nx, ny, nz);
        IntArray[] buildCells = new IntArray[nx * ny * nz];
        // add all objects into the grid cells they overlap
        int[] imin = new int[3];
        int[] imax = new int[3];
        int numCellsPerObject = 0;
        for (int i = 0; i < n; i++) {
            getGridIndex(primitives.getPrimitiveBound(i, 0), primitives.getPrimitiveBound(i, 2), primitives.getPrimitiveBound(i, 4), imin);
            getGridIndex(primitives.getPrimitiveBound(i, 1), primitives.getPrimitiveBound(i, 3), primitives.getPrimitiveBound(i, 5), imax);
            for (int ix = imin[0]; ix <= imax[0]; ix++) {
                for (int iy = imin[1]; iy <= imax[1]; iy++) {
                    for (int iz = imin[2]; iz <= imax[2]; iz++) {
                        int idx = ix + (nx * iy) + (nx * ny * iz);
                        if (buildCells[idx] == null)
                            buildCells[idx] = new IntArray();
                        buildCells[idx].add(i);
                        numCellsPerObject++;
                    }
                }
            }
        }
        UI.printDetailed(Module.ACCEL, ""Building cells ..."");
        int numEmpty = 0;
        int numInFull = 0;
        cells = new int[nx * ny * nz][];
        int i = 0;
        for (IntArray cell : buildCells) {
            if (cell != null) {
                if (cell.getSize() == 0) {
                    numEmpty++;
                    cell = null;
                } else {
                    cells[i] = cell.trim();
                    numInFull += cell.getSize();
                }
            } else
                numEmpty++;
            i++;
        }
        t.end();
        UI.printDetailed(Module.ACCEL, ""Uniform grid statistics:"");
        UI.printDetailed(Module.ACCEL, ""  * Grid cells:          %d"", cells.length);
        UI.printDetailed(Module.ACCEL, ""  * Used cells:          %d"", cells.length - numEmpty);
        UI.printDetailed(Module.ACCEL, ""  * Empty cells:         %d"", numEmpty);
        UI.printDetailed(Module.ACCEL, ""  * Occupancy:           %.2f%%"", 100.0 * (cells.length - numEmpty) / cells.length);
        UI.printDetailed(Module.ACCEL, ""  * Objects/Cell:        %.2f"", (double) numInFull / (double) cells.length);
        UI.printDetailed(Module.ACCEL, ""  * Objects/Used Cell:   %.2f"", (double) numInFull / (double) (cells.length - numEmpty));
        UI.printDetailed(Module.ACCEL, ""  * Cells/Object:        %.2f"", (double) numCellsPerObject / (double) n);
        UI.printDetailed(Module.ACCEL, ""  * Build time:          %s"", t.toString());
    }"
org.sunflow.core.accel.UniformGrid.intersect,"    public void intersect(Ray r, IntersectionState state) {
        float intervalMin = r.getMin();
        float intervalMax = r.getMax();
        float orgX = r.ox;
        float dirX = r.dx, invDirX = 1 / dirX;
        float t1, t2;
        t1 = (bounds.getMinimum().x - orgX) * invDirX;
        t2 = (bounds.getMaximum().x - orgX) * invDirX;
        if (invDirX > 0) {
            if (t1 > intervalMin)
                intervalMin = t1;
            if (t2 < intervalMax)
                intervalMax = t2;
        } else {
            if (t2 > intervalMin)
                intervalMin = t2;
            if (t1 < intervalMax)
                intervalMax = t1;
        }
        if (intervalMin > intervalMax)
            return;
        float orgY = r.oy;
        float dirY = r.dy, invDirY = 1 / dirY;
        t1 = (bounds.getMinimum().y - orgY) * invDirY;
        t2 = (bounds.getMaximum().y - orgY) * invDirY;
        if (invDirY > 0) {
            if (t1 > intervalMin)
                intervalMin = t1;
            if (t2 < intervalMax)
                intervalMax = t2;
        } else {
            if (t2 > intervalMin)
                intervalMin = t2;
            if (t1 < intervalMax)
                intervalMax = t1;
        }
        if (intervalMin > intervalMax)
            return;
        float orgZ = r.oz;
        float dirZ = r.dz, invDirZ = 1 / dirZ;
        t1 = (bounds.getMinimum().z - orgZ) * invDirZ;
        t2 = (bounds.getMaximum().z - orgZ) * invDirZ;
        if (invDirZ > 0) {
            if (t1 > intervalMin)
                intervalMin = t1;
            if (t2 < intervalMax)
                intervalMax = t2;
        } else {
            if (t2 > intervalMin)
                intervalMin = t2;
            if (t1 < intervalMax)
                intervalMax = t1;
        }
        if (intervalMin > intervalMax)
            return;
        // box is hit at [intervalMin, intervalMax]
        orgX += intervalMin * dirX;
        orgY += intervalMin * dirY;
        orgZ += intervalMin * dirZ;
        // locate starting point inside the grid
        // and set up 3D-DDA vars
        int indxX, indxY, indxZ;
        int stepX, stepY, stepZ;
        int stopX, stopY, stopZ;
        float deltaX, deltaY, deltaZ;
        float tnextX, tnextY, tnextZ;
        // stepping factors along X
        indxX = (int) ((orgX - bounds.getMinimum().x) * invVoxelwx);
        if (indxX < 0)
            indxX = 0;
        else if (indxX >= nx)
            indxX = nx - 1;
        if (Math.abs(dirX) < 1e-6f) {
            stepX = 0;
            stopX = indxX;
            deltaX = 0;
            tnextX = Float.POSITIVE_INFINITY;
        } else if (dirX > 0) {
            stepX = 1;
            stopX = nx;
            deltaX = voxelwx * invDirX;
            tnextX = intervalMin + ((indxX + 1) * voxelwx + bounds.getMinimum().x - orgX) * invDirX;
        } else {
            stepX = -1;
            stopX = -1;
            deltaX = -voxelwx * invDirX;
            tnextX = intervalMin + (indxX * voxelwx + bounds.getMinimum().x - orgX) * invDirX;
        }
        // stepping factors along Y
        indxY = (int) ((orgY - bounds.getMinimum().y) * invVoxelwy);
        if (indxY < 0)
            indxY = 0;
        else if (indxY >= ny)
            indxY = ny - 1;
        if (Math.abs(dirY) < 1e-6f) {
            stepY = 0;
            stopY = indxY;
            deltaY = 0;
            tnextY = Float.POSITIVE_INFINITY;
        } else if (dirY > 0) {
            stepY = 1;
            stopY = ny;
            deltaY = voxelwy * invDirY;
            tnextY = intervalMin + ((indxY + 1) * voxelwy + bounds.getMinimum().y - orgY) * invDirY;
        } else {
            stepY = -1;
            stopY = -1;
            deltaY = -voxelwy * invDirY;
            tnextY = intervalMin + (indxY * voxelwy + bounds.getMinimum().y - orgY) * invDirY;
        }
        // stepping factors along Z
        indxZ = (int) ((orgZ - bounds.getMinimum().z) * invVoxelwz);
        if (indxZ < 0)
            indxZ = 0;
        else if (indxZ >= nz)
            indxZ = nz - 1;
        if (Math.abs(dirZ) < 1e-6f) {
            stepZ = 0;
            stopZ = indxZ;
            deltaZ = 0;
            tnextZ = Float.POSITIVE_INFINITY;
        } else if (dirZ > 0) {
            stepZ = 1;
            stopZ = nz;
            deltaZ = voxelwz * invDirZ;
            tnextZ = intervalMin + ((indxZ + 1) * voxelwz + bounds.getMinimum().z - orgZ) * invDirZ;
        } else {
            stepZ = -1;
            stopZ = -1;
            deltaZ = -voxelwz * invDirZ;
            tnextZ = intervalMin + (indxZ * voxelwz + bounds.getMinimum().z - orgZ) * invDirZ;
        }
        int cellstepX = stepX;
        int cellstepY = stepY * nx;
        int cellstepZ = stepZ * ny * nx;
        int cell = indxX + indxY * nx + indxZ * ny * nx;
        // trace through the grid
        for (;;) {
            if (tnextX < tnextY && tnextX < tnextZ) {
                if (cells[cell] != null) {
                    for (int i : cells[cell])
                        primitives.intersectPrimitive(r, i, state);
                    if (state.hit() && (r.getMax() < tnextX && r.getMax() < intervalMax))
                        return;
                }
                intervalMin = tnextX;
                if (intervalMin > intervalMax)
                    return;
                indxX += stepX;
                if (indxX == stopX)
                    return;
                tnextX += deltaX;
                cell += cellstepX;
            } else if (tnextY < tnextZ) {
                if (cells[cell] != null) {
                    for (int i : cells[cell])
                        primitives.intersectPrimitive(r, i, state);
                    if (state.hit() && (r.getMax() < tnextY && r.getMax() < intervalMax))
                        return;
                }
                intervalMin = tnextY;
                if (intervalMin > intervalMax)
                    return;
                indxY += stepY;
                if (indxY == stopY)
                    return;
                tnextY += deltaY;
                cell += cellstepY;
            } else {
                if (cells[cell] != null) {
                    for (int i : cells[cell])
                        primitives.intersectPrimitive(r, i, state);
                    if (state.hit() && (r.getMax() < tnextZ && r.getMax() < intervalMax))
                        return;
                }
                intervalMin = tnextZ;
                if (intervalMin > intervalMax)
                    return;
                indxZ += stepZ;
                if (indxZ == stopZ)
                    return;
                tnextZ += deltaZ;
                cell += cellstepZ;
            }
        }
    }"
org.sunflow.core.accel.UniformGrid.getGridIndex,"    private void getGridIndex(float x, float y, float z, int[] i) {
        i[0] = MathUtils.clamp((int) ((x - bounds.getMinimum().x) * invVoxelwx), 0, nx - 1);
        i[1] = MathUtils.clamp((int) ((y - bounds.getMinimum().y) * invVoxelwy), 0, ny - 1);
        i[2] = MathUtils.clamp((int) ((z - bounds.getMinimum().z) * invVoxelwz), 0, nz - 1);
    }
"
org.sunflow.core.accel.BoundingIntervalHierarchy.build,"    public void build(PrimitiveList primitives) {
        this.primitives = primitives;
        int n = primitives.getNumPrimitives();
        UI.printDetailed(Module.ACCEL, ""Getting bounding box ..."");
        bounds = primitives.getWorldBounds(null);
        objects = new int[n];
        for (int i = 0; i < n; i++)
            objects[i] = i;
        UI.printDetailed(Module.ACCEL, ""Creating tree ..."");
        int initialSize = 3 * (2 * 6 * n + 1);
        IntArray tempTree = new IntArray((initialSize + 3) / 4);
        BuildStats stats = new BuildStats();
        Timer t = new Timer();
        t.start();
        buildHierarchy(tempTree, objects, stats);
        t.end();
        UI.printDetailed(Module.ACCEL, ""Trimming tree ..."");
        tree = tempTree.trim();
        // display stats
        stats.printStats();
        UI.printDetailed(Module.ACCEL, ""  * Creation time:  %s"", t);
        UI.printDetailed(Module.ACCEL, ""  * Usage of init:  %3d%%"", 100 * tree.length / initialSize);
        UI.printDetailed(Module.ACCEL, ""  * Tree memory:    %s"", Memory.sizeof(tree));
        UI.printDetailed(Module.ACCEL, ""  * Indices memory: %s"", Memory.sizeof(objects));
    }"
org.sunflow.core.accel.BoundingIntervalHierarchy.updateInner,"        void updateInner() {
            numNodes++;
        }"
org.sunflow.core.accel.BoundingIntervalHierarchy.updateBVH2,"        void updateBVH2() {
            numBVH2++;
        }"
org.sunflow.core.accel.BoundingIntervalHierarchy.updateLeaf,"        void updateLeaf(int depth, int n) {
            numLeaves++;
            minDepth = Math.min(depth, minDepth);
            maxDepth = Math.max(depth, maxDepth);
            sumDepth += depth;
            minObjects = Math.min(n, minObjects);
            maxObjects = Math.max(n, maxObjects);
            sumObjects += n;
            switch (n) {
                case 0:
                    numLeaves0++;
                    break;
                case 1:
                    numLeaves1++;
                    break;
                case 2:
                    numLeaves2++;
                    break;
                case 3:
                    numLeaves3++;
                    break;
                case 4:
                    numLeaves4++;
                    break;
                default:
                    numLeaves4p++;
                    break;
            }
        }"
org.sunflow.core.accel.BoundingIntervalHierarchy.printStats,"        void printStats() {
            UI.printDetailed(Module.ACCEL, ""Tree stats:"");
            UI.printDetailed(Module.ACCEL, ""  * Nodes:          %d"", numNodes);
            UI.printDetailed(Module.ACCEL, ""  * Leaves:         %d"", numLeaves);
            UI.printDetailed(Module.ACCEL, ""  * Objects: min    %d"", minObjects);
            UI.printDetailed(Module.ACCEL, ""             avg    %.2f"", (float) sumObjects / numLeaves);
            UI.printDetailed(Module.ACCEL, ""           avg(n>0) %.2f"", (float) sumObjects / (numLeaves - numLeaves0));
            UI.printDetailed(Module.ACCEL, ""             max    %d"", maxObjects);
            UI.printDetailed(Module.ACCEL, ""  * Depth:   min    %d"", minDepth);
            UI.printDetailed(Module.ACCEL, ""             avg    %.2f"", (float) sumDepth / numLeaves);
            UI.printDetailed(Module.ACCEL, ""             max    %d"", maxDepth);
            UI.printDetailed(Module.ACCEL, ""  * Leaves w/: N=0  %3d%%"", 100 * numLeaves0 / numLeaves);
            UI.printDetailed(Module.ACCEL, ""               N=1  %3d%%"", 100 * numLeaves1 / numLeaves);
            UI.printDetailed(Module.ACCEL, ""               N=2  %3d%%"", 100 * numLeaves2 / numLeaves);
            UI.printDetailed(Module.ACCEL, ""               N=3  %3d%%"", 100 * numLeaves3 / numLeaves);
            UI.printDetailed(Module.ACCEL, ""               N=4  %3d%%"", 100 * numLeaves4 / numLeaves);
            UI.printDetailed(Module.ACCEL, ""               N>4  %3d%%"", 100 * numLeaves4p / numLeaves);
            UI.printDetailed(Module.ACCEL, ""  * BVH2 nodes:     %d (%3d%%)"", numBVH2, 100 * numBVH2 / (numNodes + numLeaves - 2 * numBVH2));
        }
    "
org.sunflow.core.accel.BoundingIntervalHierarchy.buildHierarchy,"    private void buildHierarchy(IntArray tempTree, int[] indices, BuildStats stats) {
        // create space for the first node
        tempTree.add(3 << 30); // dummy leaf
        tempTree.add(0);
        tempTree.add(0);
        if (objects.length == 0)
            return;
        // seed bbox
        float[] gridBox = { bounds.getMinimum().x, bounds.getMaximum().x,
                bounds.getMinimum().y, bounds.getMaximum().y,
                bounds.getMinimum().z, bounds.getMaximum().z };
        float[] nodeBox = { bounds.getMinimum().x, bounds.getMaximum().x,
                bounds.getMinimum().y, bounds.getMaximum().y,
                bounds.getMinimum().z, bounds.getMaximum().z };
        // seed subdivide function
        subdivide(0, objects.length - 1, tempTree, indices, gridBox, nodeBox, 0, 1, stats);
    }"
org.sunflow.core.accel.BoundingIntervalHierarchy.createNode,"    private void createNode(IntArray tempTree, int nodeIndex, int left, int right) {
        // write leaf node
        tempTree.set(nodeIndex + 0, (3 << 30) | left);
        tempTree.set(nodeIndex + 1, right - left + 1);
    }"
org.sunflow.core.accel.BoundingIntervalHierarchy.subdivide,"    private void subdivide(int left, int right, IntArray tempTree, int[] indices, float[] gridBox, float[] nodeBox, int nodeIndex, int depth, BuildStats stats) {
        if ((right - left + 1) <= maxPrims || depth >= 64) {
            // write leaf node
            stats.updateLeaf(depth, right - left + 1);
            createNode(tempTree, nodeIndex, left, right);
            return;
        }
        // calculate extents
        int axis = -1, prevAxis, rightOrig;
        float clipL = Float.NaN, clipR = Float.NaN, prevClip = Float.NaN;
        float split = Float.NaN, prevSplit;
        boolean wasLeft = true;
        while (true) {
            prevAxis = axis;
            prevSplit = split;
            // perform quick consistency checks
            float d[] = { gridBox[1] - gridBox[0], gridBox[3] - gridBox[2],
                    gridBox[5] - gridBox[4] };
            if (d[0] < 0 || d[1] < 0 || d[2] < 0)
                throw new IllegalStateException(""negative node extents"");
            for (int i = 0; i < 3; i++) {
                if (nodeBox[2 * i + 1] < gridBox[2 * i] || nodeBox[2 * i] > gridBox[2 * i + 1]) {
                    UI.printError(Module.ACCEL, ""Reached tree area in error - discarding node with: %d objects"", right - left + 1);
                    throw new IllegalStateException(""invalid node overlap"");
                }
            }
            // find longest axis
            if (d[0] > d[1] && d[0] > d[2])
                axis = 0;
            else if (d[1] > d[2])
                axis = 1;
            else
                axis = 2;
            split = 0.5f * (gridBox[2 * axis] + gridBox[2 * axis + 1]);
            // partition L/R subsets
            clipL = Float.NEGATIVE_INFINITY;
            clipR = Float.POSITIVE_INFINITY;
            rightOrig = right; // save this for later
            float nodeL = Float.POSITIVE_INFINITY;
            float nodeR = Float.NEGATIVE_INFINITY;
            for (int i = left; i <= right;) {
                int obj = indices[i];
                float minb = primitives.getPrimitiveBound(obj, 2 * axis + 0);
                float maxb = primitives.getPrimitiveBound(obj, 2 * axis + 1);
                float center = (minb + maxb) * 0.5f;
                if (center <= split) {
                    // stay left
                    i++;
                    if (clipL < maxb)
                        clipL = maxb;
                } else {
                    // move to the right most
                    int t = indices[i];
                    indices[i] = indices[right];
                    indices[right] = t;
                    right--;
                    if (clipR > minb)
                        clipR = minb;
                }
                if (nodeL > minb)
                    nodeL = minb;
                if (nodeR < maxb)
                    nodeR = maxb;
            }
            // check for empty space
            if (nodeL > nodeBox[2 * axis + 0] && nodeR < nodeBox[2 * axis + 1]) {
                float nodeBoxW = nodeBox[2 * axis + 1] - nodeBox[2 * axis + 0];
                float nodeNewW = nodeR - nodeL;
                if (1.3f * nodeNewW < nodeBoxW) {
                    stats.updateBVH2();
                    // create clips to create empty space
                    // node box is too big compare to space occupied by
                    // primitives
                    // create leaves, update and recurse
                    int nextIndex = tempTree.getSize();
                    // allocate child - for bvh2 node
                    tempTree.add(0);
                    tempTree.add(0);
                    tempTree.add(0);
                    // write left/right clip node
                    stats.updateInner();
                    stats.updateLeaf(depth, 0);
                    tempTree.set(nodeIndex + 0, (axis << 30) | (1 << 29) | nextIndex);
                    tempTree.set(nodeIndex + 1, Float.floatToRawIntBits(nodeL));
                    tempTree.set(nodeIndex + 2, Float.floatToRawIntBits(nodeR));
                    // update nodebox and recurse
                    nodeBox[2 * axis + 0] = nodeL;
                    nodeBox[2 * axis + 1] = nodeR;
                    subdivide(left, rightOrig, tempTree, indices, gridBox, nodeBox, nextIndex, depth + 1, stats);
                    return;
                }
            }
            // ensure we are making progress in the subdivision
            if (right == rightOrig) {
                // all left
                if (clipL <= split) {
                    // keep looping on left half
                    gridBox[2 * axis + 1] = split;
                    prevClip = clipL;
                    wasLeft = true;
                    continue;
                }
                if (prevAxis == axis && prevSplit == split) {
                    // we are stuck here - create a leaf
                    stats.updateLeaf(depth, right - left + 1);
                    createNode(tempTree, nodeIndex, left, right);
                    return;
                }
                gridBox[2 * axis + 1] = split;
                prevClip = Float.NaN;
            } else if (left > right) {
                // all right
                right = rightOrig;
                if (clipR >= split) {
                    // keep looping on right half
                    gridBox[2 * axis + 0] = split;
                    prevClip = clipR;
                    wasLeft = false;
                    continue;
                }
                if (prevAxis == axis && prevSplit == split) {
                    // we are stuck here - create a leaf
                    stats.updateLeaf(depth, right - left + 1);
                    createNode(tempTree, nodeIndex, left, right);
                    return;
                }
                gridBox[2 * axis + 0] = split;
                prevClip = Float.NaN;
            } else {
                // we are actually splitting stuff
                if (prevAxis != -1 && !Float.isNaN(prevClip)) {
                    // second time through - lets create the previous split
                    // since it produced empty space
                    int nextIndex = tempTree.getSize();
                    // allocate child node
                    tempTree.add(0);
                    tempTree.add(0);
                    tempTree.add(0);
                    if (wasLeft) {
                        // create a node with a left child
                        // write leaf node
                        stats.updateInner();
                        tempTree.set(nodeIndex + 0, (prevAxis << 30) | nextIndex);
                        tempTree.set(nodeIndex + 1, Float.floatToRawIntBits(prevClip));
                        tempTree.set(nodeIndex + 2, Float.floatToRawIntBits(Float.POSITIVE_INFINITY));
                    } else {
                        // create a node with a right child
                        // write leaf node
                        stats.updateInner();
                        tempTree.set(nodeIndex + 0, (prevAxis << 30) | (nextIndex - 3));
                        tempTree.set(nodeIndex + 1, Float.floatToRawIntBits(Float.NEGATIVE_INFINITY));
                        tempTree.set(nodeIndex + 2, Float.floatToRawIntBits(prevClip));
                    }
                    // count stats for the unused leaf
                    depth++;
                    stats.updateLeaf(depth, 0);
                    // now we keep going as we are, with a new nodeIndex:
                    nodeIndex = nextIndex;
                }
                break;
            }
        }
        // compute index of child nodes
        int nextIndex = tempTree.getSize();
        // allocate left node
        int nl = right - left + 1;
        int nr = rightOrig - (right + 1) + 1;
        if (nl > 0) {
            tempTree.add(0);
            tempTree.add(0);
            tempTree.add(0);
        } else
            nextIndex -= 3;
        // allocate right node
        if (nr > 0) {
            tempTree.add(0);
            tempTree.add(0);
            tempTree.add(0);
        }
        // write leaf node
        stats.updateInner();
        tempTree.set(nodeIndex + 0, (axis << 30) | nextIndex);
        tempTree.set(nodeIndex + 1, Float.floatToRawIntBits(clipL));
        tempTree.set(nodeIndex + 2, Float.floatToRawIntBits(clipR));
        // prepare L/R child boxes
        float[] gridBoxL = new float[6];
        float[] gridBoxR = new float[6];
        float[] nodeBoxL = new float[6];
        float[] nodeBoxR = new float[6];
        for (int i = 0; i < 6; i++) {
            gridBoxL[i] = gridBoxR[i] = gridBox[i];
            nodeBoxL[i] = nodeBoxR[i] = nodeBox[i];
        }
        gridBoxL[2 * axis + 1] = gridBoxR[2 * axis] = split;
        nodeBoxL[2 * axis + 1] = clipL;
        nodeBoxR[2 * axis + 0] = clipR;
        // free memory
        gridBox = nodeBox = null;
        // recurse
        if (nl > 0)
            subdivide(left, right, tempTree, indices, gridBoxL, nodeBoxL, nextIndex, depth + 1, stats);
        else
            stats.updateLeaf(depth + 1, 0);
        if (nr > 0)
            subdivide(right + 1, rightOrig, tempTree, indices, gridBoxR, nodeBoxR, nextIndex + 3, depth + 1, stats);
        else
            stats.updateLeaf(depth + 1, 0);
    }"
org.sunflow.core.accel.BoundingIntervalHierarchy.intersect,"    public void intersect(Ray r, IntersectionState state) {
        float intervalMin = r.getMin();
        float intervalMax = r.getMax();
        float orgX = r.ox;
        float dirX = r.dx, invDirX = 1 / dirX;
        float t1, t2;
        t1 = (bounds.getMinimum().x - orgX) * invDirX;
        t2 = (bounds.getMaximum().x - orgX) * invDirX;
        if (invDirX > 0) {
            if (t1 > intervalMin)
                intervalMin = t1;
            if (t2 < intervalMax)
                intervalMax = t2;
        } else {
            if (t2 > intervalMin)
                intervalMin = t2;
            if (t1 < intervalMax)
                intervalMax = t1;
        }
        if (intervalMin > intervalMax)
            return;
        float orgY = r.oy;
        float dirY = r.dy, invDirY = 1 / dirY;
        t1 = (bounds.getMinimum().y - orgY) * invDirY;
        t2 = (bounds.getMaximum().y - orgY) * invDirY;
        if (invDirY > 0) {
            if (t1 > intervalMin)
                intervalMin = t1;
            if (t2 < intervalMax)
                intervalMax = t2;
        } else {
            if (t2 > intervalMin)
                intervalMin = t2;
            if (t1 < intervalMax)
                intervalMax = t1;
        }
        if (intervalMin > intervalMax)
            return;
        float orgZ = r.oz;
        float dirZ = r.dz, invDirZ = 1 / dirZ;
        t1 = (bounds.getMinimum().z - orgZ) * invDirZ;
        t2 = (bounds.getMaximum().z - orgZ) * invDirZ;
        if (invDirZ > 0) {
            if (t1 > intervalMin)
                intervalMin = t1;
            if (t2 < intervalMax)
                intervalMax = t2;
        } else {
            if (t2 > intervalMin)
                intervalMin = t2;
            if (t1 < intervalMax)
                intervalMax = t1;
        }
        if (intervalMin > intervalMax)
            return;

        // compute custom offsets from direction sign bit

        int offsetXFront = Float.floatToRawIntBits(dirX) >>> 31;
        int offsetYFront = Float.floatToRawIntBits(dirY) >>> 31;
        int offsetZFront = Float.floatToRawIntBits(dirZ) >>> 31;

        int offsetXBack = offsetXFront ^ 1;
        int offsetYBack = offsetYFront ^ 1;
        int offsetZBack = offsetZFront ^ 1;

        int offsetXFront3 = offsetXFront * 3;
        int offsetYFront3 = offsetYFront * 3;
        int offsetZFront3 = offsetZFront * 3;

        int offsetXBack3 = offsetXBack * 3;
        int offsetYBack3 = offsetYBack * 3;
        int offsetZBack3 = offsetZBack * 3;

        // avoid always adding 1 during the inner loop
        offsetXFront++;
        offsetYFront++;
        offsetZFront++;
        offsetXBack++;
        offsetYBack++;
        offsetZBack++;

        IntersectionState.StackNode[] stack = state.getStack();
        int stackTop = state.getStackTop();
        int stackPos = stackTop;
        int node = 0;

        while (true) {
            pushloop: while (true) {
                int tn = tree[node];
                int axis = tn & (7 << 29);
                int offset = tn & ~(7 << 29);
                switch (axis) {
                    case 0: {
                        // x axis
                        float tf = (Float.intBitsToFloat(tree[node + offsetXFront]) - orgX) * invDirX;
                        float tb = (Float.intBitsToFloat(tree[node + offsetXBack]) - orgX) * invDirX;
                        // ray passes between clip zones
                        if (tf < intervalMin && tb > intervalMax)
                            break pushloop;
                        int back = offset + offsetXBack3;
                        node = back;
                        // ray passes through far node only
                        if (tf < intervalMin) {
                            intervalMin = (tb >= intervalMin) ? tb : intervalMin;
                            continue;
                        }
                        node = offset + offsetXFront3; // front
                        // ray passes through near node only
                        if (tb > intervalMax) {
                            intervalMax = (tf <= intervalMax) ? tf : intervalMax;
                            continue;
                        }
                        // ray passes through both nodes
                        // push back node
                        stack[stackPos].node = back;
                        stack[stackPos].near = (tb >= intervalMin) ? tb : intervalMin;
                        stack[stackPos].far = intervalMax;
                        stackPos++;
                        // update ray interval for front node
                        intervalMax = (tf <= intervalMax) ? tf : intervalMax;
                        continue;
                    }
                    case 1 << 30: {
                        float tf = (Float.intBitsToFloat(tree[node + offsetYFront]) - orgY) * invDirY;
                        float tb = (Float.intBitsToFloat(tree[node + offsetYBack]) - orgY) * invDirY;
                        // ray passes between clip zones
                        if (tf < intervalMin && tb > intervalMax)
                            break pushloop;
                        int back = offset + offsetYBack3;
                        node = back;
                        // ray passes through far node only
                        if (tf < intervalMin) {
                            intervalMin = (tb >= intervalMin) ? tb : intervalMin;
                            continue;
                        }
                        node = offset + offsetYFront3; // front
                        // ray passes through near node only
                        if (tb > intervalMax) {
                            intervalMax = (tf <= intervalMax) ? tf : intervalMax;
                            continue;
                        }
                        // ray passes through both nodes
                        // push back node
                        stack[stackPos].node = back;
                        stack[stackPos].near = (tb >= intervalMin) ? tb : intervalMin;
                        stack[stackPos].far = intervalMax;
                        stackPos++;
                        // update ray interval for front node
                        intervalMax = (tf <= intervalMax) ? tf : intervalMax;
                        continue;
                    }
                    case 2 << 30: {
                        // z axis
                        float tf = (Float.intBitsToFloat(tree[node + offsetZFront]) - orgZ) * invDirZ;
                        float tb = (Float.intBitsToFloat(tree[node + offsetZBack]) - orgZ) * invDirZ;
                        // ray passes between clip zones
                        if (tf < intervalMin && tb > intervalMax)
                            break pushloop;
                        int back = offset + offsetZBack3;
                        node = back;
                        // ray passes through far node only
                        if (tf < intervalMin) {
                            intervalMin = (tb >= intervalMin) ? tb : intervalMin;
                            continue;
                        }
                        node = offset + offsetZFront3; // front
                        // ray passes through near node only
                        if (tb > intervalMax) {
                            intervalMax = (tf <= intervalMax) ? tf : intervalMax;
                            continue;
                        }
                        // ray passes through both nodes
                        // push back node
                        stack[stackPos].node = back;
                        stack[stackPos].near = (tb >= intervalMin) ? tb : intervalMin;
                        stack[stackPos].far = intervalMax;
                        stackPos++;
                        // update ray interval for front node
                        intervalMax = (tf <= intervalMax) ? tf : intervalMax;
                        continue;
                    }
                    case 3 << 30: {
                        // leaf - test some objects
                        int n = tree[node + 1];
                        while (n > 0) {
                            primitives.intersectPrimitive(r, objects[offset], state);
                            n--;
                            offset++;
                        }
                        break pushloop;
                    }
                    case 1 << 29: {
                        float tf = (Float.intBitsToFloat(tree[node + offsetXFront]) - orgX) * invDirX;
                        float tb = (Float.intBitsToFloat(tree[node + offsetXBack]) - orgX) * invDirX;
                        node = offset;
                        intervalMin = intervalMin > tf ? intervalMin : tf;
                        intervalMax = intervalMax < tb ? intervalMax : tb;
                        if (intervalMin > intervalMax)
                            break pushloop;
                        continue;
                    }
                    case 3 << 29: {
                        float tf = (Float.intBitsToFloat(tree[node + offsetYFront]) - orgY) * invDirY;
                        float tb = (Float.intBitsToFloat(tree[node + offsetYBack]) - orgY) * invDirY;
                        node = offset;
                        intervalMin = intervalMin > tf ? intervalMin : tf;
                        intervalMax = intervalMax < tb ? intervalMax : tb;
                        if (intervalMin > intervalMax)
                            break pushloop;
                        continue;
                    }
                    case 5 << 29: {
                        float tf = (Float.intBitsToFloat(tree[node + offsetZFront]) - orgZ) * invDirZ;
                        float tb = (Float.intBitsToFloat(tree[node + offsetZBack]) - orgZ) * invDirZ;
                        node = offset;
                        intervalMin = intervalMin > tf ? intervalMin : tf;
                        intervalMax = intervalMax < tb ? intervalMax : tb;
                        if (intervalMin > intervalMax)
                            break pushloop;
                        continue;
                    }
                    default:
                        return; // should not happen
                } // switch
            } // traversal loop
            do {
                // stack is empty?
                if (stackPos == stackTop)
                    return;
                // move back up the stack
                stackPos--;
                intervalMin = stack[stackPos].near;
                if (r.getMax() < intervalMin)
                    continue;
                node = stack[stackPos].node;
                intervalMax = stack[stackPos].far;
                break;
            } while (true);
        }
    }
"
org.sunflow.core.accel.NullAccelerator.build,"    public void build(PrimitiveList primitives) {
        this.primitives = primitives;
        n = primitives.getNumPrimitives();
    }"
org.sunflow.core.accel.NullAccelerator.intersect,"    public void intersect(Ray r, IntersectionState state) {
        for (int i = 0; i < n; i++)
            primitives.intersectPrimitive(r, i, state);
    }
"
org.sunflow.core.accel.KDTree.updateInner,"        void updateInner() {
            numNodes++;
        }"
org.sunflow.core.accel.KDTree.updateLeaf,"        void updateLeaf(int depth, int n) {
            numLeaves++;
            minDepth = Math.min(depth, minDepth);
            maxDepth = Math.max(depth, maxDepth);
            sumDepth += depth;
            minObjects = Math.min(n, minObjects);
            maxObjects = Math.max(n, maxObjects);
            sumObjects += n;
            switch (n) {
                case 0:
                    numLeaves0++;
                    break;
                case 1:
                    numLeaves1++;
                    break;
                case 2:
                    numLeaves2++;
                    break;
                case 3:
                    numLeaves3++;
                    break;
                case 4:
                    numLeaves4++;
                    break;
                default:
                    numLeaves4p++;
                    break;
            }
        }"
org.sunflow.core.accel.KDTree.printStats,"        void printStats() {
            UI.printDetailed(Module.ACCEL, ""KDTree stats:"");
            UI.printDetailed(Module.ACCEL, ""  * Nodes:          %d"", numNodes);
            UI.printDetailed(Module.ACCEL, ""  * Leaves:         %d"", numLeaves);
            UI.printDetailed(Module.ACCEL, ""  * Objects: min    %d"", minObjects);
            UI.printDetailed(Module.ACCEL, ""             avg    %.2f"", (float) sumObjects / numLeaves);
            UI.printDetailed(Module.ACCEL, ""           avg(n>0) %.2f"", (float) sumObjects / (numLeaves - numLeaves0));
            UI.printDetailed(Module.ACCEL, ""             max    %d"", maxObjects);
            UI.printDetailed(Module.ACCEL, ""  * Depth:   min    %d"", minDepth);
            UI.printDetailed(Module.ACCEL, ""             avg    %.2f"", (float) sumDepth / numLeaves);
            UI.printDetailed(Module.ACCEL, ""             max    %d"", maxDepth);
            UI.printDetailed(Module.ACCEL, ""  * Leaves w/: N=0  %3d%%"", 100 * numLeaves0 / numLeaves);
            UI.printDetailed(Module.ACCEL, ""               N=1  %3d%%"", 100 * numLeaves1 / numLeaves);
            UI.printDetailed(Module.ACCEL, ""               N=2  %3d%%"", 100 * numLeaves2 / numLeaves);
            UI.printDetailed(Module.ACCEL, ""               N=3  %3d%%"", 100 * numLeaves3 / numLeaves);
            UI.printDetailed(Module.ACCEL, ""               N=4  %3d%%"", 100 * numLeaves4 / numLeaves);
            UI.printDetailed(Module.ACCEL, ""               N>4  %3d%%"", 100 * numLeaves4p / numLeaves);
        }
    "
org.sunflow.core.accel.KDTree.setDumpMode,"    public static void setDumpMode(boolean dump, String prefix) {
        KDTree.dump = dump;
        KDTree.dumpPrefix = prefix;
    }"
org.sunflow.core.accel.KDTree.build,"    public void build(PrimitiveList primitives) {
        UI.printDetailed(Module.ACCEL, ""KDTree settings"");
        UI.printDetailed(Module.ACCEL, ""  * Max Leaf Size:  %d"", maxPrims);
        UI.printDetailed(Module.ACCEL, ""  * Max Depth:      %d"", MAX_DEPTH);
        UI.printDetailed(Module.ACCEL, ""  * Traversal cost: %.2f"", TRAVERSAL_COST);
        UI.printDetailed(Module.ACCEL, ""  * Intersect cost: %.2f"", INTERSECT_COST);
        UI.printDetailed(Module.ACCEL, ""  * Empty bonus:    %.2f"", EMPTY_BONUS);
        UI.printDetailed(Module.ACCEL, ""  * Dump leaves:    %s"", dump ? ""enabled"" : ""disabled"");
        Timer total = new Timer();
        total.start();
        this.primitiveList = primitives;
        // get the object space bounds
        bounds = primitives.getWorldBounds(null);
        int nPrim = primitiveList.getNumPrimitives(), nSplits = 0;
        BuildTask task = new BuildTask(nPrim);
        Timer prepare = new Timer();
        prepare.start();
        for (int i = 0; i < nPrim; i++) {
            for (int axis = 0; axis < 3; axis++) {
                float ls = primitiveList.getPrimitiveBound(i, 2 * axis + 0);
                float rs = primitiveList.getPrimitiveBound(i, 2 * axis + 1);
                if (ls == rs) {
                    // flat in this dimension
                    task.splits[nSplits] = pack(ls, PLANAR, axis, i);
                    nSplits++;
                } else {
                    task.splits[nSplits + 0] = pack(ls, OPENED, axis, i);
                    task.splits[nSplits + 1] = pack(rs, CLOSED, axis, i);
                    nSplits += 2;
                }
            }
        }
        task.n = nSplits;
        prepare.end();
        Timer t = new Timer();
        IntArray tempTree = new IntArray();
        IntArray tempList = new IntArray();
        tempTree.add(0);
        tempTree.add(1);
        t.start();
        // sort it
        Timer sorting = new Timer();
        sorting.start();
        radix12(task.splits, task.n);
        sorting.end();
        // build the actual tree
        BuildStats stats = new BuildStats();
        buildTree(bounds.getMinimum().x, bounds.getMaximum().x, bounds.getMinimum().y, bounds.getMaximum().y, bounds.getMinimum().z, bounds.getMaximum().z, task, 1, tempTree, 0, tempList, stats);
        t.end();
        // write out final arrays
        // free some memory
        task = null;
        tree = tempTree.trim();
        tempTree = null;
        this.primitives = tempList.trim();
        tempList = null;
        total.end();
        // display some extra info
        stats.printStats();
        UI.printDetailed(Module.ACCEL, ""  * Node memory:    %s"", Memory.sizeof(tree));
        UI.printDetailed(Module.ACCEL, ""  * Object memory:  %s"", Memory.sizeof(this.primitives));
        UI.printDetailed(Module.ACCEL, ""  * Prepare time:   %s"", prepare);
        UI.printDetailed(Module.ACCEL, ""  * Sorting time:   %s"", sorting);
        UI.printDetailed(Module.ACCEL, ""  * Tree creation:  %s"", t);
        UI.printDetailed(Module.ACCEL, ""  * Build time:     %s"", total);
        if (dump) {
            try {
                UI.printInfo(Module.ACCEL, ""Dumping mtls to %s.mtl ..."", dumpPrefix);
                FileWriter mtlFile = new FileWriter(dumpPrefix + "".mtl"");
                int maxN = stats.maxObjects;
                for (int n = 0; n <= maxN; n++) {
                    float blend = (float) n / (float) maxN;
                    Color nc;
                    if (blend < 0.25)
                        nc = Color.blend(Color.BLUE, Color.GREEN, blend / 0.25f);
                    else if (blend < 0.5)
                        nc = Color.blend(Color.GREEN, Color.YELLOW, (blend - 0.25f) / 0.25f);
                    else if (blend < 0.75)
                        nc = Color.blend(Color.YELLOW, Color.RED, (blend - 0.50f) / 0.25f);
                    else
                        nc = Color.MAGENTA;
                    mtlFile.write(String.format(""newmtl mtl%d\n"", n));
                    float[] rgb = nc.getRGB();
                    mtlFile.write(""Ka 0.1 0.1 0.1\n"");
                    mtlFile.write(String.format(""Kd %.12g %.12g %.12g\n"", rgb[0], rgb[1], rgb[2]));
                    mtlFile.write(""illum 1\n\n"");
                }
                FileWriter objFile = new FileWriter(dumpPrefix + "".obj"");
                UI.printInfo(Module.ACCEL, ""Dumping tree to %s.obj ..."", dumpPrefix);
                dumpObj(0, 0, maxN, new BoundingBox(bounds), objFile, mtlFile);
                objFile.close();
                mtlFile.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }"
org.sunflow.core.accel.KDTree.dumpObj,"    private int dumpObj(int offset, int vertOffset, int maxN, BoundingBox bounds, FileWriter file, FileWriter mtlFile) throws IOException {
        if (offset == 0)
            file.write(String.format(""mtllib %s.mtl\n"", dumpPrefix));
        int nextOffset = tree[offset];
        if ((nextOffset & (3 << 30)) == (3 << 30)) {
            // leaf
            int n = tree[offset + 1];
            if (n > 0) {
                // output the current voxel to the file
                Point3 min = bounds.getMinimum();
                Point3 max = bounds.getMaximum();
                file.write(String.format(""o node%d\n"", offset));
                file.write(String.format(""v %g %g %g\n"", max.x, max.y, min.z));
                file.write(String.format(""v %g %g %g\n"", max.x, min.y, min.z));
                file.write(String.format(""v %g %g %g\n"", min.x, min.y, min.z));
                file.write(String.format(""v %g %g %g\n"", min.x, max.y, min.z));
                file.write(String.format(""v %g %g %g\n"", max.x, max.y, max.z));
                file.write(String.format(""v %g %g %g\n"", max.x, min.y, max.z));
                file.write(String.format(""v %g %g %g\n"", min.x, min.y, max.z));
                file.write(String.format(""v %g %g %g\n"", min.x, max.y, max.z));
                int v0 = vertOffset;
                file.write(String.format(""usemtl mtl%d\n"", n));
                file.write(""s off\n"");
                file.write(String.format(""f %d %d %d %d\n"", v0 + 1, v0 + 2, v0 + 3, v0 + 4));
                file.write(String.format(""f %d %d %d %d\n"", v0 + 5, v0 + 8, v0 + 7, v0 + 6));
                file.write(String.format(""f %d %d %d %d\n"", v0 + 1, v0 + 5, v0 + 6, v0 + 2));
                file.write(String.format(""f %d %d %d %d\n"", v0 + 2, v0 + 6, v0 + 7, v0 + 3));
                file.write(String.format(""f %d %d %d %d\n"", v0 + 3, v0 + 7, v0 + 8, v0 + 4));
                file.write(String.format(""f %d %d %d %d\n"", v0 + 5, v0 + 1, v0 + 4, v0 + 8));
                vertOffset += 8;
            }
            return vertOffset;
        } else {
            // node, recurse
            int axis = nextOffset & (3 << 30), v0;
            float split = Float.intBitsToFloat(tree[offset + 1]), min, max;
            nextOffset &= ~(3 << 30);
            switch (axis) {
                case 0:
                    max = bounds.getMaximum().x;
                    bounds.getMaximum().x = split;
                    v0 = dumpObj(nextOffset, vertOffset, maxN, bounds, file, mtlFile);
                    // restore and go to other side
                    bounds.getMaximum().x = max;
                    min = bounds.getMinimum().x;
                    bounds.getMinimum().x = split;
                    v0 = dumpObj(nextOffset + 2, v0, maxN, bounds, file, mtlFile);
                    bounds.getMinimum().x = min;
                    break;
                case 1 << 30:
                    max = bounds.getMaximum().y;
                    bounds.getMaximum().y = split;
                    v0 = dumpObj(nextOffset, vertOffset, maxN, bounds, file, mtlFile);
                    // restore and go to other side
                    bounds.getMaximum().y = max;
                    min = bounds.getMinimum().y;
                    bounds.getMinimum().y = split;
                    v0 = dumpObj(nextOffset + 2, v0, maxN, bounds, file, mtlFile);
                    bounds.getMinimum().y = min;
                    break;
                case 2 << 30:
                    max = bounds.getMaximum().z;
                    bounds.getMaximum().z = split;
                    v0 = dumpObj(nextOffset, vertOffset, maxN, bounds, file, mtlFile);
                    // restore and go to other side
                    bounds.getMaximum().z = max;
                    min = bounds.getMinimum().z;
                    bounds.getMinimum().z = split;
                    v0 = dumpObj(nextOffset + 2, v0, maxN, bounds, file, mtlFile);
                    // restore and go to other side
                    bounds.getMinimum().z = min;
                    break;
                default:
                    v0 = vertOffset;
                    break;
            }
            return v0;
        }
    }"
org.sunflow.core.accel.KDTree.pack,"    private static long pack(float split, long type, int axis, int object) {
        // pack float in sortable form
        int f = Float.floatToRawIntBits(split);
        int top = f ^ ((f >> 31) | 0x80000000);
        long p = ((long) top & 0xFFFFFFFFL) << 32;
        p |= type; // encode type as 2 bits
        p |= ((long) axis) << 28; // encode axis as 2 bits
        p |= (object & 0xFFFFFFFL); // pack object number
        return p;
    }"
org.sunflow.core.accel.KDTree.unpackObject,"    private static int unpackObject(long p) {
        return (int) (p & 0xFFFFFFFL);
    }"
org.sunflow.core.accel.KDTree.unpackAxis,"    private static int unpackAxis(long p) {
        return (int) (p >>> 28) & 3;
    }"
org.sunflow.core.accel.KDTree.unpackSplitType,"    private static long unpackSplitType(long p) {
        return p & TYPE_MASK;
    }"
org.sunflow.core.accel.KDTree.unpackSplit,"    private static float unpackSplit(long p) {
        int f = (int) ((p >>> 32) & 0xFFFFFFFFL);
        int m = ((f >>> 31) - 1) | 0x80000000;
        return Float.intBitsToFloat(f ^ m);
    }"
org.sunflow.core.accel.KDTree.radix12,"    private static void radix12(long[] splits, int n) {
        // allocate working memory
        final int[] hist = new int[2048];
        final long[] sorted = new long[n];
        // parallel histogramming pass
        for (int i = 0; i < n; i++) {
            long pi = splits[i];
            hist[0x000 + ((int) (pi >>> 28) & 0x1FF)]++;
            hist[0x200 + ((int) (pi >>> 37) & 0x1FF)]++;
            hist[0x400 + ((int) (pi >>> 46) & 0x1FF)]++;
            hist[0x600 + ((int) (pi >>> 55))]++;
        }

        // sum the histograms - each histogram entry records the number of
        // values preceding itself.
        {
            int sum0 = 0, sum1 = 0, sum2 = 0, sum3 = 0;
            int tsum;
            for (int i = 0; i < 512; i++) {
                tsum = hist[0x000 + i] + sum0;
                hist[0x000 + i] = sum0 - 1;
                sum0 = tsum;
                tsum = hist[0x200 + i] + sum1;
                hist[0x200 + i] = sum1 - 1;
                sum1 = tsum;
                tsum = hist[0x400 + i] + sum2;
                hist[0x400 + i] = sum2 - 1;
                sum2 = tsum;
                tsum = hist[0x600 + i] + sum3;
                hist[0x600 + i] = sum3 - 1;
                sum3 = tsum;
            }
        }

        // read/write histogram passes
        for (int i = 0; i < n; i++) {
            long pi = splits[i];
            int pos = (int) (pi >>> 28) & 0x1FF;
            sorted[++hist[0x000 + pos]] = pi;
        }
        for (int i = 0; i < n; i++) {
            long pi = sorted[i];
            int pos = (int) (pi >>> 37) & 0x1FF;
            splits[++hist[0x200 + pos]] = pi;
        }
        for (int i = 0; i < n; i++) {
            long pi = splits[i];
            int pos = (int) (pi >>> 46) & 0x1FF;
            sorted[++hist[0x400 + pos]] = pi;
        }
        for (int i = 0; i < n; i++) {
            long pi = sorted[i];
            int pos = (int) (pi >>> 55);
            splits[++hist[0x600 + pos]] = pi;
        }
    }"
org.sunflow.core.accel.KDTree.buildTree,"    private void buildTree(float minx, float maxx, float miny, float maxy, float minz, float maxz, BuildTask task, int depth, IntArray tempTree, int offset, IntArray tempList, BuildStats stats) {
        // get node bounding box extents
        if (task.numObjects > maxPrims && depth < MAX_DEPTH) {
            float dx = maxx - minx;
            float dy = maxy - miny;
            float dz = maxz - minz;
            // search for best possible split
            float bestCost = INTERSECT_COST * task.numObjects;
            int bestAxis = -1;
            int bestOffsetStart = -1;
            int bestOffsetEnd = -1;
            float bestSplit = 0;
            boolean bestPlanarLeft = false;
            int bnl = 0, bnr = 0;
            // inverse area of the bounding box (factor of 2 ommitted)
            float area = (dx * dy + dy * dz + dz * dx);
            float ISECT_COST = INTERSECT_COST / area;
            // setup counts for each axis
            int[] nl = { 0, 0, 0 };
            int[] nr = { task.numObjects, task.numObjects, task.numObjects };
            // setup bounds for each axis
            float[] dp = { dy * dz, dz * dx, dx * dy };
            float[] ds = { dy + dz, dz + dx, dx + dy };
            float[] nodeMin = { minx, miny, minz };
            float[] nodeMax = { maxx, maxy, maxz };
            // search for best cost
            int nSplits = task.n;
            long[] splits = task.splits;
            byte[] lrtable = task.leftRightTable;
            for (int i = 0; i < nSplits;) {
                // extract current split
                long ptr = splits[i];
                float split = unpackSplit(ptr);
                int axis = unpackAxis(ptr);
                // mark current position
                int currentOffset = i;
                // count number of primitives start/stopping/lying on the
                // current plane
                int pClosed = 0, pPlanar = 0, pOpened = 0;
                long ptrMasked = ptr & (~TYPE_MASK & 0xFFFFFFFFF0000000L);
                long ptrClosed = ptrMasked | CLOSED;
                long ptrPlanar = ptrMasked | PLANAR;
                long ptrOpened = ptrMasked | OPENED;
                while (i < nSplits && (splits[i] & 0xFFFFFFFFF0000000L) == ptrClosed) {
                    int obj = unpackObject(splits[i]);
                    lrtable[obj >>> 2] = 0;
                    pClosed++;
                    i++;
                }
                while (i < nSplits && (splits[i] & 0xFFFFFFFFF0000000L) == ptrPlanar) {
                    int obj = unpackObject(splits[i]);
                    lrtable[obj >>> 2] = 0;
                    pPlanar++;
                    i++;
                }
                while (i < nSplits && (splits[i] & 0xFFFFFFFFF0000000L) == ptrOpened) {
                    int obj = unpackObject(splits[i]);
                    lrtable[obj >>> 2] = 0;
                    pOpened++;
                    i++;
                }
                // now we have summed all contributions from this plane
                nr[axis] -= pPlanar + pClosed;
                // compute cost
                if (split >= nodeMin[axis] && split <= nodeMax[axis]) {
                    // left and right surface area (factor of 2 ommitted)
                    float dl = split - nodeMin[axis];
                    float dr = nodeMax[axis] - split;
                    float lp = dp[axis] + dl * ds[axis];
                    float rp = dp[axis] + dr * ds[axis];
                    // planar prims go to smallest cell always
                    boolean planarLeft = dl < dr;
                    int numLeft = nl[axis] + (planarLeft ? pPlanar : 0);
                    int numRight = nr[axis] + (planarLeft ? 0 : pPlanar);
                    float eb = ((numLeft == 0 && dl > 0) || (numRight == 0 && dr > 0)) ? EMPTY_BONUS : 0;
                    float cost = TRAVERSAL_COST + ISECT_COST * (1 - eb) * (lp * numLeft + rp * numRight);
                    if (cost < bestCost) {
                        bestCost = cost;
                        bestAxis = axis;
                        bestSplit = split;
                        bestOffsetStart = currentOffset;
                        bestOffsetEnd = i;
                        bnl = numLeft;
                        bnr = numRight;
                        bestPlanarLeft = planarLeft;
                    }
                }
                // move objects left
                nl[axis] += pOpened + pPlanar;
            }
            // debug check for correctness of the scan
            for (int axis = 0; axis < 3; axis++) {
                int numLeft = nl[axis];
                int numRight = nr[axis];
                if (numLeft != task.numObjects || numRight != 0)
                    UI.printError(Module.ACCEL, ""Didn't scan full range of objects @depth=%d. Left overs for axis %d: [L: %d] [R: %d]"", depth, axis, numLeft, numRight);
            }
            // found best split?
            if (bestAxis != -1) {
                // allocate space for child nodes
                BuildTask taskL = new BuildTask(bnl, task);
                BuildTask taskR = new BuildTask(bnr, task);
                int lk = 0, rk = 0;
                for (int i = 0; i < bestOffsetStart; i++) {
                    long ptr = splits[i];
                    if (unpackAxis(ptr) == bestAxis) {
                        if (unpackSplitType(ptr) != CLOSED) {
                            int obj = unpackObject(ptr);
                            lrtable[obj >>> 2] |= 1 << ((obj & 3) << 1);
                            lk++;
                        }
                    }
                }
                for (int i = bestOffsetStart; i < bestOffsetEnd; i++) {
                    long ptr = splits[i];
                    assert unpackAxis(ptr) == bestAxis;
                    if (unpackSplitType(ptr) == PLANAR) {
                        if (bestPlanarLeft) {
                            int obj = unpackObject(ptr);
                            lrtable[obj >>> 2] |= 1 << ((obj & 3) << 1);
                            lk++;
                        } else {
                            int obj = unpackObject(ptr);
                            lrtable[obj >>> 2] |= 2 << ((obj & 3) << 1);
                            rk++;
                        }
                    }
                }
                for (int i = bestOffsetEnd; i < nSplits; i++) {
                    long ptr = splits[i];
                    if (unpackAxis(ptr) == bestAxis) {
                        if (unpackSplitType(ptr) != OPENED) {
                            int obj = unpackObject(ptr);
                            lrtable[obj >>> 2] |= 2 << ((obj & 3) << 1);
                            rk++;
                        }
                    }
                }
                // output new splits while maintaining order
                long[] splitsL = taskL.splits;
                long[] splitsR = taskR.splits;
                int nsl = 0, nsr = 0;
                for (int i = 0; i < nSplits; i++) {
                    long ptr = splits[i];
                    int obj = unpackObject(ptr);
                    int idx = obj >>> 2;
                    int mask = 1 << ((obj & 3) << 1);
                    if ((lrtable[idx] & mask) != 0) {
                        splitsL[nsl] = ptr;
                        nsl++;
                    }
                    if ((lrtable[idx] & (mask << 1)) != 0) {
                        splitsR[nsr] = ptr;
                        nsr++;
                    }
                }
                taskL.n = nsl;
                taskR.n = nsr;
                // free more memory
                task.splits = splits = splitsL = splitsR = null;
                task = null;
                // allocate child nodes
                int nextOffset = tempTree.getSize();
                tempTree.add(0);
                tempTree.add(0);
                tempTree.add(0);
                tempTree.add(0);
                // create current node
                tempTree.set(offset + 0, (bestAxis << 30) | nextOffset);
                tempTree.set(offset + 1, Float.floatToRawIntBits(bestSplit));
                // recurse for child nodes - free object arrays after each step
                stats.updateInner();
                switch (bestAxis) {
                    case 0:
                        buildTree(minx, bestSplit, miny, maxy, minz, maxz, taskL, depth + 1, tempTree, nextOffset, tempList, stats);
                        taskL = null;
                        buildTree(bestSplit, maxx, miny, maxy, minz, maxz, taskR, depth + 1, tempTree, nextOffset + 2, tempList, stats);
                        taskR = null;
                        return;
                    case 1:
                        buildTree(minx, maxx, miny, bestSplit, minz, maxz, taskL, depth + 1, tempTree, nextOffset, tempList, stats);
                        taskL = null;
                        buildTree(minx, maxx, bestSplit, maxy, minz, maxz, taskR, depth + 1, tempTree, nextOffset + 2, tempList, stats);
                        taskR = null;
                        return;
                    case 2:
                        buildTree(minx, maxx, miny, maxy, minz, bestSplit, taskL, depth + 1, tempTree, nextOffset, tempList, stats);
                        taskL = null;
                        buildTree(minx, maxx, miny, maxy, bestSplit, maxz, taskR, depth + 1, tempTree, nextOffset + 2, tempList, stats);
                        taskR = null;
                        return;
                    default:
                        assert false;
                }
            }
        }
        // create leaf node
        int listOffset = tempList.getSize();
        int n = 0;
        for (int i = 0; i < task.n; i++) {
            long ptr = task.splits[i];
            if (unpackAxis(ptr) == 0 && unpackSplitType(ptr) != CLOSED) {
                tempList.add(unpackObject(ptr));
                n++;
            }
        }
        stats.updateLeaf(depth, n);
        if (n != task.numObjects)
            UI.printError(Module.ACCEL, ""Error creating leaf node - expecting %d found %d"", task.numObjects, n);
        tempTree.set(offset + 0, (3 << 30) | listOffset);
        tempTree.set(offset + 1, task.numObjects);
        // free some memory
        task.splits = null;
    }"
org.sunflow.core.accel.KDTree.intersect,"    public void intersect(Ray r, IntersectionState state) {
        float intervalMin = r.getMin();
        float intervalMax = r.getMax();
        float orgX = r.ox;
        float dirX = r.dx, invDirX = 1 / dirX;
        float t1, t2;
        t1 = (bounds.getMinimum().x - orgX) * invDirX;
        t2 = (bounds.getMaximum().x - orgX) * invDirX;
        if (invDirX > 0) {
            if (t1 > intervalMin)
                intervalMin = t1;
            if (t2 < intervalMax)
                intervalMax = t2;
        } else {
            if (t2 > intervalMin)
                intervalMin = t2;
            if (t1 < intervalMax)
                intervalMax = t1;
        }
        if (intervalMin > intervalMax)
            return;
        float orgY = r.oy;
        float dirY = r.dy, invDirY = 1 / dirY;
        t1 = (bounds.getMinimum().y - orgY) * invDirY;
        t2 = (bounds.getMaximum().y - orgY) * invDirY;
        if (invDirY > 0) {
            if (t1 > intervalMin)
                intervalMin = t1;
            if (t2 < intervalMax)
                intervalMax = t2;
        } else {
            if (t2 > intervalMin)
                intervalMin = t2;
            if (t1 < intervalMax)
                intervalMax = t1;
        }
        if (intervalMin > intervalMax)
            return;
        float orgZ = r.oz;
        float dirZ = r.dz, invDirZ = 1 / dirZ;
        t1 = (bounds.getMinimum().z - orgZ) * invDirZ;
        t2 = (bounds.getMaximum().z - orgZ) * invDirZ;
        if (invDirZ > 0) {
            if (t1 > intervalMin)
                intervalMin = t1;
            if (t2 < intervalMax)
                intervalMax = t2;
        } else {
            if (t2 > intervalMin)
                intervalMin = t2;
            if (t1 < intervalMax)
                intervalMax = t1;
        }
        if (intervalMin > intervalMax)
            return;

        // compute custom offsets from direction sign bit
        int offsetXFront = (Float.floatToRawIntBits(dirX) & (1 << 31)) >>> 30;
        int offsetYFront = (Float.floatToRawIntBits(dirY) & (1 << 31)) >>> 30;
        int offsetZFront = (Float.floatToRawIntBits(dirZ) & (1 << 31)) >>> 30;

        int offsetXBack = offsetXFront ^ 2;
        int offsetYBack = offsetYFront ^ 2;
        int offsetZBack = offsetZFront ^ 2;

        IntersectionState.StackNode[] stack = state.getStack();
        int stackTop = state.getStackTop();
        int stackPos = stackTop;
        int node = 0;

        while (true) {
            int tn = tree[node];
            int axis = tn & (3 << 30);
            int offset = tn & ~(3 << 30);
            switch (axis) {
                case 0: {
                    float d = (Float.intBitsToFloat(tree[node + 1]) - orgX) * invDirX;
                    int back = offset + offsetXBack;
                    node = back;
                    if (d < intervalMin)
                        continue;
                    node = offset + offsetXFront; // front
                    if (d > intervalMax)
                        continue;
                    // push back node
                    stack[stackPos].node = back;
                    stack[stackPos].near = (d >= intervalMin) ? d : intervalMin;
                    stack[stackPos].far = intervalMax;
                    stackPos++;
                    // update ray interval for front node
                    intervalMax = (d <= intervalMax) ? d : intervalMax;
                    continue;
                }
                case 1 << 30: {
                    // y axis
                    float d = (Float.intBitsToFloat(tree[node + 1]) - orgY) * invDirY;
                    int back = offset + offsetYBack;
                    node = back;
                    if (d < intervalMin)
                        continue;
                    node = offset + offsetYFront; // front
                    if (d > intervalMax)
                        continue;
                    // push back node
                    stack[stackPos].node = back;
                    stack[stackPos].near = (d >= intervalMin) ? d : intervalMin;
                    stack[stackPos].far = intervalMax;
                    stackPos++;
                    // update ray interval for front node
                    intervalMax = (d <= intervalMax) ? d : intervalMax;
                    continue;
                }
                case 2 << 30: {
                    // z axis
                    float d = (Float.intBitsToFloat(tree[node + 1]) - orgZ) * invDirZ;
                    int back = offset + offsetZBack;
                    node = back;
                    if (d < intervalMin)
                        continue;
                    node = offset + offsetZFront; // front
                    if (d > intervalMax)
                        continue;
                    // push back node
                    stack[stackPos].node = back;
                    stack[stackPos].near = (d >= intervalMin) ? d : intervalMin;
                    stack[stackPos].far = intervalMax;
                    stackPos++;
                    // update ray interval for front node
                    intervalMax = (d <= intervalMax) ? d : intervalMax;
                    continue;
                }
                default: {
                    // leaf - test some objects
                    int n = tree[node + 1];
                    while (n > 0) {
                        primitiveList.intersectPrimitive(r, primitives[offset], state);
                        n--;
                        offset++;
                    }
                    if (r.getMax() < intervalMax)
                        return;
                    do {
                        // stack is empty?
                        if (stackPos == stackTop)
                            return;
                        // move back up the stack
                        stackPos--;
                        intervalMin = stack[stackPos].near;
                        if (r.getMax() < intervalMin)
                            continue;
                        node = stack[stackPos].node;
                        intervalMax = stack[stackPos].far;
                        break;
                    } while (true);
                }
            } // switch
        } // traversal loop
    }
"
org.sunflow.core.tesselatable.Gumbo.main,"    public static void main(String[] args) {
        try {
            Parser p;
            p = new Parser(""gumbo.rib"");
            int begins = 1;
            System.out.println(""{"");
            Matrix4 m = Matrix4.IDENTITY;
            p.checkNextToken(""AttributeBegin"");
            while (begins != 0) {
                if (p.peekNextToken(""Patch"")) {
                    p.checkNextToken(""bicubic"");
                    p.checkNextToken(""P"");
                    float[] patch = parseFloatArray(p);
                    if (patch.length == 48) {
                        // transform patch
                        for (int i = 0; i < 16; i++) {
                            float x = patch[3 * i + 0];
                            float y = patch[3 * i + 1];
                            float z = patch[3 * i + 2];
                            patch[3 * i + 0] = m.transformPX(x, y, z);
                            patch[3 * i + 1] = m.transformPY(x, y, z);
                            patch[3 * i + 2] = m.transformPZ(x, y, z);
                        }
                        System.out.println(""{"");
                        for (float v : patch)
                            System.out.printf(""  %g,\n"", v);
                        System.out.println(""},"");
                    }
                } else if (p.peekNextToken(""Translate"")) {
                    Matrix4 t = Matrix4.translation(p.getNextFloat(), p.getNextFloat(), p.getNextFloat());
                    m = m.multiply(t);
                } else if (p.peekNextToken(""Rotate"")) {
                    float angle = (float) Math.toRadians(p.getNextFloat());
                    Matrix4 t = Matrix4.rotate(p.getNextFloat(), p.getNextFloat(), p.getNextFloat(), angle);
                    m = m.multiply(t);
                } else if (p.peekNextToken(""Scale"")) {
                    Matrix4 t = Matrix4.scale(p.getNextFloat(), p.getNextFloat(), p.getNextFloat());
                    m = m.multiply(t);
                } else if (p.peekNextToken(""TransformEnd"")) {
                    m = Matrix4.IDENTITY;
                } else if (p.peekNextToken(""AttributeBegin"")) {
                    begins++;
                } else if (p.peekNextToken(""AttributeEnd"")) {
                    begins--;
                } else
                    p.getNextToken();
            }
            System.out.println(""};"");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ParserException e) {
            e.printStackTrace();
        }
    }"
org.sunflow.core.tesselatable.Gumbo.parseFloatArray,"    private static float[] parseFloatArray(Parser p) throws IOException {
        FloatArray array = new FloatArray();
        boolean done = false;
        do {
            String s = p.getNextToken();
            if (s.startsWith(""[""))
                s = s.substring(1);
            if (s.endsWith(""]"")) {
                s = s.substring(0, s.length() - 1);
                done = true;
            }
            array.add(Float.parseFloat(s));
        } while (!done);
        return array.trim();
    }"
org.sunflow.core.tesselatable.FileMesh.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        // world bounds can't be computed without reading file
        // return null so the mesh will be loaded right away
        return null;
    }"
org.sunflow.core.tesselatable.FileMesh.tesselate,"    public PrimitiveList tesselate() {
        if (filename.endsWith("".ra3"")) {
            try {
                UI.printInfo(Module.GEOM, ""RA3 - Reading geometry: \""%s\"" ..."", filename);
                File file = new File(filename);
                FileInputStream stream = new FileInputStream(filename);
                MappedByteBuffer map = stream.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length());
                map.order(ByteOrder.LITTLE_ENDIAN);
                IntBuffer ints = map.asIntBuffer();
                FloatBuffer buffer = map.asFloatBuffer();
                int numVerts = ints.get(0);
                int numTris = ints.get(1);
                UI.printInfo(Module.GEOM, ""RA3 -   * Reading %d vertices ..."", numVerts);
                float[] verts = new float[3 * numVerts];
                for (int i = 0; i < verts.length; i++)
                    verts[i] = buffer.get(2 + i);
                UI.printInfo(Module.GEOM, ""RA3 -   * Reading %d triangles ..."", numTris);
                int[] tris = new int[3 * numTris];
                for (int i = 0; i < tris.length; i++)
                    tris[i] = ints.get(2 + verts.length + i);
                stream.close();
                UI.printInfo(Module.GEOM, ""RA3 -   * Creating mesh ..."");
                // create geometry
                ParameterList pl = new ParameterList();
                pl.addIntegerArray(""triangles"", tris);
                pl.addPoints(""points"", InterpolationType.VERTEX, verts);
                TriangleMesh m = new TriangleMesh();
                if (m.update(pl, null))
                    return m;
            } catch (FileNotFoundException e) {
                e.printStackTrace();
                UI.printError(Module.GEOM, ""Unable to read mesh file \""%s\"" - file not found"", filename);
            } catch (IOException e) {
                e.printStackTrace();
                UI.printError(Module.GEOM, ""Unable to read mesh file \""%s\"" - I/O error occured"", filename);
            }
        } else if (filename.endsWith("".obj"")) {
            int lineNumber = 1;
            try {
                UI.printInfo(Module.GEOM, ""OBJ - Reading geometry: \""%s\"" ..."", filename);
                FloatArray verts = new FloatArray();
                IntArray tris = new IntArray();
                FileReader file = new FileReader(filename);
                BufferedReader bf = new BufferedReader(file);
                String line;
                while ((line = bf.readLine()) != null) {
                    if (line.startsWith(""v"")) {
                        String[] v = line.split(""\\s+"");
                        verts.add(Float.parseFloat(v[1]));
                        verts.add(Float.parseFloat(v[2]));
                        verts.add(Float.parseFloat(v[3]));
                    } else if (line.startsWith(""f"")) {
                        String[] f = line.split(""\\s+"");
                        if (f.length == 5) {
                            tris.add(Integer.parseInt(f[1]) - 1);
                            tris.add(Integer.parseInt(f[2]) - 1);
                            tris.add(Integer.parseInt(f[3]) - 1);
                            tris.add(Integer.parseInt(f[1]) - 1);
                            tris.add(Integer.parseInt(f[3]) - 1);
                            tris.add(Integer.parseInt(f[4]) - 1);
                        } else if (f.length == 4) {
                            tris.add(Integer.parseInt(f[1]) - 1);
                            tris.add(Integer.parseInt(f[2]) - 1);
                            tris.add(Integer.parseInt(f[3]) - 1);
                        }
                    }
                    if (lineNumber % 100000 == 0)
                        UI.printInfo(Module.GEOM, ""OBJ -   * Parsed %7d lines ..."", lineNumber);
                    lineNumber++;
                }
                file.close();
                UI.printInfo(Module.GEOM, ""OBJ -   * Creating mesh ..."");
                ParameterList pl = new ParameterList();
                pl.addIntegerArray(""triangles"", tris.trim());
                pl.addPoints(""points"", InterpolationType.VERTEX, verts.trim());
                TriangleMesh m = new TriangleMesh();
                if (m.update(pl, null))
                    return m;
            } catch (FileNotFoundException e) {
                e.printStackTrace();
                UI.printError(Module.GEOM, ""Unable to read mesh file \""%s\"" - file not found"", filename);
            } catch (NumberFormatException e) {
                e.printStackTrace();
                UI.printError(Module.GEOM, ""Unable to read mesh file \""%s\"" - syntax error at line %d"", lineNumber);
            } catch (IOException e) {
                e.printStackTrace();
                UI.printError(Module.GEOM, ""Unable to read mesh file \""%s\"" - I/O error occured"", filename);
            }
        } else if (filename.endsWith("".stl"")) {
            try {
                UI.printInfo(Module.GEOM, ""STL - Reading geometry: \""%s\"" ..."", filename);
                FileInputStream file = new FileInputStream(filename);
                DataInputStream stream = new DataInputStream(new BufferedInputStream(file));
                file.skip(80);
                int numTris = getLittleEndianInt(stream.readInt());
                UI.printInfo(Module.GEOM, ""STL -   * Reading %d triangles ..."", numTris);
                long filesize = new File(filename).length();
                if (filesize != (84 + 50 * numTris)) {
                    UI.printWarning(Module.GEOM, ""STL - Size of file mismatch (expecting %s, found %s)"", Memory.bytesToString(84 + 14 * numTris), Memory.bytesToString(filesize));
                    return null;
                }
                int[] tris = new int[3 * numTris];
                float[] verts = new float[9 * numTris];
                for (int i = 0, i3 = 0, index = 0; i < numTris; i++, i3 += 3) {
                    // skip normal
                    stream.readInt();
                    stream.readInt();
                    stream.readInt();
                    for (int j = 0; j < 3; j++, index += 3) {
                        tris[i3 + j] = i3 + j;
                        // get xyz
                        verts[index + 0] = getLittleEndianFloat(stream.readInt());
                        verts[index + 1] = getLittleEndianFloat(stream.readInt());
                        verts[index + 2] = getLittleEndianFloat(stream.readInt());
                    }
                    stream.readShort();
                    if ((i + 1) % 100000 == 0)
                        UI.printInfo(Module.GEOM, ""STL -   * Parsed %7d triangles ..."", i + 1);
                }
                file.close();
                // create geometry
                UI.printInfo(Module.GEOM, ""STL -   * Creating mesh ..."");
                ParameterList pl = new ParameterList();
                pl.addIntegerArray(""triangles"", tris);
                pl.addPoints(""points"", InterpolationType.VERTEX, verts);
                TriangleMesh m = new TriangleMesh();
                if (m.update(pl, null))
                    return m;
            } catch (FileNotFoundException e) {
                e.printStackTrace();
                UI.printError(Module.GEOM, ""Unable to read mesh file \""%s\"" - file not found"", filename);
            } catch (IOException e) {
                e.printStackTrace();
                UI.printError(Module.GEOM, ""Unable to read mesh file \""%s\"" - I/O error occured"", filename);
            }
        } else
            UI.printWarning(Module.GEOM, ""Unable to read mesh file \""%s\"" - unrecognized format"", filename);
        return null;
    }"
org.sunflow.core.tesselatable.FileMesh.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        String file = pl.getString(""filename"", null);
        if (file != null)
            filename = api.resolveIncludeFilename(file);
        return filename != null;
    }"
org.sunflow.core.tesselatable.FileMesh.getLittleEndianInt,"    private int getLittleEndianInt(int i) {
        // input integer has its bytes in big endian byte order
        // swap them around
        return (i >>> 24) | ((i >>> 8) & 0xFF00) | ((i << 8) & 0xFF0000) | (i << 24);
    }"
org.sunflow.core.tesselatable.FileMesh.getLittleEndianFloat,"    private float getLittleEndianFloat(int i) {
        // input integer has its bytes in big endian byte order
        // swap them around and interpret data as floating point
        return Float.intBitsToFloat(getLittleEndianInt(i));
    }
"
org.sunflow.core.tesselatable.BezierMesh.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        BoundingBox bounds = new BoundingBox();
        if (o2w == null) {
            for (int i = 0; i < patches.length; i++) {
                float[] patch = patches[i];
                for (int j = 0; j < patch.length; j += 3)
                    bounds.include(patch[j], patch[j + 1], patch[j + 2]);
            }
        } else {
            // transform vertices first
            for (int i = 0; i < patches.length; i++) {
                float[] patch = patches[i];
                for (int j = 0; j < patch.length; j += 3) {
                    float x = patch[j];
                    float y = patch[j + 1];
                    float z = patch[j + 2];
                    float wx = o2w.transformPX(x, y, z);
                    float wy = o2w.transformPY(x, y, z);
                    float wz = o2w.transformPZ(x, y, z);
                    bounds.include(wx, wy, wz);
                }
            }
        }
        return bounds;
    }"
org.sunflow.core.tesselatable.BezierMesh.bernstein,"    private float[] bernstein(float u) {
        float[] b = new float[4];
        float i = 1 - u;
        b[0] = i * i * i;
        b[1] = 3 * u * i * i;
        b[2] = 3 * u * u * i;
        b[3] = u * u * u;
        return b;
    }"
org.sunflow.core.tesselatable.BezierMesh.bernsteinDeriv,"    private float[] bernsteinDeriv(float u) {
        if (!smooth)
            return null;
        float[] b = new float[4];
        float i = 1 - u;
        b[0] = 3 * (0 - i * i);
        b[1] = 3 * (i * i - 2 * u * i);
        b[2] = 3 * (2 * u * i - u * u);
        b[3] = 3 * (u * u - 0);
        return b;
    }"
org.sunflow.core.tesselatable.BezierMesh.getPatchPoint,"    private void getPatchPoint(float u, float v, float[] ctrl, float[] bu, float[] bv, float[] bdu, float[] bdv, Point3 p, Vector3 n) {
        float px = 0;
        float py = 0;
        float pz = 0;
        for (int i = 0, index = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++, index += 3) {
                float scale = bu[j] * bv[i];
                px += ctrl[index + 0] * scale;
                py += ctrl[index + 1] * scale;
                pz += ctrl[index + 2] * scale;
            }
        }
        p.x = px;
        p.y = py;
        p.z = pz;
        if (n != null) {
            float dpdux = 0;
            float dpduy = 0;
            float dpduz = 0;
            float dpdvx = 0;
            float dpdvy = 0;
            float dpdvz = 0;
            for (int i = 0, index = 0; i < 4; i++) {
                for (int j = 0; j < 4; j++, index += 3) {
                    float scaleu = bdu[j] * bv[i];
                    dpdux += ctrl[index + 0] * scaleu;
                    dpduy += ctrl[index + 1] * scaleu;
                    dpduz += ctrl[index + 2] * scaleu;
                    float scalev = bu[j] * bdv[i];
                    dpdvx += ctrl[index + 0] * scalev;
                    dpdvy += ctrl[index + 1] * scalev;
                    dpdvz += ctrl[index + 2] * scalev;
                }
            }
            // surface normal
            n.x = (dpduy * dpdvz - dpduz * dpdvy);
            n.y = (dpduz * dpdvx - dpdux * dpdvz);
            n.z = (dpdux * dpdvy - dpduy * dpdvx);
        }
    }"
org.sunflow.core.tesselatable.BezierMesh.tesselate,"    public PrimitiveList tesselate() {
        float[] vertices = new float[patches.length * (subdivs + 1) * (subdivs + 1) * 3];
        float[] normals = smooth ? new float[patches.length * (subdivs + 1) * (subdivs + 1) * 3] : null;
        float[] uvs = new float[patches.length * (subdivs + 1) * (subdivs + 1) * 2];
        int[] indices = new int[patches.length * subdivs * subdivs * (quads ? 4 : (2 * 3))];

        int vidx = 0, pidx = 0;
        float step = 1.0f / subdivs;
        int vstride = subdivs + 1;
        Point3 p = new Point3();
        Vector3 n = smooth ? new Vector3() : null;
        for (float[] patch : patches) {
            // create patch vertices
            for (int i = 0, voff = 0; i <= subdivs; i++) {
                float u = i * step;
                float[] bu = bernstein(u);
                float[] bdu = bernsteinDeriv(u);
                for (int j = 0; j <= subdivs; j++, voff += 3) {
                    float v = j * step;
                    float[] bv = bernstein(v);
                    float[] bdv = bernsteinDeriv(v);
                    getPatchPoint(u, v, patch, bu, bv, bdu, bdv, p, n);
                    vertices[vidx + voff + 0] = p.x;
                    vertices[vidx + voff + 1] = p.y;
                    vertices[vidx + voff + 2] = p.z;
                    if (smooth) {
                        normals[vidx + voff + 0] = n.x;
                        normals[vidx + voff + 1] = n.y;
                        normals[vidx + voff + 2] = n.z;
                    }
                    uvs[(vidx + voff) / 3 * 2 + 0] = u;
                    uvs[(vidx + voff) / 3 * 2 + 1] = v;
                }
            }
            // generate patch triangles
            for (int i = 0, vbase = vidx / 3; i < subdivs; i++) {
                for (int j = 0; j < subdivs; j++) {
                    int v00 = (i + 0) * vstride + (j + 0);
                    int v10 = (i + 1) * vstride + (j + 0);
                    int v01 = (i + 0) * vstride + (j + 1);
                    int v11 = (i + 1) * vstride + (j + 1);
                    if (quads) {
                        indices[pidx + 0] = vbase + v01;
                        indices[pidx + 1] = vbase + v00;
                        indices[pidx + 2] = vbase + v10;
                        indices[pidx + 3] = vbase + v11;
                        pidx += 4;
                    } else {
                        // add 2 triangles
                        indices[pidx + 0] = vbase + v00;
                        indices[pidx + 1] = vbase + v10;
                        indices[pidx + 2] = vbase + v01;
                        indices[pidx + 3] = vbase + v10;
                        indices[pidx + 4] = vbase + v11;
                        indices[pidx + 5] = vbase + v01;
                        pidx += 6;
                    }
                }
            }
            vidx += vstride * vstride * 3;
        }
        ParameterList pl = new ParameterList();
        pl.addPoints(""points"", InterpolationType.VERTEX, vertices);
        if (quads)
            pl.addIntegerArray(""quads"", indices);
        else
            pl.addIntegerArray(""triangles"", indices);
        pl.addTexCoords(""uvs"", InterpolationType.VERTEX, uvs);
        if (smooth)
            pl.addVectors(""normals"", InterpolationType.VERTEX, normals);
        PrimitiveList m = quads ? new QuadMesh() : new TriangleMesh();
        m.update(pl, null);
        pl.clear(true);
        return m;
    }"
org.sunflow.core.tesselatable.BezierMesh.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        subdivs = pl.getInt(""subdivs"", subdivs);
        smooth = pl.getBoolean(""smooth"", smooth);
        quads = pl.getBoolean(""quads"", quads);
        return subdivs > 0;
    }"
org.sunflow.core.tesselatable.BezierMesh.getNumPrimitives,"    public int getNumPrimitives() {
        return patches.length;
    }"
org.sunflow.core.tesselatable.BezierMesh.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        float[] patch = patches[primID];
        int axis = i >>> 1;
        if ((i & 1) == 0) {
            float min = patch[axis];
            for (int j = axis + 3; j < patch.length; j += 3)
                if (min > patch[j])
                    min = patch[j];
            return min;
        } else {
            float max = patch[axis];
            for (int j = axis + 3; j < patch.length; j += 3)
                if (max < patch[j])
                    max = patch[j];
            return max;
        }
    }"
org.sunflow.core.tesselatable.BezierMesh.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        // ray patch intersection
        final float[] stack = state.getRobustStack();
        final int STACKSIZE = 64;
        {
            // init patch
            float[] patch = patches[primID];
            for (int i = 0; i < 4 * 4 * 3; i++)
                stack[i] = patch[i];
            stack[48] = Float.POSITIVE_INFINITY; // bbox size
            stack[49] = 0; // umin
            stack[50] = 0; // vmin
            stack[51] = 1; // umax
            stack[52] = 1; // vmax
        }
        int stackpos = 0;
        float orgX = r.ox, invDirX = 1 / r.dx;
        float orgY = r.oy, invDirY = 1 / r.dy;
        float orgZ = r.oz, invDirZ = 1 / r.dz;
        float t1, t2;
        while (stackpos >= 0) {
            float intervalMin = r.getMin();
            float intervalMax = r.getMax();
            // x-axis bbox
            float minx = stack[stackpos + 0];
            float maxx = stack[stackpos + 0];
            for (int j = 1, idx = stackpos + 3; j < 4 * 4; j++, idx += 3) {
                if (minx > stack[idx])
                    minx = stack[idx];
                if (maxx < stack[idx])
                    maxx = stack[idx];
            }
            t1 = (minx - orgX) * invDirX;
            t2 = (maxx - orgX) * invDirX;
            if (invDirX > 0) {
                if (t1 > intervalMin)
                    intervalMin = t1;
                if (t2 < intervalMax)
                    intervalMax = t2;
            } else {
                if (t2 > intervalMin)
                    intervalMin = t2;
                if (t1 < intervalMax)
                    intervalMax = t1;
            }
            if (intervalMin > intervalMax) {
                stackpos -= STACKSIZE;
                continue;
            }
            // y-axis bbox
            float miny = stack[stackpos + 1];
            float maxy = stack[stackpos + 1];
            for (int j = 1, idx = stackpos + 4; j < 4 * 4; j++, idx += 3) {
                if (miny > stack[idx])
                    miny = stack[idx];
                if (maxy < stack[idx])
                    maxy = stack[idx];
            }
            t1 = (miny - orgY) * invDirY;
            t2 = (maxy - orgY) * invDirY;
            if (invDirY > 0) {
                if (t1 > intervalMin)
                    intervalMin = t1;
                if (t2 < intervalMax)
                    intervalMax = t2;
            } else {
                if (t2 > intervalMin)
                    intervalMin = t2;
                if (t1 < intervalMax)
                    intervalMax = t1;
            }
            if (intervalMin > intervalMax) {
                stackpos -= STACKSIZE;
                continue;
            }
            // z-axis bbox
            float minz = stack[stackpos + 2];
            float maxz = stack[stackpos + 2];
            for (int j = 1, idx = stackpos + 5; j < 4 * 4; j++, idx += 3) {
                if (minz > stack[idx])
                    minz = stack[idx];
                if (maxz < stack[idx])
                    maxz = stack[idx];
            }

            t1 = (minz - orgZ) * invDirZ;
            t2 = (maxz - orgZ) * invDirZ;
            if (invDirZ > 0) {
                if (t1 > intervalMin)
                    intervalMin = t1;
                if (t2 < intervalMax)
                    intervalMax = t2;
            } else {
                if (t2 > intervalMin)
                    intervalMin = t2;
                if (t1 < intervalMax)
                    intervalMax = t1;
            }

            if (intervalMin > intervalMax) {
                stackpos -= STACKSIZE;
                continue;
            }
            // intersection was found - keep going
            float size = (maxx - minx) + (maxy - miny) + (maxz - minz);
            if (Float.floatToRawIntBits(stack[stackpos + 48]) == Float.floatToRawIntBits(size)) {
                // L1 norm is 0, we are done
                r.setMax(intervalMin);
                state.setIntersection(primID, stack[stackpos + 49], stack[stackpos + 50]);
                stackpos -= STACKSIZE;
                continue;
            }
            // not small enough yet - subdivide
            // lets pick a subdivision axis first:
            float sizeu = 0;
            float sizev = 0;
            for (int i = 0; i < 3; i++) {
                sizeu += Math.abs(stack[stackpos + (0 * 4 + 3) * 3 + i] - stack[stackpos + i]);
                sizev += Math.abs(stack[stackpos + (3 * 4 + 0) * 3 + i] - stack[stackpos + i]);
            }

            if (sizeu > sizev) {
                // split in U direction
                for (int i = 0; i < 4; i++) {
                    for (int axis = 0; axis < 3; axis++) {
                        // load data
                        float p0 = stack[stackpos + (i * 4 + 0) * 3 + axis];
                        float p1 = stack[stackpos + (i * 4 + 1) * 3 + axis];
                        float p2 = stack[stackpos + (i * 4 + 2) * 3 + axis];
                        float p3 = stack[stackpos + (i * 4 + 3) * 3 + axis];
                        // Split curve in the middle
                        float q0 = p0;
                        float q1 = (p0 + p1) * 0.5f;
                        float q2 = q1 * 0.5f + (p1 + p2) * 0.25f;
                        float r3 = p3;
                        float r2 = (p2 + p3) * 0.5f;
                        float r1 = r2 * 0.5f + (p1 + p2) * 0.25f;
                        float q3 = (q2 + r1) * 0.5f;
                        float r0 = q3;
                        // load new curve data into the stack
                        stack[stackpos + (i * 4 + 0) * 3 + axis] = q0;
                        stack[stackpos + (i * 4 + 1) * 3 + axis] = q1;
                        stack[stackpos + (i * 4 + 2) * 3 + axis] = q2;
                        stack[stackpos + (i * 4 + 3) * 3 + axis] = q3;
                        stack[stackpos + STACKSIZE + (i * 4 + 0) * 3 + axis] = r0;
                        stack[stackpos + STACKSIZE + (i * 4 + 1) * 3 + axis] = r1;
                        stack[stackpos + STACKSIZE + (i * 4 + 2) * 3 + axis] = r2;
                        stack[stackpos + STACKSIZE + (i * 4 + 3) * 3 + axis] = r3;
                    }
                }
                // copy current bbox size
                stack[stackpos + 48] = stack[stackpos + STACKSIZE + 48] = size;
                // finally - split uv ranges
                float umin = stack[stackpos + 49];
                float umax = stack[stackpos + 51];
                stack[stackpos + 49] = umin;
                stack[stackpos + STACKSIZE + 50] = stack[stackpos + 50];
                stack[stackpos + 51] = stack[stackpos + STACKSIZE + 49] = (umin + umax) * 0.5f;
                stack[stackpos + STACKSIZE + 51] = umax;
                stack[stackpos + STACKSIZE + 52] = stack[stackpos + 52];
            } else {
                // split in V direction
                for (int i = 0; i < 4; i++) {
                    for (int axis = 0; axis < 3; axis++) {
                        // load data
                        float p0 = stack[stackpos + (0 * 4 + i) * 3 + axis];
                        float p1 = stack[stackpos + (1 * 4 + i) * 3 + axis];
                        float p2 = stack[stackpos + (2 * 4 + i) * 3 + axis];
                        float p3 = stack[stackpos + (3 * 4 + i) * 3 + axis];
                        // Split curve in the middle
                        float q0 = p0;
                        float q1 = (p0 + p1) * 0.5f;
                        float q2 = q1 * 0.5f + (p1 + p2) * 0.25f;
                        float r3 = p3;
                        float r2 = (p2 + p3) * 0.5f;
                        float r1 = r2 * 0.5f + (p1 + p2) * 0.25f;
                        float q3 = (q2 + r1) * 0.5f;
                        float r0 = q3;
                        // load new curve data into the stack
                        stack[stackpos + (0 * 4 + i) * 3 + axis] = q0;
                        stack[stackpos + (1 * 4 + i) * 3 + axis] = q1;
                        stack[stackpos + (2 * 4 + i) * 3 + axis] = q2;
                        stack[stackpos + (3 * 4 + i) * 3 + axis] = q3;
                        stack[stackpos + STACKSIZE + (0 * 4 + i) * 3 + axis] = r0;
                        stack[stackpos + STACKSIZE + (1 * 4 + i) * 3 + axis] = r1;
                        stack[stackpos + STACKSIZE + (2 * 4 + i) * 3 + axis] = r2;
                        stack[stackpos + STACKSIZE + (3 * 4 + i) * 3 + axis] = r3;
                    }
                }
                // copy current bbox size
                stack[stackpos + 48] = stack[stackpos + STACKSIZE + 48] = size;
                // finally - split uv ranges
                float vmin = stack[stackpos + 50];
                float vmax = stack[stackpos + 52];
                stack[stackpos + STACKSIZE + 49] = stack[stackpos + 49];
                stack[stackpos + 50] = vmin;
                stack[stackpos + 52] = stack[stackpos + STACKSIZE + 50] = (vmin + vmax) * 0.5f;
                stack[stackpos + STACKSIZE + 51] = stack[stackpos + 51];
                stack[stackpos + STACKSIZE + 52] = vmax;
            }
            stackpos += STACKSIZE;
        }
    }"
org.sunflow.core.tesselatable.BezierMesh.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        state.init();
        state.getRay().getPoint(state.getPoint());
        Instance parent = state.getInstance();
        float u = state.getU();
        float v = state.getV();
        float[] bu = bernstein(u);
        float[] bdu = bernsteinDeriv(u);
        float[] bv = bernstein(v);
        float[] bdv = bernsteinDeriv(v);
        getPatchPoint(u, v, patches[state.getPrimitiveID()], bu, bv, bdu, bdv, new Point3(), state.getNormal());
        state.getNormal().set(parent.transformNormalObjectToWorld(state.getNormal()));
        state.getNormal().normalize();
        state.getGeoNormal().set(state.getNormal());
        state.getUV().set(u, v);
        state.setShader(parent.getShader(0));
        state.setModifier(parent.getModifier(0));
        // FIXME: use actual derivatives to create basis
        state.setBasis(OrthoNormalBasis.makeFromW(state.getNormal()));
    }"
org.sunflow.core.tesselatable.BezierMesh.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }
"
org.sunflow.core.bucket.BucketOrderFactory.create,"    public static BucketOrder create(String order) {
        boolean flip = false;
        if (order.startsWith(""inverse"") || order.startsWith(""invert"") || order.startsWith(""reverse"")) {
            String[] tokens = order.split(""\\s+"");
            if (tokens.length == 2) {
                order = tokens[1];
                flip = true;
            }
        }
        BucketOrder o = null;
        if (order.equals(""row""))
            o = new RowBucketOrder();
        else if (order.equals(""column""))
            o = new ColumnBucketOrder();
        else if (order.equals(""diagonal""))
            o = new DiagonalBucketOrder();
        else if (order.equals(""spiral""))
            o = new SpiralBucketOrder();
        else if (order.equals(""hilbert""))
            o = new HilbertBucketOrder();
        else if (order.equals(""random""))
            o = new RandomBucketOrder();
        if (o == null) {
            UI.printWarning(Module.BCKT, ""Unrecognized bucket ordering: \""%s\"" - using hilbert"", order);
            return new HilbertBucketOrder();
        } else {
            if (flip)
                o = new InvertedBucketOrder(o);
            return o;
        }
    }
"
org.sunflow.core.bucket.HilbertBucketOrder.getBucketSequence,"    public int[] getBucketSequence(int nbw, int nbh) {
        int hi = 0; // hilbert curve index
        int hn = 0; // hilbert curve order
        while (((1 << hn) < nbw || (1 << hn) < nbh) && hn < 16)
            hn++; // fit to number of buckets
        int hN = 1 << (2 * hn); // number of hilbert buckets - 2**2n
        int n = nbw * nbh; // total number of buckets
        int[] coords = new int[2 * n]; // storage for bucket coordinates
        for (int i = 0; i < n; i++) {
            int hx, hy;
            do {
                // s is the hilbert index, shifted to start in the middle
                int s = hi; // (hi + (hN >> 1)) & (hN - 1);
                // int n = hn;
                // adapted from Hacker's Delight
                int comp, swap, cs, t, sr;
                s = s | (0x55555555 << (2 * hn)); // Pad s on left with 01
                sr = (s >>> 1) & 0x55555555; // (no change) groups.
                cs = ((s & 0x55555555) + sr) ^ 0x55555555;// Compute
                // complement
                // & swap info in
                // two-bit groups.
                // Parallel prefix xor op to propagate both complement
                // and swap info together from left to right (there is
                // no step ""cs ^= cs >> 1"", so in effect it computes
                // two independent parallel prefix operations on two
                // interleaved sets of sixteen bits).
                cs = cs ^ (cs >>> 2);
                cs = cs ^ (cs >>> 4);
                cs = cs ^ (cs >>> 8);
                cs = cs ^ (cs >>> 16);
                swap = cs & 0x55555555; // Separate the swap and
                comp = (cs >>> 1) & 0x55555555; // complement bits.
                t = (s & swap) ^ comp; // Calculate x and y in
                s = s ^ sr ^ t ^ (t << 1); // the odd & even bit
                // positions, resp.
                s = s & ((1 << 2 * hn) - 1); // Clear out any junk
                // on the left (unpad).
                // Now ""unshuffle"" to separate the x and y bits.
                t = (s ^ (s >>> 1)) & 0x22222222;
                s = s ^ t ^ (t << 1);
                t = (s ^ (s >>> 2)) & 0x0C0C0C0C;
                s = s ^ t ^ (t << 2);
                t = (s ^ (s >>> 4)) & 0x00F000F0;
                s = s ^ t ^ (t << 4);
                t = (s ^ (s >>> 8)) & 0x0000FF00;
                s = s ^ t ^ (t << 8);
                hx = s >>> 16; // Assign the two halves
                hy = s & 0xFFFF; // of t to x and y.
                hi++;
            } while ((hx >= nbw || hy >= nbh || hx < 0 || hy < 0) && hi < hN);
            coords[2 * i + 0] = hx;
            coords[2 * i + 1] = hy;
        }
        return coords;
    }
"
org.sunflow.core.bucket.DiagonalBucketOrder.getBucketSequence,"    public int[] getBucketSequence(int nbw, int nbh) {
        int[] coords = new int[2 * nbw * nbh];
        int x = 0, y = 0, nx = 1, ny = 0;
        for (int i = 0; i < nbw * nbh; i++) {
            coords[2 * i + 0] = x;
            coords[2 * i + 1] = y;
            do {
                if (y == ny) {
                    y = 0;
                    x = nx;
                    ny++;
                    nx++;
                } else {
                    x--;
                    y++;
                }
            } while ((y >= nbh || x >= nbw) && i != (nbw * nbh - 1));
        }
        return coords;
    }
"
org.sunflow.core.bucket.InvertedBucketOrder.getBucketSequence,"    public int[] getBucketSequence(int nbw, int nbh) {
        int[] coords = order.getBucketSequence(nbw, nbh);
        for (int i = 0; i < coords.length / 2; i += 2) {
            int src = i;
            int dst = coords.length - 2 - i;
            int tmp = coords[src + 0];
            coords[src + 0] = coords[dst + 0];
            coords[dst + 0] = tmp;
            tmp = coords[src + 1];
            coords[src + 1] = coords[dst + 1];
            coords[dst + 1] = tmp;
        }
        return coords;
    }
"
org.sunflow.core.bucket.ColumnBucketOrder.getBucketSequence,"    public int[] getBucketSequence(int nbw, int nbh) {
        int[] coords = new int[2 * nbw * nbh];
        for (int i = 0; i < nbw * nbh; i++) {
            int bx = i / nbh;
            int by = i % nbh;
            if ((bx & 1) == 1)
                by = nbh - 1 - by;
            coords[2 * i + 0] = bx;
            coords[2 * i + 1] = by;
        }
        return coords;
    }
"
org.sunflow.core.bucket.RowBucketOrder.getBucketSequence,"    public int[] getBucketSequence(int nbw, int nbh) {
        int[] coords = new int[2 * nbw * nbh];
        for (int i = 0; i < nbw * nbh; i++) {
            int by = i / nbw;
            int bx = i % nbw;
            if ((by & 1) == 1)
                bx = nbw - 1 - bx;
            coords[2 * i + 0] = bx;
            coords[2 * i + 1] = by;
        }
        return coords;
    }
"
org.sunflow.core.bucket.RandomBucketOrder.getBucketSequence,"    public int[] getBucketSequence(int nbw, int nbh) {
        int[] coords = new int[2 * nbw * nbh];
        for (int i = 0; i < nbw * nbh; i++) {
            int by = i / nbw;
            int bx = i % nbw;
            if ((by & 1) == 1)
                bx = nbw - 1 - bx;
            coords[2 * i + 0] = bx;
            coords[2 * i + 1] = by;
        }

        long seed = 2463534242L;
        for (int i = 0; i < coords.length; i++) {
            // pick 2 random indices
            seed = xorshift(seed);
            int src = mod((int) seed, nbw * nbh);
            seed = xorshift(seed);
            int dst = mod((int) seed, nbw * nbh);
            int tmp = coords[2 * src + 0];
            coords[2 * src + 0] = coords[2 * dst + 0];
            coords[2 * dst + 0] = tmp;
            tmp = coords[2 * src + 1];
            coords[2 * src + 1] = coords[2 * dst + 1];
            coords[2 * dst + 1] = tmp;
        }

        return coords;
    }"
org.sunflow.core.bucket.RandomBucketOrder.mod,"    private int mod(int a, int b) {
        int m = a % b;
        return (m < 0) ? m + b : m;
    }"
org.sunflow.core.bucket.RandomBucketOrder.xorshift,"    private long xorshift(long y) {
        y = y ^ (y << 13);
        y = y ^ (y >>> 17); // unsigned
        y = y ^ (y << 5);
        return y;
    }
"
org.sunflow.core.bucket.SpiralBucketOrder.getBucketSequence,"    public int[] getBucketSequence(int nbw, int nbh) {
        int[] coords = new int[2 * nbw * nbh];
        for (int i = 0; i < nbw * nbh; i++) {
            int bx, by;
            int center = (Math.min(nbw, nbh) - 1) / 2;
            int nx = nbw;
            int ny = nbh;
            while (i < (nx * ny)) {
                nx--;
                ny--;
            }
            int nxny = nx * ny;
            int minnxny = Math.min(nx, ny);
            if ((minnxny & 1) == 1) {
                if (i <= (nxny + ny)) {
                    bx = nx - minnxny / 2;
                    by = -minnxny / 2 + i - nxny;
                } else {
                    bx = nx - minnxny / 2 - (i - (nxny + ny));
                    by = ny - minnxny / 2;
                }
            } else {
                if (i <= (nxny + ny)) {
                    bx = -minnxny / 2;
                    by = ny - minnxny / 2 - (i - nxny);
                } else {
                    bx = -minnxny / 2 + (i - (nxny + ny));
                    by = -minnxny / 2;
                }
            }
            coords[2 * i + 0] = bx + center;
            coords[2 * i + 1] = by + center;
        }
        return coords;
    }
"
org.sunflow.core.shader.DiffuseShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        diff = pl.getColor(""diffuse"", diff);
        return true;
    }"
org.sunflow.core.shader.DiffuseShader.getDiffuse,"    public Color getDiffuse(ShadingState state) {
        return diff;
    }"
org.sunflow.core.shader.DiffuseShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        // make sure we are on the right side of the material
        state.faceforward();
        // setup lighting
        state.initLightSamples();
        state.initCausticSamples();
        return state.diffuse(getDiffuse(state));
    }"
org.sunflow.core.shader.DiffuseShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        Color diffuse;
        // make sure we are on the right side of the material
        if (Vector3.dot(state.getNormal(), state.getRay().getDirection()) > 0.0) {
            state.getNormal().negate();
            state.getGeoNormal().negate();
        }
        diffuse = getDiffuse(state);
        state.storePhoton(state.getRay().getDirection(), power, diffuse);
        float avg = diffuse.getAverage();
        double rnd = state.getRandom(0, 0, 1);
        if (rnd < avg) {
            // photon is scattered
            power.mul(diffuse).mul(1.0f / avg);
            OrthoNormalBasis onb = state.getBasis();
            double u = 2 * Math.PI * rnd / avg;
            double v = state.getRandom(0, 1, 1);
            float s = (float) Math.sqrt(v);
            float s1 = (float) Math.sqrt(1.0 - v);
            Vector3 w = new Vector3((float) Math.cos(u) * s, (float) Math.sin(u) * s, s1);
            w = onb.transform(w, new Vector3());
            state.traceDiffusePhoton(new Ray(state.getPoint(), w), power);
        }
    }
"
org.sunflow.core.shader.AmbientOcclusionShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        bright = pl.getColor(""bright"", bright);
        dark = pl.getColor(""dark"", dark);
        samples = pl.getInt(""samples"", samples);
        maxDist = pl.getFloat(""maxdist"", maxDist);
        if (maxDist <= 0)
            maxDist = Float.POSITIVE_INFINITY;
        return true;
    }"
org.sunflow.core.shader.AmbientOcclusionShader.getBrightColor,"    public Color getBrightColor(ShadingState state) {
        return bright;
    }"
org.sunflow.core.shader.AmbientOcclusionShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        return state.occlusion(samples, maxDist, getBrightColor(state), dark);
    }"
org.sunflow.core.shader.AmbientOcclusionShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.shader.TexturedAmbientOcclusionShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        String filename = pl.getString(""texture"", null);
        if (filename != null)
            tex = TextureCache.getTexture(api.resolveTextureFilename(filename), false);
        return tex != null && super.update(pl, api);
    }"
org.sunflow.core.shader.TexturedAmbientOcclusionShader.getBrightColor,"    public Color getBrightColor(ShadingState state) {
        return tex.getPixel(state.getUV().x, state.getUV().y);
    }
"
org.sunflow.core.shader.ViewGlobalPhotonsShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.shader.ViewGlobalPhotonsShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        state.faceforward();
        return state.getGlobalRadiance();
    }"
org.sunflow.core.shader.ViewGlobalPhotonsShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.shader.NormalShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.shader.NormalShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        Vector3 n = state.getNormal();
        if (n == null)
            return Color.BLACK;
        float r = (n.x + 1) * 0.5f;
        float g = (n.y + 1) * 0.5f;
        float b = (n.z + 1) * 0.5f;
        return new Color(r, g, b);
    }"
org.sunflow.core.shader.NormalShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.shader.AnisotropicWardShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        rhoD = pl.getColor(""diffuse"", rhoD);
        rhoS = pl.getColor(""specular"", rhoS);
        alphaX = pl.getFloat(""roughnessX"", alphaX);
        alphaY = pl.getFloat(""roughnessY"", alphaY);
        numRays = pl.getInt(""samples"", numRays);
        return true;
    }"
org.sunflow.core.shader.AnisotropicWardShader.getDiffuse,"    protected Color getDiffuse(ShadingState state) {
        return rhoD;
    }"
org.sunflow.core.shader.AnisotropicWardShader.brdf,"    private float brdf(Vector3 i, Vector3 o, OrthoNormalBasis basis) {
        float fr = 4 * (float) Math.PI * alphaX * alphaY;
        fr *= (float) Math.sqrt(basis.untransformZ(i) * basis.untransformZ(o));
        Vector3 h = Vector3.add(i, o, new Vector3());
        basis.untransform(h);
        float hx = h.x / alphaX;
        hx *= hx;
        float hy = h.y / alphaY;
        hy *= hy;
        float hn = h.z * h.z;
        fr = (float) Math.exp(-(hx + hy) / hn) / fr;
        return fr;
    }"
org.sunflow.core.shader.AnisotropicWardShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        // make sure we are on the right side of the material
        state.faceforward();
        OrthoNormalBasis onb = state.getBasis();
        // direct lighting and caustics
        state.initLightSamples();
        state.initCausticSamples();
        Color lr = Color.black();
        // compute specular contribution
        if (state.includeSpecular()) {
            Vector3 in = state.getRay().getDirection().negate(new Vector3());
            for (LightSample sample : state) {
                float cosNL = sample.dot(state.getNormal());
                float fr = brdf(in, sample.getShadowRay().getDirection(), onb);
                lr.madd(cosNL * fr, sample.getSpecularRadiance());
            }

            // indirect lighting - specular
            if (numRays > 0) {
                int n = state.getDepth() == 0 ? numRays : 1;
                for (int i = 0; i < n; i++) {
                    // specular indirect lighting
                    double r1 = state.getRandom(i, 0, n);
                    double r2 = state.getRandom(i, 1, n);

                    float alphaRatio = alphaY / alphaX;
                    float phi = 0;
                    if (r1 < 0.25) {
                        double val = 4 * r1;
                        phi = (float) Math.atan(alphaRatio * Math.tan(Math.PI / 2 * val));
                    } else if (r1 < 0.5) {
                        double val = 1 - 4 * (0.5 - r1);
                        phi = (float) Math.atan(alphaRatio * Math.tan(Math.PI / 2 * val));
                        phi = (float) Math.PI - phi;
                    } else if (r1 < 0.75) {
                        double val = 4 * (r1 - 0.5);
                        phi = (float) Math.atan(alphaRatio * Math.tan(Math.PI / 2 * val));
                        phi += Math.PI;
                    } else {
                        double val = 1 - 4 * (1 - r1);
                        phi = (float) Math.atan(alphaRatio * Math.tan(Math.PI / 2 * val));
                        phi = 2 * (float) Math.PI - phi;
                    }

                    float cosPhi = (float) Math.cos(phi);
                    float sinPhi = (float) Math.sin(phi);

                    float denom = (cosPhi * cosPhi) / (alphaX * alphaX) + (sinPhi * sinPhi) / (alphaY * alphaY);
                    float theta = (float) Math.atan(Math.sqrt(-Math.log(1 - r2) / denom));

                    float sinTheta = (float) Math.sin(theta);
                    float cosTheta = (float) Math.cos(theta);

                    Vector3 h = new Vector3();
                    h.x = sinTheta * cosPhi;
                    h.y = sinTheta * sinPhi;
                    h.z = cosTheta;
                    onb.transform(h);

                    Vector3 o = new Vector3();
                    float ih = Vector3.dot(h, in);
                    o.x = 2 * ih * h.x - in.x;
                    o.y = 2 * ih * h.y - in.y;
                    o.z = 2 * ih * h.z - in.z;

                    float no = onb.untransformZ(o);
                    float ni = onb.untransformZ(in);
                    float w = ih * cosTheta * cosTheta * cosTheta * (float) Math.sqrt(Math.abs(no / ni));

                    Ray r = new Ray(state.getPoint(), o);
                    lr.madd(w / n, state.traceGlossy(r, i));
                }
            }
            lr.mul(rhoS);
        }
        // add diffuse contribution
        lr.add(state.diffuse(getDiffuse(state)));
        return lr;
    }"
org.sunflow.core.shader.AnisotropicWardShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        // make sure we are on the right side of the material
        state.faceforward();
        Color d = getDiffuse(state);
        state.storePhoton(state.getRay().getDirection(), power, d);
        float avgD = d.getAverage();
        float avgS = rhoS.getAverage();
        double rnd = state.getRandom(0, 0, 1);
        if (rnd < avgD) {
            // photon is scattered diffusely
            power.mul(d).mul(1.0f / avgD);
            OrthoNormalBasis onb = state.getBasis();
            double u = 2 * Math.PI * rnd / avgD;
            double v = state.getRandom(0, 1, 1);
            float s = (float) Math.sqrt(v);
            float s1 = (float) Math.sqrt(1.0f - v);
            Vector3 w = new Vector3((float) Math.cos(u) * s, (float) Math.sin(u) * s, s1);
            w = onb.transform(w, new Vector3());
            state.traceDiffusePhoton(new Ray(state.getPoint(), w), power);
        } else if (rnd < avgD + avgS) {
            // photon is scattered specularly
            power.mul(rhoS).mul(1 / avgS);
            OrthoNormalBasis basis = state.getBasis();
            Vector3 in = state.getRay().getDirection().negate(new Vector3());
            double r1 = rnd / avgS;
            double r2 = state.getRandom(0, 1, 1);

            float alphaRatio = alphaY / alphaX;
            float phi = 0;
            if (r1 < 0.25) {
                double val = 4 * r1;
                phi = (float) Math.atan(alphaRatio * Math.tan(Math.PI / 2 * val));
            } else if (r1 < 0.5) {
                double val = 1 - 4 * (0.5 - r1);
                phi = (float) Math.atan(alphaRatio * Math.tan(Math.PI / 2 * val));
                phi = (float) Math.PI - phi;
            } else if (r1 < 0.75) {
                double val = 4 * (r1 - 0.5);
                phi = (float) Math.atan(alphaRatio * Math.tan(Math.PI / 2 * val));
                phi += Math.PI;
            } else {
                double val = 1 - 4 * (1 - r1);
                phi = (float) Math.atan(alphaRatio * Math.tan(Math.PI / 2 * val));
                phi = 2 * (float) Math.PI - phi;
            }

            float cosPhi = (float) Math.cos(phi);
            float sinPhi = (float) Math.sin(phi);

            float denom = (cosPhi * cosPhi) / (alphaX * alphaX) + (sinPhi * sinPhi) / (alphaY * alphaY);
            float theta = (float) Math.atan(Math.sqrt(-Math.log(1 - r2) / denom));

            float sinTheta = (float) Math.sin(theta);
            float cosTheta = (float) Math.cos(theta);

            Vector3 h = new Vector3();
            h.x = sinTheta * cosPhi;
            h.y = sinTheta * sinPhi;
            h.z = cosTheta;
            basis.transform(h);

            Vector3 o = new Vector3();
            float ih = Vector3.dot(h, in);
            o.x = 2 * ih * h.x - in.x;
            o.y = 2 * ih * h.y - in.y;
            o.z = 2 * ih * h.z - in.z;

            Ray r = new Ray(state.getPoint(), o);
            state.traceReflectionPhoton(r, power);
        }
    }
"
org.sunflow.core.shader.ShinyDiffuseShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        diff = pl.getColor(""diffuse"", diff);
        refl = pl.getFloat(""shiny"", refl);
        return true;
    }"
org.sunflow.core.shader.ShinyDiffuseShader.getDiffuse,"    public Color getDiffuse(ShadingState state) {
        return diff;
    }"
org.sunflow.core.shader.ShinyDiffuseShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        // make sure we are on the right side of the material
        state.faceforward();
        // direct lighting
        state.initLightSamples();
        state.initCausticSamples();
        Color d = getDiffuse(state);
        Color lr = state.diffuse(d);
        if (!state.includeSpecular())
            return lr;
        float cos = state.getCosND();
        float dn = 2 * cos;
        Vector3 refDir = new Vector3();
        refDir.x = (dn * state.getNormal().x) + state.getRay().getDirection().x;
        refDir.y = (dn * state.getNormal().y) + state.getRay().getDirection().y;
        refDir.z = (dn * state.getNormal().z) + state.getRay().getDirection().z;
        Ray refRay = new Ray(state.getPoint(), refDir);
        // compute Fresnel term
        cos = 1 - cos;
        float cos2 = cos * cos;
        float cos5 = cos2 * cos2 * cos;

        Color ret = Color.white();
        Color r = d.copy().mul(refl);
        ret.sub(r);
        ret.mul(cos5);
        ret.add(r);
        return lr.add(ret.mul(state.traceReflection(refRay, 0)));
    }"
org.sunflow.core.shader.ShinyDiffuseShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        Color diffuse;
        // make sure we are on the right side of the material
        state.faceforward();
        diffuse = getDiffuse(state);
        state.storePhoton(state.getRay().getDirection(), power, diffuse);
        float d = diffuse.getAverage();
        float r = d * refl;
        double rnd = state.getRandom(0, 0, 1);
        if (rnd < d) {
            // photon is scattered
            power.mul(diffuse).mul(1.0f / d);
            OrthoNormalBasis onb = state.getBasis();
            double u = 2 * Math.PI * rnd / d;
            double v = state.getRandom(0, 1, 1);
            float s = (float) Math.sqrt(v);
            float s1 = (float) Math.sqrt(1.0 - v);
            Vector3 w = new Vector3((float) Math.cos(u) * s, (float) Math.sin(u) * s, s1);
            w = onb.transform(w, new Vector3());
            state.traceDiffusePhoton(new Ray(state.getPoint(), w), power);
        } else if (rnd < d + r) {
            float cos = -Vector3.dot(state.getNormal(), state.getRay().getDirection());
            power.mul(diffuse).mul(1.0f / d);
            // photon is reflected
            float dn = 2 * cos;
            Vector3 dir = new Vector3();
            dir.x = (dn * state.getNormal().x) + state.getRay().getDirection().x;
            dir.y = (dn * state.getNormal().y) + state.getRay().getDirection().y;
            dir.z = (dn * state.getNormal().z) + state.getRay().getDirection().z;
            state.traceReflectionPhoton(new Ray(state.getPoint(), dir), power);
        }
    }
"
org.sunflow.core.shader.UVShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.shader.UVShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        if (state.getUV() == null)
            return Color.BLACK;
        return new Color(state.getUV().x, state.getUV().y, 0);
    }"
org.sunflow.core.shader.UVShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.shader.MirrorShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        color = pl.getColor(""color"", color);
        return true;
    }"
org.sunflow.core.shader.MirrorShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        if (!state.includeSpecular())
            return Color.BLACK;
        state.faceforward();
        float cos = state.getCosND();
        float dn = 2 * cos;
        Vector3 refDir = new Vector3();
        refDir.x = (dn * state.getNormal().x) + state.getRay().getDirection().x;
        refDir.y = (dn * state.getNormal().y) + state.getRay().getDirection().y;
        refDir.z = (dn * state.getNormal().z) + state.getRay().getDirection().z;
        Ray refRay = new Ray(state.getPoint(), refDir);

        // compute Fresnel term
        cos = 1 - cos;
        float cos2 = cos * cos;
        float cos5 = cos2 * cos2 * cos;
        Color ret = Color.white();
        ret.sub(color);
        ret.mul(cos5);
        ret.add(color);
        return ret.mul(state.traceReflection(refRay, 0));
    }"
org.sunflow.core.shader.MirrorShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        float avg = color.getAverage();
        double rnd = state.getRandom(0, 0, 1);
        if (rnd >= avg)
            return;
        state.faceforward();
        float cos = state.getCosND();
        power.mul(color).mul(1.0f / avg);
        // photon is reflected
        float dn = 2 * cos;
        Vector3 dir = new Vector3();
        dir.x = (dn * state.getNormal().x) + state.getRay().getDirection().x;
        dir.y = (dn * state.getNormal().y) + state.getRay().getDirection().y;
        dir.z = (dn * state.getNormal().z) + state.getRay().getDirection().z;
        state.traceReflectionPhoton(new Ray(state.getPoint(), dir), power);
    }
"
org.sunflow.core.shader.ViewIrradianceShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.shader.ViewIrradianceShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        state.faceforward();
        return new Color().set(state.getIrradiance(Color.WHITE)).mul(1.0f / (float) Math.PI);
    }"
org.sunflow.core.shader.ViewIrradianceShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.shader.UberShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        diff = pl.getColor(""diffuse"", diff);
        spec = pl.getColor(""specular"", spec);
        String filename;
        filename = pl.getString(""diffuse.texture"", null);
        if (filename != null)
            diffmap = TextureCache.getTexture(api.resolveTextureFilename(filename), false);
        filename = pl.getString(""specular.texture"", null);
        if (filename != null)
            specmap = TextureCache.getTexture(api.resolveTextureFilename(filename), false);
        diffBlend = MathUtils.clamp(pl.getFloat(""diffuse.blend"", diffBlend), 0, 1);
        specBlend = MathUtils.clamp(pl.getFloat(""specular.blend"", diffBlend), 0, 1);
        glossyness = MathUtils.clamp(pl.getFloat(""glossyness"", glossyness), 0, 1);
        numSamples = pl.getInt(""samples"", numSamples);
        return true;
    }"
org.sunflow.core.shader.UberShader.getDiffuse,"    public Color getDiffuse(ShadingState state) {
        return diffmap == null ? diff : Color.blend(diff, diffmap.getPixel(state.getUV().x, state.getUV().y), diffBlend);
    }"
org.sunflow.core.shader.UberShader.getSpecular,"    public Color getSpecular(ShadingState state) {
        return specmap == null ? spec : Color.blend(spec, specmap.getPixel(state.getUV().x, state.getUV().y), specBlend);
    }"
org.sunflow.core.shader.UberShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        // make sure we are on the right side of the material
        state.faceforward();
        // direct lighting
        state.initLightSamples();
        state.initCausticSamples();
        Color d = getDiffuse(state);
        Color lr = state.diffuse(d);
        if (!state.includeSpecular())
            return lr;
        if (glossyness == 0) {
            float cos = state.getCosND();
            float dn = 2 * cos;
            Vector3 refDir = new Vector3();
            refDir.x = (dn * state.getNormal().x) + state.getRay().getDirection().x;
            refDir.y = (dn * state.getNormal().y) + state.getRay().getDirection().y;
            refDir.z = (dn * state.getNormal().z) + state.getRay().getDirection().z;
            Ray refRay = new Ray(state.getPoint(), refDir);
            // compute Fresnel term
            cos = 1 - cos;
            float cos2 = cos * cos;
            float cos5 = cos2 * cos2 * cos;

            Color ret = Color.white();
            ret.sub(spec);
            ret.mul(cos5);
            ret.add(spec);
            return lr.add(ret.mul(state.traceReflection(refRay, 0)));
        } else
            return lr.add(state.specularPhong(getSpecular(state), 2 / glossyness, numSamples));
    }"
org.sunflow.core.shader.UberShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        Color diffuse, specular;
        // make sure we are on the right side of the material
        state.faceforward();
        diffuse = getDiffuse(state);
        specular = getSpecular(state);
        state.storePhoton(state.getRay().getDirection(), power, diffuse);
        float d = diffuse.getAverage();
        float r = specular.getAverage();
        double rnd = state.getRandom(0, 0, 1);
        if (rnd < d) {
            // photon is scattered
            power.mul(diffuse).mul(1.0f / d);
            OrthoNormalBasis onb = state.getBasis();
            double u = 2 * Math.PI * rnd / d;
            double v = state.getRandom(0, 1, 1);
            float s = (float) Math.sqrt(v);
            float s1 = (float) Math.sqrt(1.0 - v);
            Vector3 w = new Vector3((float) Math.cos(u) * s, (float) Math.sin(u) * s, s1);
            w = onb.transform(w, new Vector3());
            state.traceDiffusePhoton(new Ray(state.getPoint(), w), power);
        } else if (rnd < d + r) {
            if (glossyness == 0) {
                float cos = -Vector3.dot(state.getNormal(), state.getRay().getDirection());
                power.mul(diffuse).mul(1.0f / d);
                // photon is reflected
                float dn = 2 * cos;
                Vector3 dir = new Vector3();
                dir.x = (dn * state.getNormal().x) + state.getRay().getDirection().x;
                dir.y = (dn * state.getNormal().y) + state.getRay().getDirection().y;
                dir.z = (dn * state.getNormal().z) + state.getRay().getDirection().z;
                state.traceReflectionPhoton(new Ray(state.getPoint(), dir), power);
            } else {
                float dn = 2.0f * state.getCosND();
                // reflected direction
                Vector3 refDir = new Vector3();
                refDir.x = (dn * state.getNormal().x) + state.getRay().dx;
                refDir.y = (dn * state.getNormal().y) + state.getRay().dy;
                refDir.z = (dn * state.getNormal().z) + state.getRay().dz;
                power.mul(spec).mul(1.0f / r);
                OrthoNormalBasis onb = state.getBasis();
                double u = 2 * Math.PI * (rnd - r) / r;
                double v = state.getRandom(0, 1, 1);
                float s = (float) Math.pow(v, 1 / ((1.0f / glossyness) + 1));
                float s1 = (float) Math.sqrt(1 - s * s);
                Vector3 w = new Vector3((float) Math.cos(u) * s1, (float) Math.sin(u) * s1, s);
                w = onb.transform(w, new Vector3());
                state.traceReflectionPhoton(new Ray(state.getPoint(), w), power);
            }
        }
    }
"
org.sunflow.core.shader.PhongShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        diff = pl.getColor(""diffuse"", diff);
        spec = pl.getColor(""specular"", spec);
        power = pl.getFloat(""power"", power);
        numRays = pl.getInt(""samples"", numRays);
        return true;
    }"
org.sunflow.core.shader.PhongShader.getDiffuse,"    protected Color getDiffuse(ShadingState state) {
        return diff;
    }"
org.sunflow.core.shader.PhongShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        // make sure we are on the right side of the material
        state.faceforward();
        // setup lighting
        state.initLightSamples();
        state.initCausticSamples();
        // execute shader
        return state.diffuse(getDiffuse(state)).add(state.specularPhong(spec, power, numRays));
    }"
org.sunflow.core.shader.PhongShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        // make sure we are on the right side of the material
        state.faceforward();
        Color d = getDiffuse(state);
        state.storePhoton(state.getRay().getDirection(), power, d);
        float avgD = d.getAverage();
        float avgS = spec.getAverage();
        double rnd = state.getRandom(0, 0, 1);
        if (rnd < avgD) {
            // photon is scattered diffusely
            power.mul(d).mul(1.0f / avgD);
            OrthoNormalBasis onb = state.getBasis();
            double u = 2 * Math.PI * rnd / avgD;
            double v = state.getRandom(0, 1, 1);
            float s = (float) Math.sqrt(v);
            float s1 = (float) Math.sqrt(1.0f - v);
            Vector3 w = new Vector3((float) Math.cos(u) * s, (float) Math.sin(u) * s, s1);
            w = onb.transform(w, new Vector3());
            state.traceDiffusePhoton(new Ray(state.getPoint(), w), power);
        } else if (rnd < avgD + avgS) {
            // photon is scattered specularly
            float dn = 2.0f * state.getCosND();
            // reflected direction
            Vector3 refDir = new Vector3();
            refDir.x = (dn * state.getNormal().x) + state.getRay().dx;
            refDir.y = (dn * state.getNormal().y) + state.getRay().dy;
            refDir.z = (dn * state.getNormal().z) + state.getRay().dz;
            power.mul(spec).mul(1.0f / avgS);
            OrthoNormalBasis onb = state.getBasis();
            double u = 2 * Math.PI * (rnd - avgD) / avgS;
            double v = state.getRandom(0, 1, 1);
            float s = (float) Math.pow(v, 1 / (this.power + 1));
            float s1 = (float) Math.sqrt(1 - s * s);
            Vector3 w = new Vector3((float) Math.cos(u) * s1, (float) Math.sin(u) * s1, s);
            w = onb.transform(w, new Vector3());
            state.traceReflectionPhoton(new Ray(state.getPoint(), w), power);
        }
    }
"
org.sunflow.core.shader.QuickGrayShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.shader.QuickGrayShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        if (state.getNormal() == null) {
            // if this shader has been applied to an infinite instance because of shader overrides
            // run the default shader, otherwise, just shade black
            return state.getShader() != this ? state.getShader().getRadiance(state) : Color.BLACK;
        }
        // make sure we are on the right side of the material
        state.faceforward();
        // setup lighting
        state.initLightSamples();
        state.initCausticSamples();
        return state.diffuse(Color.GRAY);
    }"
org.sunflow.core.shader.QuickGrayShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        Color diffuse;
        // make sure we are on the right side of the material
        if (Vector3.dot(state.getNormal(), state.getRay().getDirection()) > 0.0) {
            state.getNormal().negate();
            state.getGeoNormal().negate();
        }
        diffuse = Color.GRAY;
        state.storePhoton(state.getRay().getDirection(), power, diffuse);
        float avg = diffuse.getAverage();
        double rnd = state.getRandom(0, 0, 1);
        if (rnd < avg) {
            // photon is scattered
            power.mul(diffuse).mul(1.0f / avg);
            OrthoNormalBasis onb = state.getBasis();
            double u = 2 * Math.PI * rnd / avg;
            double v = state.getRandom(0, 1, 1);
            float s = (float) Math.sqrt(v);
            float s1 = (float) Math.sqrt(1.0 - v);
            Vector3 w = new Vector3((float) Math.cos(u) * s, (float) Math.sin(u) * s, s1);
            w = onb.transform(w, new Vector3());
            state.traceDiffusePhoton(new Ray(state.getPoint(), w), power);
        }
    }
"
org.sunflow.core.shader.TexturedDiffuseShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        String filename = pl.getString(""texture"", null);
        if (filename != null)
            tex = TextureCache.getTexture(api.resolveTextureFilename(filename), false);
        return tex != null && super.update(pl, api);
    }"
org.sunflow.core.shader.TexturedDiffuseShader.getDiffuse,"    public Color getDiffuse(ShadingState state) {
        return tex.getPixel(state.getUV().x, state.getUV().y);
    }
"
org.sunflow.core.shader.PrimIDShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.shader.PrimIDShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        Vector3 n = state.getNormal();
        float f = n == null ? 1.0f : Math.abs(state.getRay().dot(n));
        return BORDERS[state.getPrimitiveID() % BORDERS.length].copy().mul(f);
    }"
org.sunflow.core.shader.PrimIDShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.shader.TexturedWardShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        String filename = pl.getString(""texture"", null);
        if (filename != null)
            tex = TextureCache.getTexture(api.resolveTextureFilename(filename), false);
        return tex != null && super.update(pl, api);
    }"
org.sunflow.core.shader.TexturedWardShader.getDiffuse,"    public Color getDiffuse(ShadingState state) {
        return tex.getPixel(state.getUV().x, state.getUV().y);
    }
"
org.sunflow.core.shader.WireframeShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        lineColor = pl.getColor(""line"", lineColor);
        fillColor = pl.getColor(""fill"", fillColor);
        width = pl.getFloat(""width"", width);
        cosWidth = (float) Math.cos(width);
        return true;
    }"
org.sunflow.core.shader.WireframeShader.getFillColor,"    public Color getFillColor(ShadingState state) {
        return fillColor;
    }"
org.sunflow.core.shader.WireframeShader.getLineColor,"    public Color getLineColor(ShadingState state) {
        return lineColor;
    }"
org.sunflow.core.shader.WireframeShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        Point3[] p = new Point3[3];
        if (!state.getTrianglePoints(p))
            return getFillColor(state);
        // transform points into camera space
        Point3 center = state.getPoint();
        Matrix4 w2c = state.getWorldToCamera();
        center = w2c.transformP(center);
        for (int i = 0; i < 3; i++)
            p[i] = w2c.transformP(state.getInstance().transformObjectToWorld(p[i]));
        float cn = 1.0f / (float) Math.sqrt(center.x * center.x + center.y * center.y + center.z * center.z);
        for (int i = 0, i2 = 2; i < 3; i2 = i, i++) {
            // compute orthogonal projection of the shading point onto each
            // triangle edge as in:
            // http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
            float t = (center.x - p[i].x) * (p[i2].x - p[i].x);
            t += (center.y - p[i].y) * (p[i2].y - p[i].y);
            t += (center.z - p[i].z) * (p[i2].z - p[i].z);
            t /= p[i].distanceToSquared(p[i2]);
            float projx = (1 - t) * p[i].x + t * p[i2].x;
            float projy = (1 - t) * p[i].y + t * p[i2].y;
            float projz = (1 - t) * p[i].z + t * p[i2].z;
            float n = 1.0f / (float) Math.sqrt(projx * projx + projy * projy + projz * projz);
            // check angular width
            float dot = projx * center.x + projy * center.y + projz * center.z;
            if (dot * n * cn >= cosWidth)
                return getLineColor(state);
        }
        return getFillColor(state);
    }"
org.sunflow.core.shader.WireframeShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.shader.TexturedPhongShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        String filename = pl.getString(""texture"", null);
        if (filename != null)
            tex = TextureCache.getTexture(api.resolveTextureFilename(filename), false);
        return tex != null && super.update(pl, api);
    }"
org.sunflow.core.shader.TexturedPhongShader.getDiffuse,"    public Color getDiffuse(ShadingState state) {
        return tex.getPixel(state.getUV().x, state.getUV().y);
    }
"
org.sunflow.core.shader.SimpleShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.shader.SimpleShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        return new Color(Math.abs(state.getRay().dot(state.getNormal())));
    }"
org.sunflow.core.shader.SimpleShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.shader.ConstantShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        c = pl.getColor(""color"", c);
        return true;
    }"
org.sunflow.core.shader.ConstantShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        return c;
    }"
org.sunflow.core.shader.ConstantShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.shader.ViewCausticsShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.shader.ViewCausticsShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        state.faceforward();
        state.initCausticSamples();
        // integrate a diffuse function
        Color lr = Color.black();
        for (LightSample sample : state)
            lr.madd(sample.dot(state.getNormal()), sample.getDiffuseRadiance());
        return lr.mul(1.0f / (float) Math.PI);

    }"
org.sunflow.core.shader.ViewCausticsShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.shader.GlassShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        color = pl.getColor(""color"", color);
        eta = pl.getFloat(""eta"", eta);
        f0 = (1 - eta) / (1 + eta);
        f0 = f0 * f0;
        absorbtionDistance = pl.getFloat(""absorbtion.distance"", absorbtionDistance);
        absorbtionColor = pl.getColor(""absorbtion.color"", absorbtionColor);
        return true;
    }"
org.sunflow.core.shader.GlassShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        if (!state.includeSpecular())
            return Color.BLACK;
        Vector3 reflDir = new Vector3();
        Vector3 refrDir = new Vector3();
        state.faceforward();
        float cos = state.getCosND();
        boolean inside = state.isBehind();
        float neta = inside ? eta : 1.0f / eta;

        float dn = 2 * cos;
        reflDir.x = (dn * state.getNormal().x) + state.getRay().getDirection().x;
        reflDir.y = (dn * state.getNormal().y) + state.getRay().getDirection().y;
        reflDir.z = (dn * state.getNormal().z) + state.getRay().getDirection().z;

        // refracted ray
        float arg = 1 - (neta * neta * (1 - (cos * cos)));
        boolean tir = arg < 0;
        if (tir)
            refrDir.x = refrDir.y = refrDir.z = 0;
        else {
            float nK = (neta * cos) - (float) Math.sqrt(arg);
            refrDir.x = (neta * state.getRay().dx) + (nK * state.getNormal().x);
            refrDir.y = (neta * state.getRay().dy) + (nK * state.getNormal().y);
            refrDir.z = (neta * state.getRay().dz) + (nK * state.getNormal().z);
        }

        // compute Fresnel terms
        float cosTheta1 = Vector3.dot(state.getNormal(), reflDir);
        float cosTheta2 = -Vector3.dot(state.getNormal(), refrDir);

        float pPara = (cosTheta1 - eta * cosTheta2) / (cosTheta1 + eta * cosTheta2);
        float pPerp = (eta * cosTheta1 - cosTheta2) / (eta * cosTheta1 + cosTheta2);
        float kr = 0.5f * (pPara * pPara + pPerp * pPerp);
        float kt = 1 - kr;

        Color absorbtion = null;
        if (inside && absorbtionDistance > 0) {
            // this ray is inside the object and leaving it
            // compute attenuation that occured along the ray
            absorbtion = Color.mul(-state.getRay().getMax() / absorbtionDistance, absorbtionColor.copy().opposite()).exp();
            if (absorbtion.isBlack())
                return Color.BLACK; // nothing goes through
        }
        // refracted ray
        Color ret = Color.black();
        if (!tir) {
            ret.madd(kt, state.traceRefraction(new Ray(state.getPoint(), refrDir), 0)).mul(color);
        }
        if (!inside || tir)
            ret.add(Color.mul(kr, state.traceReflection(new Ray(state.getPoint(), reflDir), 0)).mul(color));
        return absorbtion != null ? ret.mul(absorbtion) : ret;
    }"
org.sunflow.core.shader.GlassShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        Color refr = Color.mul(1 - f0, color);
        Color refl = Color.mul(f0, color);
        float avgR = refl.getAverage();
        float avgT = refr.getAverage();
        double rnd = state.getRandom(0, 0, 1);
        if (rnd < avgR) {
            state.faceforward();
            // don't reflect internally
            if (state.isBehind())
                return;
            // photon is reflected
            float cos = state.getCosND();
            power.mul(refl).mul(1.0f / avgR);
            float dn = 2 * cos;
            Vector3 dir = new Vector3();
            dir.x = (dn * state.getNormal().x) + state.getRay().getDirection().x;
            dir.y = (dn * state.getNormal().y) + state.getRay().getDirection().y;
            dir.z = (dn * state.getNormal().z) + state.getRay().getDirection().z;
            state.traceReflectionPhoton(new Ray(state.getPoint(), dir), power);
        } else if (rnd < avgR + avgT) {
            state.faceforward();
            // photon is refracted
            float cos = state.getCosND();
            float neta = state.isBehind() ? eta : 1.0f / eta;
            power.mul(refr).mul(1.0f / avgT);
            float wK = -neta;
            float arg = 1 - (neta * neta * (1 - (cos * cos)));
            Vector3 dir = new Vector3();
            if (state.isBehind() && absorbtionDistance > 0) {
                // this ray is inside the object and leaving it
                // compute attenuation that occured along the ray
                power.mul(Color.mul(-state.getRay().getMax() / absorbtionDistance, absorbtionColor.copy().opposite()).exp());
            }
            if (arg < 0) {
                // TIR
                float dn = 2 * cos;
                dir.x = (dn * state.getNormal().x) + state.getRay().getDirection().x;
                dir.y = (dn * state.getNormal().y) + state.getRay().getDirection().y;
                dir.z = (dn * state.getNormal().z) + state.getRay().getDirection().z;
                state.traceReflectionPhoton(new Ray(state.getPoint(), dir), power);
            } else {
                float nK = (neta * cos) - (float) Math.sqrt(arg);
                dir.x = (-wK * state.getRay().dx) + (nK * state.getNormal().x);
                dir.y = (-wK * state.getRay().dy) + (nK * state.getNormal().y);
                dir.z = (-wK * state.getRay().dz) + (nK * state.getNormal().z);
                state.traceRefractionPhoton(new Ray(state.getPoint(), dir), power);
            }
        }
    }
"
org.sunflow.core.shader.TexturedShinyDiffuseShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        String filename = pl.getString(""texture"", null);
        if (filename != null)
            tex = TextureCache.getTexture(api.resolveTextureFilename(filename), false);
        return tex != null && super.update(pl, api);
    }"
org.sunflow.core.shader.TexturedShinyDiffuseShader.getDiffuse,"    public Color getDiffuse(ShadingState state) {
        return tex.getPixel(state.getUV().x, state.getUV().y);
    }
"
org.sunflow.core.shader.IDShader.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        return true;
    }"
org.sunflow.core.shader.IDShader.getRadiance,"    public Color getRadiance(ShadingState state) {
        Vector3 n = state.getNormal();
        float f = n == null ? 1.0f : Math.abs(state.getRay().dot(n));
        return new Color(state.getInstance().hashCode()).mul(f);
    }"
org.sunflow.core.shader.IDShader.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }
"
org.sunflow.core.light.SunSkyLight.computeAttenuatedSunlight,"    private SpectralCurve computeAttenuatedSunlight(float theta, float turbidity) {
        float[] data = new float[91]; // holds the sunsky curve data
        final double alpha = 1.3;
        final double lozone = 0.35;
        final double w = 2.0;
        double beta = 0.04608365822050 * turbidity - 0.04586025928522;
        // Relative optical mass
        double m = 1.0 / (Math.cos(theta) + 0.000940 * Math.pow(1.6386 - theta, -1.253));
        for (int i = 0, lambda = 350; lambda <= 800; i++, lambda += 5) {
            // Rayleigh scattering
            double tauR = Math.exp(-m * 0.008735 * Math.pow((double) lambda / 1000.0, -4.08));
            // Aerosol (water + dust) attenuation
            double tauA = Math.exp(-m * beta * Math.pow((double) lambda / 1000.0, -alpha));
            // Attenuation due to ozone absorption
            double tauO = Math.exp(-m * k_oCurve.sample(lambda) * lozone);
            // Attenuation due to mixed gases absorption
            double tauG = Math.exp(-1.41 * k_gCurve.sample(lambda) * m / Math.pow(1.0 + 118.93 * k_gCurve.sample(lambda) * m, 0.45));
            // Attenuation due to water vapor absorption
            double tauWA = Math.exp(-0.2385 * k_waCurve.sample(lambda) * w * m / Math.pow(1.0 + 20.07 * k_waCurve.sample(lambda) * w * m, 0.45));
            // 100.0 comes from solAmplitudes begin in wrong units.
            double amp = /* 100.0 * */solCurve.sample(lambda) * tauR * tauA * tauO * tauG * tauWA;
            data[i] = (float) amp;
        }
        return new RegularSpectralCurve(data, 350, 800);
    }"
org.sunflow.core.light.SunSkyLight.perezFunction,"    private double perezFunction(final double[] lam, double theta, double gamma, double lvz) {
        double den = ((1.0 + lam[0] * Math.exp(lam[1])) * (1.0 + lam[2] * Math.exp(lam[3] * sunTheta) + lam[4] * Math.cos(sunTheta) * Math.cos(sunTheta)));
        double num = ((1.0 + lam[0] * Math.exp(lam[1] / Math.cos(theta))) * (1.0 + lam[2] * Math.exp(lam[3] * gamma) + lam[4] * Math.cos(gamma) * Math.cos(gamma)));
        return lvz * num / den;
    }"
org.sunflow.core.light.SunSkyLight.initSunSky,"    private void initSunSky() {
        // perform all the required initialization of constants
        sunDirWorld.normalize();
        sunDir = basis.untransform(sunDirWorld, new Vector3());
        sunDir.normalize();
        sunTheta = (float) Math.acos(MathUtils.clamp(sunDir.z, -1, 1));
        if (sunDir.z > 0) {
            sunSpectralRadiance = computeAttenuatedSunlight(sunTheta, turbidity);
            // produce color suitable for rendering
            sunColor = RGBSpace.SRGB.convertXYZtoRGB(sunSpectralRadiance.toXYZ().mul(1e-4f)).constrainRGB();
        } else {
            sunSpectralRadiance = new ConstantSpectralCurve(0);
        }
        // sunSolidAngle = (float) (0.25 * Math.PI * 1.39 * 1.39 / (150 * 150));
        float theta2 = sunTheta * sunTheta;
        float theta3 = sunTheta * theta2;
        float T = turbidity;
        float T2 = turbidity * turbidity;
        double chi = (4.0 / 9.0 - T / 120.0) * (Math.PI - 2.0 * sunTheta);
        zenithY = (4.0453 * T - 4.9710) * Math.tan(chi) - 0.2155 * T + 2.4192;
        zenithY *= 1000; /* conversion from kcd/m^2 to cd/m^2 */
        zenithx = (0.00165 * theta3 - 0.00374 * theta2 + 0.00208 * sunTheta + 0) * T2 + (-0.02902 * theta3 + 0.06377 * theta2 - 0.03202 * sunTheta + 0.00394) * T + (0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * sunTheta + 0.25885);
        zenithy = (0.00275 * theta3 - 0.00610 * theta2 + 0.00316 * sunTheta + 0) * T2 + (-0.04212 * theta3 + 0.08970 * theta2 - 0.04153 * sunTheta + 0.00515) * T + (0.15346 * theta3 - 0.26756 * theta2 + 0.06669 * sunTheta + 0.26688);

        perezY[0] = 0.17872 * T - 1.46303;
        perezY[1] = -0.35540 * T + 0.42749;
        perezY[2] = -0.02266 * T + 5.32505;
        perezY[3] = 0.12064 * T - 2.57705;
        perezY[4] = -0.06696 * T + 0.37027;

        perezx[0] = -0.01925 * T - 0.25922;
        perezx[1] = -0.06651 * T + 0.00081;
        perezx[2] = -0.00041 * T + 0.21247;
        perezx[3] = -0.06409 * T - 0.89887;
        perezx[4] = -0.00325 * T + 0.04517;

        perezy[0] = -0.01669 * T - 0.26078;
        perezy[1] = -0.09495 * T + 0.00921;
        perezy[2] = -0.00792 * T + 0.21023;
        perezy[3] = -0.04405 * T - 1.65369;
        perezy[4] = -0.01092 * T + 0.05291;

        final int w = 32, h = 32;
        imageHistogram = new float[w][h];
        colHistogram = new float[w];
        float du = 1.0f / w;
        float dv = 1.0f / h;
        for (int x = 0; x < w; x++) {
            for (int y = 0; y < h; y++) {
                float u = (x + 0.5f) * du;
                float v = (y + 0.5f) * dv;
                Color c = getSkyRGB(getDirection(u, v));
                imageHistogram[x][y] = c.getLuminance() * (float) Math.sin(Math.PI * v);
                if (y > 0)
                    imageHistogram[x][y] += imageHistogram[x][y - 1];
            }
            colHistogram[x] = imageHistogram[x][h - 1];
            if (x > 0)
                colHistogram[x] += colHistogram[x - 1];
            for (int y = 0; y < h; y++)
                imageHistogram[x][y] /= imageHistogram[x][h - 1];
        }
        for (int x = 0; x < w; x++)
            colHistogram[x] /= colHistogram[w - 1];
        jacobian = (float) (2 * Math.PI * Math.PI) / (w * h);
    }"
org.sunflow.core.light.SunSkyLight.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        Vector3 up = pl.getVector(""up"", null);
        Vector3 east = pl.getVector(""east"", null);
        if (up != null && east != null)
            basis = OrthoNormalBasis.makeFromWV(up, east);
        else if (up != null)
            basis = OrthoNormalBasis.makeFromW(up);
        numSkySamples = pl.getInt(""samples"", numSkySamples);
        sunDirWorld = pl.getVector(""sundir"", sunDirWorld);
        turbidity = pl.getFloat(""turbidity"", turbidity);
        // recompute model
        initSunSky();
        return true;
    }"
org.sunflow.core.light.SunSkyLight.init,"    public void init(String name, SunflowAPI api) {
        // register this object with the api properly
        api.geometry(name, this);
        api.shader(name + "".shader"", this);
        api.parameter(""shaders"", name + "".shader"");
        api.instance(name + "".instance"", name);
        api.light(name + "".light"", this);
    }"
org.sunflow.core.light.SunSkyLight.getSkyRGB,"    private Color getSkyRGB(Vector3 dir) {
        if (dir.z < 0)
            return Color.BLACK;
        if (dir.z < 0.001f)
            dir.z = 0.001f;
        dir.normalize();
        double theta = Math.acos(MathUtils.clamp(dir.z, -1, 1));
        double gamma = Math.acos(MathUtils.clamp(Vector3.dot(dir, sunDir), -1, 1));
        double x = perezFunction(perezx, theta, gamma, zenithx);
        double y = perezFunction(perezy, theta, gamma, zenithy);
        double Y = perezFunction(perezY, theta, gamma, zenithY) * 1e-4;
        XYZColor c = ChromaticitySpectrum.get((float) x, (float) y);
        // XYZColor c = new ChromaticitySpectrum((float) x, (float) y).toXYZ();
        float X = (float) (c.getX() * Y / c.getY());
        float Z = (float) (c.getZ() * Y / c.getY());
        return RGBSpace.SRGB.convertXYZtoRGB(X, (float) Y, Z);
    }"
org.sunflow.core.light.SunSkyLight.getNumSamples,"    public int getNumSamples() {
        return 1 + numSkySamples;
    }"
org.sunflow.core.light.SunSkyLight.getPhoton,"    public void getPhoton(double randX1, double randY1, double randX2, double randY2, Point3 p, Vector3 dir, Color power) {
        // FIXME: not implemented
    }"
org.sunflow.core.light.SunSkyLight.getPower,"    public float getPower() {
        return 0;
    }"
org.sunflow.core.light.SunSkyLight.getSamples,"    public void getSamples(ShadingState state) {
        if (Vector3.dot(sunDirWorld, state.getGeoNormal()) > 0 && Vector3.dot(sunDirWorld, state.getNormal()) > 0) {
            LightSample dest = new LightSample();
            dest.setShadowRay(new Ray(state.getPoint(), sunDirWorld));
            dest.getShadowRay().setMax(Float.MAX_VALUE);
            dest.setRadiance(sunColor, sunColor);
            dest.traceShadow(state);
            state.addSample(dest);
        }
        int n = state.getDiffuseDepth() > 0 ? 1 : numSkySamples;
        for (int i = 0; i < n; i++) {
            // random offset on unit square, we use the infinite version of
            // getRandom because the light sampling is adaptive
            double randX = state.getRandom(i, 0, n);
            double randY = state.getRandom(i, 1, n);

            int x = 0;
            while (randX >= colHistogram[x] && x < colHistogram.length - 1)
                x++;
            float[] rowHistogram = imageHistogram[x];
            int y = 0;
            while (randY >= rowHistogram[y] && y < rowHistogram.length - 1)
                y++;
            // sample from (x, y)
            float u = (float) ((x == 0) ? (randX / colHistogram[0]) : ((randX - colHistogram[x - 1]) / (colHistogram[x] - colHistogram[x - 1])));
            float v = (float) ((y == 0) ? (randY / rowHistogram[0]) : ((randY - rowHistogram[y - 1]) / (rowHistogram[y] - rowHistogram[y - 1])));

            float px = ((x == 0) ? colHistogram[0] : (colHistogram[x] - colHistogram[x - 1]));
            float py = ((y == 0) ? rowHistogram[0] : (rowHistogram[y] - rowHistogram[y - 1]));

            float su = (x + u) / colHistogram.length;
            float sv = (y + v) / rowHistogram.length;
            float invP = (float) Math.sin(sv * Math.PI) * jacobian / (n * px * py);
            Vector3 localDir = getDirection(su, sv);
            Vector3 dir = basis.transform(localDir, new Vector3());
            if (Vector3.dot(dir, state.getGeoNormal()) > 0 && Vector3.dot(dir, state.getNormal()) > 0) {
                LightSample dest = new LightSample();
                dest.setShadowRay(new Ray(state.getPoint(), dir));
                dest.getShadowRay().setMax(Float.MAX_VALUE);
                Color radiance = getSkyRGB(localDir);
                dest.setRadiance(radiance, radiance);
                dest.getDiffuseRadiance().mul(invP);
                dest.getSpecularRadiance().mul(invP);
                dest.traceShadow(state);
                state.addSample(dest);
            }
        }
    }"
org.sunflow.core.light.SunSkyLight.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }"
org.sunflow.core.light.SunSkyLight.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.light.SunSkyLight.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        return 0;
    }"
org.sunflow.core.light.SunSkyLight.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        return null;
    }"
org.sunflow.core.light.SunSkyLight.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        if (r.getMax() == Float.POSITIVE_INFINITY)
            state.setIntersection(0, 0, 0);
    }"
org.sunflow.core.light.SunSkyLight.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        if (state.includeLights())
            state.setShader(this);
    }"
org.sunflow.core.light.SunSkyLight.getRadiance,"    public Color getRadiance(ShadingState state) {
        return getSkyRGB(basis.untransform(state.getRay().getDirection())).constrainRGB();
    }"
org.sunflow.core.light.SunSkyLight.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        // let photon escape
    }"
org.sunflow.core.light.SunSkyLight.getDirection,"    private Vector3 getDirection(float u, float v) {
        Vector3 dest = new Vector3();
        double phi = 0, theta = 0;
        theta = u * 2 * Math.PI;
        phi = v * Math.PI;
        double sin_phi = Math.sin(phi);
        dest.x = (float) (-sin_phi * Math.cos(theta));
        dest.y = (float) Math.cos(phi);
        dest.z = (float) (sin_phi * Math.sin(theta));
        return dest;
    }
"
org.sunflow.core.light.ImageBasedLight.updateBasis,"    private void updateBasis(Vector3 center, Vector3 up) {
        if (center != null && up != null) {
            basis = OrthoNormalBasis.makeFromWV(center, up);
            basis.swapWU();
            basis.flipV();
        }
    }"
org.sunflow.core.light.ImageBasedLight.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        updateBasis(pl.getVector(""center"", null), pl.getVector(""up"", null));
        numSamples = pl.getInt(""samples"", numSamples);

        String filename = pl.getString(""texture"", null);
        if (filename != null)
            texture = TextureCache.getTexture(api.resolveTextureFilename(filename), true);

        // no texture provided
        if (texture == null)
            return false;
        Bitmap b = texture.getBitmap();
        if (b == null)
            return false;

        // rebuild histograms if this is a new texture
        if (filename != null) {
            imageHistogram = new float[b.getWidth()][b.getHeight()];
            colHistogram = new float[b.getWidth()];
            float du = 1.0f / b.getWidth();
            float dv = 1.0f / b.getHeight();
            for (int x = 0; x < b.getWidth(); x++) {
                for (int y = 0; y < b.getHeight(); y++) {
                    float u = (x + 0.5f) * du;
                    float v = (y + 0.5f) * dv;
                    Color c = texture.getPixel(u, v);
                    // box filter the image
                    // c.add(texture.getPixel(u + du, v));
                    // c.add(texture.getPixel(u + du, v+ dv));
                    // c.add(texture.getPixel(u, v + dv));
                    // c.mul(0.25f);
                    imageHistogram[x][y] = c.getLuminance() * (float) Math.sin(Math.PI * v);
                    if (y > 0)
                        imageHistogram[x][y] += imageHistogram[x][y - 1];
                }
                colHistogram[x] = imageHistogram[x][b.getHeight() - 1];
                if (x > 0)
                    colHistogram[x] += colHistogram[x - 1];
                for (int y = 0; y < b.getHeight(); y++)
                    imageHistogram[x][y] /= imageHistogram[x][b.getHeight() - 1];
            }
            for (int x = 0; x < b.getWidth(); x++)
                colHistogram[x] /= colHistogram[b.getWidth() - 1];
            jacobian = (float) (2 * Math.PI * Math.PI) / (b.getWidth() * b.getHeight());
        }
        // take fixed samples
        if (pl.getBoolean(""fixed"", samples != null)) {
            // Bitmap loc = new Bitmap(filename);
            samples = new Vector3[numSamples];
            colors = new Color[numSamples];
            for (int i = 0; i < numSamples; i++) {
                double randX = (double) i / (double) numSamples;
                double randY = QMC.halton(0, i);
                int x = 0;
                while (randX >= colHistogram[x] && x < colHistogram.length - 1)
                    x++;
                float[] rowHistogram = imageHistogram[x];
                int y = 0;
                while (randY >= rowHistogram[y] && y < rowHistogram.length - 1)
                    y++;
                // sample from (x, y)
                float u = (float) ((x == 0) ? (randX / colHistogram[0]) : ((randX - colHistogram[x - 1]) / (colHistogram[x] - colHistogram[x - 1])));
                float v = (float) ((y == 0) ? (randY / rowHistogram[0]) : ((randY - rowHistogram[y - 1]) / (rowHistogram[y] - rowHistogram[y - 1])));

                float px = ((x == 0) ? colHistogram[0] : (colHistogram[x] - colHistogram[x - 1]));
                float py = ((y == 0) ? rowHistogram[0] : (rowHistogram[y] - rowHistogram[y - 1]));

                float su = (x + u) / colHistogram.length;
                float sv = (y + v) / rowHistogram.length;

                float invP = (float) Math.sin(sv * Math.PI) * jacobian / (numSamples * px * py);
                samples[i] = getDirection(su, sv);
                basis.transform(samples[i]);
                colors[i] = texture.getPixel(su, sv).mul(invP);
                // loc.setPixel(x, y, Color.YELLOW.copy().mul(1e6f));
            }
            // loc.save(""samples.hdr"");
        } else {
            // turn off
            samples = null;
            colors = null;
        }
        return true;
    }"
org.sunflow.core.light.ImageBasedLight.init,"    public void init(String name, SunflowAPI api) {
        // register this object with the api properly
        api.geometry(name, this);
        if (api.lookupGeometry(name) == null) {
            // quit if we don't see our geometry in here (error message
            // will have already been printed)
            return;
        }
        api.shader(name + "".shader"", this);
        api.parameter(""shaders"", name + "".shader"");
        api.instance(name + "".instance"", name);
        api.light(name + "".light"", this);
    }"
org.sunflow.core.light.ImageBasedLight.prepareShadingState,"    public void prepareShadingState(ShadingState state) {
        if (state.includeLights())
            state.setShader(this);
    }"
org.sunflow.core.light.ImageBasedLight.intersectPrimitive,"    public void intersectPrimitive(Ray r, int primID, IntersectionState state) {
        if (r.getMax() == Float.POSITIVE_INFINITY)
            state.setIntersection(0, 0, 0);
    }"
org.sunflow.core.light.ImageBasedLight.getNumPrimitives,"    public int getNumPrimitives() {
        return 1;
    }"
org.sunflow.core.light.ImageBasedLight.getPrimitiveBound,"    public float getPrimitiveBound(int primID, int i) {
        return 0;
    }"
org.sunflow.core.light.ImageBasedLight.getWorldBounds,"    public BoundingBox getWorldBounds(Matrix4 o2w) {
        return null;
    }"
org.sunflow.core.light.ImageBasedLight.getBakingPrimitives,"    public PrimitiveList getBakingPrimitives() {
        return null;
    }"
org.sunflow.core.light.ImageBasedLight.getNumSamples,"    public int getNumSamples() {
        return numSamples;
    }"
org.sunflow.core.light.ImageBasedLight.getSamples,"    public void getSamples(ShadingState state) {
        if (samples == null) {
            int n = state.getDiffuseDepth() > 0 ? 1 : numSamples;
            for (int i = 0; i < n; i++) {
                // random offset on unit square, we use the infinite version of
                // getRandom because the light sampling is adaptive
                double randX = state.getRandom(i, 0, n);
                double randY = state.getRandom(i, 1, n);
                int x = 0;
                while (randX >= colHistogram[x] && x < colHistogram.length - 1)
                    x++;
                float[] rowHistogram = imageHistogram[x];
                int y = 0;
                while (randY >= rowHistogram[y] && y < rowHistogram.length - 1)
                    y++;
                // sample from (x, y)
                float u = (float) ((x == 0) ? (randX / colHistogram[0]) : ((randX - colHistogram[x - 1]) / (colHistogram[x] - colHistogram[x - 1])));
                float v = (float) ((y == 0) ? (randY / rowHistogram[0]) : ((randY - rowHistogram[y - 1]) / (rowHistogram[y] - rowHistogram[y - 1])));

                float px = ((x == 0) ? colHistogram[0] : (colHistogram[x] - colHistogram[x - 1]));
                float py = ((y == 0) ? rowHistogram[0] : (rowHistogram[y] - rowHistogram[y - 1]));

                float su = (x + u) / colHistogram.length;
                float sv = (y + v) / rowHistogram.length;
                float invP = (float) Math.sin(sv * Math.PI) * jacobian / (n * px * py);
                Vector3 dir = getDirection(su, sv);
                basis.transform(dir);
                if (Vector3.dot(dir, state.getGeoNormal()) > 0) {
                    LightSample dest = new LightSample();
                    dest.setShadowRay(new Ray(state.getPoint(), dir));
                    dest.getShadowRay().setMax(Float.MAX_VALUE);
                    Color radiance = texture.getPixel(su, sv);
                    dest.setRadiance(radiance, radiance);
                    dest.getDiffuseRadiance().mul(invP);
                    dest.getSpecularRadiance().mul(invP);
                    dest.traceShadow(state);
                    state.addSample(dest);
                }
            }
        } else {
            for (int i = 0; i < numSamples; i++) {
                if (Vector3.dot(samples[i], state.getGeoNormal()) > 0 && Vector3.dot(samples[i], state.getNormal()) > 0) {
                    LightSample dest = new LightSample();
                    dest.setShadowRay(new Ray(state.getPoint(), samples[i]));
                    dest.getShadowRay().setMax(Float.MAX_VALUE);
                    dest.setRadiance(colors[i], colors[i]);
                    dest.traceShadow(state);
                    state.addSample(dest);
                }
            }
        }
    }"
org.sunflow.core.light.ImageBasedLight.getPhoton,"    public void getPhoton(double randX1, double randY1, double randX2, double randY2, Point3 p, Vector3 dir, Color power) {
    }"
org.sunflow.core.light.ImageBasedLight.getRadiance,"    public Color getRadiance(ShadingState state) {
        // lookup texture based on ray direction
        return state.includeLights() ? getColor(basis.untransform(state.getRay().getDirection(), new Vector3())) : Color.BLACK;
    }"
org.sunflow.core.light.ImageBasedLight.getColor,"    private Color getColor(Vector3 dir) {
        float u, v;
        // assume lon/lat format
        double phi = 0, theta = 0;
        phi = Math.acos(dir.y);
        theta = Math.atan2(dir.z, dir.x);
        u = (float) (0.5 - 0.5 * theta / Math.PI);
        v = (float) (phi / Math.PI);
        return texture.getPixel(u, v);
    }"
org.sunflow.core.light.ImageBasedLight.getDirection,"    private Vector3 getDirection(float u, float v) {
        Vector3 dest = new Vector3();
        double phi = 0, theta = 0;
        theta = u * 2 * Math.PI;
        phi = v * Math.PI;
        double sin_phi = Math.sin(phi);
        dest.x = (float) (-sin_phi * Math.cos(theta));
        dest.y = (float) Math.cos(phi);
        dest.z = (float) (sin_phi * Math.sin(theta));
        return dest;
    }"
org.sunflow.core.light.ImageBasedLight.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
    }"
org.sunflow.core.light.ImageBasedLight.getPower,"    public float getPower() {
        return 0;
    }
"
org.sunflow.core.light.DirectionalSpotlight.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        src = pl.getPoint(""source"", src);
        dir = pl.getVector(""dir"", dir);
        dir.normalize();
        r = pl.getFloat(""radius"", r);
        basis = OrthoNormalBasis.makeFromW(dir);
        r2 = r * r;
        radiance = pl.getColor(""radiance"", radiance);
        return true;
    }"
org.sunflow.core.light.DirectionalSpotlight.getNumSamples,"    public int getNumSamples() {
        return 1;
    }"
org.sunflow.core.light.DirectionalSpotlight.getLowSamples,"    public int getLowSamples() {
        return 1;
    }"
org.sunflow.core.light.DirectionalSpotlight.getSamples,"    public void getSamples(ShadingState state) {
        if (Vector3.dot(dir, state.getGeoNormal()) < 0 && Vector3.dot(dir, state.getNormal()) < 0) {
            // project point onto source plane
            float x = state.getPoint().x - src.x;
            float y = state.getPoint().y - src.y;
            float z = state.getPoint().z - src.z;
            float t = ((x * dir.x) + (y * dir.y) + (z * dir.z));
            if (t >= 0.0) {
                x -= (t * dir.x);
                y -= (t * dir.y);
                z -= (t * dir.z);
                if (((x * x) + (y * y) + (z * z)) <= r2) {
                    Point3 p = new Point3();
                    p.x = src.x + x;
                    p.y = src.y + y;
                    p.z = src.z + z;
                    LightSample dest = new LightSample();
                    dest.setShadowRay(new Ray(state.getPoint(), p));
                    dest.setRadiance(radiance, radiance);
                    dest.traceShadow(state);
                    state.addSample(dest);
                }
            }
        }
    }"
org.sunflow.core.light.DirectionalSpotlight.getPhoton,"    public void getPhoton(double randX1, double randY1, double randX2, double randY2, Point3 p, Vector3 dir, Color power) {
        float phi = (float) (2 * Math.PI * randX1);
        float s = (float) Math.sqrt(1.0f - randY1);
        dir.x = r * (float) Math.cos(phi) * s;
        dir.y = r * (float) Math.sin(phi) * s;
        dir.z = 0;
        basis.transform(dir);
        Point3.add(src, dir, p);
        dir.set(this.dir);
        power.set(radiance).mul((float) Math.PI * r2);
    }"
org.sunflow.core.light.DirectionalSpotlight.getPower,"    public float getPower() {
        return radiance.copy().mul((float) Math.PI * r2).getLuminance();
    }
"
org.sunflow.core.light.SphereLight.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        radiance = pl.getColor(""radiance"", radiance);
        numSamples = pl.getInt(""samples"", numSamples);
        radius = pl.getFloat(""radius"", radius);
        r2 = radius * radius;
        center = pl.getPoint(""center"", center);
        return true;
    }"
org.sunflow.core.light.SphereLight.init,"    public void init(String name, SunflowAPI api) {
        api.light(name, this);
        api.geometry(name + "".geo"", new Sphere());
        api.shader(name + "".shader"", this);
        api.parameter(""shaders"", name + "".shader"");
        api.parameter(""transform"", Matrix4.translation(center.x, center.y, center.z).multiply(Matrix4.scale(radius)));
        api.instance(name + "".instance"", name + "".geo"");
    }"
org.sunflow.core.light.SphereLight.getNumSamples,"    public int getNumSamples() {
        return numSamples;
    }"
org.sunflow.core.light.SphereLight.getLowSamples,"    public int getLowSamples() {
        return 1;
    }"
org.sunflow.core.light.SphereLight.isVisible,"    public boolean isVisible(ShadingState state) {
        return state.getPoint().distanceToSquared(center) > r2;
    }"
org.sunflow.core.light.SphereLight.getSamples,"    public void getSamples(ShadingState state) {
        if (getNumSamples() <= 0)
            return;
        Vector3 wc = Point3.sub(center, state.getPoint(), new Vector3());
        float l2 = wc.lengthSquared();
        if (l2 <= r2)
            return; // inside the sphere?
        // top of the sphere as viewed from the current shading point
        float topX = wc.x + state.getNormal().x * radius;
        float topY = wc.y + state.getNormal().y * radius;
        float topZ = wc.z + state.getNormal().z * radius;
        if (state.getNormal().dot(topX, topY, topZ) <= 0)
            return; // top of the sphere is below the horizon
        float cosThetaMax = (float) Math.sqrt(Math.max(0, 1 - r2 / Vector3.dot(wc, wc)));
        OrthoNormalBasis basis = OrthoNormalBasis.makeFromW(wc);
        int samples = state.getDiffuseDepth() > 0 ? 1 : getNumSamples();
        float scale = (float) (2 * Math.PI * (1 - cosThetaMax));
        Color c = Color.mul(scale / samples, radiance);
        for (int i = 0; i < samples; i++) {
            // random offset on unit square
            double randX = state.getRandom(i, 0, samples);
            double randY = state.getRandom(i, 1, samples);

            // cone sampling
            double cosTheta = (1 - randX) * cosThetaMax + randX;
            double sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
            double phi = randY * 2 * Math.PI;
            Vector3 dir = new Vector3((float) (Math.cos(phi) * sinTheta), (float) (Math.sin(phi) * sinTheta), (float) cosTheta);
            basis.transform(dir);

            // check that the direction of the sample is the same as the
            // normal
            float cosNx = Vector3.dot(dir, state.getNormal());
            if (cosNx <= 0)
                continue;

            float ocx = state.getPoint().x - center.x;
            float ocy = state.getPoint().y - center.y;
            float ocz = state.getPoint().z - center.z;
            float qa = Vector3.dot(dir, dir);
            float qb = 2 * ((dir.x * ocx) + (dir.y * ocy) + (dir.z * ocz));
            float qc = ((ocx * ocx) + (ocy * ocy) + (ocz * ocz)) - r2;
            double[] t = Solvers.solveQuadric(qa, qb, qc);
            if (t == null)
                continue;
            LightSample dest = new LightSample();
            // compute shadow ray to the sampled point
            dest.setShadowRay(new Ray(state.getPoint(), dir));
            // FIXME: arbitrary bias, should handle as in other places
            dest.getShadowRay().setMax((float) t[0] - 1e-3f);
            // prepare sample
            dest.setRadiance(c, c);
            dest.traceShadow(state);
            state.addSample(dest);
        }
    }"
org.sunflow.core.light.SphereLight.getPhoton,"    public void getPhoton(double randX1, double randY1, double randX2, double randY2, Point3 p, Vector3 dir, Color power) {
        float z = (float) (1 - 2 * randX2);
        float r = (float) Math.sqrt(Math.max(0, 1 - z * z));
        float phi = (float) (2 * Math.PI * randY2);
        float x = r * (float) Math.cos(phi);
        float y = r * (float) Math.sin(phi);
        p.x = center.x + x * radius;
        p.y = center.y + y * radius;
        p.z = center.z + z * radius;
        OrthoNormalBasis basis = OrthoNormalBasis.makeFromW(new Vector3(x, y, z));
        phi = (float) (2 * Math.PI * randX1);
        float cosPhi = (float) Math.cos(phi);
        float sinPhi = (float) Math.sin(phi);
        float sinTheta = (float) Math.sqrt(randY1);
        float cosTheta = (float) Math.sqrt(1 - randY1);
        dir.x = cosPhi * sinTheta;
        dir.y = sinPhi * sinTheta;
        dir.z = cosTheta;
        basis.transform(dir);
        power.set(radiance);
        power.mul((float) (Math.PI * Math.PI * 4 * r2));
    }"
org.sunflow.core.light.SphereLight.getPower,"    public float getPower() {
        return radiance.copy().mul((float) (Math.PI * Math.PI * 4 * r2)).getLuminance();
    }"
org.sunflow.core.light.SphereLight.getRadiance,"    public Color getRadiance(ShadingState state) {
        if (!state.includeLights())
            return Color.BLACK;
        state.faceforward();
        // emit constant radiance
        return state.isBehind() ? Color.BLACK : radiance;
    }"
org.sunflow.core.light.SphereLight.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        // do not scatter photons
    }
"
org.sunflow.core.light.TriangleMeshLight.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        radiance = pl.getColor(""radiance"", radiance);
        numSamples = pl.getInt(""samples"", numSamples);
        return super.update(pl, api);
    }"
org.sunflow.core.light.TriangleMeshLight.init,"    public void init(String name, SunflowAPI api) {
        api.geometry(name, this);
        api.shader(name + "".shader"", this);
        api.parameter(""shaders"", name + "".shader"");
        api.instance(name + "".instance"", name);
        for (int i = 0, j = 0; i < triangles.length; i += 3, j++) {
            TriangleLight t = new TriangleLight(j);
            String lname = String.format(""%s.light[%d]"", name, j);
            api.light(lname, t);
        }
    }"
org.sunflow.core.light.TriangleMeshLight.update,"        public boolean update(ParameterList pl, SunflowAPI api) {
            return true;
        }"
org.sunflow.core.light.TriangleMeshLight.getNumSamples,"        public int getNumSamples() {
            return numSamples;
        }"
org.sunflow.core.light.TriangleMeshLight.intersectTriangleKensler,"        private final boolean intersectTriangleKensler(Ray r) {
            int a = 3 * triangles[tri3 + 0];
            int b = 3 * triangles[tri3 + 1];
            int c = 3 * triangles[tri3 + 2];
            float edge0x = points[b + 0] - points[a + 0];
            float edge0y = points[b + 1] - points[a + 1];
            float edge0z = points[b + 2] - points[a + 2];
            float edge1x = points[a + 0] - points[c + 0];
            float edge1y = points[a + 1] - points[c + 1];
            float edge1z = points[a + 2] - points[c + 2];
            float nx = edge0y * edge1z - edge0z * edge1y;
            float ny = edge0z * edge1x - edge0x * edge1z;
            float nz = edge0x * edge1y - edge0y * edge1x;
            float v = r.dot(nx, ny, nz);
            float iv = 1 / v;
            float edge2x = points[a + 0] - r.ox;
            float edge2y = points[a + 1] - r.oy;
            float edge2z = points[a + 2] - r.oz;
            float va = nx * edge2x + ny * edge2y + nz * edge2z;
            float t = iv * va;
            if (t <= 0)
                return false;
            float ix = edge2y * r.dz - edge2z * r.dy;
            float iy = edge2z * r.dx - edge2x * r.dz;
            float iz = edge2x * r.dy - edge2y * r.dx;
            float v1 = ix * edge1x + iy * edge1y + iz * edge1z;
            float beta = iv * v1;
            if (beta < 0)
                return false;
            float v2 = ix * edge0x + iy * edge0y + iz * edge0z;
            if ((v1 + v2) * v > v * v)
                return false;
            float gamma = iv * v2;
            if (gamma < 0)
                return false;
            // FIXME: arbitrary bias, should handle as in other places
            r.setMax(t - 1e-3f);
            return true;
        }"
org.sunflow.core.light.TriangleMeshLight.getSamples,"        public void getSamples(ShadingState state) {
            if (numSamples == 0)
                return;
            Vector3 n = state.getNormal();
            Point3 p = state.getPoint();
            // vector towards each vertex of the light source
            Vector3 p0 = Point3.sub(getPoint(triangles[tri3 + 0]), p, new Vector3());
            Vector3 p1 = Point3.sub(getPoint(triangles[tri3 + 1]), p, new Vector3());
            Vector3 p2 = Point3.sub(getPoint(triangles[tri3 + 2]), p, new Vector3());

            // if all three vertices are below the hemisphere, stop
            if (Vector3.dot(p0, n) <= 0 && Vector3.dot(p1, n) <= 0 && Vector3.dot(p2, n) <= 0)
                return;

            p0.normalize();
            p1.normalize();
            p2.normalize();
            float dot = Vector3.dot(p2, p0);
            Vector3 h = new Vector3();
            h.x = p2.x - dot * p0.x;
            h.y = p2.y - dot * p0.y;
            h.z = p2.z - dot * p0.z;
            float hlen = h.length();
            if (hlen > 1e-6f)
                h.div(hlen);
            else
                return;
            Vector3 n0 = Vector3.cross(p0, p1, new Vector3());
            float len0 = n0.length();
            if (len0 > 1e-6f)
                n0.div(len0);
            else
                return;
            Vector3 n1 = Vector3.cross(p1, p2, new Vector3());
            float len1 = n1.length();
            if (len1 > 1e-6f)
                n1.div(len1);
            else
                return;
            Vector3 n2 = Vector3.cross(p2, p0, new Vector3());
            float len2 = n2.length();
            if (len2 > 1e-6f)
                n2.div(len2);
            else
                return;

            float cosAlpha = MathUtils.clamp(-Vector3.dot(n2, n0), -1.0f, 1.0f);
            float cosBeta = MathUtils.clamp(-Vector3.dot(n0, n1), -1.0f, 1.0f);
            float cosGamma = MathUtils.clamp(-Vector3.dot(n1, n2), -1.0f, 1.0f);

            float alpha = (float) Math.acos(cosAlpha);
            float beta = (float) Math.acos(cosBeta);
            float gamma = (float) Math.acos(cosGamma);

            float area = alpha + beta + gamma - (float) Math.PI;

            float cosC = MathUtils.clamp(Vector3.dot(p0, p1), -1.0f, 1.0f);
            float salpha = (float) Math.sin(alpha);
            float product = salpha * cosC;

            // use lower sampling depth for diffuse bounces
            int samples = state.getDiffuseDepth() > 0 ? 1 : numSamples;
            Color c = Color.mul(area / samples, radiance);
            for (int i = 0; i < samples; i++) {
                // random offset on unit square
                double randX = state.getRandom(i, 0, samples);
                double randY = state.getRandom(i, 1, samples);

                float phi = (float) randX * area - alpha + (float) Math.PI;
                float sinPhi = (float) Math.sin(phi);
                float cosPhi = (float) Math.cos(phi);

                float u = cosPhi + cosAlpha;
                float v = sinPhi - product;

                float q = (-v + cosAlpha * (cosPhi * -v + sinPhi * u)) / (salpha * (sinPhi * -v - cosPhi * u));
                float q1 = 1.0f - q * q;
                if (q1 < 0.0f)
                    q1 = 0.0f;

                float sqrtq1 = (float) Math.sqrt(q1);
                float ncx = q * p0.x + sqrtq1 * h.x;
                float ncy = q * p0.y + sqrtq1 * h.y;
                float ncz = q * p0.z + sqrtq1 * h.z;
                dot = p1.dot(ncx, ncy, ncz);
                float z = 1.0f - (float) randY * (1.0f - dot);
                float z1 = 1.0f - z * z;
                if (z1 < 0.0f)
                    z1 = 0.0f;
                Vector3 nd = new Vector3();
                nd.x = ncx - dot * p1.x;
                nd.y = ncy - dot * p1.y;
                nd.z = ncz - dot * p1.z;
                nd.normalize();
                float sqrtz1 = (float) Math.sqrt(z1);
                Vector3 result = new Vector3();
                result.x = z * p1.x + sqrtz1 * nd.x;
                result.y = z * p1.y + sqrtz1 * nd.y;
                result.z = z * p1.z + sqrtz1 * nd.z;

                // make sure the sample is in the right hemisphere - facing in
                // the right direction
                if (Vector3.dot(result, n) > 0 && Vector3.dot(result, state.getGeoNormal()) > 0 && Vector3.dot(result, ng) < 0) {
                    // compute intersection with triangle (if any)
                    Ray shadowRay = new Ray(state.getPoint(), result);
                    if (!intersectTriangleKensler(shadowRay))
                        continue;
                    LightSample dest = new LightSample();
                    dest.setShadowRay(shadowRay);
                    // prepare sample
                    dest.setRadiance(c, c);
                    dest.traceShadow(state);
                    state.addSample(dest);
                }
            }
        }"
org.sunflow.core.light.TriangleMeshLight.getPhoton,"        public void getPhoton(double randX1, double randY1, double randX2, double randY2, Point3 p, Vector3 dir, Color power) {
            double s = Math.sqrt(1 - randX2);
            float u = (float) (randY2 * s);
            float v = (float) (1 - s);
            float w = 1 - u - v;
            int index0 = 3 * triangles[tri3 + 0];
            int index1 = 3 * triangles[tri3 + 1];
            int index2 = 3 * triangles[tri3 + 2];
            p.x = w * points[index0 + 0] + u * points[index1 + 0] + v * points[index2 + 0];
            p.y = w * points[index0 + 1] + u * points[index1 + 1] + v * points[index2 + 1];
            p.z = w * points[index0 + 2] + u * points[index1 + 2] + v * points[index2 + 2];
            p.x += 0.001f * ng.x;
            p.y += 0.001f * ng.y;
            p.z += 0.001f * ng.z;
            OrthoNormalBasis onb = OrthoNormalBasis.makeFromW(ng);
            u = (float) (2 * Math.PI * randX1);
            s = Math.sqrt(randY1);
            onb.transform(new Vector3((float) (Math.cos(u) * s), (float) (Math.sin(u) * s), (float) (Math.sqrt(1 - randY1))), dir);
            Color.mul((float) Math.PI * area, radiance, power);
        }"
org.sunflow.core.light.TriangleMeshLight.getPower,"        public float getPower() {
            return radiance.copy().mul((float) Math.PI * area).getLuminance();
        }
    }

    public Color getRadiance(ShadingState state) {
        if (!state.includeLights())
            return Color.BLACK;
        state.faceforward();
        // emit constant radiance
        return state.isBehind() ? Color.BLACK : radiance;
    }

    public void scatterPhoton(ShadingState state, Color power) {
        // do not scatter photons
    "
org.sunflow.core.light.TriangleMeshLight.getRadiance,"    public Color getRadiance(ShadingState state) {
        if (!state.includeLights())
            return Color.BLACK;
        state.faceforward();
        // emit constant radiance
        return state.isBehind() ? Color.BLACK : radiance;
    }"
org.sunflow.core.light.TriangleMeshLight.scatterPhoton,"    public void scatterPhoton(ShadingState state, Color power) {
        // do not scatter photons
    }
"
org.sunflow.core.light.PointLight.update,"    public boolean update(ParameterList pl, SunflowAPI api) {
        lightPoint = pl.getPoint(""center"", lightPoint);
        power = pl.getColor(""power"", power);
        return true;
    }"
org.sunflow.core.light.PointLight.getNumSamples,"    public int getNumSamples() {
        return 1;
    }"
org.sunflow.core.light.PointLight.getSamples,"    public void getSamples(ShadingState state) {
        Vector3 d = Point3.sub(lightPoint, state.getPoint(), new Vector3());
        if (Vector3.dot(d, state.getNormal()) > 0 && Vector3.dot(d, state.getGeoNormal()) > 0) {
            LightSample dest = new LightSample();
            // prepare shadow ray
            dest.setShadowRay(new Ray(state.getPoint(), lightPoint));
            float scale = 1.0f / (float) (4 * Math.PI * lightPoint.distanceToSquared(state.getPoint()));
            dest.setRadiance(power, power);
            dest.getDiffuseRadiance().mul(scale);
            dest.getSpecularRadiance().mul(scale);
            dest.traceShadow(state);
            state.addSample(dest);
        }
    }"
org.sunflow.core.light.PointLight.getPhoton,"    public void getPhoton(double randX1, double randY1, double randX2, double randY2, Point3 p, Vector3 dir, Color power) {
        p.set(lightPoint);
        float phi = (float) (2 * Math.PI * randX1);
        float s = (float) Math.sqrt(randY1 * (1.0f - randY1));
        dir.x = (float) Math.cos(phi) * s;
        dir.y = (float) Math.sin(phi) * s;
        dir.z = (float) (1 - 2 * randY1);
        power.set(this.power);
    }"
org.sunflow.core.light.PointLight.getPower,"    public float getPower() {
        return power.getLuminance();
    }
"
org.sunflow.core.display.ImgPipeDisplay.imageBegin,"    public synchronized void imageBegin(int w, int h, int bucketSize) {
        ih = h;
        outputPacket(5, w, h, Float.floatToRawIntBits(1.0f), 0);
        System.out.flush();
    }"
org.sunflow.core.display.ImgPipeDisplay.imagePrepare,"    public synchronized void imagePrepare(int x, int y, int w, int h, int id) {
    }"
org.sunflow.core.display.ImgPipeDisplay.imageUpdate,"    public synchronized void imageUpdate(int x, int y, int w, int h, Color[] data) {
        int xl = x;
        int xh = x + w - 1;
        int yl = ih - 1 - (y + h - 1);
        int yh = ih - 1 - y;
        outputPacket(2, xl, xh, yl, yh);
        byte[] rgba = new byte[4 * (yh - yl + 1) * (xh - xl + 1)];
        for (int j = 0, idx = 0; j < h; j++) {
            for (int i = 0; i < w; i++, idx += 4) {
                int rgb = data[(h - j - 1) * w + i].toNonLinear().toRGB();
                int cr = (rgb >> 16) & 0xFF;
                int cg = (rgb >> 8) & 0xFF;
                int cb = rgb & 0xFF;
                rgba[idx + 0] = (byte) (cr & 0xFF);
                rgba[idx + 1] = (byte) (cg & 0xFF);
                rgba[idx + 2] = (byte) (cb & 0xFF);
                rgba[idx + 3] = (byte) (0xFF);
            }
        }
        try {
            System.out.write(rgba);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }"
org.sunflow.core.display.ImgPipeDisplay.imageFill,"    public synchronized void imageFill(int x, int y, int w, int h, Color c) {
        int xl = x;
        int xh = x + w - 1;
        int yl = ih - 1 - (y + h - 1);
        int yh = ih - 1 - y;
        outputPacket(2, xl, xh, yl, yh);
        int rgb = c.toNonLinear().toRGB();
        int cr = (rgb >> 16) & 0xFF;
        int cg = (rgb >> 8) & 0xFF;
        int cb = rgb & 0xFF;
        byte[] rgba = new byte[4 * (yh - yl + 1) * (xh - xl + 1)];
        for (int j = 0, idx = 0; j < h; j++) {
            for (int i = 0; i < w; i++, idx += 4) {
                rgba[idx + 0] = (byte) (cr & 0xFF);
                rgba[idx + 1] = (byte) (cg & 0xFF);
                rgba[idx + 2] = (byte) (cb & 0xFF);
                rgba[idx + 3] = (byte) (0xFF);
            }
        }
        try {
            System.out.write(rgba);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }"
org.sunflow.core.display.ImgPipeDisplay.imageEnd,"    public synchronized void imageEnd() {
        outputPacket(4, 0, 0, 0, 0);
        System.out.flush();
    }"
org.sunflow.core.display.ImgPipeDisplay.outputPacket,"    private void outputPacket(int type, int d0, int d1, int d2, int d3) {
        outputInt32(type);
        outputInt32(d0);
        outputInt32(d1);
        outputInt32(d2);
        outputInt32(d3);
    }"
org.sunflow.core.display.ImgPipeDisplay.outputInt32,"    private void outputInt32(int i) {
        System.out.write((i >> 24) & 0xFF);
        System.out.write((i >> 16) & 0xFF);
        System.out.write((i >> 8) & 0xFF);
        System.out.write(i & 0xFF);
    }
"
org.sunflow.core.display.FastDisplay.imageBegin,"    public synchronized void imageBegin(int w, int h, int bucketSize) {
        if (frame != null && image != null && w == image.getWidth() && h == image.getHeight()) {
            // nothing to do
        } else {
            // allocate new framebuffer
            pixels = new int[w * h];
            image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
            // prepare frame
            if (frame == null) {
                setPreferredSize(new Dimension(w, h));
                frame = new JFrame(""Sunflow v"" + SunflowAPI.VERSION);
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.addKeyListener(new KeyAdapter() {
                    @Override
                    public void keyPressed(KeyEvent e) {
                        if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
                            System.exit(0);
                    }
                });
                frame.setContentPane(this);
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        }
        // start counter
        t.start();
    }"
org.sunflow.core.display.FastDisplay.keyPressed,"                    public void keyPressed(KeyEvent e) {
                        if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
                            System.exit(0);
                    }
                "
org.sunflow.core.display.FastDisplay.imagePrepare,"    public void imagePrepare(int x, int y, int w, int h, int id) {
    }"
org.sunflow.core.display.FastDisplay.imageUpdate,"    public void imageUpdate(int x, int y, int w, int h, Color[] data) {
        int iw = image.getWidth();
        int off = x + iw * y;
        iw -= w;
        for (int j = 0, index = 0; j < h; j++, off += iw)
            for (int i = 0; i < w; i++, index++, off++)
                pixels[off] = 0xFF000000 | data[index].toRGB();
    }"
org.sunflow.core.display.FastDisplay.imageFill,"    public void imageFill(int x, int y, int w, int h, Color c) {
        int iw = image.getWidth();
        int off = x + iw * y;
        iw -= w;
        int rgb = 0xFF000000 | c.toRGB();
        for (int j = 0, index = 0; j < h; j++, off += iw)
            for (int i = 0; i < w; i++, index++, off++)
                pixels[off] = rgb;
    }"
org.sunflow.core.display.FastDisplay.imageEnd,"    public synchronized void imageEnd() {
        // copy buffer
        image.setRGB(0, 0, image.getWidth(), image.getHeight(), pixels, 0, image.getWidth());
        repaint();
        // update stats
        t.end();
        seconds += t.seconds();
        frames++;
        if (seconds > 1) {
            // display average fps every second
            frame.setTitle(String.format(""Sunflow v%s - %.2f fps"", SunflowAPI.VERSION, frames / seconds));
            frames = 0;
            seconds = 0;
        }
    }"
org.sunflow.core.display.FastDisplay.paint,"    public synchronized void paint(Graphics g) {
        if (image == null)
            return;
        g.drawImage(image, 0, 0, null);
    }
"
org.sunflow.core.display.OpenExrDisplay.setGamma,"    public void setGamma(float gamma) {
        UI.printWarning(Module.DISP, ""EXR - Gamma correction unsupported - ignoring"");
    }"
org.sunflow.core.display.OpenExrDisplay.imageBegin,"    public void imageBegin(int w, int h, int bucketSize) {
        try {
            file = new RandomAccessFile(filename, ""rw"");
            file.setLength(0);
            if (bucketSize <= 0)
                throw new Exception(""Can't use OpenEXR display without buckets."");
            writeRGBHeader(w, h, bucketSize);
        } catch (Exception e) {
            UI.printError(Module.DISP, ""EXR - %s"", e.getMessage());
            e.printStackTrace();
        }
    }"
org.sunflow.core.display.OpenExrDisplay.imagePrepare,"    public void imagePrepare(int x, int y, int w, int h, int id) {
    }"
org.sunflow.core.display.OpenExrDisplay.imageUpdate,"    public synchronized void imageUpdate(int x, int y, int w, int h, Color[] data) {
        try {
            // figure out which openexr tile corresponds to this bucket
            int tx = x / tileSize;
            int ty = y / tileSize;
            writeTile(tx, ty, w, h, data);
        } catch (IOException e) {
            UI.printError(Module.DISP, ""EXR - %s"", e.getMessage());
            e.printStackTrace();
        }
    }"
org.sunflow.core.display.OpenExrDisplay.imageFill,"    public void imageFill(int x, int y, int w, int h, Color c) {
    }"
org.sunflow.core.display.OpenExrDisplay.imageEnd,"    public void imageEnd() {
        try {
            writeTileOffsets();
            file.close();
        } catch (IOException e) {
            UI.printError(Module.DISP, ""EXR - %s"", e.getMessage());
            e.printStackTrace();
        }
    }"
org.sunflow.core.display.OpenExrDisplay.writeRGBHeader,"    public void writeRGBHeader(int w, int h, int tileSize) throws Exception {
        byte[] chanOut = { 0, channelType, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,
                0, 0, 0 };

        file.write(ByteUtil.get4Bytes(OE_MAGIC));

        file.write(ByteUtil.get4Bytes(OE_EXR_VERSION | OE_TILED_FLAG));

        file.write(""channels"".getBytes());
        file.write(0);
        file.write(""chlist"".getBytes());
        file.write(0);
        file.write(ByteUtil.get4Bytes(55));
        file.write(""R"".getBytes());
        file.write(chanOut);
        file.write(""G"".getBytes());
        file.write(chanOut);
        file.write(""B"".getBytes());
        file.write(chanOut);
        file.write(0);

        // compression
        file.write(""compression"".getBytes());
        file.write(0);
        file.write(""compression"".getBytes());
        file.write(0);
        file.write(1);
        file.write(ByteUtil.get4BytesInv(compression));

        // datawindow =~ image size
        file.write(""dataWindow"".getBytes());
        file.write(0);
        file.write(""box2i"".getBytes());
        file.write(0);
        file.write(ByteUtil.get4Bytes(0x10));
        file.write(ByteUtil.get4Bytes(0));
        file.write(ByteUtil.get4Bytes(0));
        file.write(ByteUtil.get4Bytes(w - 1));
        file.write(ByteUtil.get4Bytes(h - 1));

        // dispwindow -> look at openexr.com for more info
        file.write(""displayWindow"".getBytes());
        file.write(0);
        file.write(""box2i"".getBytes());
        file.write(0);
        file.write(ByteUtil.get4Bytes(0x10));
        file.write(ByteUtil.get4Bytes(0));
        file.write(ByteUtil.get4Bytes(0));
        file.write(ByteUtil.get4Bytes(w - 1));
        file.write(ByteUtil.get4Bytes(h - 1));

        /*
         * lines in increasing y order = 0 decreasing would be 1
         */
        file.write(""lineOrder"".getBytes());
        file.write(0);
        file.write(""lineOrder"".getBytes());
        file.write(0);
        file.write(1);
        file.write(ByteUtil.get4BytesInv(2));

        file.write(""pixelAspectRatio"".getBytes());
        file.write(0);
        file.write(""float"".getBytes());
        file.write(0);
        file.write(ByteUtil.get4Bytes(4));
        file.write(ByteUtil.get4Bytes(Float.floatToIntBits(1)));

        // meaningless to a flat (2D) image
        file.write(""screenWindowCenter"".getBytes());
        file.write(0);
        file.write(""v2f"".getBytes());
        file.write(0);
        file.write(ByteUtil.get4Bytes(8));
        file.write(ByteUtil.get4Bytes(Float.floatToIntBits(0)));
        file.write(ByteUtil.get4Bytes(Float.floatToIntBits(0)));

        // meaningless to a flat (2D) image
        file.write(""screenWindowWidth"".getBytes());
        file.write(0);
        file.write(""float"".getBytes());
        file.write(0);
        file.write(ByteUtil.get4Bytes(4));
        file.write(ByteUtil.get4Bytes((int) Float.floatToIntBits(1)));

        this.tileSize = tileSize;

        tilesX = (int) ((w + tileSize - 1) / tileSize);
        tilesY = (int) ((h + tileSize - 1) / tileSize);

        /*
         * twice the space for the compressing buffer, as for ex. the compressor
         * can actually increase the size of the data :) If that happens though,
         * it is not saved into the file, but discarded
         */
        tmpbuf = new byte[tileSize * tileSize * channelSize * 3];
        comprbuf = new byte[tileSize * tileSize * channelSize * 3 * 2];

        tileOffsets = new long[tilesX][tilesY];

        file.write(""tiles"".getBytes());
        file.write(0);
        file.write(""tiledesc"".getBytes());
        file.write(0);
        file.write(ByteUtil.get4Bytes(9));

        file.write(ByteUtil.get4Bytes(tileSize));
        file.write(ByteUtil.get4Bytes(tileSize));

        // ONE_LEVEL tiles, ROUNDING_MODE = not important
        file.write(0);

        // an attribute with a name of 0 to end the list
        file.write(0);

        // save a pointer to where the tileOffsets are stored and write dummy
        // fillers for now
        tileOffsetsPosition = file.getFilePointer();
        writeTileOffsets();
    }"
org.sunflow.core.display.OpenExrDisplay.writeTileOffsets,"    public void writeTileOffsets() throws IOException {
        file.seek(tileOffsetsPosition);
        for (int ty = 0; ty < tilesY; ty++)
            for (int tx = 0; tx < tilesX; tx++)
                file.write(ByteUtil.get8Bytes(tileOffsets[tx][ty]));
    }"
org.sunflow.core.display.OpenExrDisplay.writeTile,"    private void writeTile(int tileX, int tileY, int w, int h, Color[] tile) throws IOException {
        byte[] rgb = new byte[4];

        // setting comprSize to max integer so without compression things
        // don't go awry
        int pixptr = 0, writeSize = 0, comprSize = Integer.MAX_VALUE;
        int tileRangeX = (tileSize < w) ? tileSize : w;
        int tileRangeY = (tileSize < h) ? tileSize : h;
        int channelBase = tileRangeX * channelSize;

        // lets see if the alignment matches, you can comment this out if
        // need be
        if ((tileSize != tileRangeX) && (tileX == 0))
            System.out.print("" bad X alignment "");
        if ((tileSize != tileRangeY) && (tileY == 0))
            System.out.print("" bad Y alignment "");

        tileOffsets[tileX][tileY] = file.getFilePointer();

        // the tile header: tile's x&y coordinate, levels x&y coordinate and
        // tilesize
        file.write(ByteUtil.get4Bytes(tileX));
        file.write(ByteUtil.get4Bytes(tileY));
        file.write(ByteUtil.get4Bytes(0));
        file.write(ByteUtil.get4Bytes(0));

        // just in case
        Arrays.fill(tmpbuf, (byte) 0);

        for (int ty = 0; ty < tileRangeY; ty++) {
            for (int tx = 0; tx < tileRangeX; tx++) {
                float[] rgbf = tile[tx + ty * tileRangeX].getRGB();
                for (int component = 0; component < 3; component++) {
                    if (channelType == FLOAT) {
                        rgb = ByteUtil.get4Bytes(Float.floatToRawIntBits(rgbf[2 - component]));
                        tmpbuf[(channelBase * component) + pixptr + 0] = rgb[0];
                        tmpbuf[(channelBase * component) + pixptr + 1] = rgb[1];
                        tmpbuf[(channelBase * component) + pixptr + 2] = rgb[2];
                        tmpbuf[(channelBase * component) + pixptr + 3] = rgb[3];
                    } else if (channelType == HALF) {
                        rgb = ByteUtil.get2Bytes(ByteUtil.floatToHalf(rgbf[2 - component]));
                        tmpbuf[(channelBase * component) + pixptr + 0] = rgb[0];
                        tmpbuf[(channelBase * component) + pixptr + 1] = rgb[1];
                    }
                }
                pixptr += channelSize;
            }
            pixptr += (tileRangeX * channelSize * 2);
        }

        writeSize = tileRangeX * tileRangeY * channelSize * 3;

        if (compression != NO_COMPRESSION)
            comprSize = compress(compression, tmpbuf, writeSize, comprbuf);

        // lastly, write the size of the tile and the tile itself
        // (compressed or not)
        if (comprSize < writeSize) {
            file.write(ByteUtil.get4Bytes(comprSize));
            file.write(comprbuf, 0, comprSize);
        } else {
            file.write(ByteUtil.get4Bytes(writeSize));
            file.write(tmpbuf, 0, writeSize);
        }
    }"
org.sunflow.core.display.OpenExrDisplay.compress,"    private static final int compress(int tp, byte[] in, int inSize, byte[] out) {
        if (inSize == 0)
            return 0;

        int t1 = 0, t2 = (inSize + 1) / 2;
        int inPtr = 0, ret;
        byte[] tmp = new byte[inSize];

        // zip and rle treat the data first, in the same way so I'm not
        // repeating the code
        if ((tp == ZIP_COMPRESSION) || (tp == RLE_COMPRESSION)) {
            // reorder the pixel data ~ straight from ImfZipCompressor.cpp :)
            while (true) {
                if (inPtr < inSize)
                    tmp[t1++] = in[inPtr++];
                else
                    break;

                if (inPtr < inSize)
                    tmp[t2++] = in[inPtr++];
                else
                    break;
            }

            // Predictor ~ straight from ImfZipCompressor.cpp :)
            t1 = 1;
            int p = tmp[t1 - 1];
            while (t1 < inSize) {
                int d = (int) tmp[t1] - p + (128 + 256);
                p = (int) tmp[t1];
                tmp[t1] = (byte) d;
                t1++;
            }
        }

        // We'll just jump from here to the wanted compress/decompress stuff if
        // need be
        switch (tp) {
            case ZIP_COMPRESSION:
                Deflater def = new Deflater(Deflater.DEFAULT_COMPRESSION, false);
                def.setInput(tmp, 0, inSize);
                def.finish();
                ret = def.deflate(out);
                return ret;
            case RLE_COMPRESSION:
                return rleCompress(tmp, inSize, out);
            default:
                return -1;
        }
    }"
org.sunflow.core.display.OpenExrDisplay.rleCompress,"    private static final int rleCompress(byte[] in, int inLen, byte[] out) {
        int runStart = 0, runEnd = 1, outWrite = 0;
        while (runStart < inLen) {
            while (runEnd < inLen && in[runStart] == in[runEnd] && (runEnd - runStart - 1) < RLE_MAX_RUN)
                runEnd++;
            if (runEnd - runStart >= RLE_MIN_RUN) {
                // Compressable run
                out[outWrite++] = (byte) ((runEnd - runStart) - 1);
                out[outWrite++] = in[runStart];
                runStart = runEnd;
            } else {
                // Uncompressable run
                while (runEnd < inLen && (((runEnd + 1) >= inLen || in[runEnd] != in[runEnd + 1]) || ((runEnd + 2) >= inLen || in[runEnd + 1] != in[runEnd + 2])) && (runEnd - runStart) < RLE_MAX_RUN)
                    runEnd++;
                out[outWrite++] = (byte) (runStart - runEnd);
                while (runStart < runEnd)
                    out[outWrite++] = in[runStart++];
            }
            runEnd++;
        }
        return outWrite;
    }
"
org.sunflow.core.display.FrameDisplay.imageBegin,"    public void imageBegin(int w, int h, int bucketSize) {
        if (frame == null) {
            frame = new RenderFrame();
            frame.imagePanel.imageBegin(w, h, bucketSize);
            Dimension screenRes = Toolkit.getDefaultToolkit().getScreenSize();
            boolean needFit = false;
            if (w >= (screenRes.getWidth() - 200) || h >= (screenRes.getHeight() - 200)) {
                frame.imagePanel.setPreferredSize(new Dimension((int) screenRes.getWidth() - 200, (int) screenRes.getHeight() - 200));
                needFit = true;
            } else
                frame.imagePanel.setPreferredSize(new Dimension(w, h));
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
            if (needFit)
                frame.imagePanel.fit();
        } else
            frame.imagePanel.imageBegin(w, h, bucketSize);
    }"
org.sunflow.core.display.FrameDisplay.imagePrepare,"    public void imagePrepare(int x, int y, int w, int h, int id) {
        frame.imagePanel.imagePrepare(x, y, w, h, id);
    }"
org.sunflow.core.display.FrameDisplay.imageUpdate,"    public void imageUpdate(int x, int y, int w, int h, Color[] data) {
        frame.imagePanel.imageUpdate(x, y, w, h, data);
    }"
org.sunflow.core.display.FrameDisplay.imageFill,"    public void imageFill(int x, int y, int w, int h, Color c) {
        frame.imagePanel.imageFill(x, y, w, h, c);
    }"
org.sunflow.core.display.FrameDisplay.imageEnd,"    public void imageEnd() {
        frame.imagePanel.imageEnd();
        if (filename != null)
            frame.imagePanel.save(filename);
    }"
org.sunflow.core.display.FrameDisplay.keyPressed,"                public void keyPressed(KeyEvent e) {
                    if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
                        System.exit(0);
                }
            "
org.sunflow.core.display.FileDisplay.imageBegin,"    public void imageBegin(int w, int h, int bucketSize) {
        if (bitmap == null || bitmap.getWidth() != w || bitmap.getHeight() != h)
            bitmap = new Bitmap(w, h, filename == null || filename.endsWith("".hdr""));
    }"
org.sunflow.core.display.FileDisplay.imagePrepare,"    public void imagePrepare(int x, int y, int w, int h, int id) {
    }"
org.sunflow.core.display.FileDisplay.imageUpdate,"    public void imageUpdate(int x, int y, int w, int h, Color[] data) {
        for (int j = 0, index = 0; j < h; j++)
            for (int i = 0; i < w; i++, index++)
                bitmap.setPixel(x + i, bitmap.getHeight() - 1 - (y + j), data[index]);
    }"
org.sunflow.core.display.FileDisplay.imageFill,"    public void imageFill(int x, int y, int w, int h, Color c) {
        Color cg = c;
        for (int j = 0; j < h; j++)
            for (int i = 0; i < w; i++)
                bitmap.setPixel(x + i, bitmap.getHeight() - 1 - (y + j), cg);
    }"
org.sunflow.core.display.FileDisplay.imageEnd,"    public void imageEnd() {
        if (filename != null)
            bitmap.save(filename);
    }
"
org.sunflow.core.filter.BlackmanHarrisFilter.getSize,"    public float getSize() {
        return s;
    }"
org.sunflow.core.filter.BlackmanHarrisFilter.get,"    public float get(float x, float y) {
        return bh1d(x * inv) * bh1d(y * inv);
    }"
org.sunflow.core.filter.BlackmanHarrisFilter.bh1d,"    private float bh1d(float x) {
        if (x < -1.0f || x > 1.0f)
            return 0.0f;
        x = (x + 1) * 0.5f;
        final double A0 = 0.35875;
        final double A1 = -0.48829;
        final double A2 = 0.14128;
        final double A3 = -0.01168;
        return (float) (A0 + A1 * Math.cos(2 * Math.PI * x) + A2 * Math.cos(4 * Math.PI * x) + A3 * Math.cos(6 * Math.PI * x));
    }
"
org.sunflow.core.filter.FilterFactory.get,"    public static final Filter get(String filter) {
        if (filter.equals(""box""))
            return new BoxFilter(1);
        else if (filter.equals(""gaussian""))
            return new GaussianFilter(3);
        else if (filter.equals(""mitchell""))
            return new MitchellFilter();
        else if (filter.equals(""catmull-rom""))
            return new CatmullRomFilter();
        else if (filter.equals(""blackman-harris""))
            return new BlackmanHarrisFilter(4);
        else if (filter.equals(""sinc""))
            return new SincFilter(4);
        else if (filter.equals(""lanczos""))
            return new LanczosFilter();
        else if (filter.equals(""triangle""))
            return new TriangleFilter(2);
        else
            return null;       
    }
"
org.sunflow.core.filter.MitchellFilter.getSize,"    public float getSize() {
        return 4.0f;
    }"
org.sunflow.core.filter.MitchellFilter.get,"    public float get(float x, float y) {
        return mitchell(x) * mitchell(y);
    }"
org.sunflow.core.filter.MitchellFilter.mitchell,"    private float mitchell(float x) {
        final float B = 1 / 3.0f;
        final float C = 1 / 3.0f;
        final float SIXTH = 1 / 6.0f;
        x = Math.abs(x);
        float x2 = x * x;
        if (x > 1.0f)
            return ((-B - 6 * C) * x * x2 + (6 * B + 30 * C) * x2 + (-12 * B - 48 * C) * x + (8 * B + 24 * C)) * SIXTH;
        return ((12 - 9 * B - 6 * C) * x * x2 + (-18 + 12 * B + 6 * C) * x2 + (6 - 2 * B)) * SIXTH;
    }
"
org.sunflow.core.filter.GaussianFilter.getSize,"    public float getSize() {
        return s;
    }"
org.sunflow.core.filter.GaussianFilter.get,"    public float get(float x, float y) {
        float gx = (float) Math.exp(-x * x) + es2;
        float gy = (float) Math.exp(-y * y) + es2;
        return gx * gy;
    }
"
org.sunflow.core.filter.LanczosFilter.getSize,"    public float getSize() {
        return 4.0f;
    }"
org.sunflow.core.filter.LanczosFilter.get,"    public float get(float x, float y) {
        return sinc1d(x * 0.5f) * sinc1d(y * 0.5f);
    }"
org.sunflow.core.filter.LanczosFilter.sinc1d,"    private float sinc1d(float x) {
        x = Math.abs(x);
        if (x < 1e-5f)
            return 1;
        if (x > 1.0f)
            return 0;
        x *= Math.PI;
        float sinc = (float) Math.sin(3 * x) / (3 * x);
        float lanczos = (float) Math.sin(x) / x;
        return sinc * lanczos;
    }

"
org.sunflow.core.filter.BoxFilter.getSize,"    public float getSize() {
        return s;
    }"
org.sunflow.core.filter.BoxFilter.get,"    public float get(float x, float y) {
        return 1.0f;
    }
"
org.sunflow.core.filter.TriangleFilter.getSize,"    public float getSize() {
        return s;
    }"
org.sunflow.core.filter.TriangleFilter.get,"    public float get(float x, float y) {
        return (1.0f - Math.abs(x * inv)) * (1.0f - Math.abs(y * inv));
    }
"
org.sunflow.core.filter.SincFilter.getSize,"    public float getSize() {
        return s;
    }"
org.sunflow.core.filter.SincFilter.get,"    public float get(float x, float y) {
        return sinc1d(x) * sinc1d(y);
    }"
org.sunflow.core.filter.SincFilter.sinc1d,"    private float sinc1d(float x) {
        x = Math.abs(x);
        if (x < 0.0001f)
            return 1.0f;
        x *= Math.PI;
        return (float) Math.sin(x) / x;
    }
"
org.sunflow.core.filter.CatmullRomFilter.getSize,"    public float getSize() {
        return 4.0f;
    }"
org.sunflow.core.filter.CatmullRomFilter.get,"    public float get(float x, float y) {
        return catrom1d(x) * catrom1d(y);
    }"
org.sunflow.core.filter.CatmullRomFilter.catrom1d,"    private float catrom1d(float x) {
        x = Math.abs(x);
        float x2 = x * x;
        float x3 = x * x2;
        if (x >= 2)
            return 0;
        if (x < 1)
            return 3 * x3 - 5 * x2 + 2;
        return -x3 + 5 * x2 - 8 * x + 4;
    }
"
org.sunflow.util.FloatArray.add,"/**
* Append a float to the end of the array.
*
* @param f
*/
    public final void add(float f) {
        if (size == array.length) {
            float[] oldArray = array;
            array = new float[(size * 3) / 2 + 1];
            System.arraycopy(oldArray, 0, array, 0, size);
        }
        array[size] = f;
        size++;
    }"
org.sunflow.util.FloatArray.set,"/**
* Write a value to the specified index. Assumes the array is already big
* enough.
*
* @param index
* @param value
*/
    public final void set(int index, float value) {
        array[index] = value;
    }"
org.sunflow.util.FloatArray.get,"/**
* Read value from the array.
*
* @param index index into the array
* @return value at the specified index
*/
    public final float get(int index) {
        return array[index];
    }"
org.sunflow.util.FloatArray.getSize,"/**
* Returns the number of elements added to the array.
*
* @return
*/
    public final int getSize() {
        return size;
    }"
org.sunflow.util.FloatArray.trim,"/**
* Return a copy of the array, trimmed to fit the size of its contents
* exactly.
*
* @return
*/
    public final float[] trim() {
        if (size < array.length) {
            float[] oldArray = array;
            array = new float[size];
            System.arraycopy(oldArray, 0, array, 0, size);
        }
        return array;
    }
"
org.sunflow.util.IntArray.add,"/**
* Append an integer to the end of the array.
*
* @param i
*/
    public final void add(int i) {
        if (size == array.length) {
            int[] oldArray = array;
            array = new int[(size * 3) / 2 + 1];
            System.arraycopy(oldArray, 0, array, 0, size);
        }
        array[size] = i;
        size++;
    }"
org.sunflow.util.IntArray.set,"/**
* Write a value to the specified index. Assumes the array is already big
* enough.
*
* @param index
* @param value
*/
    public final void set(int index, int value) {
        array[index] = value;
    }"
org.sunflow.util.IntArray.get,"/**
* Read value from the array.
*
* @param index index into the array
* @return value at the specified index
*/
    public final int get(int index) {
        return array[index];
    }"
org.sunflow.util.IntArray.getSize,"/**
* Returns the number of elements added to the array.
*
* @return
*/
    public final int getSize() {
        return size;
    }"
org.sunflow.util.IntArray.trim,"/**
* Return a copy of the array, trimmed to fit the size of its contents
* exactly.
*
* @return
*/
    public final int[] trim() {
        if (size < array.length) {
            int[] oldArray = array;
            array = new int[size];
            System.arraycopy(oldArray, 0, array, 0, size);
        }
        return array;
    }
"
org.sunflow.util.FastHashMap.isRemoved,"        private boolean isRemoved() {
            return v == null;
        }"
org.sunflow.util.FastHashMap.remove,"        private void remove() {
            v = null;
        }"
org.sunflow.util.FastHashMap.getKey,"        public K getKey() {
            return k;
        }"
org.sunflow.util.FastHashMap.getValue,"        public V getValue() {
            return v;
        }
    }

    private Entry<K, V>[] entries;
    private int size;

    public FastHashMap() {
        clear();
    }

    public void clear() {
        size = 0;
        entries = alloc(MIN_SIZE);
    }

    public V put(K k, V v) {
        int hash = k.hashCode(), t = 0;
        int pos = entries.length; // mark invalid position
        for (;;) {
            hash &= entries.length - 1;
            if (entries[hash] == null)
                break; // done probing
            else if (entries[hash].isRemoved() && pos == entries.length)
                pos = hash; // store, but keep searching
            else if (entries[hash].k.equals(k)) {
                // update entry
                V old = entries[hash].v;
                entries[hash].v = v;
                return old;
            }
            t++;
            hash += t;
        }
        // did we find a spot for insertion among the deleted values ?
        if (pos < entries.length)
            hash = pos;
        entries[hash] = new Entry<K, V>(k, v);
        size++;
        if (size * 2 > entries.length)
            resize(entries.length * 2);
        return null;
    }

    public V get(K k) {
        int hash = k.hashCode(), t = 0;
        for (;;) {
            hash &= entries.length - 1;
            if (entries[hash] == null)
                return null;
            else if (!entries[hash].isRemoved() && entries[hash].k.equals(k))
                return entries[hash].v;
            t++;
            hash += t;
        }
    }

    public boolean containsKey(K k) {
        int hash = k.hashCode(), t = 0;
        for (;;) {
            hash &= entries.length - 1;
            if (entries[hash] == null)
                return false;
            else if (!entries[hash].isRemoved() && entries[hash].k.equals(k))
                return true;
            t++;
            hash += t;
        }
    }

    public void remove(K k) {
        int hash = k.hashCode(), t = 0;
        for (;;) {
            hash &= entries.length - 1;
            if (entries[hash] == null)
                return; // not found, return
            else if (!entries[hash].isRemoved() && entries[hash].k.equals(k)) {
                entries[hash].remove(); // flag as removed
                size--;
                break;
            }
            t++;
            hash += t;
        }
        // do we need to shrink?
        if (entries.length > MIN_SIZE && size * 10 < 2 * entries.length)
            resize(entries.length / 2);
    }

    /**
     * Resize internal storage to the specified capacity. The capacity must be a
     * power of two.
     * 
     * @param capacity new capacity for the internal array
     */
    private void resize(int capacity) {
        assert (capacity & (capacity - 1)) == 0;
        assert capacity >= MIN_SIZE;
        Entry<K, V>[] newentries = alloc(capacity);
        for (Entry<K, V> e : entries) {
            if (e == null || e.isRemoved())
                continue;
            int hash = e.k.hashCode(), t = 0;
            for (;;) {
                hash &= newentries.length - 1;
                if (newentries[hash] == null)
                    break;
                assert !newentries[hash].k.equals(e.k);
                t++;
                hash += t;
            }
            newentries[hash] = new Entry<K, V>(e.k, e.v);
        }
        // copy new entries over old ones
        entries = newentries;
    }

    /**
     * Wrap the entry array allocation because it requires silencing some
     * generics warnings.
     * 
     * @param size number of elements to allocate
     * @return
     */
    @SuppressWarnings(""unchecked"")
    private Entry<K, V>[] alloc(int size) {
        return new Entry[size];
    }

    private class EntryIterator implements Iterator<Entry<K, V>> {
        private int index;

        private EntryIterator() {
            index = 0;
            if (!readable())
                inc();
        }

        private boolean readable() {
            return !(entries[index] == null || entries[index].isRemoved());
        }

        private void inc() {
            do {
                index++;
            } while (hasNext() && !readable());
        }

        public boolean hasNext() {
            return index < entries.length;
        }

        public Entry<K, V> next() {
            try {
                return entries[index];
            } finally {
                inc();
            }
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    public Iterator<Entry<K, V>> iterator() {
        return new EntryIterator();
    "
org.sunflow.util.FastHashMap.clear,"    public void clear() {
        size = 0;
        entries = alloc(MIN_SIZE);
    }"
org.sunflow.util.FastHashMap.put,"    public V put(K k, V v) {
        int hash = k.hashCode(), t = 0;
        int pos = entries.length; // mark invalid position
        for (;;) {
            hash &= entries.length - 1;
            if (entries[hash] == null)
                break; // done probing
            else if (entries[hash].isRemoved() && pos == entries.length)
                pos = hash; // store, but keep searching
            else if (entries[hash].k.equals(k)) {
                // update entry
                V old = entries[hash].v;
                entries[hash].v = v;
                return old;
            }
            t++;
            hash += t;
        }
        // did we find a spot for insertion among the deleted values ?
        if (pos < entries.length)
            hash = pos;
        entries[hash] = new Entry<K, V>(k, v);
        size++;
        if (size * 2 > entries.length)
            resize(entries.length * 2);
        return null;
    }"
org.sunflow.util.FastHashMap.get,"    public V get(K k) {
        int hash = k.hashCode(), t = 0;
        for (;;) {
            hash &= entries.length - 1;
            if (entries[hash] == null)
                return null;
            else if (!entries[hash].isRemoved() && entries[hash].k.equals(k))
                return entries[hash].v;
            t++;
            hash += t;
        }
    }"
org.sunflow.util.FastHashMap.containsKey,"    public boolean containsKey(K k) {
        int hash = k.hashCode(), t = 0;
        for (;;) {
            hash &= entries.length - 1;
            if (entries[hash] == null)
                return false;
            else if (!entries[hash].isRemoved() && entries[hash].k.equals(k))
                return true;
            t++;
            hash += t;
        }
    }"
org.sunflow.util.FastHashMap.remove,"    public void remove(K k) {
        int hash = k.hashCode(), t = 0;
        for (;;) {
            hash &= entries.length - 1;
            if (entries[hash] == null)
                return; // not found, return
            else if (!entries[hash].isRemoved() && entries[hash].k.equals(k)) {
                entries[hash].remove(); // flag as removed
                size--;
                break;
            }
            t++;
            hash += t;
        }
        // do we need to shrink?
        if (entries.length > MIN_SIZE && size * 10 < 2 * entries.length)
            resize(entries.length / 2);
    }"
org.sunflow.util.FastHashMap.resize,"/**
* Resize internal storage to the specified capacity. The capacity must be a
* power of two.
*
* @param capacity new capacity for the internal array
*/
    private void resize(int capacity) {
        assert (capacity & (capacity - 1)) == 0;
        assert capacity >= MIN_SIZE;
        Entry<K, V>[] newentries = alloc(capacity);
        for (Entry<K, V> e : entries) {
            if (e == null || e.isRemoved())
                continue;
            int hash = e.k.hashCode(), t = 0;
            for (;;) {
                hash &= newentries.length - 1;
                if (newentries[hash] == null)
                    break;
                assert !newentries[hash].k.equals(e.k);
                t++;
                hash += t;
            }
            newentries[hash] = new Entry<K, V>(e.k, e.v);
        }
        // copy new entries over old ones
        entries = newentries;
    }"
org.sunflow.util.FastHashMap.alloc,"    private Entry<K, V>[] alloc(int size) {
        return new Entry[size];
    }"
org.sunflow.util.FastHashMap.readable,"        private boolean readable() {
            return !(entries[index] == null || entries[index].isRemoved());
        }"
org.sunflow.util.FastHashMap.inc,"        private void inc() {
            do {
                index++;
            } while (hasNext() && !readable());
        }"
org.sunflow.util.FastHashMap.hasNext,"        public boolean hasNext() {
            return index < entries.length;
        }"
org.sunflow.util.FastHashMap.next,"        public Entry<K, V> next() {
            try {
                return entries[index];
            } finally {
                inc();
            }
        }"
org.sunflow.util.FastHashMap.remove,"        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    public Iterator<Entry<K, V>> iterator() {
        return new EntryIterator();
    "
org.sunflow.util.FastHashMap.iterator,"    public Iterator<Entry<K, V>> iterator() {
        return new EntryIterator();
    }
"
org.sunflow.math.BoundingBox.getMinimum,"/**
* Gets the minimum corner of the box. That is the corner of smallest
* coordinates on each axis. Note that the returned reference is not cloned
* for efficiency purposes so care must be taken not to change the
* coordinates of the point.
*
* @return a reference to the minimum corner
*/
    public final Point3 getMinimum() {
        return minimum;
    }"
org.sunflow.math.BoundingBox.getMaximum,"/**
* Gets the maximum corner of the box. That is the corner of largest
* coordinates on each axis. Note that the returned reference is not cloned
* for efficiency purposes so care must be taken not to change the
* coordinates of the point.
*
* @return a reference to the maximum corner
*/
    public final Point3 getMaximum() {
        return maximum;
    }"
org.sunflow.math.BoundingBox.getCenter,"/**
* Gets the center of the box, computed as (min + max) / 2.
*
* @return a reference to the center of the box
*/
    public final Point3 getCenter() {
        return Point3.mid(minimum, maximum, new Point3());
    }"
org.sunflow.math.BoundingBox.getCorner,"/**
* Gets a corner of the bounding box. The index scheme uses the binary
* representation of the index to decide which corner to return. Corner 0 is
* equivalent to the minimum and corner 7 is equivalent to the maximum.
*
* @param i a corner index, from 0 to 7
* @return the corresponding corner
*/
    public final Point3 getCorner(int i) {
        float x = (i & 1) == 0 ? minimum.x : maximum.x;
        float y = (i & 2) == 0 ? minimum.y : maximum.y;
        float z = (i & 4) == 0 ? minimum.z : maximum.z;
        return new Point3(x, y, z);
    }"
org.sunflow.math.BoundingBox.getBound,"/**
* Gets a specific coordinate of the surface's bounding box.
*
* @param i index of a side from 0 to 5
* @return value of the request bounding box side
*/
    public final float getBound(int i) {
        switch (i) {
            case 0:
                return minimum.x;
            case 1:
                return maximum.x;
            case 2:
                return minimum.y;
            case 3:
                return maximum.y;
            case 4:
                return minimum.z;
            case 5:
                return maximum.z;
            default:
                return 0;
        }
    }"
org.sunflow.math.BoundingBox.getExtents,"/**
* Gets the extents vector for the box. This vector is computed as (max -
* min). Its coordinates are always positive and represent the dimensions of
* the box along the three axes.
*
* @return a refreence to the extent vector
* @see org.sunflow.math.Vector3#length()
*/
    public final Vector3 getExtents() {
        return Point3.sub(maximum, minimum, new Vector3());
    }"
org.sunflow.math.BoundingBox.getArea,"/**
* Gets the surface area of the box.
*
* @return surface area
*/
    public final float getArea() {
        Vector3 w = getExtents();
        float ax = Math.max(w.x, 0);
        float ay = Math.max(w.y, 0);
        float az = Math.max(w.z, 0);
        return 2 * (ax * ay + ay * az + az * ax);
    }"
org.sunflow.math.BoundingBox.getVolume,"/**
* Gets the box's volume
*
* @return volume
*/
    public final float getVolume() {
        Vector3 w = getExtents();
        float ax = Math.max(w.x, 0);
        float ay = Math.max(w.y, 0);
        float az = Math.max(w.z, 0);
        return ax * ay * az;
    }"
org.sunflow.math.BoundingBox.enlargeUlps,"/**
* Enlarge the bounding box by the minimum possible amount to avoid numeric
* precision related problems.
*/
    public final void enlargeUlps() {
        final float eps = 0.0001f;
        minimum.x -= Math.max(eps, Math.ulp(minimum.x));
        minimum.y -= Math.max(eps, Math.ulp(minimum.y));
        minimum.z -= Math.max(eps, Math.ulp(minimum.z));
        maximum.x += Math.max(eps, Math.ulp(maximum.x));
        maximum.y += Math.max(eps, Math.ulp(maximum.y));
        maximum.z += Math.max(eps, Math.ulp(maximum.z));
    }"
org.sunflow.math.BoundingBox.isEmpty,"/**
* Returns <code>true</code> when the box has just been initialized, and
* is still empty. This method might also return true if the state of the
* box becomes inconsistent and some component of the minimum corner is
* larger than the corresponding coordinate of the maximum corner.
*
* @return <code>true</code> if the box is empty, <code>false</code>
*         otherwise
*/
    public final boolean isEmpty() {
        return (maximum.x < minimum.x) || (maximum.y < minimum.y) || (maximum.z < minimum.z);
    }"
org.sunflow.math.BoundingBox.intersects,"/**
* Returns <code>true</code> if the specified bounding box intersects this
* one. The boxes are treated as volumes, so a box inside another will
* return true. Returns <code>false</code> if the parameter is
* <code>null</code>.
*
* @param b box to be tested for intersection
* @return <code>true</code> if the boxes overlap, <code>false</code>
*         otherwise
*/
    public final boolean intersects(BoundingBox b) {
        return ((b != null) && (minimum.x <= b.maximum.x) && (maximum.x >= b.minimum.x) && (minimum.y <= b.maximum.y) && (maximum.y >= b.minimum.y) && (minimum.z <= b.maximum.z) && (maximum.z >= b.minimum.z));
    }

    /**
     * Checks to see if the specified {@link org.sunflow.math.Point3 point}"
org.sunflow.math.BoundingBox.contains,"/**
* Checks to see if the specified {@link org.sunflow.math.Point3 point}is
* inside the volume defined by this box. Returns <code>false</code> if
* the parameter is <code>null</code>.
*
* @param p point to be tested for containment
* @return <code>true</code> if the point is inside the box,
*         <code>false</code> otherwise
*/
    public final boolean contains(Point3 p) {
        return ((p != null) && (p.x >= minimum.x) && (p.x <= maximum.x) && (p.y >= minimum.y) && (p.y <= maximum.y) && (p.z >= minimum.z) && (p.z <= maximum.z));
    }"
org.sunflow.math.BoundingBox.contains,"/**
* Check to see if the specified point is inside the volume defined by this
* box.
*
* @param x x coordinate of the point to be tested
* @param y y coordinate of the point to be tested
* @param z z coordinate of the point to be tested
* @return <code>true</code> if the point is inside the box,
*         <code>false</code> otherwise
*/
    public final boolean contains(float x, float y, float z) {
        return ((x >= minimum.x) && (x <= maximum.x) && (y >= minimum.y) && (y <= maximum.y) && (z >= minimum.z) && (z <= maximum.z));
    }

    /**
     * Changes the extents of the box as needed to include the given
     * {@link org.sunflow.math.Point3 point}"
org.sunflow.math.BoundingBox.include,"/**
* Changes the extents of the box as needed to include the given
* {@link org.sunflow.math.Point3 point}into this box. Does nothing if the
* parameter is <code>null</code>.
*
* @param p point to be included
*/
    public final void include(Point3 p) {
        if (p != null) {
            if (p.x < minimum.x)
                minimum.x = p.x;
            if (p.x > maximum.x)
                maximum.x = p.x;
            if (p.y < minimum.y)
                minimum.y = p.y;
            if (p.y > maximum.y)
                maximum.y = p.y;
            if (p.z < minimum.z)
                minimum.z = p.z;
            if (p.z > maximum.z)
                maximum.z = p.z;
        }
    }"
org.sunflow.math.BoundingBox.include,"/**
* Changes the extents of the box as needed to include the given point into
* this box.
*
* @param x x coordinate of the point
* @param y y coordinate of the point
* @param z z coordinate of the point
*/
    public final void include(float x, float y, float z) {
        if (x < minimum.x)
            minimum.x = x;
        if (x > maximum.x)
            maximum.x = x;
        if (y < minimum.y)
            minimum.y = y;
        if (y > maximum.y)
            maximum.y = y;
        if (z < minimum.z)
            minimum.z = z;
        if (z > maximum.z)
            maximum.z = z;
    }"
org.sunflow.math.BoundingBox.include,"/**
* Changes the extents of the box as needed to include the given box into
* this box. Does nothing if the parameter is <code>null</code>.
*
* @param b box to be included
*/
    public final void include(BoundingBox b) {
        if (b != null) {
            if (b.minimum.x < minimum.x)
                minimum.x = b.minimum.x;
            if (b.maximum.x > maximum.x)
                maximum.x = b.maximum.x;
            if (b.minimum.y < minimum.y)
                minimum.y = b.minimum.y;
            if (b.maximum.y > maximum.y)
                maximum.y = b.maximum.y;
            if (b.minimum.z < minimum.z)
                minimum.z = b.minimum.z;
            if (b.maximum.z > maximum.z)
                maximum.z = b.maximum.z;
        }
    }"
org.sunflow.math.BoundingBox.toString,"    public final String toString() {
        return String.format(""(%.2f, %.2f, %.2f) to (%.2f, %.2f, %.2f)"", minimum.x, minimum.y, minimum.z, maximum.x, maximum.y, maximum.z);
    }
"
org.sunflow.math.PerlinScalar.snoise,"    public static final float snoise(float x) {
        int xf = (int) Math.floor(x);
        int X = xf & 255;
        x -= xf;
        float u = fade(x);
        int A = p[X], B = p[X + 1];
        return lerp(u, grad(p[A], x), grad(p[B], x - 1));
    }"
org.sunflow.math.PerlinScalar.snoise,"    public static final float snoise(float x, float y) {
        int xf = (int) Math.floor(x);
        int yf = (int) Math.floor(y);
        int X = xf & 255;
        int Y = yf & 255;
        x -= xf;
        y -= yf;
        float u = fade(x);
        float v = fade(y);
        int A = p[X] + Y, B = p[X + 1] + Y;
        return lerp(v, lerp(u, grad(p[A], x, y), grad(p[B], x - 1, y)), lerp(u, grad(p[A + 1], x, y - 1), grad(p[B + 1], x - 1, y - 1)));
    }"
org.sunflow.math.PerlinScalar.snoise,"    public static final float snoise(float x, float y, float z) {
        int xf = (int) Math.floor(x);
        int yf = (int) Math.floor(y);
        int zf = (int) Math.floor(z);
        int X = xf & 255;
        int Y = yf & 255;
        int Z = zf & 255;
        x -= xf;
        y -= yf;
        z -= zf;
        float u = fade(x);
        float v = fade(y);
        float w = fade(z);
        int A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;
        return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)), lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))), lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)), lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1))));
    }"
org.sunflow.math.PerlinScalar.snoise,"    public static final float snoise(float x, float y, float z, float w) {
        int xf = (int) Math.floor(x);
        int yf = (int) Math.floor(y);
        int zf = (int) Math.floor(z);
        int wf = (int) Math.floor(w);
        int X = xf & 255;
        int Y = yf & 255;
        int Z = zf & 255;
        int W = wf & 255;
        x -= xf;
        y -= yf;
        z -= zf;
        w -= wf;
        float u = fade(x);
        float v = fade(y);
        float t = fade(z);
        float s = fade(w);
        int A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z, AAA = p[AA] + W, AAB = p[AA + 1] + W, ABA = p[AB] + W, ABB = p[AB + 1] + W, BAA = p[BA] + W, BAB = p[BA + 1] + W, BBA = p[BB] + W, BBB = p[BB + 1] + W;
        return lerp(s, lerp(t, lerp(v, lerp(u, grad(p[AAA], x, y, z, w), grad(p[BAA], x - 1, y, z, w)), lerp(u, grad(p[ABA], x, y - 1, z, w), grad(p[BBA], x - 1, y - 1, z, w))), lerp(v, lerp(u, grad(p[AAB], x, y, z - 1, w), grad(p[BAB], x - 1, y, z - 1, w)), lerp(u, grad(p[ABB], x, y - 1, z - 1, w), grad(p[BBB], x - 1, y - 1, z - 1, w)))), lerp(t, lerp(v, lerp(u, grad(p[AAA + 1], x, y, z, w - 1), grad(p[BAA + 1], x - 1, y, z, w - 1)), lerp(u, grad(p[ABA + 1], x, y - 1, z, w - 1), grad(p[BBA + 1], x - 1, y - 1, z, w - 1))), lerp(v, lerp(u, grad(p[AAB + 1], x, y, z - 1, w - 1), grad(p[BAB + 1], x - 1, y, z - 1, w - 1)), lerp(u, grad(p[ABB + 1], x, y - 1, z - 1, w - 1), grad(p[BBB + 1], x - 1, y - 1, z - 1, w - 1)))));
    }"
org.sunflow.math.PerlinScalar.snoise,"    public static final float snoise(Point2 p) {
        return snoise(p.x, p.y);
    }"
org.sunflow.math.PerlinScalar.snoise,"    public static final float snoise(Point3 p) {
        return snoise(p.x, p.y, p.z);
    }"
org.sunflow.math.PerlinScalar.snoise,"    public static final float snoise(Point3 p, float t) {
        return snoise(p.x, p.y, p.z, t);
    }"
org.sunflow.math.PerlinScalar.noise,"    public static final float noise(float x) {
        return 0.5f + 0.5f * snoise(x);
    }"
org.sunflow.math.PerlinScalar.noise,"    public static final float noise(float x, float y) {
        return 0.5f + 0.5f * snoise(x, y);
    }"
org.sunflow.math.PerlinScalar.noise,"    public static final float noise(float x, float y, float z) {
        return 0.5f + 0.5f * snoise(x, y, z);
    }"
org.sunflow.math.PerlinScalar.noise,"    public static final float noise(float x, float y, float z, float t) {
        return 0.5f + 0.5f * snoise(x, y, z, t);
    }"
org.sunflow.math.PerlinScalar.noise,"    public static final float noise(Point2 p) {
        return 0.5f + 0.5f * snoise(p.x, p.y);
    }"
org.sunflow.math.PerlinScalar.noise,"    public static final float noise(Point3 p) {
        return 0.5f + 0.5f * snoise(p.x, p.y, p.z);
    }"
org.sunflow.math.PerlinScalar.noise,"    public static final float noise(Point3 p, float t) {
        return 0.5f + 0.5f * snoise(p.x, p.y, p.z, t);
    }"
org.sunflow.math.PerlinScalar.pnoise,"    public static final float pnoise(float xi, float period) {
        float x = (xi % period) + ((xi < 0) ? period : 0);
        return ((period - x) * noise(x) + x * noise(x - period)) / period;
    }"
org.sunflow.math.PerlinScalar.pnoise,"    public static final float pnoise(float xi, float yi, float w, float h) {
        float x = (xi % w) + ((xi < 0) ? w : 0);
        float y = (yi % h) + ((yi < 0) ? h : 0);
        float w_x = w - x;
        float h_y = h - y;
        float x_w = x - w;
        float y_h = y - h;
        return (noise(x, y) * (w_x) * (h_y) + noise(x_w, y) * (x) * (h_y) + noise(x_w, y_h) * (x) * (y) + noise(x, y_h) * (w_x) * (y)) / (w * h);
    }"
org.sunflow.math.PerlinScalar.pnoise,"    public static final float pnoise(float xi, float yi, float zi, float w, float h, float d) {
        float x = (xi % w) + ((xi < 0) ? w : 0);
        float y = (yi % h) + ((yi < 0) ? h : 0);
        float z = (zi % d) + ((zi < 0) ? d : 0);
        float w_x = w - x;
        float h_y = h - y;
        float d_z = d - z;
        float x_w = x - w;
        float y_h = y - h;
        float z_d = z - d;
        float xy = x * y;
        float h_yXd_z = h_y * d_z;
        float h_yXz = h_y * z;
        float w_xXy = w_x * y;
        return (noise(x, y, z) * (w_x) * h_yXd_z + noise(x, y_h, z) * w_xXy * (d_z) + noise(x_w, y, z) * (x) * h_yXd_z + noise(x_w, y_h, z) * (xy) * (d_z) + noise(x_w, y_h, z_d) * (xy) * (z) + noise(x, y, z_d) * (w_x) * h_yXz + noise(x, y_h, z_d) * w_xXy * (z) + noise(x_w, y, z_d) * (x) * h_yXz) / (w * h * d);
    }"
org.sunflow.math.PerlinScalar.pnoise,"    public static final float pnoise(float xi, float yi, float zi, float ti, float w, float h, float d, float p) {
        float x = (xi % w) + ((xi < 0) ? w : 0);
        float y = (yi % h) + ((yi < 0) ? h : 0);
        float z = (zi % d) + ((zi < 0) ? d : 0);
        float t = (ti % p) + ((ti < 0) ? p : 0);
        float w_x = w - x;
        float h_y = h - y;
        float d_z = d - z;
        float p_t = p - t;
        float x_w = x - w;
        float y_h = y - h;
        float z_d = z - d;
        float t_p = t - p;
        float xy = x * y;
        float d_zXp_t = (d_z) * (p_t);
        float zXp_t = z * (p_t);
        float zXt = z * t;
        float d_zXt = d_z * t;
        float w_xXy = w_x * y;
        float w_xXh_y = w_x * h_y;
        float xXh_y = x * h_y;
        return (noise(x, y, z, t) * (w_xXh_y) * d_zXp_t + noise(x_w, y, z, t) * (xXh_y) * d_zXp_t + noise(x_w, y_h, z, t) * (xy) * d_zXp_t + noise(x, y_h, z, t) * (w_xXy) * d_zXp_t + noise(x_w, y_h, z_d, t) * (xy) * (zXp_t) + noise(x, y, z_d, t) * (w_xXh_y) * (zXp_t) + noise(x, y_h, z_d, t) * (w_xXy) * (zXp_t) + noise(x_w, y, z_d, t) * (xXh_y) * (zXp_t) + noise(x, y, z, t_p) * (w_xXh_y) * (d_zXt) + noise(x_w, y, z, t_p) * (xXh_y) * (d_zXt) + noise(x_w, y_h, z, t_p) * (xy) * (d_zXt) + noise(x, y_h, z, t_p) * (w_xXy) * (d_zXt) + noise(x_w, y_h, z_d, t_p) * (xy) * (zXt) + noise(x, y, z_d, t_p) * (w_xXh_y) * (zXt) + noise(x, y_h, z_d, t_p) * (w_xXy) * (zXt) + noise(x_w, y, z_d, t_p) * (xXh_y) * (zXt)) / (w * h * d * t);
    }"
org.sunflow.math.PerlinScalar.pnoise,"    public static final float pnoise(Point2 p, float periodx, float periody) {
        return pnoise(p.x, p.y, periodx, periody);
    }"
org.sunflow.math.PerlinScalar.pnoise,"    public static final float pnoise(Point3 p, Vector3 period) {
        return pnoise(p.x, p.y, p.z, period.x, period.y, period.z);
    }"
org.sunflow.math.PerlinScalar.pnoise,"    public static final float pnoise(Point3 p, float t, Vector3 pperiod, float tperiod) {
        return pnoise(p.x, p.y, p.z, t, pperiod.x, pperiod.y, pperiod.z, tperiod);
    }"
org.sunflow.math.PerlinScalar.spnoise,"    public static final float spnoise(float xi, float period) {
        float x = (xi % period) + ((xi < 0) ? period : 0);
        return (((period - x) * snoise(x) + x * snoise(x - period)) / period);
    }"
org.sunflow.math.PerlinScalar.spnoise,"    public static final float spnoise(float xi, float yi, float w, float h) {
        float x = (xi % w) + ((xi < 0) ? w : 0);
        float y = (yi % h) + ((yi < 0) ? h : 0);
        float w_x = w - x;
        float h_y = h - y;
        float x_w = x - w;
        float y_h = y - h;
        return ((snoise(x, y) * (w_x) * (h_y) + snoise(x_w, y) * (x) * (h_y) + snoise(x_w, y_h) * (x) * (y) + snoise(x, y_h) * (w_x) * (y)) / (w * h));
    }"
org.sunflow.math.PerlinScalar.spnoise,"    public static final float spnoise(float xi, float yi, float zi, float w, float h, float d) {
        float x = (xi % w) + ((xi < 0) ? w : 0);
        float y = (yi % h) + ((yi < 0) ? h : 0);
        float z = (zi % d) + ((zi < 0) ? d : 0);
        float w_x = w - x;
        float h_y = h - y;
        float d_z = d - z;
        float x_w = x - w;
        float y_h = y - h;
        float z_d = z - d;
        float xy = x * y;
        float h_yXd_z = h_y * d_z;
        float h_yXz = h_y * z;
        float w_xXy = w_x * y;
        return ((snoise(x, y, z) * (w_x) * h_yXd_z + snoise(x, y_h, z) * w_xXy * (d_z) + snoise(x_w, y, z) * (x) * h_yXd_z + snoise(x_w, y_h, z) * (xy) * (d_z) + snoise(x_w, y_h, z_d) * (xy) * (z) + snoise(x, y, z_d) * (w_x) * h_yXz + snoise(x, y_h, z_d) * w_xXy * (z) + snoise(x_w, y, z_d) * (x) * h_yXz) / (w * h * d));
    }"
org.sunflow.math.PerlinScalar.spnoise,"    public static final float spnoise(float xi, float yi, float zi, float ti, float w, float h, float d, float p) {
        float x = (xi % w) + ((xi < 0) ? w : 0);
        float y = (yi % h) + ((yi < 0) ? h : 0);
        float z = (zi % d) + ((zi < 0) ? d : 0);
        float t = (ti % p) + ((ti < 0) ? p : 0);
        float w_x = w - x;
        float h_y = h - y;
        float d_z = d - z;
        float p_t = p - t;
        float x_w = x - w;
        float y_h = y - h;
        float z_d = z - d;
        float t_p = t - p;
        float xy = x * y;
        float d_zXp_t = (d_z) * (p_t);
        float zXp_t = z * (p_t);
        float zXt = z * t;
        float d_zXt = d_z * t;
        float w_xXy = w_x * y;
        float w_xXh_y = w_x * h_y;
        float xXh_y = x * h_y;
        return ((snoise(x, y, z, t) * (w_xXh_y) * d_zXp_t + snoise(x_w, y, z, t) * (xXh_y) * d_zXp_t + snoise(x_w, y_h, z, t) * (xy) * d_zXp_t + snoise(x, y_h, z, t) * (w_xXy) * d_zXp_t + snoise(x_w, y_h, z_d, t) * (xy) * (zXp_t) + snoise(x, y, z_d, t) * (w_xXh_y) * (zXp_t) + snoise(x, y_h, z_d, t) * (w_xXy) * (zXp_t) + snoise(x_w, y, z_d, t) * (xXh_y) * (zXp_t) + snoise(x, y, z, t_p) * (w_xXh_y) * (d_zXt) + snoise(x_w, y, z, t_p) * (xXh_y) * (d_zXt) + snoise(x_w, y_h, z, t_p) * (xy) * (d_zXt) + snoise(x, y_h, z, t_p) * (w_xXy) * (d_zXt) + snoise(x_w, y_h, z_d, t_p) * (xy) * (zXt) + snoise(x, y, z_d, t_p) * (w_xXh_y) * (zXt) + snoise(x, y_h, z_d, t_p) * (w_xXy) * (zXt) + snoise(x_w, y, z_d, t_p) * (xXh_y) * (zXt)) / (w * h * d * t));
    }"
org.sunflow.math.PerlinScalar.spnoise,"    public static final float spnoise(Point2 p, float periodx, float periody) {
        return spnoise(p.x, p.y, periodx, periody);
    }"
org.sunflow.math.PerlinScalar.spnoise,"    public static final float spnoise(Point3 p, Vector3 period) {
        return spnoise(p.x, p.y, p.z, period.x, period.y, period.z);
    }"
org.sunflow.math.PerlinScalar.spnoise,"    public static final float spnoise(Point3 p, float t, Vector3 pperiod, float tperiod) {
        return spnoise(p.x, p.y, p.z, t, pperiod.x, pperiod.y, pperiod.z, tperiod);
    }"
org.sunflow.math.PerlinScalar.fade,"    private static final float fade(float t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }"
org.sunflow.math.PerlinScalar.lerp,"    private static final float lerp(float t, float a, float b) {
        return a + t * (b - a);
    }"
org.sunflow.math.PerlinScalar.grad,"    private static final float grad(int hash, float x) {
        int h = hash & 0x1;
        return x * G1[h];
    }"
org.sunflow.math.PerlinScalar.grad,"    private static final float grad(int hash, float x, float y) {
        int h = hash & 0x3;
        return x * G2[h][0] + y * G2[h][1];
    }"
org.sunflow.math.PerlinScalar.grad,"    private static final float grad(int hash, float x, float y, float z) {
        int h = hash & 15;
        return x * G3[h][0] + y * G3[h][1] + z * G3[h][2];
    }"
org.sunflow.math.PerlinScalar.grad,"    private static final float grad(int hash, float x, float y, float z, float w) {
        int h = hash & 31;
        return x * G4[h][0] + y * G4[h][1] + z * G4[h][2] + w * G4[h][3];
    }
"
org.sunflow.math.PerlinVector.snoise,"    public static final Vector3 snoise(float x) {
        return new Vector3(PerlinScalar.snoise(x + P1x), PerlinScalar.snoise(x + P2x), PerlinScalar.snoise(x + P3x));
    }"
org.sunflow.math.PerlinVector.snoise,"    public static final Vector3 snoise(float x, float y) {
        return new Vector3(PerlinScalar.snoise(x + P1x, y + P1y), PerlinScalar.snoise(x + P2x, y + P2y), PerlinScalar.snoise(x + P3x, y + P3y));
    }"
org.sunflow.math.PerlinVector.snoise,"    public static final Vector3 snoise(float x, float y, float z) {
        return new Vector3(PerlinScalar.snoise(x + P1x, y + P1y, z + P1z), PerlinScalar.snoise(x + P2x, y + P2y, z + P2z), PerlinScalar.snoise(x + P3x, y + P3y, z + P3z));
    }"
org.sunflow.math.PerlinVector.snoise,"    public static final Vector3 snoise(float x, float y, float z, float t) {
        return new Vector3(PerlinScalar.snoise(x + P1x, y + P1y, z + P1z, t), PerlinScalar.snoise(x + P2x, y + P2y, z + P2z, t), PerlinScalar.snoise(x + P3x, y + P3y, z + P3z, t));
    }"
org.sunflow.math.PerlinVector.snoise,"    public static final Vector3 snoise(Point2 p) {
        return snoise(p.x, p.y);
    }"
org.sunflow.math.PerlinVector.snoise,"    public static final Vector3 snoise(Point3 p) {
        return snoise(p.x, p.y, p.z);
    }"
org.sunflow.math.PerlinVector.snoise,"    public static final Vector3 snoise(Point3 p, float t) {
        return snoise(p.x, p.y, p.z, t);
    }"
org.sunflow.math.PerlinVector.noise,"    public static final Vector3 noise(float x) {
        return new Vector3(PerlinScalar.noise(x + P1x), PerlinScalar.noise(x + P2x), PerlinScalar.noise(x + P3x));
    }"
org.sunflow.math.PerlinVector.noise,"    public static final Vector3 noise(float x, float y) {
        return new Vector3(PerlinScalar.noise(x + P1x, y + P1y), PerlinScalar.noise(x + P2x, y + P2y), PerlinScalar.noise(x + P3x, y + P3y));
    }"
org.sunflow.math.PerlinVector.noise,"    public static final Vector3 noise(float x, float y, float z) {
        return new Vector3(PerlinScalar.noise(x + P1x, y + P1y, z + P1z), PerlinScalar.noise(x + P2x, y + P2y, z + P2z), PerlinScalar.noise(x + P3x, y + P3y, z + P3z));
    }"
org.sunflow.math.PerlinVector.noise,"    public static final Vector3 noise(float x, float y, float z, float t) {
        return new Vector3(PerlinScalar.noise(x + P1x, y + P1y, z + P1z, t), PerlinScalar.noise(x + P2x, y + P2y, z + P2z, t), PerlinScalar.noise(x + P3x, y + P3y, z + P3z, t));
    }"
org.sunflow.math.PerlinVector.noise,"    public static final Vector3 noise(Point2 p) {
        return noise(p.x, p.y);
    }"
org.sunflow.math.PerlinVector.noise,"    public static final Vector3 noise(Point3 p) {
        return noise(p.x, p.y, p.z);
    }"
org.sunflow.math.PerlinVector.noise,"    public static final Vector3 noise(Point3 p, float t) {
        return noise(p.x, p.y, p.z, t);
    }"
org.sunflow.math.PerlinVector.pnoise,"    public static final Vector3 pnoise(float x, float period) {
        return new Vector3(PerlinScalar.pnoise(x + P1x, period), PerlinScalar.pnoise(x + P2x, period), PerlinScalar.pnoise(x + P3x, period));
    }"
org.sunflow.math.PerlinVector.pnoise,"    public static final Vector3 pnoise(float x, float y, float w, float h) {
        return new Vector3(PerlinScalar.pnoise(x + P1x, y + P1y, w, h), PerlinScalar.pnoise(x + P2x, y + P2y, w, h), PerlinScalar.pnoise(x + P3x, y + P3y, w, h));
    }"
org.sunflow.math.PerlinVector.pnoise,"    public static final Vector3 pnoise(float x, float y, float z, float w, float h, float d) {
        return new Vector3(PerlinScalar.pnoise(x + P1x, y + P1y, z + P1z, w, h, d), PerlinScalar.pnoise(x + P2x, y + P2y, z + P2z, w, h, d), PerlinScalar.pnoise(x + P3x, y + P3y, z + P3z, w, h, d));
    }"
org.sunflow.math.PerlinVector.pnoise,"    public static final Vector3 pnoise(float x, float y, float z, float t, float w, float h, float d, float p) {
        return new Vector3(PerlinScalar.pnoise(x + P1x, y + P1y, z + P1z, t, w, h, d, p), PerlinScalar.pnoise(x + P2x, y + P2y, z + P2z, t, w, h, d, p), PerlinScalar.pnoise(x + P3x, y + P3y, z + P3z, t, w, h, d, p));
    }"
org.sunflow.math.PerlinVector.pnoise,"    public static final Vector3 pnoise(Point2 p, float periodx, float periody) {
        return pnoise(p.x, p.y, periodx, periody);
    }"
org.sunflow.math.PerlinVector.pnoise,"    public static final Vector3 pnoise(Point3 p, Vector3 period) {
        return pnoise(p.x, p.y, p.z, period.x, period.y, period.z);
    }"
org.sunflow.math.PerlinVector.pnoise,"    public static final Vector3 pnoise(Point3 p, float t, Vector3 pperiod, float tperiod) {
        return pnoise(p.x, p.y, p.z, t, pperiod.x, pperiod.y, pperiod.z, tperiod);
    }"
org.sunflow.math.PerlinVector.spnoise,"    public static final Vector3 spnoise(float x, float period) {
        return new Vector3(PerlinScalar.spnoise(x + P1x, period), PerlinScalar.spnoise(x + P2x, period), PerlinScalar.spnoise(x + P3x, period));
    }"
org.sunflow.math.PerlinVector.spnoise,"    public static final Vector3 spnoise(float x, float y, float w, float h) {
        return new Vector3(PerlinScalar.spnoise(x + P1x, y + P1y, w, h), PerlinScalar.spnoise(x + P2x, y + P2y, w, h), PerlinScalar.spnoise(x + P3x, y + P3y, w, h));
    }"
org.sunflow.math.PerlinVector.spnoise,"    public static final Vector3 spnoise(float x, float y, float z, float w, float h, float d) {
        return new Vector3(PerlinScalar.spnoise(x + P1x, y + P1y, z + P1z, w, h, d), PerlinScalar.spnoise(x + P2x, y + P2y, z + P2z, w, h, d), PerlinScalar.spnoise(x + P3x, y + P3y, z + P3z, w, h, d));
    }"
org.sunflow.math.PerlinVector.spnoise,"    public static final Vector3 spnoise(float x, float y, float z, float t, float w, float h, float d, float p) {
        return new Vector3(PerlinScalar.spnoise(x + P1x, y + P1y, z + P1z, t, w, h, d, p), PerlinScalar.spnoise(x + P2x, y + P2y, z + P2z, t, w, h, d, p), PerlinScalar.spnoise(x + P3x, y + P3y, z + P3z, t, w, h, d, p));
    }"
org.sunflow.math.PerlinVector.spnoise,"    public static final Vector3 spnoise(Point2 p, float periodx, float periody) {
        return spnoise(p.x, p.y, periodx, periody);
    }"
org.sunflow.math.PerlinVector.spnoise,"    public static final Vector3 spnoise(Point3 p, Vector3 period) {
        return spnoise(p.x, p.y, p.z, period.x, period.y, period.z);
    }"
org.sunflow.math.PerlinVector.spnoise,"    public static final Vector3 spnoise(Point3 p, float t, Vector3 pperiod, float tperiod) {
        return spnoise(p.x, p.y, p.z, t, pperiod.x, pperiod.y, pperiod.z, tperiod);
    }
"
org.sunflow.math.MathUtils.clamp,"    public static final int clamp(int x, int min, int max) {
        if (x > max)
            return max;
        if (x > min)
            return x;
        return min;
    }"
org.sunflow.math.MathUtils.clamp,"    public static final float clamp(float x, float min, float max) {
        if (x > max)
            return max;
        if (x > min)
            return x;
        return min;
    }"
org.sunflow.math.MathUtils.clamp,"    public static final double clamp(double x, double min, double max) {
        if (x > max)
            return max;
        if (x > min)
            return x;
        return min;
    }"
org.sunflow.math.MathUtils.min,"    public static final int min(int a, int b, int c) {
        if (a > b)
            a = b;
        if (a > c)
            a = c;
        return a;
    }"
org.sunflow.math.MathUtils.min,"    public static final float min(float a, float b, float c) {
        if (a > b)
            a = b;
        if (a > c)
            a = c;
        return a;
    }"
org.sunflow.math.MathUtils.min,"    public static final double min(double a, double b, double c) {
        if (a > b)
            a = b;
        if (a > c)
            a = c;
        return a;
    }"
org.sunflow.math.MathUtils.min,"    public static final float min(float a, float b, float c, float d) {
        if (a > b)
            a = b;
        if (a > c)
            a = c;
        if (a > d)
            a = d;
        return a;
    }"
org.sunflow.math.MathUtils.max,"    public static final int max(int a, int b, int c) {
        if (a < b)
            a = b;
        if (a < c)
            a = c;
        return a;
    }"
org.sunflow.math.MathUtils.max,"    public static final float max(float a, float b, float c) {
        if (a < b)
            a = b;
        if (a < c)
            a = c;
        return a;
    }"
org.sunflow.math.MathUtils.max,"    public static final double max(double a, double b, double c) {
        if (a < b)
            a = b;
        if (a < c)
            a = c;
        return a;
    }"
org.sunflow.math.MathUtils.max,"    public static final float max(float a, float b, float c, float d) {
        if (a < b)
            a = b;
        if (a < c)
            a = c;
        if (a < d)
            a = d;
        return a;
    }"
org.sunflow.math.MathUtils.smoothStep,"    public static final float smoothStep(float a, float b, float x) {
        if (x <= a)
            return 0;
        if (x >= b)
            return 1;
        float t = clamp((x - a) / (b - a), 0.0f, 1.0f);
        return t * t * (3 - 2 * t);
    }"
org.sunflow.math.MathUtils.fastPow,"/**
* Computes a fast approximation to <code>Math.pow(a, b)</code>. Adapted
* from <url>http://www.dctsystems.co.uk/Software/power.html</url>.
*
* @param a a positive number
* @param b a number
* @return a^b
*/
    public static final float fastPow(float a, float b) {
        // adapted from: http://www.dctsystems.co.uk/Software/power.html
        float x = Float.floatToRawIntBits(a);
        x *= 1.0f / (1 << 23);
        x = x - 127;
        float y = x - (int) Math.floor(x);
        b *= x + (y - y * y) * 0.346607f;
        y = b - (int) Math.floor(b);
        y = (y - y * y) * 0.33971f;
        return Float.intBitsToFloat((int) ((b + 127 - y) * (1 << 23)));
    }
"
org.sunflow.math.Point2.set,"    public final Point2 set(float x, float y) {
        this.x = x;
        this.y = y;
        return this;
    }"
org.sunflow.math.Point2.set,"    public final Point2 set(Point2 p) {
        x = p.x;
        y = p.y;
        return this;
    }"
org.sunflow.math.Point2.toString,"    public final String toString() {
        return String.format(""(%.2f, %.2f)"", x, y);
    }
"
org.sunflow.math.Vector3.decode,"    public static final Vector3 decode(short n, Vector3 dest) {
        int t = (n & 0xFF00) >>> 8;
        int p = n & 0xFF;
        dest.x = SIN_THETA[t] * COS_PHI[p];
        dest.y = SIN_THETA[t] * SIN_PHI[p];
        dest.z = COS_THETA[t];
        return dest;
    }"
org.sunflow.math.Vector3.decode,"    public static final Vector3 decode(short n) {
        return decode(n, new Vector3());
    }"
org.sunflow.math.Vector3.encode,"    public final short encode() {
        int theta = (int) (Math.acos(z) * (256.0 / Math.PI));
        if (theta > 255)
            theta = 255;
        int phi = (int) (Math.atan2(y, x) * (128.0 / Math.PI));
        if (phi < 0)
            phi += 256;
        else if (phi > 255)
            phi = 255;
        return (short) (((theta & 0xFF) << 8) | (phi & 0xFF));
    }"
org.sunflow.math.Vector3.get,"    public float get(int i) {
        switch (i) {
            case 0:
                return x;
            case 1:
                return y;
            default:
                return z;
        }
    }"
org.sunflow.math.Vector3.length,"    public final float length() {
        return (float) Math.sqrt((x * x) + (y * y) + (z * z));
    }"
org.sunflow.math.Vector3.lengthSquared,"    public final float lengthSquared() {
        return (x * x) + (y * y) + (z * z);
    }"
org.sunflow.math.Vector3.negate,"    public final Vector3 negate() {
        x = -x;
        y = -y;
        z = -z;
        return this;
    }"
org.sunflow.math.Vector3.negate,"    public final Vector3 negate(Vector3 dest) {
        dest.x = -x;
        dest.y = -y;
        dest.z = -z;
        return dest;
    }"
org.sunflow.math.Vector3.mul,"    public final Vector3 mul(float s) {
        x *= s;
        y *= s;
        z *= s;
        return this;
    }"
org.sunflow.math.Vector3.mul,"    public final Vector3 mul(float s, Vector3 dest) {
        dest.x = x * s;
        dest.y = y * s;
        dest.z = z * s;
        return dest;
    }"
org.sunflow.math.Vector3.div,"    public final Vector3 div(float d) {
        x /= d;
        y /= d;
        z /= d;
        return this;
    }"
org.sunflow.math.Vector3.div,"    public final Vector3 div(float d, Vector3 dest) {
        dest.x = x / d;
        dest.y = y / d;
        dest.z = z / d;
        return dest;
    }"
org.sunflow.math.Vector3.normalizeLength,"    public final float normalizeLength() {
        float n = (float) Math.sqrt(x * x + y * y + z * z);
        float in = 1.0f / n;
        x *= in;
        y *= in;
        z *= in;
        return n;
    }"
org.sunflow.math.Vector3.normalize,"    public final Vector3 normalize() {
        float in = 1.0f / (float) Math.sqrt((x * x) + (y * y) + (z * z));
        x *= in;
        y *= in;
        z *= in;
        return this;
    }"
org.sunflow.math.Vector3.normalize,"    public final Vector3 normalize(Vector3 dest) {
        float in = 1.0f / (float) Math.sqrt((x * x) + (y * y) + (z * z));
        dest.x = x * in;
        dest.y = y * in;
        dest.z = z * in;
        return dest;
    }"
org.sunflow.math.Vector3.set,"    public final Vector3 set(float x, float y, float z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }"
org.sunflow.math.Vector3.set,"    public final Vector3 set(Vector3 v) {
        x = v.x;
        y = v.y;
        z = v.z;
        return this;
    }"
org.sunflow.math.Vector3.dot,"    public final float dot(float vx, float vy, float vz) {
        return vx * x + vy * y + vz * z;
    }"
org.sunflow.math.Vector3.dot,"    public static final float dot(Vector3 v1, Vector3 v2) {
        return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);
    }"
org.sunflow.math.Vector3.cross,"    public static final Vector3 cross(Vector3 v1, Vector3 v2, Vector3 dest) {
        dest.x = (v1.y * v2.z) - (v1.z * v2.y);
        dest.y = (v1.z * v2.x) - (v1.x * v2.z);
        dest.z = (v1.x * v2.y) - (v1.y * v2.x);
        return dest;
    }"
org.sunflow.math.Vector3.add,"    public static final Vector3 add(Vector3 v1, Vector3 v2, Vector3 dest) {
        dest.x = v1.x + v2.x;
        dest.y = v1.y + v2.y;
        dest.z = v1.z + v2.z;
        return dest;
    }"
org.sunflow.math.Vector3.sub,"    public static final Vector3 sub(Vector3 v1, Vector3 v2, Vector3 dest) {
        dest.x = v1.x - v2.x;
        dest.y = v1.y - v2.y;
        dest.z = v1.z - v2.z;
        return dest;
    }"
org.sunflow.math.Vector3.toString,"    public final String toString() {
        return String.format(""(%.2f, %.2f, %.2f)"", x, y, z);
    }
"
org.sunflow.math.Point3.get,"    public float get(int i) {
        switch (i) {
            case 0:
                return x;
            case 1:
                return y;
            default:
                return z;
        }
    }"
org.sunflow.math.Point3.distanceTo,"    public final float distanceTo(Point3 p) {
        float dx = x - p.x;
        float dy = y - p.y;
        float dz = z - p.z;
        return (float) Math.sqrt((dx * dx) + (dy * dy) + (dz * dz));
    }"
org.sunflow.math.Point3.distanceTo,"    public final float distanceTo(float px, float py, float pz) {
        float dx = x - px;
        float dy = y - py;
        float dz = z - pz;
        return (float) Math.sqrt((dx * dx) + (dy * dy) + (dz * dz));
    }"
org.sunflow.math.Point3.distanceToSquared,"    public final float distanceToSquared(Point3 p) {
        float dx = x - p.x;
        float dy = y - p.y;
        float dz = z - p.z;
        return (dx * dx) + (dy * dy) + (dz * dz);
    }"
org.sunflow.math.Point3.distanceToSquared,"    public final float distanceToSquared(float px, float py, float pz) {
        float dx = x - px;
        float dy = y - py;
        float dz = z - pz;
        return (dx * dx) + (dy * dy) + (dz * dz);
    }"
org.sunflow.math.Point3.set,"    public final Point3 set(float x, float y, float z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }"
org.sunflow.math.Point3.set,"    public final Point3 set(Point3 p) {
        x = p.x;
        y = p.y;
        z = p.z;
        return this;
    }"
org.sunflow.math.Point3.add,"    public static final Point3 add(Point3 p, Vector3 v, Point3 dest) {
        dest.x = p.x + v.x;
        dest.y = p.y + v.y;
        dest.z = p.z + v.z;
        return dest;
    }"
org.sunflow.math.Point3.sub,"    public static final Vector3 sub(Point3 p1, Point3 p2, Vector3 dest) {
        dest.x = p1.x - p2.x;
        dest.y = p1.y - p2.y;
        dest.z = p1.z - p2.z;
        return dest;
    }"
org.sunflow.math.Point3.mid,"    public static final Point3 mid(Point3 p1, Point3 p2, Point3 dest) {
        dest.x = 0.5f * (p1.x + p2.x);
        dest.y = 0.5f * (p1.y + p2.y);
        dest.z = 0.5f * (p1.z + p2.z);
        return dest;
    }"
org.sunflow.math.Point3.normal,"    public static final Vector3 normal(Point3 p0, Point3 p1, Point3 p2) {
        float edge1x = p1.x - p0.x;
        float edge1y = p1.y - p0.y;
        float edge1z = p1.z - p0.z;
        float edge2x = p2.x - p0.x;
        float edge2y = p2.y - p0.y;
        float edge2z = p2.z - p0.z;
        float nx = edge1y * edge2z - edge1z * edge2y;
        float ny = edge1z * edge2x - edge1x * edge2z;
        float nz = edge1x * edge2y - edge1y * edge2x;
        return new Vector3(nx, ny, nz);
    }"
org.sunflow.math.Point3.toString,"    public final String toString() {
        return String.format(""(%.2f, %.2f, %.2f)"", x, y, z);
    }
"
org.sunflow.math.OrthoNormalBasis.flipU,"    public void flipU() {
        u.negate();
    }"
org.sunflow.math.OrthoNormalBasis.flipV,"    public void flipV() {
        v.negate();
    }"
org.sunflow.math.OrthoNormalBasis.flipW,"    public void flipW() {
        w.negate();
    }"
org.sunflow.math.OrthoNormalBasis.swapUV,"    public void swapUV() {
        Vector3 t = u;
        u = v;
        v = t;
    }"
org.sunflow.math.OrthoNormalBasis.swapVW,"    public void swapVW() {
        Vector3 t = v;
        v = w;
        w = t;
    }"
org.sunflow.math.OrthoNormalBasis.swapWU,"    public void swapWU() {
        Vector3 t = w;
        w = u;
        u = t;
    }"
org.sunflow.math.OrthoNormalBasis.transform,"    public Vector3 transform(Vector3 a, Vector3 dest) {
        dest.x = (a.x * u.x) + (a.y * v.x) + (a.z * w.x);
        dest.y = (a.x * u.y) + (a.y * v.y) + (a.z * w.y);
        dest.z = (a.x * u.z) + (a.y * v.z) + (a.z * w.z);
        return dest;
    }"
org.sunflow.math.OrthoNormalBasis.transform,"    public Vector3 transform(Vector3 a) {
        float x = (a.x * u.x) + (a.y * v.x) + (a.z * w.x);
        float y = (a.x * u.y) + (a.y * v.y) + (a.z * w.y);
        float z = (a.x * u.z) + (a.y * v.z) + (a.z * w.z);
        return a.set(x, y, z);
    }"
org.sunflow.math.OrthoNormalBasis.untransform,"    public Vector3 untransform(Vector3 a, Vector3 dest) {
        dest.x = Vector3.dot(a, u);
        dest.y = Vector3.dot(a, v);
        dest.z = Vector3.dot(a, w);
        return dest;
    }"
org.sunflow.math.OrthoNormalBasis.untransform,"    public Vector3 untransform(Vector3 a) {
        float x = Vector3.dot(a, u);
        float y = Vector3.dot(a, v);
        float z = Vector3.dot(a, w);
        return a.set(x, y, z);
    }"
org.sunflow.math.OrthoNormalBasis.untransformX,"    public float untransformX(Vector3 a) {
        return Vector3.dot(a, u);
    }"
org.sunflow.math.OrthoNormalBasis.untransformY,"    public float untransformY(Vector3 a) {
        return Vector3.dot(a, v);
    }"
org.sunflow.math.OrthoNormalBasis.untransformZ,"    public float untransformZ(Vector3 a) {
        return Vector3.dot(a, w);
    }"
org.sunflow.math.OrthoNormalBasis.makeFromW,"    public static final OrthoNormalBasis makeFromW(Vector3 w) {
        OrthoNormalBasis onb = new OrthoNormalBasis();
        w.normalize(onb.w);
        if ((Math.abs(onb.w.x) < Math.abs(onb.w.y)) && (Math.abs(onb.w.x) < Math.abs(onb.w.z))) {
            onb.v.x = 0;
            onb.v.y = onb.w.z;
            onb.v.z = -onb.w.y;
        } else if (Math.abs(onb.w.y) < Math.abs(onb.w.z)) {
            onb.v.x = onb.w.z;
            onb.v.y = 0;
            onb.v.z = -onb.w.x;
        } else {
            onb.v.x = onb.w.y;
            onb.v.y = -onb.w.x;
            onb.v.z = 0;
        }
        Vector3.cross(onb.v.normalize(), onb.w, onb.u);
        return onb;
    }"
org.sunflow.math.OrthoNormalBasis.makeFromWV,"    public static final OrthoNormalBasis makeFromWV(Vector3 w, Vector3 v) {
        OrthoNormalBasis onb = new OrthoNormalBasis();
        w.normalize(onb.w);
        Vector3.cross(v, onb.w, onb.u).normalize();
        Vector3.cross(onb.w, onb.u, onb.v);
        return onb;
    }
"
org.sunflow.math.Solvers.solveQuadric,"/**
* Solves the equation ax^2+bx+c=0. Solutions are returned in a sorted array
* if they exist.
*
* @param a coefficient of x^2
* @param b coefficient of x^1
* @param c coefficient of x^0
* @return an array containing the two real roots, or <code>null</code> if
*         no real solutions exist
*/
    public static final double[] solveQuadric(double a, double b, double c) {
        double disc = b * b - 4 * a * c;
        if (disc < 0)
            return null;
        disc = Math.sqrt(disc);
        double q = ((b < 0) ? -0.5 * (b - disc) : -0.5 * (b + disc));
        double t0 = q / a;
        double t1 = c / q;
        // return sorted array
        return (t0 > t1) ? new double[] { t1, t0 } : new double[] { t0, t1 };
    }"
org.sunflow.math.Solvers.solveQuartic,"/**
* Solve a quartic equation of the form ax^4+bx^3+cx^2+cx^1+d=0. The roots
* are returned in a sorted array of doubles in increasing order.
*
* @param a coefficient of x^4
* @param b coefficient of x^3
* @param c coefficient of x^2
* @param d coefficient of x^1
* @param e coefficient of x^0
* @return a sorted array of roots, or <code>null</code> if no solutions
*         exist
*/
    public static double[] solveQuartic(double a, double b, double c, double d, double e) {
        double inva = 1 / a;
        double c1 = b * inva;
        double c2 = c * inva;
        double c3 = d * inva;
        double c4 = e * inva;
        // cubic resolvant
        double c12 = c1 * c1;
        double p = -0.375 * c12 + c2;
        double q = 0.125 * c12 * c1 - 0.5 * c1 * c2 + c3;
        double r = -0.01171875 * c12 * c12 + 0.0625 * c12 * c2 - 0.25 * c1 * c3 + c4;
        double z = solveCubicForQuartic(-0.5 * p, -r, 0.5 * r * p - 0.125 * q * q);
        double d1 = 2.0 * z - p;
        if (d1 < 0) {
            if (d1 > 1.0e-10)
                d1 = 0;
            else
                return null;
        }
        double d2;
        if (d1 < 1.0e-10) {
            d2 = z * z - r;
            if (d2 < 0)
                return null;
            d2 = Math.sqrt(d2);
        } else {
            d1 = Math.sqrt(d1);
            d2 = 0.5 * q / d1;
        }
        // setup usefull values for the quadratic factors
        double q1 = d1 * d1;
        double q2 = -0.25 * c1;
        double pm = q1 - 4 * (z - d2);
        double pp = q1 - 4 * (z + d2);
        if (pm >= 0 && pp >= 0) {
            // 4 roots (!)
            pm = Math.sqrt(pm);
            pp = Math.sqrt(pp);
            double[] results = new double[4];
            results[0] = -0.5 * (d1 + pm) + q2;
            results[1] = -0.5 * (d1 - pm) + q2;
            results[2] = 0.5 * (d1 + pp) + q2;
            results[3] = 0.5 * (d1 - pp) + q2;
            // tiny insertion sort
            for (int i = 1; i < 4; i++) {
                for (int j = i; j > 0 && results[j - 1] > results[j]; j--) {
                    double t = results[j];
                    results[j] = results[j - 1];
                    results[j - 1] = t;
                }
            }
            return results;
        } else if (pm >= 0) {
            pm = Math.sqrt(pm);
            double[] results = new double[2];
            results[0] = -0.5 * (d1 + pm) + q2;
            results[1] = -0.5 * (d1 - pm) + q2;
            return results;
        } else if (pp >= 0) {
            pp = Math.sqrt(pp);
            double[] results = new double[2];
            results[0] = 0.5 * (d1 - pp) + q2;
            results[1] = 0.5 * (d1 + pp) + q2;
            return results;
        }
        return null;
    }"
org.sunflow.math.Solvers.solveCubicForQuartic,"/**
* Return only one root for the specified cubic equation. This routine is
* only meant to be called by the quartic solver. It assumes the cubic is of
* the form: x^3+px^2+qx+r.
*
* @param p
* @param q
* @param r
* @return
*/
    private static final double solveCubicForQuartic(double p, double q, double r) {
        double A2 = p * p;
        double Q = (A2 - 3.0 * q) / 9.0;
        double R = (p * (A2 - 4.5 * q) + 13.5 * r) / 27.0;
        double Q3 = Q * Q * Q;
        double R2 = R * R;
        double d = Q3 - R2;
        double an = p / 3.0;
        if (d >= 0) {
            d = R / Math.sqrt(Q3);
            double theta = Math.acos(d) / 3.0;
            double sQ = -2.0 * Math.sqrt(Q);
            return sQ * Math.cos(theta) - an;
        } else {
            double sQ = Math.pow(Math.sqrt(R2 - Q3) + Math.abs(R), 1.0 / 3.0);
            if (R < 0)
                return (sQ + Q / sQ) - an;
            else
                return -(sQ + Q / sQ) - an;
        }
    }
"
org.sunflow.math.QMC.nextPrime,"    private static final int nextPrime(int p) {
        p = p + (p & 1) + 1;
        while (true) {
            int div = 3;
            boolean isPrime = true;
            while (isPrime && ((div * div) <= p)) {
                isPrime = ((p % div) != 0);
                div += 2;
            }
            if (isPrime)
                return p;
            p += 2;
        }
    }"
org.sunflow.math.QMC.riVDC,"    public static double riVDC(int bits, int r) {
        bits = (bits << 16) | (bits >>> 16);
        bits = ((bits & 0x00ff00ff) << 8) | ((bits & 0xff00ff00) >>> 8);
        bits = ((bits & 0x0f0f0f0f) << 4) | ((bits & 0xf0f0f0f0) >>> 4);
        bits = ((bits & 0x33333333) << 2) | ((bits & 0xcccccccc) >>> 2);
        bits = ((bits & 0x55555555) << 1) | ((bits & 0xaaaaaaaa) >>> 1);
        bits ^= r;
        return (double) (bits & 0xFFFFFFFFL) / (double) 0x100000000L;
    }"
org.sunflow.math.QMC.riS,"    public static double riS(int i, int r) {
        for (int v = 1 << 31; i != 0; i >>>= 1, v ^= v >>> 1)
            if ((i & 1) != 0)
                r ^= v;
        return (double) r / (double) 0x100000000L;
    }"
org.sunflow.math.QMC.riLP,"    public static double riLP(int i, int r) {
        for (int v = 1 << 31; i != 0; i >>>= 1, v |= v >>> 1)
            if ((i & 1) != 0)
                r ^= v;
        return (double) r / (double) 0x100000000L;
    }"
org.sunflow.math.QMC.halton,"    public static final double halton(int d, int i) {
        // generalized Halton sequence
        switch (d) {
            case 0: {
                i = (i << 16) | (i >>> 16);
                i = ((i & 0x00ff00ff) << 8) | ((i & 0xff00ff00) >>> 8);
                i = ((i & 0x0f0f0f0f) << 4) | ((i & 0xf0f0f0f0) >>> 4);
                i = ((i & 0x33333333) << 2) | ((i & 0xcccccccc) >>> 2);
                i = ((i & 0x55555555) << 1) | ((i & 0xaaaaaaaa) >>> 1);
                return (double) (i & 0xFFFFFFFFL) / (double) 0x100000000L;
            }
            case 1: {
                double v = 0;
                double inv = 1.0 / 3;
                double p;
                int n;
                for (p = inv, n = i; n != 0; p *= inv, n /= 3)
                    v += (n % 3) * p;
                return v;
            }
            default:
        }
        int base = PRIMES[d];
        int[] perm = SIGMA[d];
        double v = 0;
        double inv = 1.0 / base;
        double p;
        int n;
        for (p = inv, n = i; n != 0; p *= inv, n /= base)
            v += perm[n % base] * p;
        return v;
    }"
org.sunflow.math.QMC.mod1,"    public static final double mod1(double x) {
        // assumes x >= 0
        return x - (int) x;
    }"
org.sunflow.math.QMC.generateSigmaTable,"    public static final int[] generateSigmaTable(int n) {
        assert (n & (n - 1)) == 0;
        int[] sigma = new int[n];
        for (int i = 0; i < n; i++) {
            int digit = n;
            sigma[i] = 0;
            for (int bits = i; bits != 0; bits >>= 1) {
                digit >>= 1;
                if ((bits & 1) != 0)
                    sigma[i] += digit;
            }
        }
        return sigma;
    }
"
org.sunflow.math.Matrix4.asRowMajor,"    public final float[] asRowMajor() {
        return new float[] { m00, m01, m02, m03, m10, m11, m12, m13, m20, m21,
                m22, m23, m30, m31, m32, m33 };
    }"
org.sunflow.math.Matrix4.asColMajor,"    public final float[] asColMajor() {
        return new float[] { m00, m10, m20, m30, m01, m11, m21, m31, m02, m12,
                m22, m32, m03, m13, m23, m33 };
    }"
org.sunflow.math.Matrix4.determinant,"/**
* Compute the matrix determinant.
*
* @return determinant of this matrix
*/
    public final float determinant() {
        float A0 = m00 * m11 - m01 * m10;
        float A1 = m00 * m12 - m02 * m10;
        float A2 = m00 * m13 - m03 * m10;
        float A3 = m01 * m12 - m02 * m11;
        float A4 = m01 * m13 - m03 * m11;
        float A5 = m02 * m13 - m03 * m12;

        float B0 = m20 * m31 - m21 * m30;
        float B1 = m20 * m32 - m22 * m30;
        float B2 = m20 * m33 - m23 * m30;
        float B3 = m21 * m32 - m22 * m31;
        float B4 = m21 * m33 - m23 * m31;
        float B5 = m22 * m33 - m23 * m32;

        return A0 * B5 - A1 * B4 + A2 * B3 + A3 * B2 - A4 * B1 + A5 * B0;
    }"
org.sunflow.math.Matrix4.inverse,"/**
* Compute the inverse of this matrix and return it as a new object. If the
* matrix is not invertible, <code>null</code> is returned.
*
* @return the inverse of this matrix, or <code>null</code> if not
*         invertible
*/
    public final Matrix4 inverse() {
        float A0 = m00 * m11 - m01 * m10;
        float A1 = m00 * m12 - m02 * m10;
        float A2 = m00 * m13 - m03 * m10;
        float A3 = m01 * m12 - m02 * m11;
        float A4 = m01 * m13 - m03 * m11;
        float A5 = m02 * m13 - m03 * m12;

        float B0 = m20 * m31 - m21 * m30;
        float B1 = m20 * m32 - m22 * m30;
        float B2 = m20 * m33 - m23 * m30;
        float B3 = m21 * m32 - m22 * m31;
        float B4 = m21 * m33 - m23 * m31;
        float B5 = m22 * m33 - m23 * m32;

        float det = A0 * B5 - A1 * B4 + A2 * B3 + A3 * B2 - A4 * B1 + A5 * B0;
        if (Math.abs(det) < 1e-12f)
            return null; // matrix is not invertible
        float invDet = 1 / det;
        Matrix4 inv = new Matrix4();
        inv.m00 = (+m11 * B5 - m12 * B4 + m13 * B3) * invDet;
        inv.m10 = (-m10 * B5 + m12 * B2 - m13 * B1) * invDet;
        inv.m20 = (+m10 * B4 - m11 * B2 + m13 * B0) * invDet;
        inv.m30 = (-m10 * B3 + m11 * B1 - m12 * B0) * invDet;
        inv.m01 = (-m01 * B5 + m02 * B4 - m03 * B3) * invDet;
        inv.m11 = (+m00 * B5 - m02 * B2 + m03 * B1) * invDet;
        inv.m21 = (-m00 * B4 + m01 * B2 - m03 * B0) * invDet;
        inv.m31 = (+m00 * B3 - m01 * B1 + m02 * B0) * invDet;
        inv.m02 = (+m31 * A5 - m32 * A4 + m33 * A3) * invDet;
        inv.m12 = (-m30 * A5 + m32 * A2 - m33 * A1) * invDet;
        inv.m22 = (+m30 * A4 - m31 * A2 + m33 * A0) * invDet;
        inv.m32 = (-m30 * A3 + m31 * A1 - m32 * A0) * invDet;
        inv.m03 = (-m21 * A5 + m22 * A4 - m23 * A3) * invDet;
        inv.m13 = (+m20 * A5 - m22 * A2 + m23 * A1) * invDet;
        inv.m23 = (-m20 * A4 + m21 * A2 - m23 * A0) * invDet;
        inv.m33 = (+m20 * A3 - m21 * A1 + m22 * A0) * invDet;
        return inv;
    }"
org.sunflow.math.Matrix4.multiply,"/**
* Computes this*m and return the result as a new Matrix4
*
* @param m right hand side of the multiplication
* @return a new Matrix4 object equal to <code>this*m</code>
*/
    public final Matrix4 multiply(Matrix4 m) {
        // matrix multiplication is m[r][c] = (row[r]).(col[c])
        float rm00 = m00 * m.m00 + m01 * m.m10 + m02 * m.m20 + m03 * m.m30;
        float rm01 = m00 * m.m01 + m01 * m.m11 + m02 * m.m21 + m03 * m.m31;
        float rm02 = m00 * m.m02 + m01 * m.m12 + m02 * m.m22 + m03 * m.m32;
        float rm03 = m00 * m.m03 + m01 * m.m13 + m02 * m.m23 + m03 * m.m33;

        float rm10 = m10 * m.m00 + m11 * m.m10 + m12 * m.m20 + m13 * m.m30;
        float rm11 = m10 * m.m01 + m11 * m.m11 + m12 * m.m21 + m13 * m.m31;
        float rm12 = m10 * m.m02 + m11 * m.m12 + m12 * m.m22 + m13 * m.m32;
        float rm13 = m10 * m.m03 + m11 * m.m13 + m12 * m.m23 + m13 * m.m33;

        float rm20 = m20 * m.m00 + m21 * m.m10 + m22 * m.m20 + m23 * m.m30;
        float rm21 = m20 * m.m01 + m21 * m.m11 + m22 * m.m21 + m23 * m.m31;
        float rm22 = m20 * m.m02 + m21 * m.m12 + m22 * m.m22 + m23 * m.m32;
        float rm23 = m20 * m.m03 + m21 * m.m13 + m22 * m.m23 + m23 * m.m33;

        float rm30 = m30 * m.m00 + m31 * m.m10 + m32 * m.m20 + m33 * m.m30;
        float rm31 = m30 * m.m01 + m31 * m.m11 + m32 * m.m21 + m33 * m.m31;
        float rm32 = m30 * m.m02 + m31 * m.m12 + m32 * m.m22 + m33 * m.m32;
        float rm33 = m30 * m.m03 + m31 * m.m13 + m32 * m.m23 + m33 * m.m33;

        return new Matrix4(rm00, rm01, rm02, rm03, rm10, rm11, rm12, rm13, rm20, rm21, rm22, rm23, rm30, rm31, rm32, rm33);
    }"
org.sunflow.math.Matrix4.transform,"/**
* Transforms each corner of the specified axis-aligned bounding box and
* returns a new bounding box which incloses the transformed corners.
*
* @param b original bounding box
* @return a new BoundingBox object which encloses the transform version of
*         b
*/
    public final BoundingBox transform(BoundingBox b) {
        if (b.isEmpty())
            return new BoundingBox();
        // special case extreme corners
        BoundingBox rb = new BoundingBox(transformP(b.getMinimum()));
        rb.include(transformP(b.getMaximum()));
        // do internal corners
        for (int i = 1; i < 7; i++)
            rb.include(transformP(b.getCorner(i)));
        return rb;
    }"
org.sunflow.math.Matrix4.transformV,"/**
* Computes this*v and returns the result as a new Vector3 object. This
* method assumes the bottom row of the matrix is <code>[0,0,0,1]</code>.
*
* @param v vector to multiply
* @return a new Vector3 object equal to <code>this*v</code>
*/
    public final Vector3 transformV(Vector3 v) {
        Vector3 rv = new Vector3();
        rv.x = m00 * v.x + m01 * v.y + m02 * v.z;
        rv.y = m10 * v.x + m11 * v.y + m12 * v.z;
        rv.z = m20 * v.x + m21 * v.y + m22 * v.z;
        return rv;
    }"
org.sunflow.math.Matrix4.transformTransposeV,"/**
* Computes (this^T)*v and returns the result as a new Vector3 object. This
* method assumes the bottom row of the matrix is <code>[0,0,0,1]</code>.
*
* @param v vector to multiply
* @return a new Vector3 object equal to <code>(this^T)*v</code>
*/
    public final Vector3 transformTransposeV(Vector3 v) {
        Vector3 rv = new Vector3();
        rv.x = m00 * v.x + m10 * v.y + m20 * v.z;
        rv.y = m01 * v.x + m11 * v.y + m21 * v.z;
        rv.z = m02 * v.x + m12 * v.y + m22 * v.z;
        return rv;
    }"
org.sunflow.math.Matrix4.transformP,"/**
* Computes this*p and returns the result as a new Point3 object. This
* method assumes the bottom row of the matrix is <code>[0,0,0,1]</code>.
*
* @param p point to multiply
* @return a new Point3 object equal to <code>this*v</code>
*/
    public final Point3 transformP(Point3 p) {
        Point3 rp = new Point3();
        rp.x = m00 * p.x + m01 * p.y + m02 * p.z + m03;
        rp.y = m10 * p.x + m11 * p.y + m12 * p.z + m13;
        rp.z = m20 * p.x + m21 * p.y + m22 * p.z + m23;
        return rp;
    }"
org.sunflow.math.Matrix4.transformVX,"/**
* Computes the x component of this*(x,y,z,0).
*
* @param x x coordinate of the vector to multiply
* @param y y coordinate of the vector to multiply
* @param z z coordinate of the vector to multiply
* @return
*/
    public final float transformVX(float x, float y, float z) {
        return m00 * x + m01 * y + m02 * z;
    }"
org.sunflow.math.Matrix4.transformVY,"/**
* Computes the y component of this*(x,y,z,0).
*
* @param x x coordinate of the vector to multiply
* @param y y coordinate of the vector to multiply
* @param z z coordinate of the vector to multiply
* @return
*/
    public final float transformVY(float x, float y, float z) {
        return m10 * x + m11 * y + m12 * z;
    }"
org.sunflow.math.Matrix4.transformVZ,"/**
* Computes the z component of this*(x,y,z,0).
*
* @param x x coordinate of the vector to multiply
* @param y y coordinate of the vector to multiply
* @param z z coordinate of the vector to multiply
* @return
*/
    public final float transformVZ(float x, float y, float z) {
        return m20 * x + m21 * y + m22 * z;
    }"
org.sunflow.math.Matrix4.transformTransposeVX,"/**
* Computes the x component of (this^T)*(x,y,z,0).
*
* @param x x coordinate of the vector to multiply
* @param y y coordinate of the vector to multiply
* @param z z coordinate of the vector to multiply
* @return
*/
    public final float transformTransposeVX(float x, float y, float z) {
        return m00 * x + m10 * y + m20 * z;
    }"
org.sunflow.math.Matrix4.transformTransposeVY,"/**
* Computes the y component of (this^T)*(x,y,z,0).
*
* @param x x coordinate of the vector to multiply
* @param y y coordinate of the vector to multiply
* @param z z coordinate of the vector to multiply
* @return
*/
    public final float transformTransposeVY(float x, float y, float z) {
        return m01 * x + m11 * y + m21 * z;
    }"
org.sunflow.math.Matrix4.transformTransposeVZ,"/**
* Computes the z component of (this^T)*(x,y,z,0).
*
* @param x x coordinate of the vector to multiply
* @param y y coordinate of the vector to multiply
* @param z z coordinate of the vector to multiply
* @return
*/
    public final float transformTransposeVZ(float x, float y, float z) {
        return m02 * x + m12 * y + m22 * z;
    }"
org.sunflow.math.Matrix4.transformPX,"/**
* Computes the x component of this*(x,y,z,1).
*
* @param x x coordinate of the vector to multiply
* @param y y coordinate of the vector to multiply
* @param z z coordinate of the vector to multiply
* @return
*/
    public final float transformPX(float x, float y, float z) {
        return m00 * x + m01 * y + m02 * z + m03;
    }"
org.sunflow.math.Matrix4.transformPY,"/**
* Computes the y component of this*(x,y,z,1).
*
* @param x x coordinate of the vector to multiply
* @param y y coordinate of the vector to multiply
* @param z z coordinate of the vector to multiply
* @return
*/
    public final float transformPY(float x, float y, float z) {
        return m10 * x + m11 * y + m12 * z + m13;
    }"
org.sunflow.math.Matrix4.transformPZ,"/**
* Computes the z component of this*(x,y,z,1).
*
* @param x x coordinate of the vector to multiply
* @param y y coordinate of the vector to multiply
* @param z z coordinate of the vector to multiply
* @return
*/
    public final float transformPZ(float x, float y, float z) {
        return m20 * x + m21 * y + m22 * z + m23;
    }"
org.sunflow.math.Matrix4.translation,"/**
* Create a translation matrix for the specified vector.
*
* @param x x component of translation
* @param y y component of translation
* @param z z component of translation
* @return a new Matrix4 object representing the translation
*/
    public final static Matrix4 translation(float x, float y, float z) {
        Matrix4 m = new Matrix4();
        m.m00 = m.m11 = m.m22 = m.m33 = 1;
        m.m03 = x;
        m.m13 = y;
        m.m23 = z;
        return m;
    }"
org.sunflow.math.Matrix4.rotateX,"/**
* Creates a rotation matrix about the X axis.
*
* @param theta angle to rotate about the X axis in radians
* @return a new Matrix4 object representing the rotation
*/
    public final static Matrix4 rotateX(float theta) {
        Matrix4 m = new Matrix4();
        float s = (float) Math.sin(theta);
        float c = (float) Math.cos(theta);
        m.m00 = m.m33 = 1;
        m.m11 = m.m22 = c;
        m.m12 = -s;
        m.m21 = +s;
        return m;
    }"
org.sunflow.math.Matrix4.rotateY,"/**
* Creates a rotation matrix about the Y axis.
*
* @param theta angle to rotate about the Y axis in radians
* @return a new Matrix4 object representing the rotation
*/
    public final static Matrix4 rotateY(float theta) {
        Matrix4 m = new Matrix4();
        float s = (float) Math.sin(theta);
        float c = (float) Math.cos(theta);
        m.m11 = m.m33 = 1;
        m.m00 = m.m22 = c;
        m.m02 = +s;
        m.m20 = -s;
        return m;
    }"
org.sunflow.math.Matrix4.rotateZ,"/**
* Creates a rotation matrix about the Z axis.
*
* @param theta angle to rotate about the Z axis in radians
* @return a new Matrix4 object representing the rotation
*/
    public final static Matrix4 rotateZ(float theta) {
        Matrix4 m = new Matrix4();
        float s = (float) Math.sin(theta);
        float c = (float) Math.cos(theta);
        m.m22 = m.m33 = 1;
        m.m00 = m.m11 = c;
        m.m01 = -s;
        m.m10 = +s;
        return m;
    }"
org.sunflow.math.Matrix4.rotate,"/**
* Creates a rotation matrix about the specified axis. The axis vector need
* not be normalized.
*
* @param x x component of the axis vector
* @param y y component of the axis vector
* @param z z component of the axis vector
* @param theta angle to rotate about the axis in radians
* @return a new Matrix4 object representing the rotation
*/
    public final static Matrix4 rotate(float x, float y, float z, float theta) {
        Matrix4 m = new Matrix4();
        float invLen = 1 / (float) Math.sqrt(x * x + y * y + z * z);
        x *= invLen;
        y *= invLen;
        z *= invLen;
        float s = (float) Math.sin(theta);
        float c = (float) Math.cos(theta);
        float t = 1 - c;
        m.m00 = t * x * x + c;
        m.m11 = t * y * y + c;
        m.m22 = t * z * z + c;
        float txy = t * x * y;
        float sz = s * z;
        m.m01 = txy - sz;
        m.m10 = txy + sz;
        float txz = t * x * z;
        float sy = s * y;
        m.m02 = txz + sy;
        m.m20 = txz - sy;
        float tyz = t * y * z;
        float sx = s * x;
        m.m12 = tyz - sx;
        m.m21 = tyz + sx;
        m.m33 = 1;
        return m;
    }"
org.sunflow.math.Matrix4.scale,"/**
* Create a uniform scaling matrix.
*
* @param s scale factor for all three axes
* @return a new Matrix4 object representing the uniform scale
*/
    public final static Matrix4 scale(float s) {
        Matrix4 m = new Matrix4();
        m.m00 = m.m11 = m.m22 = s;
        m.m33 = 1;
        return m;
    }"
org.sunflow.math.Matrix4.scale,"/**
* Creates a non-uniform scaling matrix.
*
* @param sx scale factor in the x dimension
* @param sy scale factor in the y dimension
* @param sz scale factor in the z dimension
* @return a new Matrix4 object representing the non-uniform scale
*/
    public final static Matrix4 scale(float sx, float sy, float sz) {
        Matrix4 m = new Matrix4();
        m.m00 = sx;
        m.m11 = sy;
        m.m22 = sz;
        m.m33 = 1;
        return m;
    }"
org.sunflow.math.Matrix4.fromBasis,"/**
* Creates a rotation matrix from an OrthonormalBasis.
*
* @param basis
*/
    public final static Matrix4 fromBasis(OrthoNormalBasis basis) {
        Matrix4 m = new Matrix4();
        Vector3 u = basis.transform(new Vector3(1, 0, 0));
        Vector3 v = basis.transform(new Vector3(0, 1, 0));
        Vector3 w = basis.transform(new Vector3(0, 0, 1));
        m.m00 = u.x;
        m.m01 = v.x;
        m.m02 = w.x;
        m.m10 = u.y;
        m.m11 = v.y;
        m.m12 = w.y;
        m.m20 = u.z;
        m.m21 = v.z;
        m.m22 = w.z;
        m.m33 = 1;
        return m;
    }
"
org.sunflow.image.RGBSpace.convertXYZtoRGB,"    public final Color convertXYZtoRGB(XYZColor c) {
        return convertXYZtoRGB(c.getX(), c.getY(), c.getZ());
    }"
org.sunflow.image.RGBSpace.convertXYZtoRGB,"    public final Color convertXYZtoRGB(float X, float Y, float Z) {
        float r = (rx * X) + (ry * Y) + (rz * Z);
        float g = (gx * X) + (gy * Y) + (gz * Z);
        float b = (bx * X) + (by * Y) + (bz * Z);
        return new Color(r, g, b);
    }"
org.sunflow.image.RGBSpace.convertRGBtoXYZ,"    public final XYZColor convertRGBtoXYZ(Color c) {
        float[] rgb = c.getRGB();
        float X = (xr * rgb[0]) + (xg * rgb[1]) + (xb * rgb[2]);
        float Y = (yr * rgb[0]) + (yg * rgb[1]) + (yb * rgb[2]);
        float Z = (zr * rgb[0]) + (zg * rgb[1]) + (zb * rgb[2]);
        return new XYZColor(X, Y, Z);
    }"
org.sunflow.image.RGBSpace.insideGamut,"    public final boolean insideGamut(float r, float g, float b) {
        return r >= 0 && g >= 0 && b >= 0;
    }"
org.sunflow.image.RGBSpace.gammaCorrect,"    public final float gammaCorrect(float v) {
        if (v <= 0)
            return 0;
        else if (v >= 1)
            return 1;
        else if (v <= breakPoint)
            return slope * v;
        else
            return slopeMatch * (float) Math.pow(v, 1 / gamma) - segmentOffset;
    }"
org.sunflow.image.RGBSpace.ungammaCorrect,"    public final float ungammaCorrect(float vp) {
        if (vp <= 0)
            return 0;
        else if (vp >= 1)
            return 1;
        else if (vp <= breakPoint * slope)
            return vp / slope;
        else
            return (float) Math.pow((vp + segmentOffset) / slopeMatch, gamma);
    }"
org.sunflow.image.RGBSpace.toString,"    public final String toString() {
        String info = ""Gamma function parameters:\n"";
        info += String.format(""  * Gamma:          %7.4f\n"", gamma);
        info += String.format(""  * Breakpoint:     %7.4f\n"", breakPoint);
        info += String.format(""  * Slope:          %7.4f\n"", slope);
        info += String.format(""  * Slope Match:    %7.4f\n"", slopeMatch);
        info += String.format(""  * Segment Offset: %7.4f\n"", segmentOffset);
        info += ""XYZ -> RGB Matrix:\n"";
        info += String.format(""| %7.4f %7.4f %7.4f|\n"", rx, ry, rz);
        info += String.format(""| %7.4f %7.4f %7.4f|\n"", gx, gy, gz);
        info += String.format(""| %7.4f %7.4f %7.4f|\n"", bx, by, bz);
        info += ""RGB -> XYZ Matrix:\n"";
        info += String.format(""| %7.4f %7.4f %7.4f|\n"", xr, xg, xb);
        info += String.format(""| %7.4f %7.4f %7.4f|\n"", yr, yg, yb);
        info += String.format(""| %7.4f %7.4f %7.4f|\n"", zr, zg, zb);
        return info;
    }"
org.sunflow.image.RGBSpace.main,"    public static void main(String[] args) {
        System.out.println(SRGB.toString());
        System.out.println(HDTV.toString());
        System.out.println(WIDE_GAMUT.toString());
    }
"
org.sunflow.image.XYZColor.getX,"    public final float getX() {
        return X;
    }"
org.sunflow.image.XYZColor.getY,"    public final float getY() {
        return Y;
    }"
org.sunflow.image.XYZColor.getZ,"    public final float getZ() {
        return Z;
    }"
org.sunflow.image.XYZColor.mul,"    public final XYZColor mul(float s) {
        X *= s;
        Y *= s;
        Z *= s;
        return this;
    }"
org.sunflow.image.XYZColor.normalize,"    public final void normalize() {
        float XYZ = X + Y + Z;
        if (XYZ < 1e-6f)
            return;
        float s = 1 / XYZ;
        X *= s;
        Y *= s;
        Z *= s;
    }"
org.sunflow.image.XYZColor.toString,"    public final String toString() {
        return String.format(""(%.3f, %.3f, %.3f)"", X, Y, Z);
    }
"
org.sunflow.image.BlackbodySpectrum.sample,"    public float sample(float lambda) {
        double wavelength = lambda * 1e-9;
        return (float) ((3.74183e-16 * Math.pow(wavelength, -5.0)) / (Math.exp(1.4388e-2 / (wavelength * temp)) - 1.0));
    }
"
org.sunflow.image.IrregularSpectralCurve.sample,"    public float sample(float lambda) {
        if (wavelengths.length == 0)
            return 0; // no data
        if (wavelengths.length == 1 || lambda <= wavelengths[0])
            return amplitudes[0];
        if (lambda >= wavelengths[wavelengths.length - 1])
            return amplitudes[wavelengths.length - 1];
        for (int i = 1; i < wavelengths.length; i++) {
            if (lambda < wavelengths[i]) {
                float dx = (lambda - wavelengths[i - 1]) / (wavelengths[i] - wavelengths[i - 1]);
                return (1 - dx) * amplitudes[i - 1] + dx * amplitudes[i];
            }
        }
        return amplitudes[wavelengths.length - 1];
    }
"
org.sunflow.image.ChromaticitySpectrum.sample,"    public float sample(float lambda) {
        return kS0Spectrum.sample(lambda) + M1 * kS1Spectrum.sample(lambda) + M2 * kS2Spectrum.sample(lambda);
    }"
org.sunflow.image.ChromaticitySpectrum.get,"    public static final XYZColor get(float x, float y) {
        float M1 = (-1.3515f - 1.7703f * x + 5.9114f * y) / (0.0241f + 0.2562f * x - 0.7341f * y);
        float M2 = (0.03f - 31.4424f * x + 30.0717f * y) / (0.0241f + 0.2562f * x - 0.7341f * y);
        float X = S0xyz.getX() + M1 * S1xyz.getX() + M2 * S2xyz.getX();
        float Y = S0xyz.getY() + M1 * S1xyz.getY() + M2 * S2xyz.getY();
        float Z = S0xyz.getZ() + M1 * S1xyz.getZ() + M2 * S2xyz.getZ();
        return new XYZColor(X, Y, Z);
    }
"
org.sunflow.image.ConstantSpectralCurve.sample,"    public float sample(float lambda) {
        return amp;
    }
"
org.sunflow.image.SpectralCurve.sample,"/**
* This function determines the actual spectral curve data. Note that the
* lambda parameter is assumed to be in nanometers.
*
* @param lambda wavelength to sample in nanometers
* @return the value of the spectral curve at this point
*/
"
org.sunflow.image.SpectralCurve.toXYZ,"/**
* Convert this curve to a tristimulus CIE XYZ color by integrating against
* the CIE color matching functions.
*
* @return XYZColor that represents this spectra
*/
    public final XYZColor toXYZ() {
        float X = 0, Y = 0, Z = 0;
        for (int i = 0, w = WAVELENGTH_MIN; i < CIE_xbar.length; i++, w += WAVELENGTH_STEP) {
            float s = sample(w);
            X += s * CIE_xbar[i];
            Y += s * CIE_ybar[i];
            Z += s * CIE_zbar[i];
        }
        return new XYZColor(X, Y, Z).mul(WAVELENGTH_STEP);
    }
"
org.sunflow.image.RegularSpectralCurve.sample,"    public float sample(float lambda) {
        // reject wavelengths outside the valid range
        if (lambda < lambdaMin || lambda > lambdaMax)
            return 0;
        // interpolate the two closest samples linearly
        float x = (lambda - lambdaMin) * invDelta;
        int b0 = (int) x;
        int b1 = Math.min(b0 + 1, spectrum.length - 1);
        float dx = x - b0;
        return (1 - dx) * spectrum[b0] + dx * spectrum[b1];
    }
"
org.sunflow.image.Bitmap.save,"    public static void save(BufferedImage image, String filename) {
        Bitmap b = new Bitmap(image.getWidth(), image.getHeight(), false);
        for (int y = 0; y < b.height; y++)
            for (int x = 0; x < b.width; x++)
                b.pixels[((b.height - 1 - y) * b.width) + x] = image.getRGB(x, y);
        if (filename.endsWith("".tga""))
            b.saveTGA(filename);
        else
            b.savePNG(filename);
    }"
org.sunflow.image.Bitmap.readFlatRGBE,"    private void readFlatRGBE(FileInputStream f, int rasterPos, int numPixels) throws IOException {
        while (numPixels-- > 0) {
            int r = f.read();
            int g = f.read();
            int b = f.read();
            int e = f.read();
            pixels[rasterPos] = (r << 24) | (g << 16) | (b << 8) | e;
            rasterPos++;
        }
    }"
org.sunflow.image.Bitmap.setPixel,"    public void setPixel(int x, int y, Color c) {
        if ((x >= 0) && (x < width) && (y >= 0) && (y < height))
            pixels[(y * width) + x] = isHDR ? c.toRGBE() : c.copy().toNonLinear().toRGB();
    }"
org.sunflow.image.Bitmap.getPixel,"    public Color getPixel(int x, int y) {
        if ((x >= 0) && (x < width) && (y >= 0) && (y < height))
            return isHDR ? new Color().setRGBE(pixels[(y * width) + x]) : new Color(pixels[(y * width) + x]);
        return Color.BLACK;
    }"
org.sunflow.image.Bitmap.getWidth,"    public int getWidth() {
        return width;
    }"
org.sunflow.image.Bitmap.getHeight,"    public int getHeight() {
        return height;
    }"
org.sunflow.image.Bitmap.save,"    public void save(String filename) {
        if (filename.endsWith("".hdr""))
            saveHDR(filename);
        else if (filename.endsWith("".png""))
            savePNG(filename);
        else if (filename.endsWith("".tga""))
            saveTGA(filename);
        else
            saveHDR(filename + "".hdr"");
    }"
org.sunflow.image.Bitmap.savePNG,"    private void savePNG(String filename) {
        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        for (int y = 0; y < height; y++)
            for (int x = 0; x < width; x++)
                bi.setRGB(x, height - 1 - y, isHDR ? getPixel(x, y).toRGB() : pixels[(y * width) + x]);
        try {
            ImageIO.write(bi, ""png"", new File(filename));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }"
org.sunflow.image.Bitmap.saveHDR,"    private void saveHDR(String filename) {
        try {
            FileOutputStream f = new FileOutputStream(filename);
            f.write(""#?RGBE\n"".getBytes());
            f.write(""FORMAT=32-bit_rle_rgbe\n\n"".getBytes());
            f.write((""-Y "" + height + "" +X "" + width + ""\n"").getBytes());
            for (int y = height - 1; y >= 0; y--) {
                for (int x = 0; x < width; x++) {
                    int rgbe = isHDR ? pixels[(y * width) + x] : new Color(pixels[(y * width) + x]).toRGBE();
                    f.write(rgbe >> 24);
                    f.write(rgbe >> 16);
                    f.write(rgbe >> 8);
                    f.write(rgbe);
                }
            }
            f.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }"
org.sunflow.image.Bitmap.saveTGA,"    private void saveTGA(String filename) {
        try {
            FileOutputStream f = new FileOutputStream(filename);
            // no id, no colormap, uncompressed 3bpp RGB
            byte[] tgaHeader = { 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            f.write(tgaHeader);
            // then the size info
            f.write(width & 0xFF);
            f.write((width >> 8) & 0xFF);
            f.write(height & 0xFF);
            f.write((height >> 8) & 0xFF);
            // bitsperpixel and filler
            f.write(32);
            f.write(0);
            // image data
            for (int y = 0; y < height; y++) {
                for (int x = 0; x < width; x++) {
                    int pix = isHDR ? getPixel(x, y).toRGB() : pixels[y * width + x];
                    f.write(pix & 0xFF);
                    f.write((pix >> 8) & 0xFF);
                    f.write((pix >> 16) & 0xFF);
                    f.write(0xFF);
                }
            }
            f.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
"
org.sunflow.image.Color.black,"    public static Color black() {
        return new Color();
    }"
org.sunflow.image.Color.white,"    public static Color white() {
        return new Color(1, 1, 1);
    }"
org.sunflow.image.Color.sRGBCurve,"    private static float sRGBCurve(float c) {
        if (c <= 0.00304)
            return 12.92f * c;
        else
            return (float) (1.055 * Math.pow(c, 1.0 / 2.4) - 0.055);
    }"
org.sunflow.image.Color.sRGBCurveInverse,"    private static float sRGBCurveInverse(float c) {
        if (c <= 0.03928)
            return c / 12.92f;
        else
            return (float) Math.pow((c + 0.055) / 1.055, 2.4);
    }"
org.sunflow.image.Color.toNonLinear,"    public Color toNonLinear() {
        r = sRGBCurve(r);
        g = sRGBCurve(g);
        b = sRGBCurve(b);
        return this;
    }"
org.sunflow.image.Color.toLinear,"    public Color toLinear() {
        r = sRGBCurveInverse(r);
        g = sRGBCurveInverse(g);
        b = sRGBCurveInverse(b);
        return this;
    }"
org.sunflow.image.Color.rgbToLinear,"    public static int rgbToLinear(int rgb) {
        // convert a packed RGB triplet to a linearized one by applying the
        // proper LUT
        int rp = SRGB_CURVE_INV[(rgb >> 16) & 0xFF];
        int gp = SRGB_CURVE_INV[(rgb >> 8) & 0xFF];
        int bp = SRGB_CURVE_INV[rgb & 0xFF];
        return (rp << 16) | (gp << 8) | bp;
    }"
org.sunflow.image.Color.rgbFromLinear,"    public static int rgbFromLinear(int rgb) {
        // convert a packed RGB triple to non-linear one by applying the proper
        // LUT
        int rp = SRGB_CURVE[(rgb >> 16) & 0xFF];
        int gp = SRGB_CURVE[(rgb >> 8) & 0xFF];
        int bp = SRGB_CURVE[rgb & 0xFF];
        return (rp << 16) | (gp << 8) | bp;
    }"
org.sunflow.image.Color.copy,"    public Color copy() {
        return new Color(this);
    }"
org.sunflow.image.Color.set,"    public final Color set(float r, float g, float b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    }"
org.sunflow.image.Color.set,"    public final Color set(Color c) {
        r = c.r;
        g = c.g;
        b = c.b;
        return this;
    }"
org.sunflow.image.Color.setRGB,"    public final Color setRGB(int rgb) {
        r = ((rgb >> 16) & 0xFF) / 255.0f;
        g = ((rgb >> 8) & 0xFF) / 255.0f;
        b = (rgb & 0xFF) / 255.0f;
        return this;
    }"
org.sunflow.image.Color.setRGBE,"    public final Color setRGBE(int rgbe) {
        float f = EXPONENT[rgbe & 0xFF];
        r = f * ((rgbe >>> 24) + 0.5f);
        g = f * (((rgbe >> 16) & 0xFF) + 0.5f);
        b = f * (((rgbe >> 8) & 0xFF) + 0.5f);
        return this;
    }"
org.sunflow.image.Color.isBlack,"    public final boolean isBlack() {
        return r <= 0 && g <= 0 && b <= 0;
    }"
org.sunflow.image.Color.getLuminance,"    public final float getLuminance() {
        return (0.2989f * r) + (0.5866f * g) + (0.1145f * b);
    }"
org.sunflow.image.Color.getMin,"    public final float getMin() {
        return MathUtils.min(r, g, b);
    }"
org.sunflow.image.Color.getMax,"    public final float getMax() {
        return MathUtils.max(r, g, b);
    }"
org.sunflow.image.Color.getAverage,"    public final float getAverage() {
        return (r + g + b) / 3.0f;
    }"
org.sunflow.image.Color.getRGB,"    public final float[] getRGB() {
        return new float[] { r, g, b };
    }"
org.sunflow.image.Color.toRGB,"    public final int toRGB() {
        int ir = (int) (r * 255 + 0.5);
        int ig = (int) (g * 255 + 0.5);
        int ib = (int) (b * 255 + 0.5);
        ir = MathUtils.clamp(ir, 0, 255);
        ig = MathUtils.clamp(ig, 0, 255);
        ib = MathUtils.clamp(ib, 0, 255);
        return (ir << 16) | (ig << 8) | ib;
    }"
org.sunflow.image.Color.toRGBE,"    public final int toRGBE() {
        // encode the color into 32bits while preserving HDR using Ward's RGBE
        // technique
        float v = MathUtils.max(r, g, b);
        if (v < 1e-32f)
            return 0;

        // get mantissa and exponent
        float m = v;
        int e = 0;
        if (v > 1.0f) {
            while (m > 1.0f) {
                m *= 0.5f;
                e++;
            }
        } else if (v <= 0.5f) {
            while (m <= 0.5f) {
                m *= 2.0f;
                e--;
            }
        }
        v = (m * 255.0f) / v;
        int c = (e + 128);
        c |= ((int) (r * v) << 24);
        c |= ((int) (g * v) << 16);
        c |= ((int) (b * v) << 8);
        return c;
    }"
org.sunflow.image.Color.constrainRGB,"    public final Color constrainRGB() {
        // clamp the RGB value to a representable value
        float w = -MathUtils.min(0, r, g, b);
        if (w > 0) {
            r += w;
            g += w;
            b += w;
        }
        return this;
    }"
org.sunflow.image.Color.isNan,"    public final boolean isNan() {
        return Float.isNaN(r) || Float.isNaN(g) || Float.isNaN(b);
    }"
org.sunflow.image.Color.isInf,"    public final boolean isInf() {
        return Float.isInfinite(r) || Float.isInfinite(g) || Float.isInfinite(b);
    }"
org.sunflow.image.Color.add,"    public final Color add(Color c) {
        r += c.r;
        g += c.g;
        b += c.b;
        return this;
    }"
org.sunflow.image.Color.add,"    public static final Color add(Color c1, Color c2) {
        return Color.add(c1, c2, new Color());
    }"
org.sunflow.image.Color.add,"    public static final Color add(Color c1, Color c2, Color dest) {
        dest.r = c1.r + c2.r;
        dest.g = c1.g + c2.g;
        dest.b = c1.b + c2.b;
        return dest;
    }"
org.sunflow.image.Color.madd,"    public final Color madd(float s, Color c) {
        r += (s * c.r);
        g += (s * c.g);
        b += (s * c.b);
        return this;
    }"
org.sunflow.image.Color.madd,"    public final Color madd(Color s, Color c) {
        r += s.r * c.r;
        g += s.g * c.g;
        b += s.b * c.b;
        return this;
    }"
org.sunflow.image.Color.sub,"    public final Color sub(Color c) {
        r -= c.r;
        g -= c.g;
        b -= c.b;
        return this;
    }"
org.sunflow.image.Color.sub,"    public static final Color sub(Color c1, Color c2) {
        return Color.sub(c1, c2, new Color());
    }"
org.sunflow.image.Color.sub,"    public static final Color sub(Color c1, Color c2, Color dest) {
        dest.r = c1.r - c2.r;
        dest.g = c1.g - c2.g;
        dest.b = c1.b - c2.b;
        return dest;
    }"
org.sunflow.image.Color.mul,"    public final Color mul(Color c) {
        r *= c.r;
        g *= c.g;
        b *= c.b;
        return this;
    }"
org.sunflow.image.Color.mul,"    public static final Color mul(Color c1, Color c2) {
        return Color.mul(c1, c2, new Color());
    }"
org.sunflow.image.Color.mul,"    public static final Color mul(Color c1, Color c2, Color dest) {
        dest.r = c1.r * c2.r;
        dest.g = c1.g * c2.g;
        dest.b = c1.b * c2.b;
        return dest;
    }"
org.sunflow.image.Color.mul,"    public final Color mul(float s) {
        r *= s;
        g *= s;
        b *= s;
        return this;
    }"
org.sunflow.image.Color.mul,"    public static final Color mul(float s, Color c) {
        return Color.mul(s, c, new Color());
    }"
org.sunflow.image.Color.mul,"    public static final Color mul(float s, Color c, Color dest) {
        dest.r = s * c.r;
        dest.g = s * c.g;
        dest.b = s * c.b;
        return dest;
    }"
org.sunflow.image.Color.div,"    public final Color div(Color c) {
        r /= c.r;
        g /= c.g;
        b /= c.b;
        return this;
    }"
org.sunflow.image.Color.div,"    public static final Color div(Color c1, Color c2) {
        return Color.div(c1, c2, new Color());
    }"
org.sunflow.image.Color.div,"    public static final Color div(Color c1, Color c2, Color dest) {
        dest.r = c1.r / c2.r;
        dest.g = c1.g / c2.g;
        dest.b = c1.b / c2.b;
        return dest;
    }"
org.sunflow.image.Color.exp,"    public final Color exp() {
        r = (float) Math.exp(r);
        g = (float) Math.exp(g);
        b = (float) Math.exp(b);
        return this;
    }"
org.sunflow.image.Color.opposite,"    public final Color opposite() {
        r = 1 - r;
        g = 1 - g;
        b = 1 - b;
        return this;
    }"
org.sunflow.image.Color.clamp,"    public final Color clamp(float min, float max) {
        r = MathUtils.clamp(r, min, max);
        g = MathUtils.clamp(r, min, max);
        b = MathUtils.clamp(r, min, max);
        return this;
    }"
org.sunflow.image.Color.blend,"    public static final Color blend(Color c1, Color c2, float b) {
        return blend(c1, c2, b, new Color());
    }"
org.sunflow.image.Color.blend,"    public static final Color blend(Color c1, Color c2, float b, Color dest) {
        dest.r = (1.0f - b) * c1.r + b * c2.r;
        dest.g = (1.0f - b) * c1.g + b * c2.g;
        dest.b = (1.0f - b) * c1.b + b * c2.b;
        return dest;
    }"
org.sunflow.image.Color.blend,"    public static final Color blend(Color c1, Color c2, Color b) {
        return blend(c1, c2, b, new Color());
    }"
org.sunflow.image.Color.blend,"    public static final Color blend(Color c1, Color c2, Color b, Color dest) {
        dest.r = (1.0f - b.r) * c1.r + b.r * c2.r;
        dest.g = (1.0f - b.g) * c1.g + b.g * c2.g;
        dest.b = (1.0f - b.b) * c1.b + b.b * c2.b;
        return dest;
    }"
org.sunflow.image.Color.hasContrast,"    public static final boolean hasContrast(Color c1, Color c2, float thresh) {
        if (Math.abs(c1.r - c2.r) / (c1.r + c2.r) > thresh)
            return true;
        if (Math.abs(c1.g - c2.g) / (c1.g + c2.g) > thresh)
            return true;
        if (Math.abs(c1.b - c2.b) / (c1.b + c2.b) > thresh)
            return true;
        return false;
    }"
org.sunflow.image.Color.toString,"    public String toString() {
        return String.format(""(%.3f, %.3f, %.3f)"", r, g, b);
    }
"
org.sunflow.system.ByteUtil.get2Bytes,"    public static final byte[] get2Bytes(int i) {
        byte[] b = new byte[2];

        b[0] = (byte) (i & 0xFF);
        b[1] = (byte) ((i >> 8) & 0xFF);

        return b;
    }"
org.sunflow.system.ByteUtil.get4Bytes,"    public static final byte[] get4Bytes(int i) {
        byte[] b = new byte[4];

        b[0] = (byte) (i & 0xFF);
        b[1] = (byte) ((i >> 8) & 0xFF);
        b[2] = (byte) ((i >> 16) & 0xFF);
        b[3] = (byte) ((i >> 24) & 0xFF);

        return b;
    }"
org.sunflow.system.ByteUtil.get4BytesInv,"    public static final byte[] get4BytesInv(int i) {
        byte[] b = new byte[4];

        b[3] = (byte) (i & 0xFF);
        b[2] = (byte) ((i >> 8) & 0xFF);
        b[1] = (byte) ((i >> 16) & 0xFF);
        b[0] = (byte) ((i >> 24) & 0xFF);

        return b;
    }"
org.sunflow.system.ByteUtil.get8Bytes,"    public static final byte[] get8Bytes(long i) {
        byte[] b = new byte[8];

        b[0] = (byte) (i & 0xFF);
        b[1] = (byte) ((long) ((long) i >> (long) 8) & (long) 0xFF);
        b[2] = (byte) ((long) ((long) i >> (long) 16) & (long) 0xFF);
        b[3] = (byte) ((long) ((long) i >> (long) 24) & (long) 0xFF);

        b[4] = (byte) ((long) ((long) i >> (long) 32) & (long) 0xFF);
        b[5] = (byte) ((long) ((long) i >> (long) 40) & (long) 0xFF);
        b[6] = (byte) ((long) ((long) i >> (long) 48) & (long) 0xFF);
        b[7] = (byte) ((long) ((long) i >> (long) 56) & (long) 0xFF);

        return b;
    }"
org.sunflow.system.ByteUtil.toLong,"    public static final long toLong(byte[] in) {
        return (long) (((long) (toInt(in[0], in[1], in[2], in[3]))) | ((long) (toInt(in[4], in[5], in[6], in[7])) << (long) 32));
    }"
org.sunflow.system.ByteUtil.toInt,"    public static final int toInt(byte in0, byte in1, byte in2, byte in3) {
        return (in0 & 0xFF) | ((in1 & 0xFF) << 8) | ((in2 & 0xFF) << 16) | ((in3 & 0xFF) << 24);
    }"
org.sunflow.system.ByteUtil.toInt,"    public static final int toInt(byte[] in) {
        return toInt(in[0], in[1], in[2], in[3]);
    }"
org.sunflow.system.ByteUtil.toInt,"    public static final int toInt(byte[] in, int ofs) {
        return toInt(in[ofs + 0], in[ofs + 1], in[ofs + 2], in[ofs + 3]);
    }"
org.sunflow.system.ByteUtil.floatToHalf,"    public static final int floatToHalf(float f) {
        int i = Float.floatToRawIntBits(f);
        // unpack the s, e and m of the float
        int s = (i >> 16) & 0x00008000;
        int e = ((i >> 23) & 0x000000ff) - (127 - 15);
        int m = i & 0x007fffff;
        // pack them back up, forming a half
        if (e <= 0) {
            if (e < -10) {
                // E is less than -10. The absolute value of f is less than
                // HALF_MIN
                // convert f to 0
                return 0;
            }
            // E is between -10 and 0.
            m = (m | 0x00800000) >> (1 - e);
            // Round to nearest, round ""0.5"" up.
            if ((m & 0x00001000) == 0x00001000)
                m += 0x00002000;
            // Assemble the half from s, e (zero) and m.
            return s | (m >> 13);
        } else if (e == 0xff - (127 - 15)) {
            if (m == 0) {
                // F is an infinity; convert f to a half infinity
                return s | 0x7c00;
            } else {
                // F is a NAN; we produce a half NAN that preserves the sign bit
                // and the 10 leftmost bits of the significand of f
                m >>= 13;
                return s | 0x7c00 | m | ((m == 0) ? 0 : 1);
            }
        } else {
            // E is greater than zero. F is a normalized float. Round to
            // nearest, round ""0.5"" up
            if ((m & 0x00001000) == 0x00001000) {
                m += 0x00002000;
                if ((m & 0x00800000) == 0x00800000) {
                    m = 0;
                    e += 1;
                }
            }
            // Handle exponent overflow
            if (e > 30) {
                // overflow (); // Cause a hardware floating point overflow;
                return s | 0x7c00; // if this returns, the half becomes an
            } // infinity with the same sign as f.
            // Assemble the half from s, e and m.
            return s | (e << 10) | (m >> 13);
        }
    }
"
org.sunflow.system.Parser.close,"    public void close() throws IOException {
        if (file != null)
            file.close();
        bf = null;
    }"
org.sunflow.system.Parser.getNextToken,"    public String getNextToken() throws IOException {
        while (true) {
            String tok = fetchNextToken();
            if (tok == null)
                return null;
            if (tok.equals(""/*"")) {
                do {
                    tok = fetchNextToken();
                    if (tok == null)
                        return null;
                } while (!tok.equals(""*/""));
            } else
                return tok;
        }
    }"
org.sunflow.system.Parser.peekNextToken,"    public boolean peekNextToken(String tok) throws IOException {
        while (true) {
            String t = fetchNextToken();
            if (t == null)
                return false; // nothing left
            if (t.equals(""/*"")) {
                do {
                    t = fetchNextToken();
                    if (t == null)
                        return false; // nothing left
                } while (!t.equals(""*/""));
            } else if (t.equals(tok)) {
                // we found the right token, keep parsing
                return true;
            } else {
                // rewind the token so we can try again
                index--;
                return false;
            }
        }
    }"
org.sunflow.system.Parser.fetchNextToken,"    private String fetchNextToken() throws IOException {
        if (bf == null)
            return null;
        while (true) {
            if (index < lineTokens.length)
                return lineTokens[index++];
            else if (!getNextLine())
                return null;
        }
    }"
org.sunflow.system.Parser.getNextLine,"    private boolean getNextLine() throws IOException {
        String line = bf.readLine();

        if (line == null)
            return false;

        ArrayList<String> tokenList = new ArrayList<String>();
        String current = new String();
        boolean inQuotes = false;

        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if (current.length() == 0 && (c == '%' || c == '#'))
                break;

            boolean quote = c == '\""';
            inQuotes = inQuotes ^ quote;

            if (!quote && (inQuotes || !Character.isWhitespace(c)))
                current += c;
            else if (current.length() > 0) {
                tokenList.add(current);
                current = new String();
            }
        }

        if (current.length() > 0)
            tokenList.add(current);
        lineTokens = tokenList.toArray(new String[0]);
        index = 0;
        return true;
    }"
org.sunflow.system.Parser.getNextCodeBlock,"    public String getNextCodeBlock() throws ParserException, IOException {
        // read a java code block
        String code = new String();
        checkNextToken(""<code>"");
        while (true) {
            String line;
            try {
                line = bf.readLine();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
            if (line.trim().equals(""</code>""))
                return code;
            code += line;
            code += ""\n"";
        }
    }"
org.sunflow.system.Parser.getNextBoolean,"    public boolean getNextBoolean() throws IOException {
        return Boolean.valueOf(getNextToken()).booleanValue();
    }"
org.sunflow.system.Parser.getNextInt,"    public int getNextInt() throws IOException {
        return Integer.parseInt(getNextToken());
    }"
org.sunflow.system.Parser.getNextFloat,"    public float getNextFloat() throws IOException {
        return Float.parseFloat(getNextToken());
    }"
org.sunflow.system.Parser.checkNextToken,"    public void checkNextToken(String token) throws ParserException, IOException {
        String found = getNextToken();
        if (!token.equals(found)) {
            close();
            throw new ParserException(token, found);
        }
    }"
org.sunflow.system.UserInterface.print,"/**
* Displays some information to the user from the specified module with the
* specified print level. A user interface is free to show or ignore any
* message. Level filtering is done in the core and shouldn't be
* re-implemented by the user interface. All messages will be short enough
* to fit on one line.
*
* @param m module the message came from
* @param level seriousness of the message
* @param s string to display
*/
"
org.sunflow.system.UserInterface.taskStart,"/**
* Prepare a progress bar representing a lengthy task. The actual progress
* is first shown by the call to update and closed when update is closed
* with the max value. It is currently not possible to nest calls to
* setTask, so only one task needs to be tracked at a time.
*
* @param s desriptive string
* @param min minimum value of the task
* @param max maximum value of the task
*/
"
org.sunflow.system.UserInterface.taskUpdate,"/**
* Updates the current progress bar to a value between the current min and
* max. When min or max are passed the progressed bar is shown or hidden
* respectively.
*
* @param current current value of the task in progress.
*/
"
org.sunflow.system.UserInterface.taskStop,"/**
* Closes the current progress bar to indicate the task is over
*/
    void taskStop();
"
org.sunflow.system.BenchmarkFramework.execute,"    public void execute(BenchmarkTest test) {
        // clear previous results
        for (int i = 0; i < timers.length; i++)
            timers[i] = null;
        // loop for the specified number of iterations or until the time limit
        long startTime = System.nanoTime();
        for (int i = 0; i < timers.length && ((System.nanoTime() - startTime) / 1000000000) < timeLimit; i++) {
            UI.printInfo(Module.BENCH, ""Running iteration %d"", (i + 1));
            timers[i] = new Timer();
            test.kernelBegin();
            timers[i].start();
            test.kernelMain();
            timers[i].end();
            test.kernelEnd();
        }
        // report stats
        double avg = 0;
        double min = Double.POSITIVE_INFINITY;
        double max = Double.NEGATIVE_INFINITY;
        int n = 0;
        for (Timer t : timers) {
            if (t == null)
                break;
            double s = t.seconds();
            min = Math.min(min, s);
            max = Math.max(max, s);
            avg += s;
            n++;
        }
        if (n == 0)
            return;
        avg /= n;
        double stdDev = 0;
        for (Timer t : timers) {
            if (t == null)
                break;
            double s = t.seconds();
            stdDev += (s - avg) * (s - avg);
        }
        stdDev = Math.sqrt(stdDev / n);
        UI.printInfo(Module.BENCH, ""Benchmark results:"");
        UI.printInfo(Module.BENCH, ""  * Iterations: %d"", n);
        UI.printInfo(Module.BENCH, ""  * Average:    %s"", Timer.toString(avg));
        UI.printInfo(Module.BENCH, ""  * Fastest:    %s"", Timer.toString(min));
        UI.printInfo(Module.BENCH, ""  * Longest:    %s"", Timer.toString(max));
        UI.printInfo(Module.BENCH, ""  * Deviation:  %s"", Timer.toString(stdDev));
        for (int i = 0; i < timers.length && timers[i] != null; i++)
            UI.printDetailed(Module.BENCH, ""  * Iteration %d: %s"", i + 1, timers[i]);
    }
"
org.sunflow.system.ImagePanel.mousePressed,"        public void mousePressed(MouseEvent e) {
            mx = e.getX();
            my = e.getY();
            switch (e.getButton()) {
                case MouseEvent.BUTTON1:
                    dragging = true;
                    zooming = false;
                    break;
                case MouseEvent.BUTTON2: {
                    dragging = zooming = false;
                    // if CTRL is pressed
                    if ((e.getModifiersEx() & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK)
                        fit();
                    else
                        reset();
                    break;
                }
                case MouseEvent.BUTTON3:
                    zooming = true;
                    dragging = false;
                    break;
                default:
                    return;
            }
            repaint();
        }"
org.sunflow.system.ImagePanel.mouseDragged,"        public void mouseDragged(MouseEvent e) {
            int mx2 = e.getX();
            int my2 = e.getY();
            if (dragging)
                drag(mx2 - mx, my2 - my);
            if (zooming)
                zoom(mx2 - mx, my2 - my);
            mx = mx2;
            my = my2;
        }"
org.sunflow.system.ImagePanel.mouseReleased,"        public void mouseReleased(MouseEvent e) {
            // same behaviour
            mouseDragged(e);
        }"
org.sunflow.system.ImagePanel.mouseWheelMoved,"        public void mouseWheelMoved(MouseWheelEvent e) {
            zoom(-20 * e.getWheelRotation(), 0);
        }
    }

    public ImagePanel() {
        setPreferredSize(new Dimension(640, 480));
        image = null;
        xo = yo = 0;
        w = h = 0;
        ScrollZoomListener listener = new ScrollZoomListener();
        addMouseListener(listener);
        addMouseMotionListener(listener);
        addMouseWheelListener(listener);
    }

    public void save(String filename) {
        Bitmap.save(image, filename);
    }

    private synchronized void drag(int dx, int dy) {
        xo += dx;
        yo += dy;
        repaint();
    }

    private synchronized void zoom(int dx, int dy) {
        int a = Math.max(dx, dy);
        int b = Math.min(dx, dy);
        if (Math.abs(b) > Math.abs(a))
            a = b;
        if (a == 0)
            return;
        // window center
        float cx = getWidth() * 0.5f;
        float cy = getHeight() * 0.5f;

        // origin of the image in window space
        float x = xo + (getWidth() - w) * 0.5f;
        float y = yo + (getHeight() - h) * 0.5f;

        // coordinates of the pixel we are over
        float sx = cx - x;
        float sy = cy - y;

        // scale
        if (w + a > 100) {
            h = (w + a) * h / w;
            sx = (w + a) * sx / w;
            sy = (w + a) * sy / w;
            w = (w + a);
        }

        // restore center pixel

        float x2 = cx - sx;
        float y2 = cy - sy;

        xo = (x2 - (getWidth() - w) * 0.5f);
        yo = (y2 - (getHeight() - h) * 0.5f);

        repaint();
    }

    public synchronized void reset() {
        xo = yo = 0;
        if (image != null) {
            w = image.getWidth();
            h = image.getHeight();
        }
        repaint();
    }

    public synchronized void fit() {
        xo = yo = 0;
        if (image != null) {
            float wx = Math.max(getWidth() - 10, 100);
            float hx = wx * image.getHeight() / image.getWidth();
            float hy = Math.max(getHeight() - 10, 100);
            float wy = hy * image.getWidth() / image.getHeight();
            if (hx > hy) {
                w = wy;
                h = hy;
            } else {
                w = wx;
                h = hx;
            }
            repaint();
        }
    }

    public synchronized void imageBegin(int w, int h, int bucketSize) {
        if (image != null && w == image.getWidth() && h == image.getHeight()) {
            // dull image if it has same resolution (75%)
            for (int y = 0; y < h; y++) {
                for (int x = 0; x < w; x++) {
                    int rgb = image.getRGB(x, y);
                    image.setRGB(x, y, ((rgb & 0x00FEFEFE) >>> 1) + ((rgb & 0x00FCFCFC) >>> 2));
                }
            }
        } else {
            // allocate new framebuffer
            image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
            // center
            this.w = w;
            this.h = h;
            xo = yo = 0;
        }
        repaintCounter = System.nanoTime();
        repaint();
    }

    public synchronized void imagePrepare(int x, int y, int w, int h, int id) {
        int border = BORDERS[id % BORDERS.length];
        for (int by = 0; by < h; by++) {
            for (int bx = 0; bx < w; bx++) {
                if (bx == 0 || bx == w - 1) {
                    if (5 * by < h || 5 * (h - by - 1) < h)
                        image.setRGB(x + bx, y + by, border);
                } else if (by == 0 || by == h - 1) {
                    if (5 * bx < w || 5 * (w - bx - 1) < w)
                        image.setRGB(x + bx, y + by, border);
                }
            }
        }
        repaint();
    }

    public synchronized void imageUpdate(int x, int y, int w, int h, Color[] data) {
        if ((image == null) || (data == null))
            return;
        for (int j = 0, index = 0; j < h; j++)
            for (int i = 0; i < w; i++, index++)
                image.setRGB(x + i, y + j, data[index].copy().toNonLinear().toRGB());
        repaint();
    }

    public synchronized void imageFill(int x, int y, int w, int h, Color c) {
        if ((image == null) || (c == null))
            return;
        int rgb = c.copy().toNonLinear().toRGB();
        for (int j = 0, index = 0; j < h; j++)
            for (int i = 0; i < w; i++, index++)
                image.setRGB(x + i, y + j, rgb);
        fastRepaint();
    }

    public void imageEnd() {
        repaint();
    }

    private void fastRepaint() {
        long t = System.nanoTime();
        if (repaintCounter + 125000000 < t) {
            repaintCounter = t;
            repaint();
        }
    }

    @Override
    public synchronized void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (image == null)
            return;
        int x = (int) Math.round(xo + (getWidth() - w) * 0.5f);
        int y = (int) Math.round(yo + (getHeight() - h) * 0.5f);
        int iw = (int) Math.round(w);
        int ih = (int) Math.round(h);
        int x0 = x - 1;
        int y0 = y - 1;
        int x1 = x + iw + 1;
        int y1 = y + ih + 1;
        g.setColor(java.awt.Color.WHITE);
        g.drawLine(x0, y0, x1, y0);
        g.drawLine(x1, y0, x1, y1);
        g.drawLine(x1, y1, x0, y1);
        g.drawLine(x0, y1, x0, y0);
        g.drawImage(image, x, y, iw, ih, this);
    "
org.sunflow.system.ImagePanel.save,"    public void save(String filename) {
        Bitmap.save(image, filename);
    }"
org.sunflow.system.ImagePanel.drag,"    private synchronized void drag(int dx, int dy) {
        xo += dx;
        yo += dy;
        repaint();
    }"
org.sunflow.system.ImagePanel.zoom,"    private synchronized void zoom(int dx, int dy) {
        int a = Math.max(dx, dy);
        int b = Math.min(dx, dy);
        if (Math.abs(b) > Math.abs(a))
            a = b;
        if (a == 0)
            return;
        // window center
        float cx = getWidth() * 0.5f;
        float cy = getHeight() * 0.5f;

        // origin of the image in window space
        float x = xo + (getWidth() - w) * 0.5f;
        float y = yo + (getHeight() - h) * 0.5f;

        // coordinates of the pixel we are over
        float sx = cx - x;
        float sy = cy - y;

        // scale
        if (w + a > 100) {
            h = (w + a) * h / w;
            sx = (w + a) * sx / w;
            sy = (w + a) * sy / w;
            w = (w + a);
        }

        // restore center pixel

        float x2 = cx - sx;
        float y2 = cy - sy;

        xo = (x2 - (getWidth() - w) * 0.5f);
        yo = (y2 - (getHeight() - h) * 0.5f);

        repaint();
    }"
org.sunflow.system.ImagePanel.reset,"    public synchronized void reset() {
        xo = yo = 0;
        if (image != null) {
            w = image.getWidth();
            h = image.getHeight();
        }
        repaint();
    }"
org.sunflow.system.ImagePanel.fit,"    public synchronized void fit() {
        xo = yo = 0;
        if (image != null) {
            float wx = Math.max(getWidth() - 10, 100);
            float hx = wx * image.getHeight() / image.getWidth();
            float hy = Math.max(getHeight() - 10, 100);
            float wy = hy * image.getWidth() / image.getHeight();
            if (hx > hy) {
                w = wy;
                h = hy;
            } else {
                w = wx;
                h = hx;
            }
            repaint();
        }
    }"
org.sunflow.system.ImagePanel.imageBegin,"    public synchronized void imageBegin(int w, int h, int bucketSize) {
        if (image != null && w == image.getWidth() && h == image.getHeight()) {
            // dull image if it has same resolution (75%)
            for (int y = 0; y < h; y++) {
                for (int x = 0; x < w; x++) {
                    int rgb = image.getRGB(x, y);
                    image.setRGB(x, y, ((rgb & 0x00FEFEFE) >>> 1) + ((rgb & 0x00FCFCFC) >>> 2));
                }
            }
        } else {
            // allocate new framebuffer
            image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
            // center
            this.w = w;
            this.h = h;
            xo = yo = 0;
        }
        repaintCounter = System.nanoTime();
        repaint();
    }"
org.sunflow.system.ImagePanel.imagePrepare,"    public synchronized void imagePrepare(int x, int y, int w, int h, int id) {
        int border = BORDERS[id % BORDERS.length];
        for (int by = 0; by < h; by++) {
            for (int bx = 0; bx < w; bx++) {
                if (bx == 0 || bx == w - 1) {
                    if (5 * by < h || 5 * (h - by - 1) < h)
                        image.setRGB(x + bx, y + by, border);
                } else if (by == 0 || by == h - 1) {
                    if (5 * bx < w || 5 * (w - bx - 1) < w)
                        image.setRGB(x + bx, y + by, border);
                }
            }
        }
        repaint();
    }"
org.sunflow.system.ImagePanel.imageUpdate,"    public synchronized void imageUpdate(int x, int y, int w, int h, Color[] data) {
        if ((image == null) || (data == null))
            return;
        for (int j = 0, index = 0; j < h; j++)
            for (int i = 0; i < w; i++, index++)
                image.setRGB(x + i, y + j, data[index].copy().toNonLinear().toRGB());
        repaint();
    }"
org.sunflow.system.ImagePanel.imageFill,"    public synchronized void imageFill(int x, int y, int w, int h, Color c) {
        if ((image == null) || (c == null))
            return;
        int rgb = c.copy().toNonLinear().toRGB();
        for (int j = 0, index = 0; j < h; j++)
            for (int i = 0; i < w; i++, index++)
                image.setRGB(x + i, y + j, rgb);
        fastRepaint();
    }"
org.sunflow.system.ImagePanel.imageEnd,"    public void imageEnd() {
        repaint();
    }"
org.sunflow.system.ImagePanel.fastRepaint,"    private void fastRepaint() {
        long t = System.nanoTime();
        if (repaintCounter + 125000000 < t) {
            repaintCounter = t;
            repaint();
        }
    }"
org.sunflow.system.ImagePanel.paintComponent,"    public synchronized void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (image == null)
            return;
        int x = (int) Math.round(xo + (getWidth() - w) * 0.5f);
        int y = (int) Math.round(yo + (getHeight() - h) * 0.5f);
        int iw = (int) Math.round(w);
        int ih = (int) Math.round(h);
        int x0 = x - 1;
        int y0 = y - 1;
        int x1 = x + iw + 1;
        int y1 = y + ih + 1;
        g.setColor(java.awt.Color.WHITE);
        g.drawLine(x0, y0, x1, y0);
        g.drawLine(x1, y0, x1, y1);
        g.drawLine(x1, y1, x0, y1);
        g.drawLine(x0, y1, x0, y0);
        g.drawImage(image, x, y, iw, ih, this);
    }
"
org.sunflow.system.UI.set,"/**
* Sets the active user interface implementation. Passing <code>null</code>
* silences printing completely (by using the
*
* @see SilentInterface).
* @param ui
*/
    public final static void set(UserInterface ui) {
        if (ui == null)
            ui = new SilentInterface();
        UI.ui = ui;
    }"
org.sunflow.system.UI.verbosity,"    public final static void verbosity(int verbosity) {
        UI.verbosity = verbosity;
    }"
org.sunflow.system.UI.formatOutput,"    public final static String formatOutput(Module m, PrintLevel level, String s) {
        return String.format(""%-5s  %-6s: %s"", m.name(), level.name().toLowerCase(), s);
    }"
org.sunflow.system.UI.printDetailed,"    public final static synchronized void printDetailed(Module m, String s, Object... args) {
        if (verbosity > 3)
            ui.print(m, PrintLevel.DETAIL, String.format(s, args));
    }"
org.sunflow.system.UI.printInfo,"    public final static synchronized void printInfo(Module m, String s, Object... args) {
        if (verbosity > 2)
            ui.print(m, PrintLevel.INFO, String.format(s, args));
    }"
org.sunflow.system.UI.printWarning,"    public final static synchronized void printWarning(Module m, String s, Object... args) {
        if (verbosity > 1)
            ui.print(m, PrintLevel.WARN, String.format(s, args));
    }"
org.sunflow.system.UI.printError,"    public final static synchronized void printError(Module m, String s, Object... args) {
        if (verbosity > 0)
            ui.print(m, PrintLevel.ERROR, String.format(s, args));
    }"
org.sunflow.system.UI.taskStart,"    public final static synchronized void taskStart(String s, int min, int max) {
        ui.taskStart(s, min, max);
    }"
org.sunflow.system.UI.taskUpdate,"    public final static synchronized void taskUpdate(int current) {
        ui.taskUpdate(current);
    }"
org.sunflow.system.UI.taskStop,"    public final static synchronized void taskStop() {
        ui.taskStop();
        // reset canceled status
        // this assume the parent application will deal with it immediately
        canceled = false;
    }"
org.sunflow.system.UI.taskCancel,"/**
* Cancel the currently active task. This forces the application to abort as
* soon as possible.
*/
    public final static synchronized void taskCancel() {
        printInfo(Module.GUI, ""Abort requested by the user ..."");
        canceled = true;
    }"
org.sunflow.system.UI.taskCanceled,"/**
* Check to see if the current task should be aborted.
*
* @return <code>true</code> if the current task should be stopped,
*         <code>false</code> otherwise
*/
    public final static synchronized boolean taskCanceled() {
        if (canceled)
            printInfo(Module.GUI, ""Abort request noticed by the current task"");
        return canceled;
    }
"
org.sunflow.system.Timer.start,"    public void start() {
        startTime = endTime = System.nanoTime();
    }"
org.sunflow.system.Timer.end,"    public void end() {
        endTime = System.nanoTime();
    }"
org.sunflow.system.Timer.nanos,"    public long nanos() {
        return endTime - startTime;
    }"
org.sunflow.system.Timer.seconds,"    public double seconds() {
        return (endTime - startTime) * 1e-9;
    }"
org.sunflow.system.Timer.toString,"    public static String toString(long nanos) {
        Timer t = new Timer();
        t.endTime = nanos;
        return t.toString();
    }"
org.sunflow.system.Timer.toString,"    public static String toString(double seconds) {
        Timer t = new Timer();
        t.endTime = (long) (seconds * 1e9);
        return t.toString();
    }"
org.sunflow.system.Timer.toString,"    public String toString() {
        long millis = nanos() / (1000 * 1000);
        if (millis < 10000)
            return String.format(""%dms"", millis);
        long hours = millis / (60 * 60 * 1000);
        millis -= hours * 60 * 60 * 1000;
        long minutes = millis / (60 * 1000);
        millis -= minutes * 60 * 1000;
        long seconds = millis / 1000;
        millis -= seconds * 1000;
        return String.format(""%d:%02d:%02d.%1d"", hours, minutes, seconds, millis / 100);
    }
"
org.sunflow.system.Memory.sizeof,"    public static final String sizeof(int[] array) {
        return bytesToString(array == null ? 0 : 4 * array.length);
    }"
org.sunflow.system.Memory.bytesToString,"    public static final String bytesToString(long bytes) {
        if (bytes < 1024)
            return String.format(""%db"", bytes);
        if (bytes < 1024 * 1024)
            return String.format(""%dKb"", (bytes + 512) >>> 10);
        return String.format(""%dMb"", (bytes + 512 * 1024) >>> 20);
    }
"
org.sunflow.system.BenchmarkTest.kernelBegin,
org.sunflow.system.BenchmarkTest.kernelMain,
org.sunflow.system.BenchmarkTest.kernelEnd,"    public void kernelEnd();
"
org.sunflow.system.RenderGlobalsPanel.initialize,"/**
* This method initializes this
*/
    private void initialize() {

    }"
org.sunflow.system.RenderGlobalsPanel.main,"/**
* Auto-generated main method to display this JPanel inside a new JFrame.
*/
    public static void main(String[] args) {
        JFrame frame = new JFrame();
        frame.getContentPane().add(new RenderGlobalsPanel());
        frame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }"
org.sunflow.system.RenderGlobalsPanel.initGUI,"    private void initGUI() {
        try {
            setPreferredSize(new Dimension(400, 300));
            {
                generalPanel = new JPanel();
                FlowLayout generalPanelLayout = new FlowLayout();
                generalPanelLayout.setAlignment(FlowLayout.LEFT);
                generalPanel.setLayout(generalPanelLayout);
                this.addTab(""General"", null, generalPanel, null);
                {
                    resolutionPanel = new JPanel();
                    generalPanel.add(resolutionPanel);
                    FlowLayout resolutionPanelLayout = new FlowLayout();
                    resolutionPanel.setLayout(resolutionPanelLayout);
                    resolutionPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(BevelBorder.LOWERED), ""Resolution"", TitledBorder.LEADING, TitledBorder.TOP));
                    {
                        resolutionCheckBox = new JCheckBox();
                        resolutionPanel.add(resolutionCheckBox);
                        resolutionCheckBox.setText(""Override"");
                    }
                    {
                        jLabel1 = new JLabel();
                        resolutionPanel.add(jLabel1);
                        jLabel1.setText(""Image Width:"");
                    }
                    {
                        resolutionXTextField = new JTextField();
                        resolutionPanel.add(resolutionXTextField);
                        resolutionXTextField.setText(""640"");
                        resolutionXTextField.setPreferredSize(new java.awt.Dimension(50, 20));
                    }
                    {
                        jLabel2 = new JLabel();
                        resolutionPanel.add(jLabel2);
                        jLabel2.setText(""Image Height:"");
                    }
                    {
                        resolutionYTextField = new JTextField();
                        resolutionPanel.add(resolutionYTextField);
                        resolutionYTextField.setText(""480"");
                        resolutionYTextField.setPreferredSize(new java.awt.Dimension(50, 20));
                    }
                }
                {
                    threadsPanel = new JPanel();
                    generalPanel.add(threadsPanel);
                    threadsPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(BevelBorder.LOWERED), ""Threads"", TitledBorder.LEADING, TitledBorder.TOP));
                    {
                        threadCheckBox = new JCheckBox();
                        threadsPanel.add(threadCheckBox);
                        threadCheckBox.setText(""Use All Processors"");
                    }
                    {
                        jLabel3 = new JLabel();
                        threadsPanel.add(jLabel3);
                        jLabel3.setText(""Threads:"");
                    }
                    {
                        threadTextField = new JTextField();
                        threadsPanel.add(threadTextField);
                        threadTextField.setText(""1"");
                        threadTextField.setPreferredSize(new java.awt.Dimension(50, 20));
                    }
                }
            }
            {
                rendererPanel = new JPanel();
                FlowLayout rendererPanelLayout = new FlowLayout();
                rendererPanelLayout.setAlignment(FlowLayout.LEFT);
                rendererPanel.setLayout(rendererPanelLayout);
                this.addTab(""Renderer"", null, rendererPanel, null);
                {
                    defaultRendererRadioButton = new JRadioButton();
                    rendererPanel.add(defaultRendererRadioButton);
                    defaultRendererRadioButton.setText(""Default Renderer"");
                }
                {
                    bucketRendererPanel = new JPanel();
                    BoxLayout bucketRendererPanelLayout = new BoxLayout(bucketRendererPanel, javax.swing.BoxLayout.Y_AXIS);
                    bucketRendererPanel.setLayout(bucketRendererPanelLayout);
                    rendererPanel.add(bucketRendererPanel);
                    bucketRendererPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(BevelBorder.LOWERED), ""Bucket Renderer"", TitledBorder.LEADING, TitledBorder.TOP));
                    {
                        bucketRendererRadioButton = new JRadioButton();
                        bucketRendererPanel.add(bucketRendererRadioButton);
                        bucketRendererRadioButton.setText(""Enable"");
                    }
                    {
                        samplingPanel = new JPanel();
                        GridLayout samplingPanelLayout = new GridLayout(2, 2);
                        samplingPanelLayout.setColumns(2);
                        samplingPanelLayout.setHgap(5);
                        samplingPanelLayout.setVgap(5);
                        samplingPanelLayout.setRows(2);
                        samplingPanel.setLayout(samplingPanelLayout);
                        bucketRendererPanel.add(samplingPanel);
                        {
                            jLabel5 = new JLabel();
                            samplingPanel.add(jLabel5);
                            jLabel5.setText(""Min:"");
                        }
                        {
                            ComboBoxModel minSamplingComboBoxModel = new DefaultComboBoxModel(new String[] {
                                    ""Item One"", ""Item Two"" });
                            minSamplingComboBox = new JComboBox();
                            samplingPanel.add(minSamplingComboBox);
                            minSamplingComboBox.setModel(minSamplingComboBoxModel);
                        }
                        {
                            jLabel6 = new JLabel();
                            samplingPanel.add(jLabel6);
                            jLabel6.setText(""Max:"");
                        }
                        {
                            ComboBoxModel maxSamplingComboxBoxModel = new DefaultComboBoxModel(new String[] {
                                    ""Item One"", ""Item Two"" });
                            maxSamplingComboxBox = new JComboBox();
                            samplingPanel.add(maxSamplingComboxBox);
                            maxSamplingComboxBox.setModel(maxSamplingComboxBoxModel);
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
"
org.sunflow.system.SearchPath.resetSearchPath,"    public void resetSearchPath() {
        searchPath.clear();
    }"
org.sunflow.system.SearchPath.addSearchPath,"    public void addSearchPath(String path) {
        File f = new File(path);
        if (f.exists() && f.isDirectory()) {
            try {
                path = f.getCanonicalPath();
                for (String prefix : searchPath)
                    if (prefix.equals(path))
                        return;
                UI.printInfo(Module.SYS, ""Adding %s search path: \""%s\"""", type, path);
                searchPath.add(path);
            } catch (IOException e) {
                UI.printError(Module.SYS, ""Invalid %s search path specification: \""%s\"" - %s"", type, path, e.getMessage());
            }
        } else
            UI.printError(Module.SYS, ""Invalid %s search path specification: \""%s\"" - invalid directory"", type, path);
    }"
org.sunflow.system.SearchPath.resolvePath,"    public String resolvePath(String filename) {
        // account for relative naming schemes from 3rd party softwares
        if (filename.startsWith(""//""))
            filename = filename.substring(2);
        UI.printDetailed(Module.SYS, ""Resolving %s path \""%s\"" ..."", type, filename);
        File f = new File(filename);
        if (!f.isAbsolute()) {
            for (String prefix : searchPath) {
                UI.printDetailed(Module.SYS, ""  * searching: \""%s\"" ..."", prefix);
                if (prefix.endsWith(File.separator) || filename.startsWith(File.separator))
                    f = new File(prefix + filename);
                else
                    f = new File(prefix + File.separator + filename);
                if (f.exists()) {
                    // suggested path exists - try it
                    return f.getAbsolutePath();
                }
            }
        }
        // file was not found in the search paths - return the filename itself
        return filename;
    }
"
org.sunflow.system.ui.SilentInterface.print,"    public void print(Module m, PrintLevel level, String s) {
    }"
org.sunflow.system.ui.SilentInterface.taskStart,"    public void taskStart(String s, int min, int max) {
    }"
org.sunflow.system.ui.SilentInterface.taskUpdate,"    public void taskUpdate(int current) {
    }"
org.sunflow.system.ui.SilentInterface.taskStop,"    public void taskStop() {
    }
"
org.sunflow.system.ui.ConsoleInterface.print,"    public void print(Module m, PrintLevel level, String s) {
        System.err.println(UI.formatOutput(m, level, s));
    }"
org.sunflow.system.ui.ConsoleInterface.taskStart,"    public void taskStart(String s, int min, int max) {
        task = s;
        this.min = min;
        this.max = max;
        lastP = -1;
        invP = 100.0f / (max - min);
    }"
org.sunflow.system.ui.ConsoleInterface.taskUpdate,"    public void taskUpdate(int current) {
        int p = (min == max) ? 0 : (int) ((current - min) * invP);
        if (p != lastP)
            System.err.print(task + "" ["" + (lastP = p) + ""%]\r"");
    }"
org.sunflow.system.ui.ConsoleInterface.taskStop,"    public void taskStop() {
        System.err.print(""                                                                      \r"");
    }
"
