Method Signature,Method Body
org.prevayler.SureTransactionWithQuery.executeAndQuery,"/**
* The same as TransactionWithQuery.executeAndQuery(P, Date) except it does not throw Exception when executed.
*
* @see TransactionWithQuery#executeAndQuery(Object, Date)
*/
  public R executeAndQuery(P prevalentSystem, Date executionTime);

"
org.prevayler.TransactionWithQuery.executeAndQuery,"/**
* Performs the necessary modifications on the given prevalentSystem and also returns an object or throws an Exception.
* This method is called by Prevayler.execute(TransactionWithQuery&lt;P, R&gt;) to execute this TransactionWithQuery on the given Prevalent System. See org.prevayler.demos for usage examples.
*
* @param prevalentSystem The system on which this TransactionWithQuery will execute.
* @param executionTime   The time at which this TransactionWithQuery is being executed. Every Transaction executes completely within a single moment in time. Logically, a Prevalent System's time does not pass during the execution of a Transaction.
*/
  public R executeAndQuery(P prevalentSystem, Date executionTime) throws Exception;

"
org.prevayler.Prevayler.prevalentSystem,"/**
* Returns the object which holds direct or indirect references to all other Business Objects in the system.
*/
"
org.prevayler.Prevayler.clock,"/**
* Returns the Clock used to determine the execution time of all Transaction and Queries executed using this Prevayler. This Clock is useful only to Communication Objects and must NOT be used by Transactions, Queries or Business Objects, since that would make them become non-deterministic. Instead, Transactions, Queries and Business Objects must use the executionTime parameter which is passed on their execution.
*/
"
org.prevayler.Prevayler.execute,"/**
* Executes the given Transaction on the prevalentSystem(). ALL operations that alter the observable state of the prevalentSystem() must be implemented as Transaction or TransactionWithQuery objects and must be executed using the Prevayler.execute() methods. This method synchronizes on the prevalentSystem() to execute the Transaction. It is therefore guaranteed that only one Transaction is executed at a time. This means the prevalentSystem() does not have to worry about concurrency issues among Transactions.
* Implementations of this interface can log the given Transaction for crash or shutdown recovery, for example, or execute it remotely on replicas of the prevalentSystem() for fault-tolerance and load-balancing purposes.
*
* @see org.prevayler.PrevaylerFactory
*/
"
org.prevayler.Prevayler.execute,"/**
* Executes the given sensitiveQuery on the prevalentSystem(). A sensitiveQuery is a Query that would be affected by the concurrent execution of a Transaction or other sensitiveQuery. This method synchronizes on the prevalentSystem() to execute the sensitiveQuery. It is therefore guaranteed that no other Transaction or sensitiveQuery is executed at the same time.
* <br> Robust Queries (queries that do not affect other operations and that are not affected by them) can be executed directly as plain old method calls on the prevalentSystem() without the need of being implemented as Query objects. Examples of Robust Queries are queries that read the value of a single field or historical queries such as: ""What was this account's balance at mid-night?"".
*
* @return The result returned by the execution of the sensitiveQuery on the prevalentSystem().
* @throws Exception The Exception thrown by the execution of the sensitiveQuery on the prevalentSystem().
*/
"
org.prevayler.Prevayler.execute,"/**
* Executes the given transactionWithQuery on the prevalentSystem().
* Implementations of this interface can log the given transaction for crash or shutdown recovery, for example, or execute it remotely on replicas of the prevalentSystem() for fault-tolerance and load-balancing purposes.
*
* @return The result returned by the execution of the transactionWithQuery on the prevalentSystem().
* @throws Exception The Exception thrown by the execution of the sensitiveQuery on the prevalentSystem().
* @see org.prevayler.PrevaylerFactory
*/
"
org.prevayler.Prevayler.execute,"/**
* The same as execute(TransactionWithQuery&lt;P, R&gt;) except no Exception is thrown.
*
* @return The result returned by the execution of the sureTransactionWithQuery on the prevalentSystem().
*/
"
org.prevayler.Prevayler.takeSnapshot,"/**
* Produces a complete serialized image of the underlying PrevalentSystem.
* This will accelerate future system startups. Taking a snapshot once a day is enough for most applications.
* This method synchronizes on the prevalentSystem() in order to take the snapshot. This means that transaction execution will be blocked while the snapshot is taken.
*
* @return The file to which the snapshot was written. This file should be left where it is, so that Prevayler can read it during startup. You can copy it to another location for backup purposes if desired.
* @throws Exception if there is trouble writing to the snapshot file or serializing the prevalent system.
*/
"
org.prevayler.Prevayler.close,"/**
* Closes any files or other system resources opened by this Prevayler.
*
* @throws IOException if there is trouble closing a file or some other system resource.
*/
  public void close() throws IOException;

"
org.prevayler.Query.query,"/**
* @param prevalentSystem The Prevalent System to be queried.
* @param executionTime   The ""current"" time.
* @return The result of this Query.
* @throws Exception Any Exception encountered by this Query.
*/
  public R query(P prevalentSystem, Date executionTime) throws Exception;

"
org.prevayler.Clock.time,"/**
* Tells the time.
*
* @return A Date greater or equal to the one returned by the last call to this method. If the time is the same as the last call, the SAME Date object is returned rather than a new, equal one.
*/
  public java.util.Date time();

"
org.prevayler.Transaction.executeOn,"/**
* This method is called by Prevayler.execute(Transaction) to execute this Transaction on the given Prevalent System. See org.prevayler.demos for usage examples.
*
* @param prevalentSystem The system on which this Transaction will execute.
* @param executionTime   The time at which this Transaction is being executed. Every Transaction executes completely within a single moment in time. Logically, a Prevalent System's time does not pass during the execution of a Transaction.
*/
  public void executeOn(P prevalentSystem, Date executionTime);

"
org.prevayler.foundation.StopWatch.start,"  static public StopWatch start() {
    return new StopWatch();
  }"
org.prevayler.foundation.StopWatch.millisEllapsed,"  public long millisEllapsed() {
    return System.currentTimeMillis() - t0;
  }"
org.prevayler.foundation.StopWatch.secondsEllapsed,"  public double secondsEllapsed() {
    return millisEllapsed() / 1000.0;
  }"
org.prevayler.foundation.Chunking.validToken,"  private static boolean validToken(String token) {
    return TOKEN_PATTERN.matcher(token).matches();
  }"
org.prevayler.foundation.Chunking.writeChunk,"  public static void writeChunk(OutputStream stream, Chunk chunk) throws IOException {
    stream.write(Integer.toHexString(chunk.getBytes().length).toUpperCase().getBytes(ASCII));
    Iterator<Map.Entry<String, String>> iterator = chunk.getParameters().entrySet().iterator();
    while (iterator.hasNext()) {
      Map.Entry<String, String> entry = iterator.next();
      String name = entry.getKey();
      String value = entry.getValue();
      if (!validToken(name)) {
        throw new IOException(""Invalid parameter name '"" + name + ""'"");
      }
      if (!validToken(value)) {
        throw new IOException(""Invalid parameter value '"" + value + ""'"");
      }
      stream.write(';');
      stream.write(name.getBytes(ASCII));
      stream.write('=');
      stream.write(value.getBytes(ASCII));
    }
    stream.write(CRLF);
    stream.write(chunk.getBytes());
    stream.write(CRLF);
  }"
org.prevayler.foundation.Chunking.readChunk,"  public static Chunk readChunk(InputStream stream) throws IOException {
    String header = readLine(stream);

    if (header == null) {
      return null;
    }

    if (!HEADER_PATTERN.matcher(header).matches()) {
      throw new IOException(""Chunk header corrupted"");
    }

    StringTokenizer tokenizer = new StringTokenizer(header, "";=\r\n"");

    int size = Integer.parseInt(tokenizer.nextToken(), 16);

    Map<String, String> parameters = new LinkedHashMap<String, String>();
    while (tokenizer.hasMoreTokens()) {
      String name = tokenizer.nextToken();
      String value = tokenizer.nextToken();
      parameters.put(name, value);
    }

    byte[] bytes = new byte[size];
    int total = 0;
    while (total < size) {
      int read = stream.read(bytes, total, size - total);
      if (read == -1) {
        throw new EOFException(""Unexpected end of stream in chunk data"");
      }
      total += read;
    }

    int cr = stream.read();
    int lf = stream.read();
    if (cr == -1 || cr == '\r' && lf == -1) {
      throw new EOFException(""Unexpected end of stream in chunk trailer"");
    } else if (cr != '\r' || lf != '\n') {
      throw new IOException(""Chunk trailer corrupted"");
    }

    return new Chunk(bytes, parameters);
  }"
org.prevayler.foundation.Chunking.readLine,"  private static String readLine(InputStream stream) throws IOException {
    ByteArrayOutputStream header = new ByteArrayOutputStream();
    while (true) {
      int b = stream.read();
      if (b == -1) {
        if (header.size() == 0) {
          return null;
        } else {
          throw new EOFException(""Unexpected end of stream in chunk header"");
        }
      }
      header.write(b);
      if (b == '\n') {
        return header.toString(ASCII);
      }
    }
  }

"
org.prevayler.foundation.Turn.first,"/**
* The first turn through a pipeline, allowed to flow freely through all
* stages.
*/
  public static Turn first() {
    return new Turn(true);
  }"
org.prevayler.foundation.Turn.next,"/**
* The next turn through the pipeline, allowed to flow only as far as this
* turn has already gone.
*
* @throws IllegalStateException if this or any preceding turn has been aborted.
*/
  public synchronized Turn next() {
    if (_allowed < 0) {
      throw new IllegalStateException(""All transaction processing is now aborted, probably due to an earlier IOException."");
    }
    if (_next == null) {
      _next = new Turn(false);
    }
    return _next;
  }"
org.prevayler.foundation.Turn.start,"/**
* Start a stage in the pipeline. Will block until the preceding turn has
* ended the same stage.
*
* @throws IllegalStateException if this or any preceding turn has been aborted.
*/
  public synchronized void start() {
    while (_allowed == 0) {
      Cool.wait(this);
    }
    if (_allowed < 0) {
      throw new IllegalStateException(""All transaction processing is now aborted, probably due to an earlier IOException."");
    }
    _allowed--;
  }"
org.prevayler.foundation.Turn.end,"/**
* End a stage in the pipeline. Allows the next turn to start the same
* stage.
*/
  public void end() {
    next().allow();
  }"
org.prevayler.foundation.Turn.allow,"  private synchronized void allow() {
    _allowed++;
    notifyAll();
  }"
org.prevayler.foundation.Turn.abort,"/**
* Abort the pipeline. Prevents this or any following turn from continuing,
* but doesn't affect preceding turns already further along in the pipeline.
*
* @throws IllegalStateException always, with the given message and cause.
*/
  public void abort(String message, Throwable cause) {
    Turn turn = this;
    while (turn != null) {
      turn = turn.die();
    }
    throw new IllegalStateException(message, cause);
  }"
org.prevayler.foundation.Turn.die,"  private synchronized Turn die() {
    _allowed = Integer.MIN_VALUE;
    notifyAll();
    return _next;
  }

"
org.prevayler.foundation.Guided.startTurn,"  public void startTurn() {
    _turn.start();
  }"
org.prevayler.foundation.Guided.endTurn,"  public void endTurn() {
    _turn.end();
  }"
org.prevayler.foundation.Guided.abortTurn,"  public void abortTurn(String message, Throwable cause) {
    _turn.abort(message, cause);
  }"
org.prevayler.foundation.Guided.writeTo,"  public abstract void writeTo(OutputStream stream) throws IOException;

"
org.prevayler.foundation.DurableOutputStream.preallocate,"  private void preallocate() throws IOException {
    assert _fileChannel != null : ""_fileChannel is null"";

    long position = _fileChannel.position();
    long size = _fileChannel.size();
    int bufSize = _inactive.size();
    long need = bufSize - (size - position);
    if (need <= 0) {
      return;
    } else if (need < _preallocateLength) {
      need = _preallocateLength;
    }
    _fileChannel.write(ByteBuffer.allocate(1), size + need - 1);
    _fileChannel.force(true);
  }"
org.prevayler.foundation.DurableOutputStream.sync,"  public void sync(Guided guide) throws IOException {
    int thisWrite;

    // When a thread arrives here, all we care about at first is that it
    // gets properly sequenced according to its turn.

    guide.startTurn();
    try {
      thisWrite = writeObject(guide);
    } finally {
      guide.endTurn();
    }

    // Now, having ended the turn, the next thread is allowed to come in
    // and try to write its object before we get to the sync.

    waitUntilSynced(thisWrite);
  }"
org.prevayler.foundation.DurableOutputStream.writeObject,"  private int writeObject(Guided guide) throws IOException {
    synchronized (_writeLock) {
      if (_closed) {
        throw new IOException(""already closed"");
      }

      try {
        guide.writeTo(_active);
      } catch (IOException exception) {
        internalClose();
        throw exception;
      }

      _objectsWritten++;
      return _objectsWritten;
    }
  }"
org.prevayler.foundation.DurableOutputStream.waitUntilSynced,"  private void waitUntilSynced(int thisWrite) throws IOException {
    // Here's the real magic. If this thread is the first to have written
    // an object after a period of inactivity, and there are no other
    // threads coming in, then thisWrite is trivially one greater than
    // _objectsSynced, so this thread goes right ahead to sync its own
    // object alone. But then, if another thread comes along and writes
    // another object while this thread is syncing, it will write to the
    // _active buffer and then promply block on the _syncLock until this
    // thread finishes the sync. If threads continue to come in at just
    // about the rate that syncs can happen, each thread will wait for the
    // previous sync to complete and then initiate its own sync. The
    // latency for the first thread is exactly the time for one sync, which
    // is the minimum possible latency; the latency for any later thread is
    // somewhere between that minimum and a maximum of two syncs, with the
    // average being closer to the minimum end.
    //
    // Now, consider the steady state under heavy load. Some thread will
    // always be syncing the _inactive buffer to disk, so every thread that
    // arrives will write its object to the _active buffer and then wait
    // here on the _syncLock. If 10 threads arrive during a given sync
    // operation, then _active will hold 10 objects when that sync
    // completes. As soon as that earlier thread releases _syncLock, one of
    // those 10 new threads will acquire the lock and notice that its
    // object has not yet been synced; it will then swap the buffers and
    // flush and sync all 10 objects at once. Each of the 10 threads will
    // acquire _syncLock in turn and now see that their object has already
    // been synced and do nothing.

    synchronized (_syncLock) {
      if (_objectsSynced < thisWrite) {
        int objectsWritten;
        synchronized (_writeLock) {
          if (_closed) {
            throw new IOException(""already closed"");
          }

          ByteArrayOutputStream swap = _active;
          _active = _inactive;
          _inactive = swap;

          objectsWritten = _objectsWritten;
        }

        try {
          // preallocate more disk space if needed
          preallocate();

          // Resetting the buffer clears its contents but keeps the
          // allocated space. Therefore the buffers should quickly
          // reach a steady state of an appropriate size and then not
          // need to grow any more.

          _inactive.writeTo(_fileOutputStream);
          _inactive.reset();
          _fileOutputStream.flush();

          if (_journalDiskSync) {
            _fileChannel.force(false);
          }
        } catch (IOException exception) {
          internalClose();
          throw exception;
        }

        _objectsSynced = objectsWritten;
        _fileSyncCount++;
      }
    }
  }"
org.prevayler.foundation.DurableOutputStream.close,"  public void close() throws IOException {
    synchronized (_syncLock) {
      synchronized (_writeLock) {
        if (_closed) {
          return;
        }

        internalClose();
        // remove preallocated bytes from the journal
        if (_fileChannel != null && _fileChannel.isOpen())
          _fileChannel.truncate(_fileChannel.position());
        _fileOutputStream.close();
      }
    }
  }"
org.prevayler.foundation.DurableOutputStream.internalClose,"  private void internalClose() {
    synchronized (_writeLock) {
      _closed = true;
      _active = null;
      _inactive = null;
    }
  }"
org.prevayler.foundation.DurableOutputStream.file,"  public File file() {
    return _file;
  }"
org.prevayler.foundation.DurableOutputStream.fileSyncCount,"  public synchronized int fileSyncCount() {
    synchronized (_syncLock) {
      return _fileSyncCount;
    }
  }"
org.prevayler.foundation.DurableOutputStream.reallyClosed,"  public boolean reallyClosed() {
    synchronized (_writeLock) {
      return _closed;
    }
  }
"
org.prevayler.foundation.ObjectInputStreamWithClassLoader.resolveClass,"  protected Class<?> resolveClass(ObjectStreamClass v) throws IOException, ClassNotFoundException {
    if (_loader == null)
      return super.resolveClass(v);
    try {
      return Class.forName(v.getName(), false, _loader);
    } catch (ClassNotFoundException ex) {
      return super.resolveClass(v); // fall back for resolving primitive types
    }
  }
"
org.prevayler.foundation.Chunk.getBytes,"  public byte[] getBytes() {
    return _bytes;
  }"
org.prevayler.foundation.Chunk.setParameter,"  public void setParameter(String name, String value) {
    _parameters.put(name, value);
  }"
org.prevayler.foundation.Chunk.getParameter,"  public String getParameter(String name) {
    return _parameters.get(name);
  }"
org.prevayler.foundation.Chunk.getParameters,"  public Map<String, String> getParameters() {
    return _parameters;
  }

"
org.prevayler.foundation.FileManager.produceDirectory,"  public static File produceDirectory(String directoryPath) throws IOException {
    File directory = new File(directoryPath);
    produceDirectory(directory);
    return directory;
  }"
org.prevayler.foundation.FileManager.produceDirectory,"  public static void produceDirectory(File directory) throws IOException {
    if (!directory.exists() && !directory.mkdirs())
      throw new IOException(""Directory doesn't exist and could not be created: "" + directory);
    if (!directory.isDirectory()) throw new IOException(""Path exists but is not a directory: "" + directory);
  }

"
org.prevayler.foundation.DeepCopier.deepCopy,"/**
* Same as deepCopy(original, new JavaSerializer()).
*
* @throws ClassNotFoundException
* @throws IOException
*/
  public static Object deepCopy(Object original) {
    return deepCopy(original, new JavaSerializer());
  }"
org.prevayler.foundation.DeepCopier.deepCopy,"/**
* Produce a deep copy of the given object. Serializes the entire object to a byte array in memory. Recommended for
* relatively small objects, such as individual transactions.
*/
  public static Object deepCopy(Object original, Serializer serializer) {
    try {
      ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
      serializer.writeObject(byteOut, original);
      ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());
      return serializer.readObject(byteIn);
    } catch (Exception e) {
      Cool.unexpected(e);
      return null;
    }
  }"
org.prevayler.foundation.DeepCopier.deepCopyParallel,"/**
* Produce a deep copy of the given object. Serializes the object through a pipe between two threads. Recommended for
* very large objects, such as an entire prevalent system. The current thread is used for serializing the original
* object in order to respect any synchronization the caller may have around it, and a new thread is used for
* deserializing the copy.
*/
  public static <P> P deepCopyParallel(P original, Serializer serializer) throws Exception {
    PipedOutputStream outputStream = new PipedOutputStream();
    PipedInputStream inputStream = new PipedInputStream(outputStream);

    Receiver<P> receiver = new Receiver<P>(inputStream, serializer);

    try {
      serializer.writeObject(outputStream, original);
    } finally {
      outputStream.close();
    }

    return receiver.getResult();
  }"
org.prevayler.foundation.DeepCopier.run,"    public void run() {
      try {
        _result = (P) _serializer.readObject(_inputStream);
      } catch (Exception e) {
        _exception = e;
      } catch (Error e) {
        _error = e;
        throw e;
      }

      try {
        // Some serializers may write more than they actually need to deserialize the object, but if
        // we don't read it all the PipedOutputStream will choke.
        while (_inputStream.read() != -1) {
        }
      } catch (IOException e) {
        // The object has been successfully deserialized, so ignore problems at this point (for example,
        // the serializer may have explicitly closed the _inputStream itself, causing this read to fail).
      }
    }"
org.prevayler.foundation.DeepCopier.getResult,"    public P getResult() throws Exception {
      try {
        join();
      } catch (InterruptedException e) {
        throw new RuntimeException(""Unexpected InterruptedException"", e);
      }

      // join() guarantees that all shared memory is synchronized between the two threads

      if (_error != null) throw new RuntimeException(""Error during deserialization"", _error);
      if (_exception != null) throw _exception;
      if (_result == null) throw new RuntimeException(""Deep copy failed in an unknown way"");

      return _result;
    }

  "
org.prevayler.foundation.DurableInputStream.readChunk,"  public Chunk readChunk() throws IOException {
    if (_EOF) throw new EOFException();

    try {
      Chunk chunk = Chunking.readChunk(_fileStream);
      if (chunk != null) return chunk;
    } catch (EOFException eofx) {
      // Do nothing.
    } catch (ObjectStreamException scx) {
      ignoreStreamCorruption(scx);
    } catch (UTFDataFormatException utfx) {
      ignoreStreamCorruption(utfx);
    } catch (RuntimeException rx) {   //Some stream corruptions cause runtime exceptions in JDK1.3.1!
      ignoreStreamCorruption(rx);
    }

    _fileStream.close();
    _EOF = true;
    throw new EOFException();
  }"
org.prevayler.foundation.DurableInputStream.ignoreStreamCorruption,"  private void ignoreStreamCorruption(Exception ex) {
    String message = ""Stream corruption found while reading a transaction from the journal. If this is a transaction that was being written when a system crash occurred, there is no problem because it was never executed on the Prevalent System. Before executing each transaction, Prevayler writes it to the journal and calls the java.io.FileDescritor.sync() method to instruct the Java API to physically sync all operating system RAM buffers to disk."";
    _monitor.notify(this.getClass(), message, _file, ex);
  }"
org.prevayler.foundation.DurableInputStream.close,"  public void close() throws IOException {
    _fileStream.close();
    _EOF = true;
  }

"
org.prevayler.foundation.Cool.wait,"  public static void wait(Object object) {
    try {
      object.wait();
    } catch (InterruptedException e) {
      unexpected(e);
    }
  }"
org.prevayler.foundation.Cool.sleep,"  public static void sleep(long milliseconds) {
    try {
      Thread.sleep(milliseconds);
    } catch (InterruptedException e) {
      unexpected(e);
    }
  }"
org.prevayler.foundation.Cool.unexpected,"  public static void unexpected(Exception e) {
    throw new RuntimeException(""Unexpected Exception was thrown."", e);
  }"
org.prevayler.foundation.Cool.startDaemon,"  public static void startDaemon(Runnable runnable) {
    Thread daemon = new Thread(runnable);
    daemon.setDaemon(true);
    daemon.start();
  }

"
org.prevayler.foundation.monitor.NullMonitor.notify,"/**
* Does nothing.
*/
  public void notify(Class<?> clazz, String message, File file, Exception exception) {
  }"
org.prevayler.foundation.monitor.NullMonitor.notify,"/**
* Does nothing.
*/
  public void notify(Class<?> clazz, String message) {
  }"
org.prevayler.foundation.monitor.NullMonitor.notify,"/**
* Does nothing.
*/
  public void notify(Class<?> clazz, String message, Exception ex) {
  }"
org.prevayler.foundation.monitor.NullMonitor.notify,"/**
* Does nothing.
*/
  public void notify(Class<?> clazz, String message, File file) {
  }

"
org.prevayler.foundation.monitor.LoggingMonitor.notify,"  public void notify(Class<?> clazz, String message) {
    if (isInfoEnabled(clazz)) info(clazz, message);
  }"
org.prevayler.foundation.monitor.LoggingMonitor.notify,"  public void notify(Class<?> clazz, String message, Exception ex) {
    error(clazz, message, ex);
  }"
org.prevayler.foundation.monitor.LoggingMonitor.notify,"  public void notify(Class<?> clazz, String message, File file) {
    if (isInfoEnabled(clazz)) info(clazz, message + ""\nFile: "" + file);
  }"
org.prevayler.foundation.monitor.LoggingMonitor.notify,"  public void notify(Class<?> clazz, String message, File file, Exception ex) {
    error(clazz, message + ""\nFile: "" + file, ex);
  }"
org.prevayler.foundation.monitor.LoggingMonitor.info,
org.prevayler.foundation.monitor.LoggingMonitor.error,
org.prevayler.foundation.monitor.LoggingMonitor.isInfoEnabled,"/**
* default returns true. Override as needed.
*/
  protected boolean isInfoEnabled(Class<?> clazz) {
    return true;
  }
"
org.prevayler.foundation.monitor.Monitor.notify,"/**
* Something interesting happened.
*/
"
org.prevayler.foundation.monitor.Monitor.notify,"/**
* An interesting exception was thrown.
*/
"
org.prevayler.foundation.monitor.Monitor.notify,"/**
* Something interesting happened regarding access to a file.
*/
"
org.prevayler.foundation.monitor.Monitor.notify,"/**
* An exception was thrown while trying to access a file.
*/
  void notify(Class<?> clazz, String message, File file, Exception ex);

"
org.prevayler.foundation.monitor.SimpleMonitor.info,"  protected void info(Class<?> clazz, String message) {
    _stream.println(""\n"" + message);
  }"
org.prevayler.foundation.monitor.SimpleMonitor.error,"  protected void error(Class<?> clazz, String message, Exception ex) {
    _stream.println(""\n"" + message);
    ex.printStackTrace(_stream);
  }
"
org.prevayler.foundation.serialization.GZIPSerializer.writeObject,"  public void writeObject(OutputStream stream, Object object) throws Exception {
    GZIPOutputStream gzip = new GZIPOutputStream(stream, _bufferSize);
    _delegate.writeObject(gzip, object);
    gzip.close();
  }"
org.prevayler.foundation.serialization.GZIPSerializer.readObject,"  public Object readObject(InputStream stream) throws Exception {
    GZIPInputStream gunzip = new GZIPInputStream(stream, _bufferSize);
    return _delegate.readObject(gunzip);
  }

"
org.prevayler.foundation.serialization.DESSerializer.initialValue,"    protected Cipher initialValue() {
      try {
        return Cipher.getInstance(_triple ? ""DESede"" : ""DES"");
      } catch (GeneralSecurityException e) {
        throw new RuntimeException(e);
      }
    }
  "
org.prevayler.foundation.serialization.DESSerializer.writeObject,"  public void writeObject(OutputStream stream, Object object) throws Exception {
    Cipher cipher = getCipher();
    cipher.init(Cipher.ENCRYPT_MODE, _key);
    CipherOutputStream encrypt = new CipherOutputStream(stream, cipher);
    _delegate.writeObject(encrypt, object);
    encrypt.close();
  }"
org.prevayler.foundation.serialization.DESSerializer.readObject,"  public Object readObject(InputStream stream) throws Exception {
    Cipher cipher = getCipher();
    cipher.init(Cipher.DECRYPT_MODE, _key);
    CipherInputStream decrypt = new CipherInputStream(stream, cipher);
    return _delegate.readObject(decrypt);
  }"
org.prevayler.foundation.serialization.DESSerializer.getCipher,"  private Cipher getCipher() throws GeneralSecurityException {
    try {
      return _ciphers.get();
    } catch (RuntimeException e) {
      if (e.getCause() instanceof GeneralSecurityException) {
        throw (GeneralSecurityException) e.getCause();
      } else {
        throw e;
      }
    }
  }

"
org.prevayler.foundation.serialization.JavaSerializer.writeObject,"  public void writeObject(OutputStream stream, Object object) throws IOException {
    ObjectOutputStream objects = new ObjectOutputStream(stream);
    objects.writeObject(object);
    objects.close();
  }"
org.prevayler.foundation.serialization.JavaSerializer.readObject,"  public Object readObject(InputStream stream) throws IOException, ClassNotFoundException {
    ObjectInputStream objects = new ObjectInputStreamWithClassLoader(stream, _loader);
    Object object = objects.readObject();
    objects.close();
    return object;
  }

"
org.prevayler.foundation.serialization.Serializer.writeObject,"/**
* Write an object to a stream. An implementation must ensure that the object is written
* completely before returning. An implementation is free to flush or close the given stream
* as it sees fit, but is not required to do either. An implementation can expect that the
* stream is already buffered, so additional buffering is not required for performance.
*/
"
org.prevayler.foundation.serialization.Serializer.readObject,"/**
* Read an object from a stream. An implementation is free to close the given stream
* as it sees fit, but is not required to do so. An implementation can expect that the
* stream is already buffered, so additional buffering is not required for performance.
*/
  public Object readObject(InputStream stream) throws Exception;

"
org.prevayler.implementation.PrevaylerImpl.prevalentSystem,"  public P prevalentSystem() {
    return _guard.prevalentSystem();
  }"
org.prevayler.implementation.PrevaylerImpl.clock,"  public Clock clock() {
    return _clock;
  }"
org.prevayler.implementation.PrevaylerImpl.execute,"  public void execute(Transaction<? super P> transaction) {
    publish(new TransactionCapsule<P>(transaction, _journalSerializer, _transactionDeepCopyMode));    //TODO Optimization: The Censor can use the actual given transaction if it is Immutable instead of deserializing a new one from the byte array, even if ""_transactionDeepCopyMode"" is ""true""
  }"
org.prevayler.implementation.PrevaylerImpl.publish,"  private void publish(Capsule<? super P, ? extends TransactionBase> capsule) {
    _publisher.publish(capsule);
  }"
org.prevayler.implementation.PrevaylerImpl.execute,"  public <R> R execute(Query<? super P, R> sensitiveQuery) throws Exception {
    return _guard.executeQuery(sensitiveQuery, clock());
  }"
org.prevayler.implementation.PrevaylerImpl.execute,"  public <R> R execute(TransactionWithQuery<? super P, R> transactionWithQuery) throws Exception {
    TransactionWithQueryCapsule<? super P, R> capsule = new TransactionWithQueryCapsule<P, R>(transactionWithQuery, _journalSerializer, _transactionDeepCopyMode);
    publish(capsule);
    return capsule.result();
  }"
org.prevayler.implementation.PrevaylerImpl.execute,"  public <R> R execute(SureTransactionWithQuery<? super P, R> sureTransactionWithQuery) {
    try {
      return execute(sureTransactionWithQuery);
    } catch (RuntimeException runtime) {
      throw runtime;
    } catch (Exception checked) {
      throw new RuntimeException(""Unexpected Exception thrown."", checked);
    }
  }"
org.prevayler.implementation.PrevaylerImpl.takeSnapshot,"  public File takeSnapshot() throws Exception {
    return _guard.takeSnapshot(_snapshotManager);
  }"
org.prevayler.implementation.PrevaylerImpl.close,"  public void close() throws IOException {
    _publisher.close();
  }

"
org.prevayler.implementation.PrevalentSystemGuard.prevalentSystem,"  public P prevalentSystem() {
    synchronized (this) {
      if (_prevalentSystem == null) {
        throw new Error(""Prevayler is no longer allowing access to the prevalent system due to an Error thrown from an earlier transaction."");
      }
      return _prevalentSystem;
    }
  }"
org.prevayler.implementation.PrevalentSystemGuard.subscribeTo,"  public void subscribeTo(TransactionPublisher<P> publisher) throws IOException, ClassNotFoundException {
    long initialTransaction;
    synchronized (this) {
      _ignoreRuntimeExceptions = true;     //During pending transaction recovery (rolling forward), RuntimeExceptions are ignored because they were already thrown and handled during the first transaction execution.
      initialTransaction = _systemVersion + 1;
    }

    publisher.subscribe(this, initialTransaction);

    synchronized (this) {
      _ignoreRuntimeExceptions = false;
    }
  }"
org.prevayler.implementation.PrevalentSystemGuard.receive,"  public void receive(TransactionTimestamp<? super P> transactionTimestamp) {
    Capsule<? super P, ? extends TransactionBase> capsule = transactionTimestamp.capsule();
    long systemVersion = transactionTimestamp.systemVersion();
    Date executionTime = transactionTimestamp.executionTime();

    synchronized (this) {
      if (_prevalentSystem == null) {
        throw new Error(""Prevayler is no longer processing transactions due to an Error thrown from an earlier transaction."");
      }

      if (systemVersion != _systemVersion + 1) {
        throw new IllegalStateException(
            ""Attempted to apply transaction "" + systemVersion + "" when prevalent system was only at "" + _systemVersion);
      }

      _systemVersion = systemVersion;

      try {
        // Don't synchronize on _prevalentSystem here so that the capsule can deserialize a fresh
        // copy of the transaction without blocking queries.
        capsule.executeOn(_prevalentSystem, executionTime, _journalSerializer);
      } catch (RuntimeException rx) {
        if (!_ignoreRuntimeExceptions)
          throw rx;  //TODO Guarantee that transactions received from pending transaction recovery don't ever throw RuntimeExceptions. Maybe use a wrapper for that.
      } catch (Error error) {
        _prevalentSystem = null;
        throw error;
      } finally {
        notifyAll();
      }
    }
  }"
org.prevayler.implementation.PrevalentSystemGuard.executeQuery,"  public <R> R executeQuery(Query<? super P, R> sensitiveQuery, Clock clock) throws Exception {
    synchronized (this) {
      if (_prevalentSystem == null) {
        throw new Error(""Prevayler is no longer processing queries due to an Error thrown from an earlier transaction."");
      }

      synchronized (_prevalentSystem) {
        return sensitiveQuery.query(_prevalentSystem, clock.time());
      }
    }
  }"
org.prevayler.implementation.PrevalentSystemGuard.takeSnapshot,"  public File takeSnapshot(GenericSnapshotManager<P> snapshotManager) throws Exception {
    synchronized (this) {
      if (_prevalentSystem == null) {
        throw new Error(""Prevayler is no longer allowing snapshots due to an Error thrown from an earlier transaction."");
      }

      synchronized (_prevalentSystem) {
        return snapshotManager.writeSnapshot(_prevalentSystem, _systemVersion);
      }
    }
  }"
org.prevayler.implementation.PrevalentSystemGuard.deepCopy,"  public PrevalentSystemGuard<P> deepCopy(long systemVersion, Serializer snapshotSerializer) throws Exception {
    synchronized (this) {
      while (_systemVersion < systemVersion && _prevalentSystem != null) {
        Cool.wait(this);
      }

      if (_prevalentSystem == null) {
        throw new Error(""Prevayler is no longer accepting transactions due to an Error thrown from an earlier transaction."");
      }

      if (_systemVersion > systemVersion) {
        throw new IllegalStateException(""Already at "" + _systemVersion + ""; can't go back to "" + systemVersion);
      }

      synchronized (_prevalentSystem) {
        return new PrevalentSystemGuard<P>(DeepCopier.deepCopyParallel(_prevalentSystem, snapshotSerializer), _systemVersion, _journalSerializer);
      }
    }
  }

"
org.prevayler.implementation.TransactionGuide.timestamp,"  public TransactionTimestamp<P> timestamp() {
    return _transactionTimestamp;
  }"
org.prevayler.implementation.TransactionGuide.checkSystemVersion,"  public void checkSystemVersion(long expectedSystemVersion) {
    if (_transactionTimestamp.systemVersion() != expectedSystemVersion) {
      throw new IllegalStateException(""Attempted to process "" + _transactionTimestamp.systemVersion() + "" when ready for "" + expectedSystemVersion);
    }
  }"
org.prevayler.implementation.TransactionGuide.executionTime,"  public Date executionTime() {
    return _transactionTimestamp.executionTime();
  }"
org.prevayler.implementation.TransactionGuide.writeTo,"  public void writeTo(OutputStream stream) throws IOException {
    Chunking.writeChunk(stream, _transactionTimestamp.toChunk());
  }

"
org.prevayler.implementation.TransactionCapsule.justExecute,"  protected void justExecute(Transaction<? super P> transaction, P prevalentSystem, Date executionTime) {
    transaction.executeOn(prevalentSystem, executionTime);
  }"
org.prevayler.implementation.TransactionCapsule.cleanCopy,"  public Capsule<P, Transaction<? super P>> cleanCopy() {
    // TransactionCapsule, unlike TransactionWithQueryCapsule, is completely immutable.
    return this;
  }

"
org.prevayler.implementation.Capsule.serialized,"/**
* Gets the serialized representation of the transaction. Callers must not modify the returned array.
*/
  public byte[] serialized() {
    return _serialized;
  }"
org.prevayler.implementation.Capsule.deserialize,"  public T deserialize(Serializer journalSerializer) {
    try {
      return (T) journalSerializer.readObject(new ByteArrayInputStream(_serialized));
    } catch (Exception exception) {
      throw new Error(""Unable to deserialize transaction"", exception);
    }
  }"
org.prevayler.implementation.Capsule.executeOn,"/**
* Executes a freshly deserialized copy of the transaction by default. If <code>configureTransactionDeepCopy</code> was set to <code>true</code> on your <code>PrevaylerFactory</code>, this will execute the transaction directly. The execution will synchronize on the prevalentSystem.
*/
  public void executeOn(P prevalentSystem, Date executionTime, Serializer journalSerializer) {
    T transaction;
    if (_directTransaction != null) {
      transaction = _directTransaction;
    } else {
      transaction = deserialize(journalSerializer);
    }

    synchronized (prevalentSystem) {
      justExecute(transaction, prevalentSystem, executionTime);
    }
  }"
org.prevayler.implementation.Capsule.justExecute,"/**
* Actually executes the Transaction or TransactionWithQuery. The caller
* is responsible for synchronizing on the prevalentSystem.
*/
"
org.prevayler.implementation.Capsule.cleanCopy,"/**
* Makes a clean copy of this capsule that will have its own query result fields.
*/
"
org.prevayler.implementation.Capsule.toChunk,"  Chunk toChunk() {
    Chunk chunk = new Chunk(_serialized);
    chunk.setParameter(""withQuery"", String.valueOf(this instanceof TransactionWithQueryCapsule));
    return chunk;
  }"
org.prevayler.implementation.Capsule.fromChunk,"  static <P> Capsule<P, ? extends TransactionBase> fromChunk(Chunk chunk) {
    boolean withQuery = Boolean.valueOf(chunk.getParameter(""withQuery"")).booleanValue();
    if (withQuery) {
      return new TransactionWithQueryCapsule<P, Object>(chunk.getBytes());
    } else {
      return new TransactionCapsule<P>(chunk.getBytes());
    }
  }

"
org.prevayler.implementation.PrevaylerDirectory.produceDirectory,"/**
* Ensure that the directory exists, creating it and parent directories if necessary.
*
* @throws IOException if the directory can't be created or isn't a directory.
*/
  public void produceDirectory() throws IOException {
    FileManager.produceDirectory(_directory);
  }"
org.prevayler.implementation.PrevaylerDirectory.checkValidSnapshotSuffix,"/**
* Ensure that the given suffix (which should not include a dot) is valid for snapshots.
* <p/>
* Snapshot suffixes must match the pattern /[a-zA-Z0-9]*[Ss]napshot/.
*
* @throws IllegalArgumentException otherwise.
*/
  public static void checkValidSnapshotSuffix(String suffix) {
    if (!suffix.matches(SNAPSHOT_SUFFIX_PATTERN)) {
      throw new IllegalArgumentException(
          ""Snapshot filename suffix must match /"" + SNAPSHOT_SUFFIX_PATTERN + ""/, but '"" + suffix + ""' does not"");
    }
  }"
org.prevayler.implementation.PrevaylerDirectory.checkValidJournalSuffix,"/**
* Ensure that the given suffix (which should not include a dot) is valid for journals.
* <p/>
* Journal suffixes must match the pattern /[a-zA-Z0-9]*[Jj]ournal/.
*
* @throws IllegalArgumentException otherwise.
*/
  public static void checkValidJournalSuffix(String suffix) {
    if (!suffix.matches(JOURNAL_SUFFIX_PATTERN)) {
      throw new IllegalArgumentException(
          ""Journal filename suffix must match /"" + JOURNAL_SUFFIX_PATTERN + ""/, but '"" + suffix + ""' does not"");
    }
  }"
org.prevayler.implementation.PrevaylerDirectory.snapshotFile,"/**
* Generate a valid snapshot filename.
*
* @throws IllegalArgumentException if the version is negative or the suffix is invalid.
*/
  public File snapshotFile(long version, String suffix) {
    checkValidSnapshotSuffix(suffix);
    return file(version, suffix);
  }"
org.prevayler.implementation.PrevaylerDirectory.journalFile,"/**
* Generate a valid journal filename.
*
* @throws IllegalArgumentException if the version is negative or the suffix is invalid.
*/
  public File journalFile(long transaction, String suffix) {
    checkValidJournalSuffix(suffix);
    return file(transaction, suffix);
  }"
org.prevayler.implementation.PrevaylerDirectory.file,"  private File file(long version, String suffix) {
    if (version < 0) {
      throw new IllegalArgumentException(""Snapshot and journal version numbers must be non-negative: "" + version);
    }
    String fileName = ""0000000000000000000"" + version;
    return new File(_directory, fileName.substring(fileName.length() - DIGITS_IN_FILENAME) + ""."" + suffix);
  }"
org.prevayler.implementation.PrevaylerDirectory.snapshotVersion,"/**
* Extract the version number from a snapshot filename.
* <p/>
* Returns -1 if file does not have a valid snapshot filename.
*/
  public static long snapshotVersion(File file) {
    return version(file, SNAPSHOT_FILENAME_PATTERN);
  }"
org.prevayler.implementation.PrevaylerDirectory.journalVersion,"/**
* Extract the version number from a journal filename.
* <p/>
* Returns -1 if file does not have a valid journal filename.
*/
  public static long journalVersion(File file) {
    return version(file, JOURNAL_FILENAME_PATTERN);
  }"
org.prevayler.implementation.PrevaylerDirectory.version,"  private static long version(File file, String filenamePattern) {
    String fileName = file.getName();
    if (!fileName.matches(filenamePattern)) return -1;
    return Long.parseLong(fileName.substring(0, fileName.indexOf(""."")));
  }"
org.prevayler.implementation.PrevaylerDirectory.latestSnapshot,"/**
* Find the latest snapshot file.
* <p/>
* Returns null if no snapshot file was found.
*/
  public File latestSnapshot() throws IOException {
    File[] files = _directory.listFiles();
    if (files == null) throw new IOException(""Error reading file list from directory "" + _directory);

    File latestSnapshot = null;
    long latestVersion = -1;
    for (int i = 0; i < files.length; i++) {
      File candidateSnapshot = files[i];
      long candidateVersion = snapshotVersion(candidateSnapshot);
      if (candidateVersion > latestVersion) {
        latestVersion = candidateVersion;
        latestSnapshot = candidateSnapshot;
      }
    }
    return latestSnapshot;
  }"
org.prevayler.implementation.PrevaylerDirectory.findInitialJournalFile,"/**
* Find the journal file containing the desired transaction.
* <p/>
* Returns null if no appropriate journal file was found.
*/
  public File findInitialJournalFile(long initialTransactionWanted) {
    File[] journals = _directory.listFiles(new FileFilter() {
      public boolean accept(File pathname) {
        return pathname.getName().matches(JOURNAL_FILENAME_PATTERN);
      }
    });

    Arrays.sort(journals, new Comparator<File>() {
      public int compare(File f1, File f2) {
        return Long.valueOf(journalVersion(f1)).compareTo(Long.valueOf(journalVersion(f2)));
      }
    });

    for (int i = journals.length - 1; i >= 0; i--) {
      File journal = journals[i];
      long version = journalVersion(journal);
      if (version <= initialTransactionWanted) {
        return journal;
      }
    }

    return null;
  }"
org.prevayler.implementation.PrevaylerDirectory.accept,"      public boolean accept(File pathname) {
        return pathname.getName().matches(JOURNAL_FILENAME_PATTERN);
      }
    "
org.prevayler.implementation.PrevaylerDirectory.compare,"      public int compare(File f1, File f2) {
        return Long.valueOf(journalVersion(f1)).compareTo(Long.valueOf(journalVersion(f2)));
      }
    "
org.prevayler.implementation.PrevaylerDirectory.createTempFile,"/**
* Create a temporary file in the directory.
*/
  public File createTempFile(String prefix, String suffix) throws IOException {
    return File.createTempFile(prefix, suffix, _directory);
  }"
org.prevayler.implementation.PrevaylerDirectory.renameUnusedFile,"/**
* Rename a journal file to indicate it was found empty and is being ignored.
*/
  public static void renameUnusedFile(File journalFile) {
    journalFile.renameTo(new File(journalFile.getAbsolutePath() + "".unusedFile"" + System.currentTimeMillis()));
  }"
org.prevayler.implementation.PrevaylerDirectory.necessaryFiles,"/**
* Determine which snapshot and journal files are still necessary for recovery.
* <p/>
* Necessary files include the latest snapshot file and any journal files
* potentially containing transactions after that snapshot version.
*/
  public Set<File> necessaryFiles() throws IOException {
    File[] allFiles = _directory.listFiles();
    if (allFiles == null) {
      throw new IOException(""Error reading file list from directory "" + _directory);
    }
    File latestSnapshot = latestSnapshot();
    long systemVersion = latestSnapshot == null ? 0 : snapshotVersion(latestSnapshot);
    File initialJournal = findInitialJournalFile(systemVersion + 1);
    Set<File> neededFiles = new TreeSet<File>();
    if (latestSnapshot != null) {
      neededFiles.add(latestSnapshot);
    }
    if (initialJournal != null) {
      neededFiles.add(initialJournal);
      long initialJournalVersion = journalVersion(initialJournal);
      for (int i = 0; i < allFiles.length; i++) {
        File file = allFiles[i];
        if (journalVersion(file) > initialJournalVersion) {
          neededFiles.add(file);
        }
      }
    }
    return neededFiles;
  }
"
org.prevayler.implementation.TransactionWithQueryCapsule.justExecute,"  protected void justExecute(TransactionWithQuery<? super P, R> transaction, P prevalentSystem, Date executionTime) {
    try {
      _queryResult = transaction.executeAndQuery(prevalentSystem, executionTime);
    } catch (RuntimeException rx) {
      _queryException = rx;
      throw rx;   //This is necessary because of the rollback feature.
    } catch (Exception ex) {
      _queryException = ex;
    }
  }"
org.prevayler.implementation.TransactionWithQueryCapsule.result,"  public R result() throws Exception {
    if (_queryException != null) throw _queryException;
    return _queryResult;
  }"
org.prevayler.implementation.TransactionWithQueryCapsule.cleanCopy,"  public Capsule<P, TransactionWithQuery<? super P, R>> cleanCopy() {
    return new TransactionWithQueryCapsule<P, R>(serialized());
  }

"
org.prevayler.implementation.TransactionTimestamp.capsule,"  public Capsule<? super P, ? extends TransactionBase> capsule() {
    return _capsule;
  }"
org.prevayler.implementation.TransactionTimestamp.systemVersion,"  public long systemVersion() {
    return _systemVersion;
  }"
org.prevayler.implementation.TransactionTimestamp.executionTime,"  public Date executionTime() {
    return new Date(_executionTime);
  }"
org.prevayler.implementation.TransactionTimestamp.cleanCopy,"  public TransactionTimestamp<P> cleanCopy() {
    return new TransactionTimestamp<P>(_capsule.cleanCopy(), _systemVersion, _executionTime);
  }"
org.prevayler.implementation.TransactionTimestamp.toChunk,"  public Chunk toChunk() {
    Chunk chunk = _capsule.toChunk();
    chunk.setParameter(""systemVersion"", String.valueOf(_systemVersion));
    chunk.setParameter(""executionTime"", String.valueOf(_executionTime));
    return chunk;
  }"
org.prevayler.implementation.TransactionTimestamp.fromChunk,"  public static <P> TransactionTimestamp<P> fromChunk(Chunk chunk) {
    Capsule<P, ? extends TransactionBase> capsule = Capsule.fromChunk(chunk);
    long systemVersion = Long.parseLong(chunk.getParameter(""systemVersion""));
    long executionTime = Long.parseLong(chunk.getParameter(""executionTime""));
    return new TransactionTimestamp<P>(capsule, systemVersion, executionTime);
  }

"
org.prevayler.implementation.journal.TransientJournal.append,"  public void append(TransactionGuide<? super P> guide) {
    if (!_initialTransactionInitialized)
      throw new IllegalStateException(""Journal.update() has to be called at least once before Journal.journal()."");

    guide.startTurn();
    try {
      guide.checkSystemVersion(_initialTransaction + journal.size());
      journal.add(guide.timestamp().cleanCopy());
    } finally {
      guide.endTurn();
    }
  }"
org.prevayler.implementation.journal.TransientJournal.update,"  public synchronized void update(TransactionSubscriber<P> subscriber, long initialTransaction) throws IOException {
    if (!_initialTransactionInitialized) {
      _initialTransactionInitialized = true;
      _initialTransaction = initialTransaction;
      return;
    }
    if (initialTransaction < _initialTransaction)
      throw new IOException(""Unable to recover transaction "" + initialTransaction + "". The oldest recoverable transaction is "" + _initialTransaction + ""."");

    int i = (int) (initialTransaction - _initialTransaction);
    if (i > journal.size())
      throw new IOException(""The transaction journal has not yet reached transaction "" + initialTransaction + "". The last logged transaction was "" + (_initialTransaction + journal.size() - 1) + ""."");

    while (i != journal.size()) {
      TransactionTimestamp<? super P> entry = journal.get(i);
      long recoveringTransaction = _initialTransaction + i;
      if (entry.systemVersion() != recoveringTransaction) {
        throw new IOException(""Expected "" + recoveringTransaction + "" but was "" + entry.systemVersion());
      }
      subscriber.receive(entry);
      i++;
    }
  }"
org.prevayler.implementation.journal.TransientJournal.close,"  public void close() {
  }"
org.prevayler.implementation.journal.TransientJournal.nextTransaction,"  public synchronized long nextTransaction() {
    if (!_initialTransactionInitialized) throw new IllegalStateException(""update() must be called at least once"");
    return _initialTransaction + journal.size();
  }

"
org.prevayler.implementation.journal.Journal.append,
org.prevayler.implementation.journal.Journal.update,
org.prevayler.implementation.journal.Journal.close,
org.prevayler.implementation.journal.Journal.nextTransaction,"  public long nextTransaction();

"
org.prevayler.implementation.journal.PersistentJournal.append,"  public void append(TransactionGuide<? super P> guide) {
    if (!_nextTransactionInitialized)
      throw new IllegalStateException(""Journal.update() has to be called at least once before Journal.append()."");

    DurableOutputStream myOutputJournal;
    DurableOutputStream outputJournalToClose = null;

    guide.startTurn();
    try {
      guide.checkSystemVersion(_nextTransaction);

      if (!isOutputJournalStillValid()) {
        outputJournalToClose = _outputJournal;
        _outputJournal = createOutputJournal(_nextTransaction, guide);
        _journalAgeTimer = StopWatch.start();
      }

      _nextTransaction++;

      myOutputJournal = _outputJournal;
    } finally {
      guide.endTurn();
    }

    try {
      myOutputJournal.sync(guide);
    } catch (Exception exception) {
      abort(exception, _outputJournal.file(), ""writing to"", guide);
    }

    guide.startTurn();
    try {
      try {
        if (outputJournalToClose != null) outputJournalToClose.close();
      } catch (Exception exception) {
        abort(exception, outputJournalToClose.file(), ""closing"", guide);
      }
    } finally {
      guide.endTurn();
    }
  }"
org.prevayler.implementation.journal.PersistentJournal.isOutputJournalStillValid,"  private boolean isOutputJournalStillValid() {
    return _outputJournal != null
        && !isOutputJournalTooBig()
        && !isOutputJournalTooOld();
  }"
org.prevayler.implementation.journal.PersistentJournal.isOutputJournalTooOld,"  private boolean isOutputJournalTooOld() {
    return _journalAgeThresholdInMillis != 0
        && _journalAgeTimer.millisEllapsed() >= _journalAgeThresholdInMillis;
  }"
org.prevayler.implementation.journal.PersistentJournal.isOutputJournalTooBig,"  private boolean isOutputJournalTooBig() {
    return _journalSizeThresholdInBytes != 0
        && _outputJournal.file().length() >= _journalSizeThresholdInBytes;
  }"
org.prevayler.implementation.journal.PersistentJournal.createOutputJournal,"  private DurableOutputStream createOutputJournal(long transactionNumber, Guided guide) {
    File file = _directory.journalFile(transactionNumber, _journalSuffix);
    try {
      return new DurableOutputStream(file, _journalDiskSync, _journalSizeThresholdInBytes);
    } catch (Exception exception) {
      abort(exception, file, ""creating"", guide);
      return null;
    }
  }"
org.prevayler.implementation.journal.PersistentJournal.update,"/**
* IMPORTANT: This method cannot be called while the log() method is being called in another thread.
* If there are no journal files in the directory (when a snapshot is taken and all journal files are manually deleted, for example), the initialTransaction parameter in the first call to this method will define what the next transaction number will be. We have to find clearer/simpler semantics.
*/
  public void update(TransactionSubscriber<P> subscriber, long initialTransactionWanted) throws IOException, ClassNotFoundException {
    File initialJournal = _directory.findInitialJournalFile(initialTransactionWanted);

    if (initialJournal == null) {
      initializeNextTransaction(initialTransactionWanted, 1);
      return;
    }

    long nextTransaction = recoverPendingTransactions(subscriber, initialTransactionWanted, initialJournal);

    initializeNextTransaction(initialTransactionWanted, nextTransaction);
  }"
org.prevayler.implementation.journal.PersistentJournal.initializeNextTransaction,"  private void initializeNextTransaction(long initialTransactionWanted, long nextTransaction) throws IOException {
    if (_nextTransactionInitialized) {
      if (_nextTransaction < initialTransactionWanted)
        throw new IOException(""The transaction log has not yet reached transaction "" + initialTransactionWanted + "". The last logged transaction was "" + (_nextTransaction - 1) + ""."");
      if (nextTransaction < _nextTransaction)
        throw new IOException(""Unable to find journal file containing transaction "" + nextTransaction + "". Might have been manually deleted."");
      if (nextTransaction > _nextTransaction) throw new IllegalStateException();
      return;
    }
    _nextTransactionInitialized = true;
    _nextTransaction = initialTransactionWanted > nextTransaction
        ? initialTransactionWanted
        : nextTransaction;
  }"
org.prevayler.implementation.journal.PersistentJournal.recoverPendingTransactions,"  private long recoverPendingTransactions(TransactionSubscriber<P> subscriber, long initialTransaction, File initialJournal) throws IOException {
    long recoveringTransaction = PrevaylerDirectory.journalVersion(initialJournal);
    File journal = initialJournal;
    DurableInputStream input = new DurableInputStream(journal, _monitor);

    while (true) {
      try {
        Chunk chunk = input.readChunk();

        if (recoveringTransaction >= initialTransaction) {
          if (!journal.getName().endsWith(_journalSuffix)) {
            throw new IOException(""There are transactions needing to be recovered from "" +
                journal + "", but only "" + _journalSuffix + "" files are supported"");
          }

          TransactionTimestamp<P> entry = TransactionTimestamp.fromChunk(chunk);

          if (entry.systemVersion() != recoveringTransaction) {
            throw new IOException(""Expected "" + recoveringTransaction + "" but was "" + entry.systemVersion());
          }

          subscriber.receive(entry);
        }

        recoveringTransaction++;

      } catch (EOFException eof) {
        File nextFile = _directory.journalFile(recoveringTransaction, _journalSuffix);
        if (journal.equals(nextFile))
          PrevaylerDirectory.renameUnusedFile(journal);  //The first transaction in this log file is incomplete. We need to reuse this file name.
        journal = nextFile;
        if (!journal.exists()) break;
        input = new DurableInputStream(journal, _monitor);
      }
    }
    return recoveringTransaction;
  }"
org.prevayler.implementation.journal.PersistentJournal.abort,"  private void abort(Exception exception, File journal, String action, Guided guide) {
    guide.abortTurn(""All transaction processing is now aborted. An IOException was thrown while "" + action + "" a .journal file."", exception);
  }"
org.prevayler.implementation.journal.PersistentJournal.close,"  public void close() throws IOException {
    if (_outputJournal != null) _outputJournal.close();
  }"
org.prevayler.implementation.journal.PersistentJournal.nextTransaction,"  public long nextTransaction() {
    if (!_nextTransactionInitialized) throw new IllegalStateException(""update() must be called at least once"");
    return _nextTransaction;
  }

"
org.prevayler.implementation.publishing.TransactionSubscriber.receive,"  public void receive(TransactionTimestamp<? super P> transactionTimestamp);

"
org.prevayler.implementation.publishing.TransactionPublisher.subscribe,"/**
* Updates the given subscriber with all transactions published since initialTransaction, returns and continues publishing all future transactions to him.
*/
"
org.prevayler.implementation.publishing.TransactionPublisher.cancelSubscription,"/**
* Stops publishing future transactions to the given subscriber.
*/
"
org.prevayler.implementation.publishing.TransactionPublisher.publish,"/**
* Publishes transaction to the subscribers synchronously. This method will only return after all subscribers have received transaction. Note that no guarantee can be made as to wether the subscribers have actually executed it.
*/
"
org.prevayler.implementation.publishing.TransactionPublisher.clock,"/**
* Returns a Clock which is consistent with the Transaction publishing time.
*/
"
org.prevayler.implementation.publishing.TransactionPublisher.close,"/**
* Closes any files or other system resources opened by this TransactionPublisher.
*/
  public void close() throws IOException;

"
org.prevayler.implementation.publishing.CentralPublisher.publish,"  public void publish(Capsule<? super P, ? extends TransactionBase> capsule) {
    synchronized (_pendingPublicationsMonitor) {  //Blocks all new subscriptions until the publication is over.
      if (_pendingPublications == 0) _clock.pause();
      _pendingPublications++;
    }

    try {
      publishWithoutWorryingAboutNewSubscriptions(capsule);  // Suggestions for a better method name are welcome.  :)
    } finally {
      synchronized (_pendingPublicationsMonitor) {
        _pendingPublications--;
        if (_pendingPublications == 0) {
          _clock.resume();
          _pendingPublicationsMonitor.notifyAll();
        }
      }
    }
  }"
org.prevayler.implementation.publishing.CentralPublisher.publishWithoutWorryingAboutNewSubscriptions,"  private void publishWithoutWorryingAboutNewSubscriptions(Capsule<? super P, ? extends TransactionBase> capsule) {
    TransactionGuide<? super P> guide = guideFor(capsule);
    _journal.append(guide);
    notifySubscribers(guide);
  }"
org.prevayler.implementation.publishing.CentralPublisher.guideFor,"  private TransactionGuide<? super P> guideFor(Capsule<? super P, ? extends TransactionBase> capsule) {
    synchronized (_nextTurnMonitor) {
      TransactionTimestamp<P> timestamp = new TransactionTimestamp<P>(capsule, _nextTransaction, _clock.realTime());

      // Count this transaction
      Turn turn = _nextTurn;
      _nextTurn = _nextTurn.next();
      _nextTransaction++;

      return new TransactionGuide<P>(timestamp, turn);
    }
  }"
org.prevayler.implementation.publishing.CentralPublisher.notifySubscribers,"  private void notifySubscribers(TransactionGuide<? super P> guide) {
    guide.startTurn();
    try {
      _clock.advanceTo(guide.executionTime());
      notifySubscribers(guide.timestamp());
    } finally {
      guide.endTurn();
    }
  }"
org.prevayler.implementation.publishing.CentralPublisher.subscribe,"  public void subscribe(TransactionSubscriber<P> subscriber, long initialTransaction) throws IOException, ClassNotFoundException {
    synchronized (_pendingPublicationsMonitor) {
      while (_pendingPublications != 0) Cool.wait(_pendingPublicationsMonitor);

      _journal.update(subscriber, initialTransaction);

      synchronized (_nextTurnMonitor) {
        _nextTransaction = _journal.nextTransaction();
      }

      super.addSubscriber(subscriber);
    }
  }"
org.prevayler.implementation.publishing.CentralPublisher.close,"  public void close() throws IOException {
    _journal.close();
  }

"
org.prevayler.implementation.publishing.AbstractPublisher.clock,"  public Clock clock() {
    return _clock;
  }"
org.prevayler.implementation.publishing.AbstractPublisher.addSubscriber,"  public synchronized void addSubscriber(TransactionSubscriber<P> subscriber) {
    _subscribers.add(subscriber);
  }"
org.prevayler.implementation.publishing.AbstractPublisher.cancelSubscription,"  public synchronized void cancelSubscription(TransactionSubscriber<P> subscriber) {
    _subscribers.remove(subscriber);
  }"
org.prevayler.implementation.publishing.AbstractPublisher.notifySubscribers,"  protected synchronized void notifySubscribers(TransactionTimestamp<? super P> transactionTimestamp) {
    Iterator<TransactionSubscriber<P>> i = _subscribers.iterator();
    while (i.hasNext()) i.next().receive(transactionTimestamp);
  }

"
org.prevayler.implementation.publishing.POBox.receive,"  public synchronized void receive(TransactionTimestamp<? super P> transactionTimestamp) {
    _queue.add(transactionTimestamp);
    notify();
  }"
org.prevayler.implementation.publishing.POBox.run,"  public void run() {
    while (true) {
      TransactionTimestamp<? super P> notification = waitForNotification();
      _delegate.receive(notification);
    }
  }"
org.prevayler.implementation.publishing.POBox.waitForNotification,"  private synchronized TransactionTimestamp<? super P> waitForNotification() {
    while (_queue.size() == 0) {
      synchronized (_emptynessMonitor) {
        _emptynessMonitor.notify();
      }
      Cool.wait(this);
    }
    return _queue.removeFirst();
  }"
org.prevayler.implementation.publishing.POBox.waitToEmpty,"  public void waitToEmpty() {
    synchronized (_emptynessMonitor) {
      while (_queue.size() != 0) Cool.wait(_emptynessMonitor);
    }
  }


"
org.prevayler.implementation.snapshot.NullSnapshotManager.writeSnapshot,"  public File writeSnapshot(P prevalentSystem, long version) throws IOException {
    throw new IOException(_snapshotAttemptErrorMessage);
  }

"
org.prevayler.implementation.snapshot.GenericSnapshotManager.primarySerializer,"  public Serializer primarySerializer() {
    return _strategies.get(_primarySuffix);
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManager.recoveredPrevalentSystem,"  public PrevalentSystemGuard<P> recoveredPrevalentSystem() {
    return _recoveredPrevalentSystem;
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManager.writeSnapshot,"  public File writeSnapshot(P prevalentSystem, long version) throws Exception {
    File tempFile = _directory.createTempFile(""snapshot"" + version + ""temp"", ""generatingSnapshot"");

    writeSnapshot(prevalentSystem, tempFile);

    File permanent = snapshotFile(version);
    permanent.delete();
    if (!tempFile.renameTo(permanent)) throw new IOException(
        ""Temporary snapshot file generated: "" + tempFile + ""\nUnable to rename it permanently to: "" + permanent);

    return permanent;
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManager.writeSnapshot,"  private void writeSnapshot(P prevalentSystem, File snapshotFile) throws Exception {
    OutputStream out = new FileOutputStream(snapshotFile);
    try {
      primarySerializer().writeObject(out, prevalentSystem);
    } finally {
      out.close();
    }
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManager.snapshotFile,"  private File snapshotFile(long version) {
    return _directory.snapshotFile(version, _primarySuffix);
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManager.readSnapshot,"  private P readSnapshot(File snapshotFile) throws Exception {
    String suffix = snapshotFile.getName().substring(snapshotFile.getName().indexOf('.') + 1);
    if (!_strategies.containsKey(suffix)) throw new IOException(
        snapshotFile.toString() + "" cannot be read; only "" + _strategies.keySet().toString() + "" supported"");

    Serializer serializer = _strategies.get(suffix);
    FileInputStream in = new FileInputStream(snapshotFile);
    try {
      return (P) serializer.readObject(in);
    } finally {
      in.close();
    }
  }

"
org.prevayler.implementation.clock.PausableClock.time,"  public synchronized Date time() {
    return _activeClock.time();
  }"
org.prevayler.implementation.clock.PausableClock.pause,"  public synchronized void pause() {
    advanceTo(_realClock.time());
    _activeClock = _brokenClock;
  }"
org.prevayler.implementation.clock.PausableClock.advanceTo,"  public void advanceTo(Date time) {
    _brokenClock.advanceTo(time);
  }"
org.prevayler.implementation.clock.PausableClock.resume,"  public synchronized void resume() {
    _activeClock = _realClock;
  }"
org.prevayler.implementation.clock.PausableClock.realTime,"  public Date realTime() {
    return _realClock.time();
  }
"
org.prevayler.implementation.clock.MachineClock.time,"/**
* @return The local machine time.
*/
  public synchronized Date time() {
    update();
    return super.time();
  }"
org.prevayler.implementation.clock.MachineClock.update,"  private synchronized void update() {
    long newTime = System.currentTimeMillis();
    if (newTime != _millis) advanceTo(new Date(newTime));
  }

"
org.prevayler.implementation.clock.BrokenClock.time,"  public synchronized Date time() {
    return _time;
  }"
org.prevayler.implementation.clock.BrokenClock.advanceTo,"  public synchronized void advanceTo(Date newTime) {
    long newMillis = newTime.getTime();
    if (newMillis == _millis) return;
    _millis = newMillis;
    _time = newTime;
  }

"
org.prevayler.foundation.ChunkingTest.testChunkedOutput,"  public void testChunkedOutput() throws IOException {
    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
    Chunking.writeChunk(bytes, new Chunk(""abcdefghijklmno"".getBytes(""US-ASCII"")));
    assertEquals(""F\r\nabcdefghijklmno\r\n"", bytes.toString(""US-ASCII""));
  }"
org.prevayler.foundation.ChunkingTest.testChunkedInput,"  public void testChunkedInput() throws IOException {
    ByteArrayInputStream bytes = new ByteArrayInputStream(""F\r\nabcdefghijklmno\r\n"".getBytes());
    assertEquals(""abcdefghijklmno"", new String(Chunking.readChunk(bytes).getBytes(), ""US-ASCII""));
  }"
org.prevayler.foundation.ChunkingTest.testMultipleChunks,"  public void testMultipleChunks() throws IOException {
    ByteArrayOutputStream output = new ByteArrayOutputStream();

    Chunking.writeChunk(output, new Chunk(""foo"".getBytes(""US-ASCII"")));
    Chunking.writeChunk(output, new Chunk(""bar"".getBytes(""US-ASCII"")));
    Chunking.writeChunk(output, new Chunk("""".getBytes(""US-ASCII"")));
    Chunking.writeChunk(output, new Chunk(""zot"".getBytes(""US-ASCII"")));

    ByteArrayInputStream input = new ByteArrayInputStream(output.toByteArray());

    assertEquals(""foo"", new String(Chunking.readChunk(input).getBytes(), ""US-ASCII""));
    assertEquals(""bar"", new String(Chunking.readChunk(input).getBytes(), ""US-ASCII""));
    assertEquals("""", new String(Chunking.readChunk(input).getBytes(), ""US-ASCII""));
    assertEquals(""zot"", new String(Chunking.readChunk(input).getBytes(), ""US-ASCII""));
    assertNull(Chunking.readChunk(input));
  }"
org.prevayler.foundation.ChunkingTest.testMalformed,"  public void testMalformed() throws IOException {
    checkMalformed(""3\nfoo\r\n"", ""Chunk header corrupted"");
    checkMalformed(""3\rfoo\r\n"", ""Chunk header corrupted"");
    checkMalformed(""03\r\nfoo\r\n"", ""Chunk header corrupted"");
    checkMalformed(""f\r\nabcdefghijklmno\r\n"", ""Chunk header corrupted"");
    checkMalformed(""FFF\r\nabcdefghijklmno\r\n"", ""Unexpected end of stream in chunk data"");
    checkMalformed(""FFF"", ""Unexpected end of stream in chunk header"");
    checkMalformed(""F\r\nabcdefghijklmno\n"", ""Chunk trailer corrupted"");
    checkMalformed(""F\r\nabcdefghijklmno\r"", ""Unexpected end of stream in chunk trailer"");
    checkMalformed(""F\r\nabcdefghijklmno"", ""Unexpected end of stream in chunk trailer"");
  }"
org.prevayler.foundation.ChunkingTest.checkMalformed,"  private void checkMalformed(String input, String message) throws IOException {
    ByteArrayInputStream bytes = new ByteArrayInputStream(input.getBytes(""US-ASCII""));
    try {
      Chunking.readChunk(bytes);
      fail(""Should have thrown IOException"");
    } catch (IOException exception) {
      assertEquals(message, exception.getMessage());
      if (message.startsWith(""Unexpected end of stream"")) {
        assertTrue(""Actual exception class was <"" + exception.getClass().getName() + "">"",
            exception instanceof EOFException);
      }
    }
  }"
org.prevayler.foundation.ChunkingTest.testParameters,"  public void testParameters() throws IOException {
    ByteArrayOutputStream output = new ByteArrayOutputStream();

    Chunk chunkOut = new Chunk(""foo"".getBytes(""US-ASCII""));
    chunkOut.setParameter(""one"", ""uno"");
    chunkOut.setParameter(""two"", ""dos"");
    Chunking.writeChunk(output, chunkOut);

    assertEquals(""3;one=uno;two=dos\r\nfoo\r\n"", output.toString(""US-ASCII""));

    ByteArrayInputStream input = new ByteArrayInputStream(output.toByteArray());

    Chunk chunkIn = Chunking.readChunk(input);

    assertEquals(""foo"", new String(chunkIn.getBytes(), ""US-ASCII""));
    assertEquals(""uno"", chunkIn.getParameter(""one""));
    assertEquals(""dos"", chunkIn.getParameter(""two""));
  }

"
org.prevayler.foundation.DeepCopierTest.testNormal,"  public void testNormal() {
    Object original = ""foo"";
    Object copy = DeepCopier.deepCopy(original, new JavaSerializer());

    assertEquals(original, copy);
    assertNotSame(original, copy);
  }"
org.prevayler.foundation.DeepCopierTest.testParallel,"  public void testParallel() throws Exception {
    Object original = ""foo"";
    Object copy = DeepCopier.deepCopyParallel(original, new JavaSerializer());

    assertEquals(original, copy);
    assertNotSame(original, copy);
  }"
org.prevayler.foundation.DeepCopierTest.testParallelPathological,"  public void testParallelPathological() throws Exception {
    Object original = Byte.valueOf((byte) 17);

    Object copy = DeepCopier.deepCopyParallel(original, new Serializer() {

      public void writeObject(OutputStream stream, Object object) throws Exception {
        stream.write(((Byte) object).byteValue());
        stream.flush();

        Cool.sleep(10);

        // By this time the receiver has read an entire object; if it doesn't wait
        // for the actual end of the stream, the following write will get a ""Read end dead""
        // exception. Some real-life serializers have this behavior -- serialization may
        // include a trailer, for example, that deserialization doesn't actually care about.

        stream.write(99);
      }

      public Object readObject(InputStream stream) throws Exception {
        return Byte.valueOf((byte) stream.read());
      }

    });

    assertEquals(original, copy);
    //assertNotSame(original, copy);
  }

"
org.prevayler.foundation.DeepCopierTest.writeObject,"      public void writeObject(OutputStream stream, Object object) throws Exception {
        stream.write(((Byte) object).byteValue());
        stream.flush();

        Cool.sleep(10);

        // By this time the receiver has read an entire object; if it doesn't wait
        // for the actual end of the stream, the following write will get a ""Read end dead""
        // exception. Some real-life serializers have this behavior -- serialization may
        // include a trailer, for example, that deserialization doesn't actually care about.

        stream.write(99);
      }"
org.prevayler.foundation.DeepCopierTest.readObject,"      public Object readObject(InputStream stream) throws Exception {
        return Byte.valueOf((byte) stream.read());
      }

    "
org.prevayler.foundation.DurableOutputStreamTest.testSingleThreaded,"  public void testSingleThreaded() throws Exception {
    for (int i = 0; i < 10 /*5000*/; i++) {
//            System.out.println(""i="" + i);

      File file = new File(_testDirectory, ""stream"" + i + "".bin"");

      DurableOutputStream out = new DurableOutputStream(file, true, 0);

      Turn myTurn = Turn.first();
      out.sync(new DummyGuide(""first"", myTurn));
      out.sync(new DummyGuide(""second"", myTurn.next()));
      out.close();

      assertTrue(out.reallyClosed());
      assertEquals(2, out.fileSyncCount());

      BufferedReader reader = new BufferedReader(new FileReader(file));
      assertEquals(""first"", reader.readLine());
      assertEquals(""second"", reader.readLine());
      assertEquals(null, reader.readLine());
      reader.close();

      delete(file);
    }
  }"
org.prevayler.foundation.DurableOutputStreamTest.testMultiThreaded,"  public void testMultiThreaded() throws Exception {
    for (int i = 0; i < 10 /*5000*/; i++) {
//            System.out.println(""i="" + i);
      File file = new File(_testDirectory, ""stream"" + i + "".bin"");
      DurableOutputStream out = new DurableOutputStream(file, true, 0);

      Turn one = Turn.first();
      Turn two = one.next();
      Turn three = two.next();
      Turn four = three.next();
      Worker worker1 = new Worker(out, 1, two, four);
      Worker worker2 = new Worker(out, 2, one, three);

      Thread thread1 = new Thread(worker1, ""Worker 1"");
      Thread thread2 = new Thread(worker2, ""Worker 2"");

      assertEquals(0, out.fileSyncCount());
      thread1.start();
      assertEquals(0, out.fileSyncCount());

      thread2.start();
      thread1.join();
      thread2.join();

      int syncsBeforeClose = out.fileSyncCount();
      assertTrue(syncsBeforeClose >= 2);
      assertTrue(syncsBeforeClose <= 4);
      assertFalse(out.reallyClosed());

      out.close();

      assertTrue(out.reallyClosed());
      assertEquals(syncsBeforeClose, out.fileSyncCount());

      BufferedReader reader = new BufferedReader(new FileReader(file));
      assertEquals(""2.first"", reader.readLine());
      assertEquals(""1.first"", reader.readLine());
      assertEquals(""2.second"", reader.readLine());
      assertEquals(""1.second"", reader.readLine());
      assertEquals(null, reader.readLine());
      reader.close();

      delete(file);
    }
  }"
org.prevayler.foundation.DurableOutputStreamTest.writeTo,"    public void writeTo(OutputStream stream) throws IOException {
      stream.write(_value.getBytes());
      stream.write('\n');
    }

  }

  private static class Worker implements Runnable {

    private final DurableOutputStream _out;
    private final int _id;
    private final Turn _firstTurn;
    private final Turn _secondTurn;
    @SuppressWarnings(""unused"")
    public Exception _ex;

    public Worker(DurableOutputStream out, int id, Turn firstTurn, Turn secondTurn) {
      _out = out;
      _id = id;
      _firstTurn = firstTurn;
      _secondTurn = secondTurn;
    }

    public void run() {
      try {
        _out.sync(new DummyGuide(_id + "".first"", _firstTurn));
        _out.sync(new DummyGuide(_id + "".second"", _secondTurn));
      } catch (IOException e) {
        _ex = e;
      }
    }

  "
org.prevayler.foundation.DurableOutputStreamTest.run,"    public void run() {
      try {
        _out.sync(new DummyGuide(_id + "".first"", _firstTurn));
        _out.sync(new DummyGuide(_id + "".second"", _secondTurn));
      } catch (IOException e) {
        _ex = e;
      }
    }

  "
org.prevayler.implementation.JournalSerializerTest.testConfigureJournalSerializationStrategy,"  public void testConfigureJournalSerializationStrategy() throws Exception {
    Serializer strategy = new MySerializer();

    startAndCrash(""MyJournal"", strategy);

    assertEquals(""6;withQuery=false;systemVersion=1;executionTime=1000002\r\n"" +
        "" first\r\n"" +
        ""7;withQuery=false;systemVersion=2;executionTime=1000004\r\n"" +
        "" second\r\n"" +
        ""6;withQuery=false;systemVersion=3;executionTime=1000006\r\n"" +
        "" third\r\n"", journalContents(""MyJournal""));

    recover(""MyJournal"", strategy);
  }"
org.prevayler.implementation.JournalSerializerTest.testBadSuffix,"  public void testBadSuffix() {
    PrevaylerFactory<Serializable> factory = new PrevaylerFactory<Serializable>();
    try {
      factory.configureJournalSerializer(""JOURNAL"", new JavaSerializer());
      fail();
    } catch (IllegalArgumentException expected) {
      assertEquals(""Journal filename suffix must match /[a-zA-Z0-9]*[Jj]ournal/, but 'JOURNAL' does not"", expected.getMessage());
    }
  }"
org.prevayler.implementation.JournalSerializerTest.testTryToConfigureTwo,"  public void testTryToConfigureTwo() {
    PrevaylerFactory<Serializable> factory = new PrevaylerFactory<Serializable>();
    factory.configureJournalSerializer(""journal"", new JavaSerializer());
    try {
      factory.configureJournalSerializer(""newjournal"", new JavaSerializer());
      fail();
    } catch (IllegalStateException expected) {
    }
  }"
org.prevayler.implementation.JournalSerializerTest.testJavaJournal,"  public void testJavaJournal() throws Exception {
    Serializer strategy = new JavaSerializer();

    startAndCrash(""journal"", strategy);

    assertEquals(""69;withQuery=false;systemVersion=1;executionTime=1000002\r\n"" +
        ""\254\355\0\005sr\0.org.prevayler.implementation.AppendTransaction\312\330`~\232\305\204\035\002\0\001L\0\005toAddt\0\022Ljava/lang/String;xpt\0\006 first\r\n"" +
        ""6A;withQuery=false;systemVersion=2;executionTime=1000004\r\n"" +
        ""\254\355\0\005sr\0.org.prevayler.implementation.AppendTransaction\312\330`~\232\305\204\035\002\0\001L\0\005toAddt\0\022Ljava/lang/String;xpt\0\007 second\r\n"" +
        ""69;withQuery=false;systemVersion=3;executionTime=1000006\r\n"" +
        ""\254\355\0\005sr\0.org.prevayler.implementation.AppendTransaction\312\330`~\232\305\204\035\002\0\001L\0\005toAddt\0\022Ljava/lang/String;xpt\0\006 third\r\n"",
        journalContents(""journal""));

    recover(""journal"", strategy);
  }"
org.prevayler.implementation.JournalSerializerTest.testXStreamJournal,"  public void testXStreamJournal() throws Exception {
    Serializer strategy = new XStreamSerializer();

    startAndCrash(""journal"", strategy);

    assertEquals(""7A;withQuery=false;systemVersion=1;executionTime=1000002\r\n"" +
        ""<org.prevayler.implementation.AppendTransaction>\n  <toAdd> first</toAdd>\n</org.prevayler.implementation.AppendTransaction>\r\n"" +
        ""7B;withQuery=false;systemVersion=2;executionTime=1000004\r\n"" +
        ""<org.prevayler.implementation.AppendTransaction>\n  <toAdd> second</toAdd>\n</org.prevayler.implementation.AppendTransaction>\r\n"" +
        ""7A;withQuery=false;systemVersion=3;executionTime=1000006\r\n"" +
        ""<org.prevayler.implementation.AppendTransaction>\n  <toAdd> third</toAdd>\n</org.prevayler.implementation.AppendTransaction>\r\n"",
        journalContents(""journal""));

    recover(""journal"", strategy);
  }"
org.prevayler.implementation.JournalSerializerTest.testCompressedJournal,"  public void testCompressedJournal() throws Exception {
    GZIPSerializer serializer = new GZIPSerializer(new MySerializer());

    startAndCrash(""journal"", serializer);

    assertEquals(""1A;withQuery=false;systemVersion=1;executionTime=1000002\r\n"" +
        ""\037\213\b\0\0\0\0\0\0\0SH\313,*.\001\0\337\275=\342\006\0\0\0\r\n"" +
        ""1B;withQuery=false;systemVersion=2;executionTime=1000004\r\n"" +
        ""\037\213\b\0\0\0\0\0\0\0S(NM\316\317K\001\0(V\fU\007\0\0\0\r\n"" +
        ""1A;withQuery=false;systemVersion=3;executionTime=1000006\r\n"" +
        ""\037\213\b\0\0\0\0\0\0\0S(\311\310,J\001\0\354s~T\006\0\0\0\r\n"",
        journalContents(""journal""));

    recover(""journal"", serializer);
  }"
org.prevayler.implementation.JournalSerializerTest.testCompressedAndEncryptedJournal,"  public void testCompressedAndEncryptedJournal() throws Exception {
    byte[] key = {35, 24, 45, 123, 86, 36, 21, 1};
    JavaSerializer java = new JavaSerializer();
    GZIPSerializer gzip = new GZIPSerializer(java);
    DESSerializer des = new DESSerializer(gzip, key);

    startAndCrash(""journal"", des);

    assertEquals(""80;withQuery=false;systemVersion=1;executionTime=1000002\r\n"" +
        ""E+\315\256D\023p\241\271hC\n\025\313n\340%\306:\273T\022\365\002\312/\2529'\247\224\220\217\367\006\306\353\n\363\004o\b\337\032\320\207\255\265\007\032\213\177_Wg\360X\366\214\316\276\366 \341!~!\035Y*\3473OB\007\""hmDT_\347\337\354\337\360\211\226\004IV.N\205\204\246\001k8K\007\205W\236\312EI\336\360\037w\177\255\034\035me3\311\374\223\212\377\256\021\f\367\272\r\n"" +
        ""80;withQuery=false;systemVersion=2;executionTime=1000004\r\n"" +
        ""E+\315\256D\023p\241\271hC\n\025\313n\340%\306:\273T\022\365\002\312/\2529'\247\224\220\217\367\006\306\353\n\363\004o\b\337\032\320\207\255\265\007\032\213\177_Wg\360X\366\214\316\276\366 \341!~!\035Y*\3473OB\007\""hmDT_\347\337\354\337\360\211\226\004IV.N\205\204\246\001k8K\007\205W\236\346\374\017a\205C|\272\032\237\226\307\26662h2\262\277\232\022B\022\377\r\n"" +
        ""80;withQuery=false;systemVersion=3;executionTime=1000006\r\n"" +
        ""E+\315\256D\023p\241\271hC\n\025\313n\340%\306:\273T\022\365\002\312/\2529'\247\224\220\217\367\006\306\353\n\363\004o\b\337\032\320\207\255\265\007\032\213\177_Wg\360X\366\214\316\276\366 \341!~!\035Y*\3473OB\007\""hmDT_\347\337\354\337\360\211\226\004IV.N\205\204\246\001k8K\007\205W\236+\026\216\030\322O\271\3627\360\020{\\5\031\201\223\212\377\256\021\f\367\272\r\n"",
        journalContents(""journal""));

    recover(""journal"", des);
  "
org.prevayler.implementation.JournalSerializerTest.testTripleDES,"  public void testTripleDES() throws Exception {
    byte[] key = {35, 24, 45, 123, 86, 36, 21, 1, 54, 45, 6, 123, 34, 57, 34, 75, 12, 32, 4, 7, 23, 78, 97,"
org.prevayler.implementation.JournalSerializerTest.startAndCrash,"  private void startAndCrash(String suffix, Serializer journalSerializer)
      throws Exception {
    Prevayler<StringBuffer> prevayler = createPrevayler(suffix, journalSerializer);

    prevayler.execute(new AppendTransaction("" first""));
    prevayler.execute(new AppendTransaction("" second""));
    prevayler.execute(new AppendTransaction("" third""));
    assertEquals(""the system first second third"", prevayler.prevalentSystem().toString());
    prevayler.close();
  }"
org.prevayler.implementation.JournalSerializerTest.recover,"  private void recover(String suffix, Serializer journalSerializer)
      throws Exception {
    Prevayler<StringBuffer> prevayler = createPrevayler(suffix, journalSerializer);
    assertEquals(""the system first second third"", prevayler.prevalentSystem().toString());
  }"
org.prevayler.implementation.JournalSerializerTest.createPrevayler,"  private Prevayler<StringBuffer> createPrevayler(String suffix, Serializer journalSerializer)
      throws Exception {
    PrevaylerFactory<StringBuffer> factory = new PrevaylerFactory<StringBuffer>();
    factory.configurePrevalentSystem(new StringBuffer(""the system""));
    factory.configurePrevalenceDirectory(_testDirectory);
    factory.configureJournalSerializer(suffix, journalSerializer);
    factory.configureClock(new Clock() {
      private long time = 1000000;

      public Date time() {
        return new Date(++time);
      }
    });
    return factory.create();
  }"
org.prevayler.implementation.JournalSerializerTest.time,"      public Date time() {
        return new Date(++time);
      }
    "
org.prevayler.implementation.JournalSerializerTest.writeObject,"    public void writeObject(OutputStream stream, Object object) throws IOException {
      Writer writer = new OutputStreamWriter(stream, ""UTF-8"");
      AppendTransaction transaction = (AppendTransaction) object;
      writer.write(transaction.toAdd);
      writer.flush();
    }"
org.prevayler.implementation.JournalSerializerTest.readObject,"    public Object readObject(InputStream stream) throws IOException, ClassNotFoundException {
      BufferedReader reader = new BufferedReader(new InputStreamReader(stream, ""UTF-8""));
      return new AppendTransaction(reader.readLine());
    }

  "
org.prevayler.implementation.JournalFileRollingTest.testFileRolling,"  public void testFileRolling() throws Exception {

    crashRecover(""""); //There is nothing to recover at first. A new system will be created.

    append(""a"", ""a"");
    crashRecover(""a"");

    append(""b"", ""ab""); //Starts new journal (2).
    append(""c"", ""abc"");
    append(""d"", ""abcd""); //Starts new journal (4).
    append(""e"", ""abcde"");
    append(""f"", ""abcdef"");  //Starts new journal (6).
    crashRecover(""abcdef"");

    append(""g"", ""abcdefg""); //Starts new journal (7).
    snapshot();
    append(""h"", ""abcdefgh"");
    append(""i"", ""abcdefghi"");  //Starts new journal (9).
    append(""j"", ""abcdefghij"");
    crashRecover(""abcdefghij"");

    _prevayler.close();
    deleteFromTestDirectory(""0000000000000000001.journal"");
    deleteFromTestDirectory(""0000000000000000002.journal"");
    deleteFromTestDirectory(""0000000000000000004.journal"");
    deleteFromTestDirectory(""0000000000000000006.journal"");
    deleteFromTestDirectory(""0000000000000000007.journal"");
    deleteFromTestDirectory(""0000000000000000007.snapshot"");
    deleteFromTestDirectory(""0000000000000000009.journal"");
    assertEquals(Collections.EMPTY_LIST,
        Arrays.asList(new java.io.File(_testDirectory).list()));
  }"
org.prevayler.implementation.JournalFileRollingTest.crashRecover,"  private void crashRecover(String expectedResult) throws Exception {
    out(""CrashRecovery."");
    if (_prevayler != null) _prevayler.close();
    PrevaylerFactory<AppendingSystem> factory = new PrevaylerFactory<AppendingSystem>();
    factory.configureJournalFileSizeThreshold(232);  //Enough to hold 2 transactions.
    factory.configureJournalFileAgeThreshold(0);  //Not being tested.
    factory.configurePrevalenceDirectory(_testDirectory);
    factory.configurePrevalentSystem(new AppendingSystem());
    _prevayler = factory.create();
    verify(expectedResult);
  }"
org.prevayler.implementation.JournalFileRollingTest.snapshot,"  private void snapshot() throws Exception {
    out(""Snapshot."");
    _prevayler.takeSnapshot();
  }"
org.prevayler.implementation.JournalFileRollingTest.append,"  private void append(String appendix, String expectedResult) throws Exception {
    out(""Appending "" + appendix);
    _prevayler.execute(new Appendix(appendix));
    verify(expectedResult);
  }"
org.prevayler.implementation.JournalFileRollingTest.verify,"  private void verify(String expectedResult) {
    out(""Expecting result: "" + expectedResult);
    assertEquals(expectedResult, system().value());
  }"
org.prevayler.implementation.JournalFileRollingTest.system,"  private AppendingSystem system() {
    return _prevayler.prevalentSystem();
  }"
org.prevayler.implementation.JournalFileRollingTest.out,"  private static void out(Object obj) {
    if (false) System.out.println(obj);   //Change this line to see what the test is doing.
  }

"
org.prevayler.implementation.PersistenceTest.tearDown,"  public void tearDown() throws Exception {
    if (_prevayler != null) {
      _prevayler.close();
    }
    super.tearDown();
  }"
org.prevayler.implementation.PersistenceTest.testPersistenceWithDiskSync,"  public void testPersistenceWithDiskSync() throws Exception {
    doTestPersistence(true);
  }"
org.prevayler.implementation.PersistenceTest.testPersistenceWithoutDiskSync,"  public void testPersistenceWithoutDiskSync() throws Exception {
    doTestPersistence(false);
  }"
org.prevayler.implementation.PersistenceTest.doTestPersistence,"  public void doTestPersistence(boolean journalDiskSync) throws Exception {
    newPrevalenceBase();

    crashRecover(journalDiskSync); //There is nothing to recover at first. A new system will be created.
    crashRecover(journalDiskSync);
    append(""a"", ""a"");
    append(""b"", ""ab"");
    verify(""ab"");

    crashRecover(journalDiskSync);
    verify(""ab"");

    append(""c"", ""abc"");
    append(""d"", ""abcd"");
    snapshot(""0000000000000000004.snapshot"");
    snapshot(""0000000000000000004.snapshot"");
    verify(""abcd"");

    crashRecover(journalDiskSync);
    snapshot(""0000000000000000004.snapshot"");
    append(""e"", ""abcde"");
    snapshot(""0000000000000000005.snapshot"");
    append(""f"", ""abcdef"");
    append(""g"", ""abcdefg"");
    verify(""abcdefg"");

    crashRecover(journalDiskSync);
    append(""h"", ""abcdefgh"");
    verify(""abcdefgh"");

    snapshot(""0000000000000000008.snapshot"");
    _prevayler.close();
    File lastSnapshot = new File(_prevalenceBase, ""0000000000000000008.snapshot"");
    File lastTransactionLog = new File(_prevalenceBase, ""0000000000000000008.journal"");
    newPrevalenceBase();
    FileManager.produceDirectory(_prevalenceBase);
    lastSnapshot.renameTo(new File(_prevalenceBase, ""0000000000000000008.snapshot""));  //Moving the file.
    lastTransactionLog.renameTo(new File(_prevalenceBase, ""0000000000000000008.journal""));

    crashRecover(journalDiskSync);
    append(""i"", ""abcdefghi"");
    append(""j"", ""abcdefghij"");
    crashRecover(journalDiskSync);
    append(""k"", ""abcdefghijk"");
    append(""l"", ""abcdefghijkl"");
    crashRecover(journalDiskSync);
    append(""m"", ""abcdefghijklm"");
    append(""n"", ""abcdefghijklmn"");
    crashRecover(journalDiskSync);
    verify(""abcdefghijklmn"");
  }"
org.prevayler.implementation.PersistenceTest.testDiskSyncPerformance,"  public void testDiskSyncPerformance() throws Exception {
    long false1 = doDiskSyncPerformanceRun(false);
    long true1 = doDiskSyncPerformanceRun(true);
    long false2 = doDiskSyncPerformanceRun(false);
    long true2 = doDiskSyncPerformanceRun(true);
    long bestTrue = Math.min(true1, true2);
    long worstFalse = Math.max(false1, false2);
    // todo: This fails when executing the test from within IntelliJ IDEA
    // todo: but not when executed from command line.
    assertTrue(bestTrue + "" should be worse than "" + worstFalse + "" (This test has been seen failing when executed from within IntelliJ IDEA, but should never fail when executed from command line using 'mvn install'.)"", bestTrue > worstFalse);
  }"
org.prevayler.implementation.PersistenceTest.doDiskSyncPerformanceRun,"  private long doDiskSyncPerformanceRun(boolean journalDiskSync) throws Exception {

    newPrevalenceBase();
    crashRecover(journalDiskSync);
    append(""a"", ""a"");
    long start = System.nanoTime();
    String expected = ""a"";

    for (char c = 'b'; c <= 'z'; c++) {
      expected += c;
      append(String.valueOf(c), expected);
    }

    long end = System.nanoTime();
    crashRecover(journalDiskSync);
    verify(expected);

    return end - start;
  }"
org.prevayler.implementation.PersistenceTest.testSnapshotVersion0,"  public void testSnapshotVersion0() throws Exception {
    newPrevalenceBase();

    crashRecover(); //There is nothing to recover at first. A new system will be created.
    append(""a"", ""a"");
    append(""b"", ""ab"");
    append(""c"", ""abc"");
    verify(""abc"");
    File snapshot = snapshot(""0000000000000000003.snapshot"");

    _prevayler.close();
    assertTrue(snapshot.renameTo(new File(prevalenceBase(), ""0000000000000000000.snapshot"")));
    assertTrue(new File(_prevalenceBase, ""0000000000000000001.journal"").delete());

    crashRecover();
    verify(""abc"");
    append(""d"", ""abcd"");
    snapshot(""0000000000000000001.snapshot"");
  }"
org.prevayler.implementation.PersistenceTest.testNondeterminsticError,"  public void testNondeterminsticError() throws Exception {
    newPrevalenceBase();
    crashRecover(); //There is nothing to recover at first. A new system will be created.

    append(""a"", ""a"");
    append(""b"", ""ab"");
    verify(""ab"");

    NondeterministicErrorTransaction.armBomb(1);
    try {
      _prevayler.execute(new NondeterministicErrorTransaction(""c""));
      fail();
    } catch (AssertionFailedError failed) {
      throw failed;
    } catch (Error expected) {
      assertEquals(Error.class, expected.getClass());
      assertEquals(""BOOM!"", expected.getMessage());
    }

    try {
      _prevayler.execute(new Appendix(""x""));
      fail();
    } catch (AssertionFailedError failed) {
      throw failed;
    } catch (Error expected) {
      assertEquals(Error.class, expected.getClass());
      assertEquals(""Prevayler is no longer processing transactions due to an Error thrown from an earlier transaction."", expected.getMessage());
    }

    try {
      _prevayler.execute(new NullQuery<AppendingSystem>());
      fail();
    } catch (AssertionFailedError failed) {
      throw failed;
    } catch (Error expected) {
      assertEquals(Error.class, expected.getClass());
      assertEquals(""Prevayler is no longer processing queries due to an Error thrown from an earlier transaction."", expected.getMessage());
    }

    try {
      _prevayler.prevalentSystem();
      fail();
    } catch (AssertionFailedError failed) {
      throw failed;
    } catch (Error expected) {
      assertEquals(Error.class, expected.getClass());
      assertEquals(""Prevayler is no longer allowing access to the prevalent system due to an Error thrown from an earlier transaction."", expected.getMessage());
    }

    try {
      _prevayler.takeSnapshot();
      fail();
    } catch (AssertionFailedError failed) {
      throw failed;
    } catch (Error expected) {
      assertEquals(Error.class, expected.getClass());
      assertEquals(""Prevayler is no longer allowing snapshots due to an Error thrown from an earlier transaction."", expected.getMessage());
    }

    crashRecover();

    // Note that both the transaction that threw the Error and the
    // subsequent transaction *were* journaled, so they get applied
    // successfully on recovery.
    verify(""abcx"");
  }"
org.prevayler.implementation.PersistenceTest.testJournalPanic,"  public void testJournalPanic() throws Exception {
    newPrevalenceBase();

    crashRecover();
    append(""a"", ""a"");
    append(""b"", ""ab"");

    sneakilyCloseUnderlyingJournalStream();

    try {
      _prevayler.execute(new Appendix(""x""));
      fail();
    } catch (IllegalStateException aborted) {
      assertEquals(""All transaction processing is now aborted. An IOException was thrown while writing to a .journal file."", aborted.getMessage());
      assertNotNull(aborted.getCause());
    }

    try {
      _prevayler.execute(new Appendix(""y""));
      fail();
    } catch (IllegalStateException aborted) {
      assertEquals(""All transaction processing is now aborted, probably due to an earlier IOException."", aborted.getMessage());
      assertNull(aborted.getCause());
    }

    crashRecover();
    verify(""ab"");
    append(""c"", ""abc"");
  }"
org.prevayler.implementation.PersistenceTest.sneakilyCloseUnderlyingJournalStream,"  private void sneakilyCloseUnderlyingJournalStream() throws Exception {
    FileOutputStream journalStream = (FileOutputStream) Sneaky.get(_prevayler, ""_publisher._journal._outputJournal._fileOutputStream"");
    journalStream.close();
  }"
org.prevayler.implementation.PersistenceTest.testFileCleanupHelper,"  public void testFileCleanupHelper() throws Exception {
    newPrevalenceBase();

    PrevaylerDirectory directory = new PrevaylerDirectory(prevalenceBase());
    directory.produceDirectory();

    checkNecessaryFiles(directory, new String[]{});

    crashRecover(); //There is nothing to recover at first. A new system will be created.
    append(""a"", ""a"");
    append(""b"", ""ab"");

    checkNecessaryFiles(directory, new String[]{""0000000000000000001.journal""});

    crashRecover();
    append(""c"", ""abc"");
    append(""d"", ""abcd"");

    checkNecessaryFiles(directory, new String[]{""0000000000000000001.journal"", ""0000000000000000003.journal""});

    snapshot(""0000000000000000004.snapshot"");

    checkNecessaryFiles(directory, new String[]{""0000000000000000004.snapshot"", ""0000000000000000003.journal""});

    crashRecover();

    append(""e"", ""abcde"");
    append(""f"", ""abcdef"");

    checkNecessaryFiles(directory, new String[]{""0000000000000000004.snapshot"", ""0000000000000000005.journal""});

    crashRecover();

    append(""g"", ""abcdefg"");

    checkNecessaryFiles(directory, new String[]{""0000000000000000004.snapshot"", ""0000000000000000005.journal"", ""0000000000000000007.journal""});

    snapshot(""0000000000000000007.snapshot"");

    _prevayler.close();

    checkNecessaryFiles(directory, new String[]{""0000000000000000007.snapshot"", ""0000000000000000007.journal""});
  }"
org.prevayler.implementation.PersistenceTest.checkNecessaryFiles,"  private void checkNecessaryFiles(PrevaylerDirectory directory, String[] filenames) throws IOException {
    assertEquals(setOfFiles(filenames), directory.necessaryFiles());
  }"
org.prevayler.implementation.PersistenceTest.setOfFiles,"  private Set<File> setOfFiles(String[] filenames) {
    Set<File> set = new HashSet<File>();
    for (int i = 0; i < filenames.length; i++) {
      set.add(new File(prevalenceBase(), filenames[i]));
    }
    return set;
  }"
org.prevayler.implementation.PersistenceTest.crashRecover,"  private void crashRecover() throws Exception {
    crashRecover(true);
  }"
org.prevayler.implementation.PersistenceTest.crashRecover,"  private void crashRecover(boolean journalDiskSync) throws Exception {
    out(""CrashRecovery."");

    if (_prevayler != null) _prevayler.close();

    PrevaylerFactory<AppendingSystem> factory = new PrevaylerFactory<AppendingSystem>();
    factory.configurePrevalentSystem(new AppendingSystem());
    factory.configurePrevalenceDirectory(prevalenceBase());
    factory.configureJournalDiskSync(journalDiskSync);
    _prevayler = factory.create();
  }"
org.prevayler.implementation.PersistenceTest.snapshot,"  private File snapshot(String expectedSnapshotFilename) throws Exception {
    out(""Snapshot."");
    File snapshotFile = _prevayler.takeSnapshot();
    assertEquals(new File(prevalenceBase(), expectedSnapshotFilename), snapshotFile);
    return snapshotFile;
  }"
org.prevayler.implementation.PersistenceTest.append,"  private void append(String appendix, String expectedResult) throws Exception {
    out(""Appending "" + appendix);
    _prevayler.execute(new Appendix(appendix));
    verify(expectedResult);
  }"
org.prevayler.implementation.PersistenceTest.verify,"  private void verify(String expectedResult) {
    out(""Expecting result: "" + expectedResult);
    assertEquals(expectedResult, system().value());
  }"
org.prevayler.implementation.PersistenceTest.system,"  private AppendingSystem system() {
    return _prevayler.prevalentSystem();
  }"
org.prevayler.implementation.PersistenceTest.prevalenceBase,"  private String prevalenceBase() {
    return _prevalenceBase;
  }"
org.prevayler.implementation.PersistenceTest.newPrevalenceBase,"  private void newPrevalenceBase() throws Exception {
    _prevalenceBase = _testDirectory + File.separator + System.currentTimeMillis();
  }"
org.prevayler.implementation.PersistenceTest.out,"  private static void out(Object obj) {
    if (false) System.out.println(obj);   //Change this line to see what the test is doing.
  }

"
org.prevayler.implementation.QueryExecutionTest.testQuery,"  public void testQuery() throws Exception {
    LinkedList<String> prevalentSystem = new LinkedList<String>();
    Prevayler<LinkedList<String>> prevayler = PrevaylerFactory.createTransientPrevayler(prevalentSystem);
    Integer result = prevayler.execute(query());
    assertEquals(0, result.intValue());
  }"
org.prevayler.implementation.QueryExecutionTest.query,"  private static Query<LinkedList<String>, Integer> query() {
    return new Query<LinkedList<String>, Integer>() {
      private static final long serialVersionUID = -9053395276292652684L;

      public Integer query(LinkedList<String> prevalentSystem, Date ignored) throws Exception {
        return prevalentSystem.size();
      }
    };
  }"
org.prevayler.implementation.QueryExecutionTest.query,"      public Integer query(LinkedList<String> prevalentSystem, Date ignored) throws Exception {
        return prevalentSystem.size();
      }
    "
org.prevayler.implementation.QueryExecutionTest.testTransactionWithQuery,"  public void testTransactionWithQuery() throws Exception {
    LinkedList<String> prevalentSystem = new LinkedList<String>();
    Prevayler<LinkedList<String>> prevayler = PrevaylerFactory.createTransientPrevayler(prevalentSystem);
    String result = prevayler.execute(transactionWithQuery());
    assertEquals(""abc"", result);
    assertEquals(""added element"", prevalentSystem.get(0));
  }"
org.prevayler.implementation.QueryExecutionTest.transactionWithQuery,"  private static TransactionWithQuery<LinkedList<String>, String> transactionWithQuery() {
    return new TransactionWithQuery<LinkedList<String>, String>() {
      private static final long serialVersionUID = -2976662596936807721L;

      public String executeAndQuery(LinkedList<String> prevalentSystem, Date timestamp) {
        prevalentSystem.add(""added element"");
        return ""abc"";
      }
    };
  }

"
org.prevayler.implementation.QueryExecutionTest.executeAndQuery,"      public String executeAndQuery(LinkedList<String> prevalentSystem, Date timestamp) {
        prevalentSystem.add(""added element"");
        return ""abc"";
      }
    "
org.prevayler.implementation.SkipOldTransactionsTest.testSkipOldTransactions,"  public void testSkipOldTransactions() throws Exception {
    Prevayler<StringBuffer> original = createPrevayler(""MyJournal"", new MySerializer(false));

    original.execute(new AppendTransaction("" first""));
    original.execute(new AppendTransaction("" second""));

    original.takeSnapshot();

    original.execute(new AppendTransaction("" third""));
    assertEquals(""the system first second third"", original.prevalentSystem().toString());
    original.close();

    assertEquals(""6;withQuery=false;systemVersion=1;executionTime=1000002\r\n"" +
        "" first\r\n"" +
        ""7;withQuery=false;systemVersion=2;executionTime=1000004\r\n"" +
        "" second\r\n"" +
        ""6;withQuery=false;systemVersion=3;executionTime=1000006\r\n"" +
        "" third\r\n"", journalContents(""MyJournal""));

    Prevayler<StringBuffer> recovered = createPrevayler(""MyJournal"", new MySerializer(true));
    assertEquals(""the system first second third"", recovered.prevalentSystem().toString());
  }"
org.prevayler.implementation.SkipOldTransactionsTest.testDetectOldJournalSuffix,"  public void testDetectOldJournalSuffix() throws Exception {
    Prevayler<StringBuffer> original = createPrevayler(""OldJournal"", new MySerializer(false));

    original.execute(new AppendTransaction("" first""));
    original.execute(new AppendTransaction("" second""));

    original.takeSnapshot();

    original.execute(new AppendTransaction("" third""));
    assertEquals(""the system first second third"", original.prevalentSystem().toString());
    original.close();

    assertEquals(""6;withQuery=false;systemVersion=1;executionTime=1000002\r\n"" +
        "" first\r\n"" +
        ""7;withQuery=false;systemVersion=2;executionTime=1000004\r\n"" +
        "" second\r\n"" +
        ""6;withQuery=false;systemVersion=3;executionTime=1000006\r\n"" +
        "" third\r\n"", journalContents(""OldJournal""));

    try {
      createPrevayler(""NewJournal"", new MySerializer(true));
      fail();
    } catch (IOException exception) {
      File journal = new PrevaylerDirectory(_testDirectory).journalFile(1, ""OldJournal"");
      assertEquals(""There are transactions needing to be recovered from "" + journal +
          "", but only NewJournal files are supported"", exception.getMessage());
    }
  }"
org.prevayler.implementation.SkipOldTransactionsTest.testAllowOldJournalSuffix,"  public void testAllowOldJournalSuffix() throws Exception {
    Prevayler<StringBuffer> original = createPrevayler(""OldJournal"", new MySerializer(false));

    original.execute(new AppendTransaction("" first""));
    original.execute(new AppendTransaction("" second""));
    original.execute(new AppendTransaction("" third""));
    original.takeSnapshot();

    assertEquals(""the system first second third"", original.prevalentSystem().toString());
    original.close();

    assertEquals(""6;withQuery=false;systemVersion=1;executionTime=1000002\r\n"" +
        "" first\r\n"" +
        ""7;withQuery=false;systemVersion=2;executionTime=1000004\r\n"" +
        "" second\r\n"" +
        ""6;withQuery=false;systemVersion=3;executionTime=1000006\r\n"" +
        "" third\r\n"", journalContents(""OldJournal""));

    Prevayler<StringBuffer> recovered = createPrevayler(""NewJournal"", new MySerializer(true));
    assertEquals(""the system first second third"", recovered.prevalentSystem().toString());
  }"
org.prevayler.implementation.SkipOldTransactionsTest.createPrevayler,"  private Prevayler<StringBuffer> createPrevayler(String suffix, Serializer journalSerializer)
      throws Exception {
    PrevaylerFactory<StringBuffer> factory = new PrevaylerFactory<StringBuffer>();
    factory.configurePrevalentSystem(new StringBuffer(""the system""));
    factory.configurePrevalenceDirectory(_testDirectory);
    factory.configureJournalSerializer(suffix, journalSerializer);
    factory.configureClock(new Clock() {
      private long time = 1000000;

      public Date time() {
        return new Date(++time);
      }
    });
    return factory.create();
  }"
org.prevayler.implementation.SkipOldTransactionsTest.time,"      public Date time() {
        return new Date(++time);
      }
    "
org.prevayler.implementation.SkipOldTransactionsTest.writeObject,"    public void writeObject(OutputStream stream, Object object) throws IOException {
      Writer writer = new OutputStreamWriter(stream, ""UTF-8"");
      AppendTransaction transaction = (AppendTransaction) object;
      writer.write(transaction.toAdd);
      writer.flush();
    }"
org.prevayler.implementation.SkipOldTransactionsTest.readObject,"    public Object readObject(InputStream stream) throws IOException, ClassNotFoundException {
      BufferedReader reader = new BufferedReader(new InputStreamReader(stream, ""UTF-8""));
      String toAdd = reader.readLine();
      if (afterSnapshot) {
        assertFalse(""Shouldn't have recovered transaction from before snapshot"",
            toAdd.equals("" first"") || toAdd.equals("" second""));
      }
      return new AppendTransaction(toAdd);
    }

  "
org.prevayler.implementation.TransactionWithQueryTest.testJavaJournal,"  public void testJavaJournal() throws Exception {
    Serializer strategy = new JavaSerializer();

    startAndCrash(strategy);
    recover(strategy);
  }"
org.prevayler.implementation.TransactionWithQueryTest.testXStreamJournal,"  public void testXStreamJournal() throws Exception {
    Serializer strategy = new XStreamSerializer();

    startAndCrash(strategy);
    recover(strategy);
  }"
org.prevayler.implementation.TransactionWithQueryTest.startAndCrash,"  private void startAndCrash(Serializer journalSerializer) throws Exception {
    Prevayler<StringBuffer> prevayler = createPrevayler(journalSerializer);

    assertEquals(""the system first"", prevayler.execute(new AppendTransactionWithQuery("" first"")));
    assertEquals(""the system first second"", prevayler.execute(new AppendTransactionWithQuery("" second"")));
    assertEquals(""the system first second third"", prevayler.execute(new AppendTransactionWithQuery("" third"")));
    assertEquals(""the system first second third"", prevayler.prevalentSystem().toString());
    prevayler.close();
  }"
org.prevayler.implementation.TransactionWithQueryTest.recover,"  private void recover(Serializer journalSerializer) throws Exception {
    Prevayler<StringBuffer> prevayler = createPrevayler(journalSerializer);
    assertEquals(""the system first second third"", prevayler.prevalentSystem().toString());
  }"
org.prevayler.implementation.TransactionWithQueryTest.createPrevayler,"  private Prevayler<StringBuffer> createPrevayler(Serializer journalSerializer) throws Exception {
    PrevaylerFactory<StringBuffer> factory = new PrevaylerFactory<StringBuffer>();
    factory.configurePrevalentSystem(new StringBuffer(""the system""));
    factory.configurePrevalenceDirectory(_testDirectory);
    factory.configureJournalSerializer(""journal"", journalSerializer);
    return factory.create();
  }

"
org.prevayler.implementation.PrevaylerBenchmark.executeOn,"    public void executeOn(Map<String, Serializable> prevalentSystem, Date executionTime) {
      Map<String, Serializable> map = prevalentSystem;
      map.put(key, value);
    }"
org.prevayler.implementation.PrevaylerBenchmark.toString,"    public String toString() {
      return ""("" + key + "", "" + value + "")"";
    }
  }

  public static class GetQuery implements Query<Map<String, Serializable>, Serializable> {
    private static final long serialVersionUID = 1L;

    private String key;

    public GetQuery(String key) {
      this.key = key;
    }

    @Override
    public Serializable query(Map<String, Serializable> prevalentSystem, Date executionTime)
        throws Exception {
      Map<String, Serializable> map = prevalentSystem;
      return map.get(key);
    }
  }

  @BeforeClass
  public static void setUpBeforeClass() throws Exception {
    deletePrevaylerDirectory();

    prevayler = createPrevayler(true);
    Map<String, Serializable> map = prevayler.prevalentSystem();
    assertEquals(""Prevayler size"", 0, map.size());
    LOG.info(""Created empty prevayler"");
  }

  @AfterClass
  public static void tearDownAfterClass() throws Exception {
    if(prevayler != null) prevayler.close();
    // deletePrevaylerDirectory();
    LOG.info(""Closed prevayler"");
  }

  static Prevayler<Map<String, Serializable>>
  createPrevayler(boolean journalDiskSync) throws Exception {
    PrevaylerFactory<Map<String, Serializable>> factory =
        new PrevaylerFactory<Map<String, Serializable>>();
    factory.configurePrevalentSystem(new ConcurrentHashMap<String, Serializable>());
    factory.configurePrevalenceDirectory(TEST_DATA_DIRECTORY);
    factory.configureJournalDiskSync(journalDiskSync);
    factory.configureTransactionDeepCopy(false);
    return factory.create();
  }

  @Test
  public void testSingleThreaded() throws Exception {
    AddOp bench = new AddOp(Arrays.asList(new String[]
        {""-op"", ""add"", ""-threads"", ""1"", ""-numTx"", ""100""}));
    bench.benchmark();
    bench.printResults();

    // verify
    for(int i = 0; i < NUM_TRANSACTIONS; i++) {
      String key = ""key_"" + 0 + ""_"" + i;
      String data = ""data_"" + 0 + ""_"" + i;
      Serializable val = prevayler.execute(new GetQuery(key));
      assertEquals(""Prevayler's value is different."", data, val);
    }
  }

  @Test
  public void testMultithreaded() throws Exception {
    AddOp bench = new AddOp(Arrays.asList(new String[]
        {""-op"", ""add"", ""-threads"", ""128"", ""-numTx"", ""5000""}));
    bench.benchmark();
    bench.printResults();
  }

  private static void deletePrevaylerDirectory() {
    File prevaylerDir = new File(TEST_DATA_DIRECTORY);
    if(prevaylerDir.exists())
      assertTrue(""Cannot delete prevayler directory"",
          delete(prevaylerDir, true));
  }

  /**
   * Delete file or directory
   * @param file path to delete
   * @param recursive delete recursively if true
   * @return true if successfully deleted
   */
  public static boolean delete(File file, boolean recursive) {
    if (!file.exists()) {
        return true;
    }

    if (!recursive || !file.isDirectory())
        return file.delete();

    String[] list = file.list();
    for (int i = 0; i < list.length; i++) {
        if (!delete(new File(file, list[i]), true))
            return false;
    }

    return file.delete();
  }

  public static long now() {
    // return System.nanoTime();
    return System.currentTimeMillis();
  }

  /**
   * One of the threads that perform stats operations.
   */
  private static class StatsDaemon extends Thread {
    private final int daemonId;
    private int opsPerThread;
    private String arg1;      // argument passed to executeOp()
    private volatile int  localNumOpsExecuted = 0;
    private volatile long localCumulativeTime = 0;
    private final OperationStatsBase statsOp;

    StatsDaemon(int daemonId, int nrOps, OperationStatsBase op) {
      this.daemonId = daemonId;
      this.opsPerThread = nrOps;
      this.statsOp = op;
      setName(toString());
    }

    @Override
    public void run() {
      localNumOpsExecuted = 0;
      localCumulativeTime = 0;
      arg1 = statsOp.getExecutionArgument(daemonId);
      try {
        benchmarkOne();
      } catch(IOException ex) {
        LOG.log(Level.SEVERE, ""StatsDaemon "" + daemonId + "" failed: \n"", ex);
      }
    }

    @Override
    public String toString() {
      return ""StatsDaemon-"" + daemonId;
    }

    void benchmarkOne() throws IOException {
      for(int idx = 0; idx < opsPerThread; idx++) {
        long stat = statsOp.executeOp(daemonId, idx, arg1);
        localNumOpsExecuted++;
        localCumulativeTime += stat;
      }
    }

    boolean isInProgress() {
      return localNumOpsExecuted < opsPerThread;
    }
  }

  /**
   * Base class for collecting operation statistics.
   * 
   * Overload this class in order to run statistics for a 
   * specific name-node operation.
   */
  abstract static class OperationStatsBase {
    protected static final String OP_ALL_NAME = ""all"";
    protected static final String OP_ALL_USAGE = ""-op all <other ops options>"";

    protected int  numThreads = 0;        // number of threads
    protected int  numOpsRequired = 0;    // number of operations requested
    protected int  numOpsExecuted = 0;    // number of operations executed
    protected long cumulativeTime = 0;    // sum of times for each op
    protected long elapsedTime = 0;       // time from start to finish
    protected boolean keepResults = false;// don't clean base directory on exit
    protected Level logLevel;             // logging level, OFF by default

    protected List<StatsDaemon> daemons;

    /**
     * Operation name.
     */
    abstract String getOpName();

    /**
     * Parse command line arguments.
     * 
     * @param args arguments
     * @throws IOException
     */
    abstract void parseArguments(List<String> args) throws IOException;

    /**
     * Generate inputs for each daemon thread.
     * 
     * @param opsPerThread number of inputs for each thread.
     * @throws IOException
     */
    abstract void generateInputs(int[] opsPerThread) throws IOException;

    /**
     * This corresponds to the arg1 argument of 
     * {@link #executeOp(int, int, String)}, which can have different meanings
     * depending on the operation performed.
     * 
     * @param daemonId id of the daemon calling this method
     * @return the argument
     */
    abstract String getExecutionArgument(int daemonId);

    /**
     * Execute name-node operation.
     * 
     * @param daemonId id of the daemon calling this method.
     * @param inputIdx serial index of the operation called by the deamon.
     * @param arg1 operation specific argument.
     * @return time of the individual name-node call.
     * @throws IOException
     */
    abstract long executeOp(int daemonId, int inputIdx, String arg1) throws IOException;

    /**
     * Print the results of the benchmarking.
     */
    abstract void printResults();

    OperationStatsBase() {
      numOpsRequired = 10;
      numThreads = 3;
      logLevel = Level.OFF;
    }

    void benchmark() throws IOException {
      daemons = new ArrayList<StatsDaemon>();
      long start = 0;
      try {
        numOpsExecuted = 0;
        cumulativeTime = 0;
        if(numThreads < 1)
          return;
        int tIdx = 0; // thread index < nrThreads
        int opsPerThread[] = new int[numThreads];
        for(int opsScheduled = 0; opsScheduled < numOpsRequired; 
                                  opsScheduled += opsPerThread[tIdx++]) {
          // execute  in a separate thread
          opsPerThread[tIdx] = (numOpsRequired-opsScheduled)/(numThreads-tIdx);
          if(opsPerThread[tIdx] == 0)
            opsPerThread[tIdx] = 1;
        }
        // if numThreads > numOpsRequired then the remaining threads will do nothing
        for(; tIdx < numThreads; tIdx++)
          opsPerThread[tIdx] = 0;
        generateInputs(opsPerThread);
        for(tIdx=0; tIdx < numThreads; tIdx++)
          daemons.add(new StatsDaemon(tIdx, opsPerThread[tIdx], this));
        start = now();
        LOG.info(""Starting "" + numOpsRequired + "" "" + getOpName() + ""(s)""
            + "" using "" + numThreads + "" threads."");
        for(StatsDaemon d : daemons)
          d.start();
      } finally {
        while(isInProgress()) {
          // wait until all threads complete
        }
        elapsedTime = now() - start;
        for(StatsDaemon d : daemons) {
          incrementStats(d.localNumOpsExecuted, d.localCumulativeTime);
        }
      }
    }

    private boolean isInProgress() {
      for(StatsDaemon d : daemons)
        if(d.isInProgress())
          return true;
      return false;
    }

    int getNumOpsExecuted() {
      return numOpsExecuted;
    }

    long getCumulativeTime() {
      return cumulativeTime;
    }

    long getElapsedTime() {
      return elapsedTime;
    }

    long getAverageTime() {
      return numOpsExecuted == 0 ? 0 : cumulativeTime / numOpsExecuted;
    }

    double getOpsPerSecond() {
      return elapsedTime == 0 ? 0 : 1000*(double)numOpsExecuted / elapsedTime;
    }

    /* String getBaseDir() {
      return baseDir;
    } */

    String getClientName(int idx) {
      return getOpName() + ""-client-"" + idx;
    }

    void incrementStats(int ops, long time) {
      numOpsExecuted += ops;
      cumulativeTime += time;
    }

    /**
     * Parse first 2 arguments, corresponding to the ""-op"" option.
     * 
     * @param args argument list
     * @return true if operation is all, which means that options not related
     * to this operation should be ignored, or false otherwise, meaning
     * that usage should be printed when an unrelated option is encountered.
     */
    protected boolean verifyOpArgument(List<String> args) {
      if(args.size() < 2 || ! args.get(0).startsWith(""-op""))
        printUsage();

      // process common options
      int llIndex = args.indexOf(""-logLevel"");
      if(llIndex >= 0) {
        if(args.size() <= llIndex + 1)
          printUsage();
        logLevel = Level.parse(args.get(llIndex+1));
        args.remove(llIndex+1);
        args.remove(llIndex);
      }

      String type = args.get(1);
      if(OP_ALL_NAME.equals(type)) {
        type = getOpName();
        return true;
      }
      if(!getOpName().equals(type))
        printUsage();
      return false;
    }

    void printStats() {
      LOG.info(""--- "" + getOpName() + "" stats  ---"");
      LOG.info(""# operations: "" + getNumOpsExecuted());
      LOG.info(""Elapsed Time: "" + getElapsedTime());
      LOG.info("" Ops per sec: "" + getOpsPerSecond());
      LOG.info(""Average Time: "" + getAverageTime());
    }
  }

  /**
   * Add operation.
   */
  public static class AddOp extends OperationStatsBase {
    static final String OP_ADD_NAME = ""add"";
    static final String OP_ADD_USAGE = ""-op add [-threads T] [-numTx N] "";

    protected AddTx[][] transactions;

    AddOp(List<String> args) {
      super();
      parseArguments(args);
    }

    @Override
    String getOpName() {
      return OP_ADD_NAME;
    }

    @Override
    void parseArguments(List<String> args) {
      boolean ignoreUnrelatedOptions = verifyOpArgument(args);
      for (int i = 2; i < args.size(); i++) {       // parse command line
        if(args.get(i).equals(""-numTx"")) {
          if(i+1 == args.size())  printUsage();
          numOpsRequired = Integer.parseInt(args.get(++i));
        } else if(args.get(i).equals(""-threads"")) {
          if(i+1 == args.size())  printUsage();
          numThreads = Integer.parseInt(args.get(++i));
        } else if(!ignoreUnrelatedOptions)
          printUsage();
      }
    }

    @Override
    void generateInputs(int[] opsPerThread) throws IOException {
      assert opsPerThread.length == numThreads : ""Error opsPerThread.length"";
      LOG.info(""Generate "" + numOpsRequired + "" inputs for "" + getOpName());
      transactions = new AddTx[numThreads][];
      for(int idx=0; idx < numThreads; idx++) {
        int threadOps = opsPerThread[idx];
        transactions[idx] = new AddTx[threadOps];
        for(int jdx=0; jdx < threadOps; jdx++) {
          transactions[idx][jdx] =
              new AddTx(""key_"" + idx + ""_"" + jdx, ""data_"" + idx + ""_"" + jdx);
        }
      }
    }

    /**
     * returns client name
     */
    @Override
    String getExecutionArgument(int daemonId) {
      return getClientName(daemonId);
    }

    /**
     * Do add operation.
     */
    @Override
    long executeOp(int daemonId, int inputIdx, String clientName)
        throws IOException {
      long start = now();
      prevayler.execute(transactions[daemonId][inputIdx]);
      long end = now();
      return end-start;
    }

    @Override
    void printResults() {
      LOG.info(""--- "" + getOpName() + "" inputs ---"");
      LOG.info(""numTx = "" + numOpsRequired);
      LOG.info(""nrThreads = "" + numThreads);
      printStats();
    }
  }

  static void printUsage() {
    System.err.println(""Usage: "" + PrevaylerBenchmark.class.getSimpleName()
        + ""\n\t""    + OperationStatsBase.OP_ALL_USAGE
        + "" | \n\t"" + AddOp.OP_ADD_USAGE
    );
    System.exit(-1);
  }

  public static void main(String[] args) throws Exception {
    setUpBeforeClass();
    AddOp bench = null;
    try {
      bench = new AddOp(Arrays.asList(args));
      bench.benchmark();
      bench.printResults();
    } finally {
      tearDownAfterClass();
    }
  "
org.prevayler.implementation.PrevaylerBenchmark.query,"    public Serializable query(Map<String, Serializable> prevalentSystem, Date executionTime)
        throws Exception {
      Map<String, Serializable> map = prevalentSystem;
      return map.get(key);
    }
  }

  @BeforeClass
  public static void setUpBeforeClass() throws Exception {
    deletePrevaylerDirectory();

    prevayler = createPrevayler(true);
    Map<String, Serializable> map = prevayler.prevalentSystem();
    assertEquals(""Prevayler size"", 0, map.size());
    LOG.info(""Created empty prevayler"");
  }

  @AfterClass
  public static void tearDownAfterClass() throws Exception {
    if(prevayler != null) prevayler.close();
    // deletePrevaylerDirectory();
    LOG.info(""Closed prevayler"");
  }

  static Prevayler<Map<String, Serializable>>
  createPrevayler(boolean journalDiskSync) throws Exception {
    PrevaylerFactory<Map<String, Serializable>> factory =
        new PrevaylerFactory<Map<String, Serializable>>();
    factory.configurePrevalentSystem(new ConcurrentHashMap<String, Serializable>());
    factory.configurePrevalenceDirectory(TEST_DATA_DIRECTORY);
    factory.configureJournalDiskSync(journalDiskSync);
    factory.configureTransactionDeepCopy(false);
    return factory.create();
  }

  @Test
  public void testSingleThreaded() throws Exception {
    AddOp bench = new AddOp(Arrays.asList(new String[]
        {""-op"", ""add"", ""-threads"", ""1"", ""-numTx"", ""100""}));
    bench.benchmark();
    bench.printResults();

    // verify
    for(int i = 0; i < NUM_TRANSACTIONS; i++) {
      String key = ""key_"" + 0 + ""_"" + i;
      String data = ""data_"" + 0 + ""_"" + i;
      Serializable val = prevayler.execute(new GetQuery(key));
      assertEquals(""Prevayler's value is different."", data, val);
    }
  }

  @Test
  public void testMultithreaded() throws Exception {
    AddOp bench = new AddOp(Arrays.asList(new String[]
        {""-op"", ""add"", ""-threads"", ""128"", ""-numTx"", ""5000""}));
    bench.benchmark();
    bench.printResults();
  }

  private static void deletePrevaylerDirectory() {
    File prevaylerDir = new File(TEST_DATA_DIRECTORY);
    if(prevaylerDir.exists())
      assertTrue(""Cannot delete prevayler directory"",
          delete(prevaylerDir, true));
  }

  /**
   * Delete file or directory
   * @param file path to delete
   * @param recursive delete recursively if true
   * @return true if successfully deleted
   */
  public static boolean delete(File file, boolean recursive) {
    if (!file.exists()) {
        return true;
    }

    if (!recursive || !file.isDirectory())
        return file.delete();

    String[] list = file.list();
    for (int i = 0; i < list.length; i++) {
        if (!delete(new File(file, list[i]), true))
            return false;
    }

    return file.delete();
  }

  public static long now() {
    // return System.nanoTime();
    return System.currentTimeMillis();
  }

  /**
   * One of the threads that perform stats operations.
   */
  private static class StatsDaemon extends Thread {
    private final int daemonId;
    private int opsPerThread;
    private String arg1;      // argument passed to executeOp()
    private volatile int  localNumOpsExecuted = 0;
    private volatile long localCumulativeTime = 0;
    private final OperationStatsBase statsOp;

    StatsDaemon(int daemonId, int nrOps, OperationStatsBase op) {
      this.daemonId = daemonId;
      this.opsPerThread = nrOps;
      this.statsOp = op;
      setName(toString());
    }

    @Override
    public void run() {
      localNumOpsExecuted = 0;
      localCumulativeTime = 0;
      arg1 = statsOp.getExecutionArgument(daemonId);
      try {
        benchmarkOne();
      } catch(IOException ex) {
        LOG.log(Level.SEVERE, ""StatsDaemon "" + daemonId + "" failed: \n"", ex);
      }
    }

    @Override
    public String toString() {
      return ""StatsDaemon-"" + daemonId;
    }

    void benchmarkOne() throws IOException {
      for(int idx = 0; idx < opsPerThread; idx++) {
        long stat = statsOp.executeOp(daemonId, idx, arg1);
        localNumOpsExecuted++;
        localCumulativeTime += stat;
      }
    }

    boolean isInProgress() {
      return localNumOpsExecuted < opsPerThread;
    }
  }

  /**
   * Base class for collecting operation statistics.
   * 
   * Overload this class in order to run statistics for a 
   * specific name-node operation.
   */
  abstract static class OperationStatsBase {
    protected static final String OP_ALL_NAME = ""all"";
    protected static final String OP_ALL_USAGE = ""-op all <other ops options>"";

    protected int  numThreads = 0;        // number of threads
    protected int  numOpsRequired = 0;    // number of operations requested
    protected int  numOpsExecuted = 0;    // number of operations executed
    protected long cumulativeTime = 0;    // sum of times for each op
    protected long elapsedTime = 0;       // time from start to finish
    protected boolean keepResults = false;// don't clean base directory on exit
    protected Level logLevel;             // logging level, OFF by default

    protected List<StatsDaemon> daemons;

    /**
     * Operation name.
     */
    abstract String getOpName();

    /**
     * Parse command line arguments.
     * 
     * @param args arguments
     * @throws IOException
     */
    abstract void parseArguments(List<String> args) throws IOException;

    /**
     * Generate inputs for each daemon thread.
     * 
     * @param opsPerThread number of inputs for each thread.
     * @throws IOException
     */
    abstract void generateInputs(int[] opsPerThread) throws IOException;

    /**
     * This corresponds to the arg1 argument of 
     * {@link #executeOp(int, int, String)}, which can have different meanings
     * depending on the operation performed.
     * 
     * @param daemonId id of the daemon calling this method
     * @return the argument
     */
    abstract String getExecutionArgument(int daemonId);

    /**
     * Execute name-node operation.
     * 
     * @param daemonId id of the daemon calling this method.
     * @param inputIdx serial index of the operation called by the deamon.
     * @param arg1 operation specific argument.
     * @return time of the individual name-node call.
     * @throws IOException
     */
    abstract long executeOp(int daemonId, int inputIdx, String arg1) throws IOException;

    /**
     * Print the results of the benchmarking.
     */
    abstract void printResults();

    OperationStatsBase() {
      numOpsRequired = 10;
      numThreads = 3;
      logLevel = Level.OFF;
    }

    void benchmark() throws IOException {
      daemons = new ArrayList<StatsDaemon>();
      long start = 0;
      try {
        numOpsExecuted = 0;
        cumulativeTime = 0;
        if(numThreads < 1)
          return;
        int tIdx = 0; // thread index < nrThreads
        int opsPerThread[] = new int[numThreads];
        for(int opsScheduled = 0; opsScheduled < numOpsRequired; 
                                  opsScheduled += opsPerThread[tIdx++]) {
          // execute  in a separate thread
          opsPerThread[tIdx] = (numOpsRequired-opsScheduled)/(numThreads-tIdx);
          if(opsPerThread[tIdx] == 0)
            opsPerThread[tIdx] = 1;
        }
        // if numThreads > numOpsRequired then the remaining threads will do nothing
        for(; tIdx < numThreads; tIdx++)
          opsPerThread[tIdx] = 0;
        generateInputs(opsPerThread);
        for(tIdx=0; tIdx < numThreads; tIdx++)
          daemons.add(new StatsDaemon(tIdx, opsPerThread[tIdx], this));
        start = now();
        LOG.info(""Starting "" + numOpsRequired + "" "" + getOpName() + ""(s)""
            + "" using "" + numThreads + "" threads."");
        for(StatsDaemon d : daemons)
          d.start();
      } finally {
        while(isInProgress()) {
          // wait until all threads complete
        }
        elapsedTime = now() - start;
        for(StatsDaemon d : daemons) {
          incrementStats(d.localNumOpsExecuted, d.localCumulativeTime);
        }
      }
    }

    private boolean isInProgress() {
      for(StatsDaemon d : daemons)
        if(d.isInProgress())
          return true;
      return false;
    }

    int getNumOpsExecuted() {
      return numOpsExecuted;
    }

    long getCumulativeTime() {
      return cumulativeTime;
    }

    long getElapsedTime() {
      return elapsedTime;
    }

    long getAverageTime() {
      return numOpsExecuted == 0 ? 0 : cumulativeTime / numOpsExecuted;
    }

    double getOpsPerSecond() {
      return elapsedTime == 0 ? 0 : 1000*(double)numOpsExecuted / elapsedTime;
    }

    /* String getBaseDir() {
      return baseDir;
    } */

    String getClientName(int idx) {
      return getOpName() + ""-client-"" + idx;
    }

    void incrementStats(int ops, long time) {
      numOpsExecuted += ops;
      cumulativeTime += time;
    }

    /**
     * Parse first 2 arguments, corresponding to the ""-op"" option.
     * 
     * @param args argument list
     * @return true if operation is all, which means that options not related
     * to this operation should be ignored, or false otherwise, meaning
     * that usage should be printed when an unrelated option is encountered.
     */
    protected boolean verifyOpArgument(List<String> args) {
      if(args.size() < 2 || ! args.get(0).startsWith(""-op""))
        printUsage();

      // process common options
      int llIndex = args.indexOf(""-logLevel"");
      if(llIndex >= 0) {
        if(args.size() <= llIndex + 1)
          printUsage();
        logLevel = Level.parse(args.get(llIndex+1));
        args.remove(llIndex+1);
        args.remove(llIndex);
      }

      String type = args.get(1);
      if(OP_ALL_NAME.equals(type)) {
        type = getOpName();
        return true;
      }
      if(!getOpName().equals(type))
        printUsage();
      return false;
    }

    void printStats() {
      LOG.info(""--- "" + getOpName() + "" stats  ---"");
      LOG.info(""# operations: "" + getNumOpsExecuted());
      LOG.info(""Elapsed Time: "" + getElapsedTime());
      LOG.info("" Ops per sec: "" + getOpsPerSecond());
      LOG.info(""Average Time: "" + getAverageTime());
    }
  }

  /**
   * Add operation.
   */
  public static class AddOp extends OperationStatsBase {
    static final String OP_ADD_NAME = ""add"";
    static final String OP_ADD_USAGE = ""-op add [-threads T] [-numTx N] "";

    protected AddTx[][] transactions;

    AddOp(List<String> args) {
      super();
      parseArguments(args);
    }

    @Override
    String getOpName() {
      return OP_ADD_NAME;
    }

    @Override
    void parseArguments(List<String> args) {
      boolean ignoreUnrelatedOptions = verifyOpArgument(args);
      for (int i = 2; i < args.size(); i++) {       // parse command line
        if(args.get(i).equals(""-numTx"")) {
          if(i+1 == args.size())  printUsage();
          numOpsRequired = Integer.parseInt(args.get(++i));
        } else if(args.get(i).equals(""-threads"")) {
          if(i+1 == args.size())  printUsage();
          numThreads = Integer.parseInt(args.get(++i));
        } else if(!ignoreUnrelatedOptions)
          printUsage();
      }
    }

    @Override
    void generateInputs(int[] opsPerThread) throws IOException {
      assert opsPerThread.length == numThreads : ""Error opsPerThread.length"";
      LOG.info(""Generate "" + numOpsRequired + "" inputs for "" + getOpName());
      transactions = new AddTx[numThreads][];
      for(int idx=0; idx < numThreads; idx++) {
        int threadOps = opsPerThread[idx];
        transactions[idx] = new AddTx[threadOps];
        for(int jdx=0; jdx < threadOps; jdx++) {
          transactions[idx][jdx] =
              new AddTx(""key_"" + idx + ""_"" + jdx, ""data_"" + idx + ""_"" + jdx);
        }
      }
    }

    /**
     * returns client name
     */
    @Override
    String getExecutionArgument(int daemonId) {
      return getClientName(daemonId);
    }

    /**
     * Do add operation.
     */
    @Override
    long executeOp(int daemonId, int inputIdx, String clientName)
        throws IOException {
      long start = now();
      prevayler.execute(transactions[daemonId][inputIdx]);
      long end = now();
      return end-start;
    }

    @Override
    void printResults() {
      LOG.info(""--- "" + getOpName() + "" inputs ---"");
      LOG.info(""numTx = "" + numOpsRequired);
      LOG.info(""nrThreads = "" + numThreads);
      printStats();
    }
  }

  static void printUsage() {
    System.err.println(""Usage: "" + PrevaylerBenchmark.class.getSimpleName()
        + ""\n\t""    + OperationStatsBase.OP_ALL_USAGE
        + "" | \n\t"" + AddOp.OP_ADD_USAGE
    );
    System.exit(-1);
  }

  public static void main(String[] args) throws Exception {
    setUpBeforeClass();
    AddOp bench = null;
    try {
      bench = new AddOp(Arrays.asList(args));
      bench.benchmark();
      bench.printResults();
    } finally {
      tearDownAfterClass();
    }
  "
org.prevayler.implementation.PrevaylerBenchmark.setUpBeforeClass,"  public static void setUpBeforeClass() throws Exception {
    deletePrevaylerDirectory();

    prevayler = createPrevayler(true);
    Map<String, Serializable> map = prevayler.prevalentSystem();
    assertEquals(""Prevayler size"", 0, map.size());
    LOG.info(""Created empty prevayler"");
  }"
org.prevayler.implementation.PrevaylerBenchmark.tearDownAfterClass,"  public static void tearDownAfterClass() throws Exception {
    if(prevayler != null) prevayler.close();
    // deletePrevaylerDirectory();
    LOG.info(""Closed prevayler"");
  }"
org.prevayler.implementation.PrevaylerBenchmark.createPrevayler,"  static Prevayler<Map<String, Serializable>>
  createPrevayler(boolean journalDiskSync) throws Exception {
    PrevaylerFactory<Map<String, Serializable>> factory =
        new PrevaylerFactory<Map<String, Serializable>>();
    factory.configurePrevalentSystem(new ConcurrentHashMap<String, Serializable>());
    factory.configurePrevalenceDirectory(TEST_DATA_DIRECTORY);
    factory.configureJournalDiskSync(journalDiskSync);
    factory.configureTransactionDeepCopy(false);
    return factory.create();
  }"
org.prevayler.implementation.PrevaylerBenchmark.testSingleThreaded,"  public void testSingleThreaded() throws Exception {
    AddOp bench = new AddOp(Arrays.asList(new String[]
        {""-op"", ""add"", ""-threads"", ""1"", ""-numTx"", ""100""}));
    bench.benchmark();
    bench.printResults();

    // verify
    for(int i = 0; i < NUM_TRANSACTIONS; i++) {
      String key = ""key_"" + 0 + ""_"" + i;
      String data = ""data_"" + 0 + ""_"" + i;
      Serializable val = prevayler.execute(new GetQuery(key));
      assertEquals(""Prevayler's value is different."", data, val);
    }
  }"
org.prevayler.implementation.PrevaylerBenchmark.testMultithreaded,"  public void testMultithreaded() throws Exception {
    AddOp bench = new AddOp(Arrays.asList(new String[]
        {""-op"", ""add"", ""-threads"", ""128"", ""-numTx"", ""5000""}));
    bench.benchmark();
    bench.printResults();
  }"
org.prevayler.implementation.PrevaylerBenchmark.deletePrevaylerDirectory,"  private static void deletePrevaylerDirectory() {
    File prevaylerDir = new File(TEST_DATA_DIRECTORY);
    if(prevaylerDir.exists())
      assertTrue(""Cannot delete prevayler directory"",
          delete(prevaylerDir, true));
  }"
org.prevayler.implementation.PrevaylerBenchmark.delete,"/**
* Delete file or directory
* @param file path to delete
* @param recursive delete recursively if true
* @return true if successfully deleted
*/
  public static boolean delete(File file, boolean recursive) {
    if (!file.exists()) {
        return true;
    }

    if (!recursive || !file.isDirectory())
        return file.delete();

    String[] list = file.list();
    for (int i = 0; i < list.length; i++) {
        if (!delete(new File(file, list[i]), true))
            return false;
    }

    return file.delete();
  }"
org.prevayler.implementation.PrevaylerBenchmark.now,"  public static long now() {
    // return System.nanoTime();
    return System.currentTimeMillis();
  }"
org.prevayler.implementation.PrevaylerBenchmark.run,"    public void run() {
      localNumOpsExecuted = 0;
      localCumulativeTime = 0;
      arg1 = statsOp.getExecutionArgument(daemonId);
      try {
        benchmarkOne();
      } catch(IOException ex) {
        LOG.log(Level.SEVERE, ""StatsDaemon "" + daemonId + "" failed: \n"", ex);
      }
    }"
org.prevayler.implementation.PrevaylerBenchmark.toString,"    public String toString() {
      return ""StatsDaemon-"" + daemonId;
    }"
org.prevayler.implementation.PrevaylerBenchmark.benchmarkOne,"    void benchmarkOne() throws IOException {
      for(int idx = 0; idx < opsPerThread; idx++) {
        long stat = statsOp.executeOp(daemonId, idx, arg1);
        localNumOpsExecuted++;
        localCumulativeTime += stat;
      }
    }"
org.prevayler.implementation.PrevaylerBenchmark.isInProgress,"    boolean isInProgress() {
      return localNumOpsExecuted < opsPerThread;
    }
  }

  /**
   * Base class for collecting operation statistics.
   * 
   * Overload this class in order to run statistics for a 
   * specific name-node operation.
   */
  abstract static class OperationStatsBase {
    protected static final String OP_ALL_NAME = ""all"";
    protected static final String OP_ALL_USAGE = ""-op all <other ops options>"";

    protected int  numThreads = 0;        // number of threads
    protected int  numOpsRequired = 0;    // number of operations requested
    protected int  numOpsExecuted = 0;    // number of operations executed
    protected long cumulativeTime = 0;    // sum of times for each op
    protected long elapsedTime = 0;       // time from start to finish
    protected boolean keepResults = false;// don't clean base directory on exit
    protected Level logLevel;             // logging level, OFF by default

    protected List<StatsDaemon> daemons;

    /**
     * Operation name.
     */
    abstract String getOpName();

    /**
     * Parse command line arguments.
     * 
     * @param args arguments
     * @throws IOException
     */
    abstract void parseArguments(List<String> args) throws IOException;

    /**
     * Generate inputs for each daemon thread.
     * 
     * @param opsPerThread number of inputs for each thread.
     * @throws IOException
     */
    abstract void generateInputs(int[] opsPerThread) throws IOException;

    /**
     * This corresponds to the arg1 argument of 
     * {@link #executeOp(int, int, String)}, which can have different meanings
     * depending on the operation performed.
     * 
     * @param daemonId id of the daemon calling this method
     * @return the argument
     */
    abstract String getExecutionArgument(int daemonId);

    /**
     * Execute name-node operation.
     * 
     * @param daemonId id of the daemon calling this method.
     * @param inputIdx serial index of the operation called by the deamon.
     * @param arg1 operation specific argument.
     * @return time of the individual name-node call.
     * @throws IOException
     */
    abstract long executeOp(int daemonId, int inputIdx, String arg1) throws IOException;

    /**
     * Print the results of the benchmarking.
     */
    abstract void printResults();

    OperationStatsBase() {
      numOpsRequired = 10;
      numThreads = 3;
      logLevel = Level.OFF;
    }

    void benchmark() throws IOException {
      daemons = new ArrayList<StatsDaemon>();
      long start = 0;
      try {
        numOpsExecuted = 0;
        cumulativeTime = 0;
        if(numThreads < 1)
          return;
        int tIdx = 0; // thread index < nrThreads
        int opsPerThread[] = new int[numThreads];
        for(int opsScheduled = 0; opsScheduled < numOpsRequired; 
                                  opsScheduled += opsPerThread[tIdx++]) {
          // execute  in a separate thread
          opsPerThread[tIdx] = (numOpsRequired-opsScheduled)/(numThreads-tIdx);
          if(opsPerThread[tIdx] == 0)
            opsPerThread[tIdx] = 1;
        }
        // if numThreads > numOpsRequired then the remaining threads will do nothing
        for(; tIdx < numThreads; tIdx++)
          opsPerThread[tIdx] = 0;
        generateInputs(opsPerThread);
        for(tIdx=0; tIdx < numThreads; tIdx++)
          daemons.add(new StatsDaemon(tIdx, opsPerThread[tIdx], this));
        start = now();
        LOG.info(""Starting "" + numOpsRequired + "" "" + getOpName() + ""(s)""
            + "" using "" + numThreads + "" threads."");
        for(StatsDaemon d : daemons)
          d.start();
      } finally {
        while(isInProgress()) {
          // wait until all threads complete
        }
        elapsedTime = now() - start;
        for(StatsDaemon d : daemons) {
          incrementStats(d.localNumOpsExecuted, d.localCumulativeTime);
        }
      }
    }

    private boolean isInProgress() {
      for(StatsDaemon d : daemons)
        if(d.isInProgress())
          return true;
      return false;
    }

    int getNumOpsExecuted() {
      return numOpsExecuted;
    }

    long getCumulativeTime() {
      return cumulativeTime;
    }

    long getElapsedTime() {
      return elapsedTime;
    }

    long getAverageTime() {
      return numOpsExecuted == 0 ? 0 : cumulativeTime / numOpsExecuted;
    }

    double getOpsPerSecond() {
      return elapsedTime == 0 ? 0 : 1000*(double)numOpsExecuted / elapsedTime;
    }

    /* String getBaseDir() {
      return baseDir;
    } */

    String getClientName(int idx) {
      return getOpName() + ""-client-"" + idx;
    }

    void incrementStats(int ops, long time) {
      numOpsExecuted += ops;
      cumulativeTime += time;
    }

    /**
     * Parse first 2 arguments, corresponding to the ""-op"" option.
     * 
     * @param args argument list
     * @return true if operation is all, which means that options not related
     * to this operation should be ignored, or false otherwise, meaning
     * that usage should be printed when an unrelated option is encountered.
     */
    protected boolean verifyOpArgument(List<String> args) {
      if(args.size() < 2 || ! args.get(0).startsWith(""-op""))
        printUsage();

      // process common options
      int llIndex = args.indexOf(""-logLevel"");
      if(llIndex >= 0) {
        if(args.size() <= llIndex + 1)
          printUsage();
        logLevel = Level.parse(args.get(llIndex+1));
        args.remove(llIndex+1);
        args.remove(llIndex);
      }

      String type = args.get(1);
      if(OP_ALL_NAME.equals(type)) {
        type = getOpName();
        return true;
      }
      if(!getOpName().equals(type))
        printUsage();
      return false;
    }

    void printStats() {
      LOG.info(""--- "" + getOpName() + "" stats  ---"");
      LOG.info(""# operations: "" + getNumOpsExecuted());
      LOG.info(""Elapsed Time: "" + getElapsedTime());
      LOG.info("" Ops per sec: "" + getOpsPerSecond());
      LOG.info(""Average Time: "" + getAverageTime());
    }
  }

  /**
   * Add operation.
   */
  public static class AddOp extends OperationStatsBase {
    static final String OP_ADD_NAME = ""add"";
    static final String OP_ADD_USAGE = ""-op add [-threads T] [-numTx N] "";

    protected AddTx[][] transactions;

    AddOp(List<String> args) {
      super();
      parseArguments(args);
    }

    @Override
    String getOpName() {
      return OP_ADD_NAME;
    }

    @Override
    void parseArguments(List<String> args) {
      boolean ignoreUnrelatedOptions = verifyOpArgument(args);
      for (int i = 2; i < args.size(); i++) {       // parse command line
        if(args.get(i).equals(""-numTx"")) {
          if(i+1 == args.size())  printUsage();
          numOpsRequired = Integer.parseInt(args.get(++i));
        } else if(args.get(i).equals(""-threads"")) {
          if(i+1 == args.size())  printUsage();
          numThreads = Integer.parseInt(args.get(++i));
        } else if(!ignoreUnrelatedOptions)
          printUsage();
      }
    }

    @Override
    void generateInputs(int[] opsPerThread) throws IOException {
      assert opsPerThread.length == numThreads : ""Error opsPerThread.length"";
      LOG.info(""Generate "" + numOpsRequired + "" inputs for "" + getOpName());
      transactions = new AddTx[numThreads][];
      for(int idx=0; idx < numThreads; idx++) {
        int threadOps = opsPerThread[idx];
        transactions[idx] = new AddTx[threadOps];
        for(int jdx=0; jdx < threadOps; jdx++) {
          transactions[idx][jdx] =
              new AddTx(""key_"" + idx + ""_"" + jdx, ""data_"" + idx + ""_"" + jdx);
        }
      }
    }

    /**
     * returns client name
     */
    @Override
    String getExecutionArgument(int daemonId) {
      return getClientName(daemonId);
    }

    /**
     * Do add operation.
     */
    @Override
    long executeOp(int daemonId, int inputIdx, String clientName)
        throws IOException {
      long start = now();
      prevayler.execute(transactions[daemonId][inputIdx]);
      long end = now();
      return end-start;
    }

    @Override
    void printResults() {
      LOG.info(""--- "" + getOpName() + "" inputs ---"");
      LOG.info(""numTx = "" + numOpsRequired);
      LOG.info(""nrThreads = "" + numThreads);
      printStats();
    }
  }

  static void printUsage() {
    System.err.println(""Usage: "" + PrevaylerBenchmark.class.getSimpleName()
        + ""\n\t""    + OperationStatsBase.OP_ALL_USAGE
        + "" | \n\t"" + AddOp.OP_ADD_USAGE
    );
    System.exit(-1);
  }

  public static void main(String[] args) throws Exception {
    setUpBeforeClass();
    AddOp bench = null;
    try {
      bench = new AddOp(Arrays.asList(args));
      bench.benchmark();
      bench.printResults();
    } finally {
      tearDownAfterClass();
    }
  "
org.prevayler.implementation.PrevaylerBenchmark.getOpName,"/**
* Operation name.
*/
"
org.prevayler.implementation.PrevaylerBenchmark.parseArguments,"/**
* Parse command line arguments.
*
* @param args arguments
* @throws IOException
*/
"
org.prevayler.implementation.PrevaylerBenchmark.generateInputs,"/**
* Generate inputs for each daemon thread.
*
* @param opsPerThread number of inputs for each thread.
* @throws IOException
*/
    abstract void generateInputs(int[] opsPerThread) throws IOException;

    /**
     * This corresponds to the arg1 argument of 
     * {@link #executeOp(int, int, String)}"
org.prevayler.implementation.PrevaylerBenchmark.getExecutionArgument,"/**
* This corresponds to the arg1 argument of
* {@link #executeOp(int, int, String)}, which can have different meanings
* depending on the operation performed.
*
* @param daemonId id of the daemon calling this method
* @return the argument
*/
"
org.prevayler.implementation.PrevaylerBenchmark.executeOp,"/**
* Execute name-node operation.
*
* @param daemonId id of the daemon calling this method.
* @param inputIdx serial index of the operation called by the deamon.
* @param arg1 operation specific argument.
* @return time of the individual name-node call.
* @throws IOException
*/
"
org.prevayler.implementation.PrevaylerBenchmark.printResults,"/**
* Print the results of the benchmarking.
*/
"
org.prevayler.implementation.PrevaylerBenchmark.benchmark,"    void benchmark() throws IOException {
      daemons = new ArrayList<StatsDaemon>();
      long start = 0;
      try {
        numOpsExecuted = 0;
        cumulativeTime = 0;
        if(numThreads < 1)
          return;
        int tIdx = 0; // thread index < nrThreads
        int opsPerThread[] = new int[numThreads];
        for(int opsScheduled = 0; opsScheduled < numOpsRequired; 
                                  opsScheduled += opsPerThread[tIdx++]) {
          // execute  in a separate thread
          opsPerThread[tIdx] = (numOpsRequired-opsScheduled)/(numThreads-tIdx);
          if(opsPerThread[tIdx] == 0)
            opsPerThread[tIdx] = 1;
        }
        // if numThreads > numOpsRequired then the remaining threads will do nothing
        for(; tIdx < numThreads; tIdx++)
          opsPerThread[tIdx] = 0;
        generateInputs(opsPerThread);
        for(tIdx=0; tIdx < numThreads; tIdx++)
          daemons.add(new StatsDaemon(tIdx, opsPerThread[tIdx], this));
        start = now();
        LOG.info(""Starting "" + numOpsRequired + "" "" + getOpName() + ""(s)""
            + "" using "" + numThreads + "" threads."");
        for(StatsDaemon d : daemons)
          d.start();
      } finally {
        while(isInProgress()) {
          // wait until all threads complete
        }
        elapsedTime = now() - start;
        for(StatsDaemon d : daemons) {
          incrementStats(d.localNumOpsExecuted, d.localCumulativeTime);
        }
      }
    }"
org.prevayler.implementation.PrevaylerBenchmark.isInProgress,"    private boolean isInProgress() {
      for(StatsDaemon d : daemons)
        if(d.isInProgress())
          return true;
      return false;
    }"
org.prevayler.implementation.PrevaylerBenchmark.getNumOpsExecuted,"    int getNumOpsExecuted() {
      return numOpsExecuted;
    }"
org.prevayler.implementation.PrevaylerBenchmark.getCumulativeTime,"    long getCumulativeTime() {
      return cumulativeTime;
    }"
org.prevayler.implementation.PrevaylerBenchmark.getElapsedTime,"    long getElapsedTime() {
      return elapsedTime;
    }"
org.prevayler.implementation.PrevaylerBenchmark.getAverageTime,"    long getAverageTime() {
      return numOpsExecuted == 0 ? 0 : cumulativeTime / numOpsExecuted;
    }"
org.prevayler.implementation.PrevaylerBenchmark.getOpsPerSecond,"    double getOpsPerSecond() {
      return elapsedTime == 0 ? 0 : 1000*(double)numOpsExecuted / elapsedTime;
    }

    /* String getBaseDir() {
      return baseDir;
    }"
org.prevayler.implementation.PrevaylerBenchmark.getClientName,"    String getClientName(int idx) {
      return getOpName() + ""-client-"" + idx;
    }"
org.prevayler.implementation.PrevaylerBenchmark.incrementStats,"    void incrementStats(int ops, long time) {
      numOpsExecuted += ops;
      cumulativeTime += time;
    }"
org.prevayler.implementation.PrevaylerBenchmark.verifyOpArgument,"/**
* Parse first 2 arguments, corresponding to the ""-op"" option.
*
* @param args argument list
* @return true if operation is all, which means that options not related
* to this operation should be ignored, or false otherwise, meaning
* that usage should be printed when an unrelated option is encountered.
*/
    protected boolean verifyOpArgument(List<String> args) {
      if(args.size() < 2 || ! args.get(0).startsWith(""-op""))
        printUsage();

      // process common options
      int llIndex = args.indexOf(""-logLevel"");
      if(llIndex >= 0) {
        if(args.size() <= llIndex + 1)
          printUsage();
        logLevel = Level.parse(args.get(llIndex+1));
        args.remove(llIndex+1);
        args.remove(llIndex);
      }

      String type = args.get(1);
      if(OP_ALL_NAME.equals(type)) {
        type = getOpName();
        return true;
      }
      if(!getOpName().equals(type))
        printUsage();
      return false;
    }"
org.prevayler.implementation.PrevaylerBenchmark.printStats,"    void printStats() {
      LOG.info(""--- "" + getOpName() + "" stats  ---"");
      LOG.info(""# operations: "" + getNumOpsExecuted());
      LOG.info(""Elapsed Time: "" + getElapsedTime());
      LOG.info("" Ops per sec: "" + getOpsPerSecond());
      LOG.info(""Average Time: "" + getAverageTime());
    }
  "
org.prevayler.implementation.PrevaylerBenchmark.getOpName,"    String getOpName() {
      return OP_ADD_NAME;
    }"
org.prevayler.implementation.PrevaylerBenchmark.parseArguments,"    void parseArguments(List<String> args) {
      boolean ignoreUnrelatedOptions = verifyOpArgument(args);
      for (int i = 2; i < args.size(); i++) {       // parse command line
        if(args.get(i).equals(""-numTx"")) {
          if(i+1 == args.size())  printUsage();
          numOpsRequired = Integer.parseInt(args.get(++i));
        } else if(args.get(i).equals(""-threads"")) {
          if(i+1 == args.size())  printUsage();
          numThreads = Integer.parseInt(args.get(++i));
        } else if(!ignoreUnrelatedOptions)
          printUsage();
      }
    }"
org.prevayler.implementation.PrevaylerBenchmark.generateInputs,"    void generateInputs(int[] opsPerThread) throws IOException {
      assert opsPerThread.length == numThreads : ""Error opsPerThread.length"";
      LOG.info(""Generate "" + numOpsRequired + "" inputs for "" + getOpName());
      transactions = new AddTx[numThreads][];
      for(int idx=0; idx < numThreads; idx++) {
        int threadOps = opsPerThread[idx];
        transactions[idx] = new AddTx[threadOps];
        for(int jdx=0; jdx < threadOps; jdx++) {
          transactions[idx][jdx] =
              new AddTx(""key_"" + idx + ""_"" + jdx, ""data_"" + idx + ""_"" + jdx);
        }
      }
    }"
org.prevayler.implementation.PrevaylerBenchmark.getExecutionArgument,"    String getExecutionArgument(int daemonId) {
      return getClientName(daemonId);
    }"
org.prevayler.implementation.PrevaylerBenchmark.executeOp,"    long executeOp(int daemonId, int inputIdx, String clientName)
        throws IOException {
      long start = now();
      prevayler.execute(transactions[daemonId][inputIdx]);
      long end = now();
      return end-start;
    }"
org.prevayler.implementation.PrevaylerBenchmark.printResults,"    void printResults() {
      LOG.info(""--- "" + getOpName() + "" inputs ---"");
      LOG.info(""numTx = "" + numOpsRequired);
      LOG.info(""nrThreads = "" + numThreads);
      printStats();
    }
  }

  static void printUsage() {
    System.err.println(""Usage: "" + PrevaylerBenchmark.class.getSimpleName()
        + ""\n\t""    + OperationStatsBase.OP_ALL_USAGE
        + "" | \n\t"" + AddOp.OP_ADD_USAGE
    );
    System.exit(-1);
  }

  public static void main(String[] args) throws Exception {
    setUpBeforeClass();
    AddOp bench = null;
    try {
      bench = new AddOp(Arrays.asList(args));
      bench.benchmark();
      bench.printResults();
    } finally {
      tearDownAfterClass();
    }
  "
org.prevayler.implementation.PrevaylerBenchmark.printUsage,"  static void printUsage() {
    System.err.println(""Usage: "" + PrevaylerBenchmark.class.getSimpleName()
        + ""\n\t""    + OperationStatsBase.OP_ALL_USAGE
        + "" | \n\t"" + AddOp.OP_ADD_USAGE
    );
    System.exit(-1);
  }"
org.prevayler.implementation.PrevaylerBenchmark.main,"  public static void main(String[] args) throws Exception {
    setUpBeforeClass();
    AddOp bench = null;
    try {
      bench = new AddOp(Arrays.asList(args));
      bench.benchmark();
      bench.printResults();
    } finally {
      tearDownAfterClass();
    }
  }
"
org.prevayler.implementation.PrevaylerFactoryTest.testTransientPrevaylerCreation,"  public void testTransientPrevaylerCreation() {
    Prevayler<Serializable> prevayler = PrevaylerFactory.createTransientPrevayler(POJO);
    assertEquals(POJO, prevayler.prevalentSystem());
  }"
org.prevayler.implementation.PrevaylerFactoryTest.testSnapshotPrevaylerCreation,"  public void testSnapshotPrevaylerCreation() throws Exception {
    Prevayler<Serializable> prevayler = PrevaylerFactory.createPrevayler(POJO, _testDirectory);
    assertEquals(POJO, prevayler.prevalentSystem());
  }"
org.prevayler.implementation.PrevaylerFactoryTest.testCheckpointPrevaylerCreation,"  public void testCheckpointPrevaylerCreation() {
    Prevayler<Serializable> prevayler = PrevaylerFactory.createCheckpointPrevayler(POJO, _testDirectory);
    assertEquals(POJO, prevayler.prevalentSystem());
  }

"
org.prevayler.implementation.TransientPrevaylerTest.setUp,"  protected void setUp() throws Exception {
    super.setUp();
    prevayler = PrevaylerFactory.createTransientPrevayler(new AppendingSystem());
  }"
org.prevayler.implementation.TransientPrevaylerTest.testTransactionExecution,"  public void testTransactionExecution() {
    assertState("""");

    append(""a"");
    assertState(""a"");

    append(""b"");
    append(""c"");
    assertState(""abc"");
  }"
org.prevayler.implementation.TransientPrevaylerTest.testSnapshotAttempt,"  public void testSnapshotAttempt() throws Exception {
    try {
      prevayler.takeSnapshot();
      fail(""IOException expected."");
    } catch (IOException iox) {
      assertEquals(""Transient Prevaylers are unable to take snapshots."", iox.getMessage());
    }
  }"
org.prevayler.implementation.TransientPrevaylerTest.testFailFastBaptismProblem,"/**
* The baptism problem occurs when a Transaction keeps a direct reference to a business object instead of querying for it given the Prevalent System.
*/
  public void testFailFastBaptismProblem() {
    append(""a"");

    AppendingSystem directReference = prevayler.prevalentSystem();
    prevayler.execute(new DirectReferenceTransaction(directReference));

    assertState(""a"");
  }"
org.prevayler.implementation.TransientPrevaylerTest.tearDown,"  protected void tearDown() throws Exception {
    prevayler = null;
    super.tearDown();
  }"
org.prevayler.implementation.TransientPrevaylerTest.assertState,"  private void assertState(String expected) {
    String result = prevayler.prevalentSystem().value();
    assertEquals(expected, result);
  }"
org.prevayler.implementation.TransientPrevaylerTest.append,"  private void append(String appendix) {
    prevayler.execute(new Appendix(appendix));
  }"
org.prevayler.implementation.TransientPrevaylerTest.executeOn,"    public void executeOn(AppendingSystem ignored, Date ignoredToo) {
      _illegalDirectReference.append(""anything"");
    }

  "
org.prevayler.implementation.CheckpointTest.testCheckpoint,"  public void testCheckpoint() throws Exception {

    crashRecover(); //There is nothing to recover at first. A new system will be created.
    crashRecover();
    append(""a"", ""a"");
    append(""b"", ""ab"");
    verify(""ab"");

    crashRecover();
    verify("""");

    append(""a"", ""a"");
    append(""b"", ""ab"");
    snapshot();
    snapshot();
    verify(""ab"");

    crashRecover();
    snapshot();
    append(""c"", ""abc"");
    snapshot();
    append(""d"", ""abcd"");
    append(""e"", ""abcde"");
    verify(""abcde"");

    crashRecover();
    append(""d"", ""abcd"");
    verify(""abcd"");

  }"
org.prevayler.implementation.CheckpointTest.crashRecover,"  private void crashRecover() throws Exception {
    out(""CrashRecovery."");
    _prevayler = PrevaylerFactory.createCheckpointPrevayler(new AppendingSystem(), _testDirectory);
  }"
org.prevayler.implementation.CheckpointTest.snapshot,"  private void snapshot() throws Exception {
    out(""Snapshot."");
    _prevayler.takeSnapshot();
  }"
org.prevayler.implementation.CheckpointTest.append,"  private void append(String appendix, String expectedResult) throws Exception {
    out(""Appending "" + appendix);
    _prevayler.execute(new Appendix(appendix));
    verify(expectedResult);
  }"
org.prevayler.implementation.CheckpointTest.verify,"  private void verify(String expectedResult) {
    out(""Expecting result: "" + expectedResult);
    assertEquals(expectedResult, system().value());
  }"
org.prevayler.implementation.CheckpointTest.system,"  private AppendingSystem system() {
    return _prevayler.prevalentSystem();
  }"
org.prevayler.implementation.CheckpointTest.out,"  private static void out(Object obj) {
    if (false) System.out.println(obj);   //Change this line to see what the test is doing.
  }

"
org.prevayler.implementation.SnapshotSerializerTest.testConfigureSnapshotSerializer,"  public void testConfigureSnapshotSerializer() throws Exception {
    Serializer serializer = new MySerializer();

    takeSnapshot(serializer);

    assertEquals(""Yes, this is MySerializationStrategy!\n"" +
        ""the system first second third\n"", snapshotContents());

    recover(serializer);
  }"
org.prevayler.implementation.SnapshotSerializerTest.testBadSuffix,"  public void testBadSuffix() {
    PrevaylerFactory<Serializable> factory = new PrevaylerFactory<Serializable>();
    try {
      factory.configureSnapshotSerializer(""SNAPSHOT"", new JavaSerializer());
      fail();
    } catch (IllegalArgumentException exception) {
      assertEquals(""Snapshot filename suffix must match /[a-zA-Z0-9]*[Ss]napshot/, but 'SNAPSHOT' does not"", exception.getMessage());
    }
  }"
org.prevayler.implementation.SnapshotSerializerTest.testXStreamSnapshot,"  public void testXStreamSnapshot() throws Exception {
    Serializer serializer = new XStreamSerializer();

    takeSnapshot(serializer);
    recover(serializer);
  }"
org.prevayler.implementation.SnapshotSerializerTest.takeSnapshot,"  private void takeSnapshot(Serializer snapshotSerializer) throws Exception {
    Prevayler<StringBuffer> prevayler = createPrevayler(snapshotSerializer);

    prevayler.execute(new AppendTransaction("" first""));
    prevayler.execute(new AppendTransaction("" second""));
    prevayler.execute(new AppendTransaction("" third""));
    assertEquals(""the system first second third"", prevayler.prevalentSystem().toString());

    prevayler.takeSnapshot();
    prevayler.close();
  }"
org.prevayler.implementation.SnapshotSerializerTest.recover,"  private void recover(Serializer snapshotSerializer) throws Exception {
    Prevayler<StringBuffer> prevayler = createPrevayler(snapshotSerializer);
    assertEquals(""the system first second third"", prevayler.prevalentSystem().toString());
  }"
org.prevayler.implementation.SnapshotSerializerTest.createPrevayler,"  private Prevayler<StringBuffer> createPrevayler(Serializer snapshotSerializer) throws Exception {
    PrevaylerFactory<StringBuffer> factory = new PrevaylerFactory<StringBuffer>();
    factory.configurePrevalentSystem(new StringBuffer(""the system""));
    factory.configurePrevalenceDirectory(_testDirectory);
    factory.configureSnapshotSerializer(""snapshot"", snapshotSerializer);
    return factory.create();
  }"
org.prevayler.implementation.SnapshotSerializerTest.snapshotContents,"  private String snapshotContents() throws IOException {
    File snapshot = new File(_testDirectory).listFiles(new FilenameFilter() {
      public boolean accept(File dir, String name) {
        return name.endsWith("".snapshot"");
      }
    })[0];

    FileReader file = new FileReader(snapshot);
    StringWriter string = new StringWriter();

    int n;
    char[] c = new char[1024];
    while ((n = file.read(c)) != -1) {
      string.write(c, 0, n);
    }

    file.close();

    return string.toString();
  }"
org.prevayler.implementation.SnapshotSerializerTest.accept,"      public boolean accept(File dir, String name) {
        return name.endsWith("".snapshot"");
      }"
org.prevayler.implementation.SnapshotSerializerTest.writeObject,"    public void writeObject(OutputStream stream, Object object) throws IOException {
      StringBuffer system = (StringBuffer) object;
      Writer writer = new OutputStreamWriter(stream, ""UTF-8"");
      writer.write(""Yes, this is MySerializationStrategy!\n"");
      writer.write(system.toString());
      writer.write('\n');
      writer.flush();
    }"
org.prevayler.implementation.SnapshotSerializerTest.readObject,"    public Object readObject(InputStream stream) throws IOException, ClassNotFoundException {
      BufferedReader reader = new BufferedReader(new InputStreamReader(stream, ""UTF-8""));
      String prolog = reader.readLine();
      if (""Yes, this is MySerializationStrategy!"".equals(prolog)) {
        String contents = reader.readLine();
        return new StringBuffer(contents);
      } else {
        throw new AssertionFailedError(""got prolog="" + prolog);
      }
    }

  "
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.testNoExistingSnapshot,"  public void testNoExistingSnapshot() throws Exception {
    Prevayler<StringBuffer> prevayler = createPrevayler(""snapshot"", new JavaSerializer());
    assertEquals(""initial"", prevayler.prevalentSystem().toString());
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.testRoundtripJava,"  public void testRoundtripJava() throws Exception {
    checkRoundtrip(""snapshot"", new JavaSerializer());
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.testRoundtripXStream,"  public void testRoundtripXStream() throws Exception {
    checkRoundtrip(""xstreamsnapshot"", new XStreamSerializer());
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.checkRoundtrip,"  private void checkRoundtrip(String suffix, Serializer serializer) throws Exception {
    Prevayler<StringBuffer> first = createPrevayler(suffix, serializer);
    appendTakeSnapshotAndClose(first);

    checkSnapshotAndDeleteJournal(""0000000000000000002."" + suffix, ""0000000000000000001.journal"");

    Prevayler<StringBuffer> second = createPrevayler(suffix, serializer);
    assertEquals(""initial one two"", second.prevalentSystem().toString());
    second.close();
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.testDetectExistingSnapshotFromUnknownSnapshotManager,"  public void testDetectExistingSnapshotFromUnknownSnapshotManager() throws Exception {
    Prevayler<StringBuffer> first = createPrevayler(""xstreamsnapshot"", new XStreamSerializer());
    appendTakeSnapshotAndClose(first);

    try {
      createPrevayler(""snapshot"", new JavaSerializer());
      fail();
    } catch (IOException e) {
      // This is good because if we only looked for .snapshot files we could silently ignore an existing snapshot.
      assertTrue(""Actual message was <"" + e.getMessage() + "">"",
          e.getMessage().endsWith(""0000000000000000002.xstreamsnapshot cannot be read; only [snapshot] supported""));
    }
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.testMultipleSerializationStrategiesFromXStream,"  public void testMultipleSerializationStrategiesFromXStream() throws Exception {
    Prevayler<StringBuffer> prevayler = createPrevayler(""xstreamsnapshot"", new XStreamSerializer());
    appendTakeSnapshotAndClose(prevayler);

    checkSnapshotAndDeleteJournal(""0000000000000000002.xstreamsnapshot"", ""0000000000000000001.journal"");

    checkCanReadSnapshotWithMultipleStrategies();
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.testMultipleSerializationStrategiesFromJava,"  public void testMultipleSerializationStrategiesFromJava() throws Exception {
    Prevayler<StringBuffer> prevayler = createPrevayler(""snapshot"", new JavaSerializer());
    appendTakeSnapshotAndClose(prevayler);

    checkSnapshotAndDeleteJournal(""0000000000000000002.snapshot"", ""0000000000000000001.journal"");

    checkCanReadSnapshotWithMultipleStrategies();
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.testUsePrimaryForWritingSnapshot,"  public void testUsePrimaryForWritingSnapshot() throws Exception {
    Prevayler<StringBuffer> first = createPrevaylerMulti();
    appendTakeSnapshotAndClose(first);
    checkSnapshotAndDeleteJournal(""0000000000000000002.xstreamsnapshot"", ""0000000000000000001.journal"");

    Prevayler<StringBuffer> second = createPrevayler(""xstreamsnapshot"", new XStreamSerializer());
    assertEquals(""initial one two"", second.prevalentSystem().toString());
    second.close();
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.checkCanReadSnapshotWithMultipleStrategies,"  private void checkCanReadSnapshotWithMultipleStrategies() throws Exception {
    Prevayler<StringBuffer> prevayler = createPrevaylerMulti();
    assertEquals(""initial one two"", prevayler.prevalentSystem().toString());
    prevayler.close();
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.createPrevaylerMulti,"  private Prevayler<StringBuffer> createPrevaylerMulti() throws Exception {
    PrevaylerFactory<StringBuffer> factory = new PrevaylerFactory<StringBuffer>();
    factory.configurePrevalentSystem(new StringBuffer(""initial""));
    factory.configurePrevalenceDirectory(_testDirectory);
    factory.configureSnapshotSerializer(""xstreamsnapshot"", new XStreamSerializer());
    factory.configureSnapshotSerializer(""snapshot"", new JavaSerializer());
    return factory.create();
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.createPrevayler,"  private Prevayler<StringBuffer> createPrevayler(String suffix, Serializer serializer) throws Exception {
    PrevaylerFactory<StringBuffer> factory = new PrevaylerFactory<StringBuffer>();
    factory.configurePrevalentSystem(new StringBuffer(""initial""));
    factory.configurePrevalenceDirectory(_testDirectory);
    factory.configureSnapshotSerializer(suffix, serializer);
    return factory.create();
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.appendTakeSnapshotAndClose,"  private void appendTakeSnapshotAndClose(Prevayler<StringBuffer> prevayler) throws Exception {
    prevayler.execute(new AppendTransaction("" one""));
    prevayler.execute(new AppendTransaction("" two""));
    prevayler.takeSnapshot();
    prevayler.close();
  }"
org.prevayler.implementation.snapshot.GenericSnapshotManagerTest.checkSnapshotAndDeleteJournal,"  private void checkSnapshotAndDeleteJournal(String snapshot, String journal) {
    assertTrue(new File(_testDirectory, snapshot).exists());
    deleteFromTestDirectory(journal);
  }

"
org.prevayler.foundation.FileIOTest.setUp,"  protected void setUp() throws Exception {
    File tempFile = new File(""Test"" + System.currentTimeMillis() + counter++);
    assertTrue(""Unable to create directory "" + tempFile, tempFile.mkdirs());
    _testDirectory = tempFile.getAbsolutePath();
  }"
org.prevayler.foundation.FileIOTest.tearDown,"  protected void tearDown() throws Exception {
    delete(_testDirectory);
  }"
org.prevayler.foundation.FileIOTest.deleteFromTestDirectory,"  protected void deleteFromTestDirectory(String fileName) {
    delete(new File(_testDirectory + File.separator + fileName));
  }"
org.prevayler.foundation.FileIOTest.delete,"  static public void delete(String fileName) {
    delete(new File(fileName));
  }"
org.prevayler.foundation.FileIOTest.delete,"  static public void delete(File file) {
    if (file.isDirectory()) deleteDirectoryContents(file);
    assertTrue(""File does not exist: "" + file, file.exists());
    if (!file.delete()) {
      System.gc();
      assertTrue(""Unable to delete "" + file, file.delete());
    }
  }"
org.prevayler.foundation.FileIOTest.deleteDirectoryContents,"  static private void deleteDirectoryContents(File directory) {
    File[] files = directory.listFiles();
    if (files == null) return;
    for (int i = 0; i < files.length; i++) delete(files[i]);
  }"
org.prevayler.foundation.FileIOTest.journalContents,"  protected String journalContents(final String suffix) throws IOException {
    File journal = findJournal(suffix);

    FileInputStream file = new FileInputStream(journal);
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();

    int n;
    byte[] b = new byte[1024];
    while ((n = file.read(b)) != -1) {
      buffer.write(b, 0, n);
    }

    file.close();

    return buffer.toString(""ISO-8859-1"");
  }"
org.prevayler.foundation.FileIOTest.findJournal,"  protected File findJournal(final String suffix) {
    File[] files = new File(_testDirectory).listFiles(new FilenameFilter() {
      public boolean accept(File dir, String name) {
        return name.endsWith(""."" + suffix);
      }
    });
    assertEquals(1, files.length);
    return files[0];
  }

"
org.prevayler.foundation.FileIOTest.accept,"      public boolean accept(File dir, String name) {
        return name.endsWith(""."" + suffix);
      }
    "
org.prevayler.implementation.NondeterministicErrorTransaction.armBomb,"  public static synchronized void armBomb(int timeToDetonation) {
    _timeToDetonation = timeToDetonation;
  }"
org.prevayler.implementation.NondeterministicErrorTransaction.triggerBomb,"  private static synchronized void triggerBomb() {
    if (_timeToDetonation > 0 && --_timeToDetonation == 0) {
      throw new Error(""BOOM!"");
    }
  }"
org.prevayler.implementation.NondeterministicErrorTransaction.executeOn,"  public void executeOn(AppendingSystem prevalentSystem, Date executionTime) {
    triggerBomb();
    super.executeOn(prevalentSystem, executionTime);
  }

"
org.prevayler.implementation.AppendingSystem.value,"  String value() {
    return value;
  }"
org.prevayler.implementation.AppendingSystem.append,"  void append(String appendix) {
    value = value + appendix;
    if (appendix.equals(""rollback"")) throw new RuntimeException(""Testing Rollback"");
  }

"
org.prevayler.implementation.Sneaky.get,"/**
* Get a field value using reflection.
*
* @param root The object to start from.
* @param path The field name, or a ""path"" such as ""a.b.c"".
*/
  public static Object get(Object root, String path) throws Exception {
    int dot = path.indexOf('.');
    String first = dot == -1 ? path : path.substring(0, dot);
    String rest = dot == -1 ? null : path.substring(dot + 1);

    Field field = root.getClass().getDeclaredField(first);
    field.setAccessible(true);
    Object value = field.get(root);

    return rest == null ? value : get(value, rest);
  }

"
org.prevayler.implementation.Appendix.executeOn,"  public void executeOn(AppendingSystem prevalentSystem, Date ignored) {
    prevalentSystem.append(appendix);
  }"
org.prevayler.implementation.AppendTransaction.executeOn,"  public void executeOn(StringBuffer prevalentSystem, Date executionTime) {
    prevalentSystem.append(toAdd);
  }

"
org.prevayler.implementation.AppendTransactionWithQuery.executeAndQuery,"  public String executeAndQuery(StringBuffer prevalentSystem, Date executionTime) throws Exception {

    prevalentSystem.append(toAdd);
    return prevalentSystem.toString();
  }

"
org.prevayler.implementation.NullQuery.query,"  public Object query(Object prevalentSystem, Date executionTime) throws Exception {
    return null;
  }

"
org.prevayler.cluster.ClusteredPrevaylerTest.setUp,"  protected void setUp() throws Exception {
    super.setUp();
    prevalenceBase = createTempDirectory();
    factory = new PrevaylerFactory();
    factory.configureTransientMode(true);
    factory.configurePrevalentSystem(new ListSystem());
    prevayler1 = createPrevayler(""1"");
    prevayler2 = createPrevayler(""2"");
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.tearDown,"  protected void tearDown() throws Exception {
    super.tearDown();
    prevayler1.close();
    prevayler2.close();
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.testReplicationOfTransactions,"  public void testReplicationOfTransactions() throws Exception {
    Transaction<P> transaction = new AddToList(""Hello World"");
    prevayler1.execute(transaction);
    assertAllSystemsEqual();
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.testMultipleTransactionExecutions,"  public void testMultipleTransactionExecutions() throws Exception {
    Transaction transaction = new AddToList(""And once more"");
    prevayler2.execute(transaction);
    assertAllSystemsEqual();

    prevayler2.execute(transaction);
    assertAllSystemsEqual();
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.testSync,"  public void testSync() throws Exception {
    prevayler2.close();
    prevayler1.execute(new AddToList(""Hello World""));
    prevayler2 = createPrevayler(""2"");
    assertAllSystemsEqual();
    prevayler2.execute(new AddToList(""And some more worlds...""));
    assertAllSystemsEqual();
    prevayler1.close();
    prevayler1 = createPrevayler(""1"");
    assertAllSystemsEqual();
    assertEquals(""Hello WorldAnd some more worlds..."", prevayler1.prevalentSystem().text.toString());
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.testRestartingClusterWillKeepData,"  public void testRestartingClusterWillKeepData() throws Exception {
    prevayler1.close();
    prevayler2.close();
    factory.configureTransientMode(false);
    prevayler1 = createPrevayler(""1"");
    prevayler2 = createPrevayler(""2"");

    prevayler1.execute(new AddToList(""Hello world is persistent""));
    assertNotNull(new File(prevalenceBase(""new1"")).list());
    assertEquals(""Hello world is persistent"", prevayler1.prevalentSystem().text.toString());
    assertAllSystemsEqual();

    prevayler1.close();
    prevayler2.close();

    prevayler1 = createPrevayler(""1"");
    prevayler2 = createPrevayler(""2"");

    assertEquals(""Hello world is persistent"", prevayler1.prevalentSystem().text.toString());
    assertAllSystemsEqual();
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.testLocking,"  public void testLocking() throws Exception {
    Thread t1 = createAddToListThread(prevayler1, ""1"");
    Thread t2 = createAddToListThread(prevayler1, ""2"");
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    assertEquals(20, prevayler1.prevalentSystem().text.length());
    assertAllSystemsEqual();
    System.out.println(prevayler1.prevalentSystem());
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.createAddToListThread,"  private Thread createAddToListThread(final Prevayler prevayler, final String string) {
    return new Thread() {
      public void run() {
        for (int i = 0; i < 10; i++) {
          prevayler.execute(new AddToList(string));
        }
      }
    };
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.run,"      public void run() {
        for (int i = 0; i < 10; i++) {
          prevayler.execute(new AddToList(string));
        }
      }
    "
org.prevayler.cluster.ClusteredPrevaylerTest.assertAllSystemsEqual,"  private void assertAllSystemsEqual() {
    assertEquals(prevayler1.prevalentSystem(), prevayler2.prevalentSystem());
    assertEquals(prevayler1.clock().time(), prevayler2.clock().time());
    assertObjectsInSystemNotSame();
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.assertObjectsInSystemNotSame,"  private void assertObjectsInSystemNotSame() {
    assertNotSame(prevayler1.prevalentSystem().text, prevayler2.prevalentSystem().text);
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.createPrevayler,"  private ClusteredPrevayler createPrevayler(String name) throws Exception {
    factory.configurePrevalentSystem(new ListSystem());
    return new ClusteredPrevayler(factory, prevalenceBase(""old"" + name), prevalenceBase(""new"" + name));
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.prevalenceBase,"  private String prevalenceBase(String name) {
    return new File(prevalenceBase, name).getAbsolutePath();
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.createTempDirectory,"  private File createTempDirectory() throws IOException {
    File dir = File.createTempFile(""prevalenceBase"", "".tmp"");
    dir.delete();
    dir.mkdirs();
    return dir;
  }"
org.prevayler.cluster.ClusteredPrevaylerTest.executeOn,"    public void executeOn(ListSystem prevalentSystem, Date executionTime) {
      ListSystem list = prevalentSystem;
      list.add(string, executionTime);
    }
  }

  private static class ListSystem implements Serializable {
    private StringBuffer text = new StringBuffer();

    public void add(String string, Date executionTime) {
      text.append(string);
    }

    public boolean equals(Object o) {
      if (this == o) return true;
      if (!(o instanceof ListSystem)) return false;

      final ListSystem clockedList = (ListSystem) o;

      if (!text.toString().equals(clockedList.text.toString())) return false;

      return true;
    }

    public int hashCode() {
      int result;
      result = (text != null ? text.hashCode() : 0);
      return result;
    }

    public String toString() {
      return ""ClockedList@"" + hashCode() + "" text: "" + text;
    }
  "
org.prevayler.cluster.ClusteredPrevaylerTest.add,"    public void add(String string, Date executionTime) {
      text.append(string);
    }"
org.prevayler.cluster.ClusteredPrevaylerTest.equals,"    public boolean equals(Object o) {
      if (this == o) return true;
      if (!(o instanceof ListSystem)) return false;

      final ListSystem clockedList = (ListSystem) o;

      if (!text.toString().equals(clockedList.text.toString())) return false;

      return true;
    }"
org.prevayler.cluster.ClusteredPrevaylerTest.hashCode,"    public int hashCode() {
      int result;
      result = (text != null ? text.hashCode() : 0);
      return result;
    }"
org.prevayler.cluster.ClusteredPrevaylerTest.toString,"    public String toString() {
      return ""ClockedList@"" + hashCode() + "" text: "" + text;
    }
  "
org.prevayler.cluster.NodeTest.setUp,"  protected void setUp() throws Exception {
    super.setUp();
    node = new Node();
    receivedMessages = new ArrayList();
  }"
org.prevayler.cluster.NodeTest.tearDown,"  protected void tearDown() throws Exception {
    super.tearDown();
    node.shutdown();
  }"
org.prevayler.cluster.NodeTest.testFindNodes,"  public void testFindNodes() throws Exception {
    assertEquals(1, node.getNumberOfNodesInCluster());
    Node node2 = createNodeAndWait();
    assertEquals(2, node.getNumberOfNodesInCluster());
    node2.shutdown();
    assertEquals(1, node.getNumberOfNodesInCluster());
  }"
org.prevayler.cluster.NodeTest.testAssignMaster,"  public void testAssignMaster() throws Exception {
    assertEquals(node.getAddress(), node.getMasterAddress());
    Node node2 = createNodeAndWait();
    assertEquals(node.getAddress(), node2.getMasterAddress());
    assertFalse(node.getAddress().equals(node2.getAddress()));
    node.shutdown();
    assertEquals(node2.getAddress(), node2.getMasterAddress());
    node2.shutdown();
  }"
org.prevayler.cluster.NodeTest.testMultipleNodes,"  public void testMultipleNodes() throws Exception {
    Node node2 = createNodeAndWait();
    assertEquals(node.getAddress(), node.getMasterAddress());
    assertEquals(node.getAddress(), node2.getMasterAddress());
    node2.shutdown();
  }"
org.prevayler.cluster.NodeTest.testBroadCast,"  public void testBroadCast() throws Exception {
    Node node2 = createNodeAndWait();
    node2.setListener(createListAddListener());
    String message = ""Hello World"";
    node.broadcast(message);
    assertEquals(1, receivedMessages.size());
    assertEquals(message, receivedMessages.get(0));
    node2.shutdown();
  }"
org.prevayler.cluster.NodeTest.testMultipleMessages,"  public void testMultipleMessages() throws Exception {
    Node node2 = createNodeAndWait();
    node.setListener(createListAddListener());
    int numberOfMessages = 100;
    for (int i = 0; i < numberOfMessages; i++) {
      if (numberOfMessages % 2 == 0) {
        node.broadcast(Integer.valueOf(i));
      } else {
        node2.broadcast(Integer.valueOf(i));
      }
    }
    node2.shutdown();
    assertEquals(100, receivedMessages.size());
    for (int i = 0; i < numberOfMessages; i++) {
      assertEquals(Integer.valueOf(i), receivedMessages.get(i));
    }
  }"
org.prevayler.cluster.NodeTest.createListAddListener,"  private ClusterListener createListAddListener() {
    return new ClusterListener() {
      public Object receive(Object message) {
        receivedMessages.add(message);
        return null;
      }

      public Object getState() {
        return null;
      }

      public void setState(Object state) {
      }
    };
  }"
org.prevayler.cluster.NodeTest.receive,"      public Object receive(Object message) {
        receivedMessages.add(message);
        return null;
      }"
org.prevayler.cluster.NodeTest.getState,"      public Object getState() {
        return null;
      }"
org.prevayler.cluster.NodeTest.setState,"      public void setState(Object state) {
      }
    "
org.prevayler.cluster.NodeTest.createNodeAndWait,"  private Node createNodeAndWait() throws InterruptedException {
    Node node = new Node();
    node.waitForConnection();
    return node;
  }
"
org.prevayler.cluster.ClusteredTransaction.executeOn,"  public Object executeOn(ClusteredPrevayler<P> prevayler) {
    // TODO what about executionTime!
    System.out.println(""Executing "" + transaction);
    try {
      prevayler.executeBroadcastedTransaction(transaction);
    } catch (Throwable t) {
      t.printStackTrace();
    }
    return null;
  }
"
org.prevayler.cluster.Node.viewAccepted,"  public void viewAccepted(View view) {
    System.out.println(""Members "" + view.size());
  }"
org.prevayler.cluster.Node.suspect,"  public void suspect(Address suspected_mbr) {
  }"
org.prevayler.cluster.Node.block,"  public void block() {
  }"
org.prevayler.cluster.Node.receive,"  public void receive(Message msg) {
  }"
org.prevayler.cluster.Node.getState,"  public byte[] getState() {
    System.out.println(""Getting state"");
    if (listener != null) {
      try {
        return Util.objectToByteBuffer(listener.getState());
      } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException(e.toString());
      }
    }
    return null;
  }"
org.prevayler.cluster.Node.setState,"  public void setState(byte[] state) {
    System.out.println(""Setting state"");
    try {
      if (listener != null) {
        listener.setState((P) Util.objectFromByteBuffer(state));
      }
    } catch (Exception e) {
      throw new RuntimeException(e.toString());
    } finally {
      try {
        // unlock cluster, lock acquired when state was requested
        releaseClusterWideLock();
      } catch (ChannelException e) {
        e.printStackTrace();
      }
    }
  }"
org.prevayler.cluster.Node.waitForConnection,"  public void waitForConnection() throws InterruptedException {
    broadcast(""Node Connecting"");
  }"
org.prevayler.cluster.Node.getNumberOfNodesInCluster,"  public int getNumberOfNodesInCluster() {
    return channel.getView().getMembers().size();
  }"
org.prevayler.cluster.Node.broadcast,"  public void broadcast(Serializable message) {
    try {
      acquireClusterWideLock();
      synchronized (broadcastLock) {
        System.out.println(""Broadcasting "" + message);
        dispatcher.castMessage(null, new Message(null, null, message), GroupRequest.GET_ALL, 0);
      }
      releaseClusterWideLock();
    } catch (Exception e) {
      e.printStackTrace();
      throw new RuntimeException(e.toString());
    }
  }"
org.prevayler.cluster.Node.releaseClusterWideLock,"  private void releaseClusterWideLock() throws ChannelException {
    System.out.println(""Releasing cluster lock"");
    boolean lockReleased = false;
    while (!lockReleased) {
      try {
        distributedLockManager.unlock(LOCK_ID, lockChannel.getLocalAddress().toString());
        lockReleased = true;
      } catch (LockNotReleasedException e) {
      }
    }
    System.out.println(""Broadcast lock released"");
  }"
org.prevayler.cluster.Node.acquireClusterWideLock,"  private void acquireClusterWideLock() throws ChannelException {
    System.out.println(""Grabbing cluster lock"");
    boolean lockAcquired = false;
    while (!lockAcquired) {
      try {
        distributedLockManager.lock(LOCK_ID, lockChannel.getLocalAddress().toString(), 1000);
        lockAcquired = true;
      } catch (LockNotGrantedException e) {
      }
    }
  }"
org.prevayler.cluster.Node.handle,"  public Object handle(Message message) {
    System.out.println(""Received message "" + message + "" on "" + getAddress());
    if (listener != null) {
      return listener.receive((ClusteredTransaction<P>) message.getObject());
    }
    return null;
  }"
org.prevayler.cluster.Node.isMaster,"  public boolean isMaster() {
    return getAddress().equals(getMasterAddress());
  }"
org.prevayler.cluster.Node.getMasterAddress,"  public Address getMasterAddress() {
    try {
      Vector<Address> members = channel.getView().getMembers();
      Address master = members.firstElement();
      channel.getState(master, 1000);
      return channel.getView().getMembers().firstElement();
    } catch (Exception e) {
      throw new RuntimeException(e.toString());
    }
  }"
org.prevayler.cluster.Node.shutdown,"  public void shutdown() {
    channel.close();
    lockChannel.close();
    dispatcher.stop();
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
    }
  }"
org.prevayler.cluster.Node.setListener,"  public void setListener(ClusterListener<P> listener) {
    this.listener = listener;
  }"
org.prevayler.cluster.Node.getAddress,"  public Address getAddress() {
    return channel.getLocalAddress();
  }
  
"
org.prevayler.cluster.ClusteredPrevaylerState.getSystem,"  public P getSystem() {
    return system;
  }"
org.prevayler.cluster.ClusteredPrevaylerState.getTime,"  public Date getTime() {
    return time;
  }
"
org.prevayler.cluster.ClusterListener.getState,
org.prevayler.cluster.ClusterListener.setState,
org.prevayler.cluster.ClusterListener.receive,"  Object receive(ClusteredTransaction<P> transaction);
"
org.prevayler.cluster.ClusteredPrevayler.receive,"  public Object receive(ClusteredTransaction<P> transaction) {
    return transaction.executeOn(this);
  }"
org.prevayler.cluster.ClusteredPrevayler.getState,"  public P getState() {
    System.out.println(""Distributing system "" + prevalentSystem());
    return prevalentSystem();
  }"
org.prevayler.cluster.ClusteredPrevayler.setState,"  public void setState(P prevalentSystem) {
    if (prevalentSystem != null) {
      backupOldLocalTransactionLogs();
      factory.configurePrevalentSystem(prevalentSystem);
    }
    try {
      factory.configurePrevalenceDirectory(newPrevalenceBase);
      prevayler = factory.create();
      System.out.println(""Setting new system "" + prevayler.prevalentSystem());
      System.out.println(""Taking snapshot"");
      prevayler.takeSnapshot();
    } catch (Exception e) {
      e.printStackTrace();
      throw new RuntimeException(e.toString());
    }
  }"
org.prevayler.cluster.ClusteredPrevayler.prevalentSystem,"  public P prevalentSystem() {
    return prevayler.prevalentSystem();
  }"
org.prevayler.cluster.ClusteredPrevayler.clock,"  public Clock clock() {
    return prevayler.clock();
  }"
org.prevayler.cluster.ClusteredPrevayler.execute,"  public void execute(Transaction<? super P> transaction) {
    ClusteredTransaction<P> clusterTransaction = new ClusteredTransaction<P>(transaction, clock().time());
    System.out.println(""ClusterTransaction created = "" + clusterTransaction);
    node.broadcast(clusterTransaction);
  }"
org.prevayler.cluster.ClusteredPrevayler.execute,"  public <R> R execute(Query<? super P, R> sensitiveQuery) throws Exception {
    return prevayler.execute(sensitiveQuery);
  }"
org.prevayler.cluster.ClusteredPrevayler.execute,"  public <R> R execute(TransactionWithQuery<? super P, R> transactionWithQuery) throws Exception {
    throw new UnsupportedOperationException(""Not implemented"");
  }"
org.prevayler.cluster.ClusteredPrevayler.execute,"  public <R> R execute(SureTransactionWithQuery<? super P, R> sureTransactionWithQuery) {
    throw new UnsupportedOperationException(""Not implemented"");
  }"
org.prevayler.cluster.ClusteredPrevayler.takeSnapshot,"  public File takeSnapshot() throws Exception {
    return prevayler.takeSnapshot();
  }"
org.prevayler.cluster.ClusteredPrevayler.close,"  public void close() {
    node.shutdown();
  }"
org.prevayler.cluster.ClusteredPrevayler.backupOldLocalTransactionLogs,"  private void backupOldLocalTransactionLogs() {
    System.out.println(""Moving away old local transaction logs"");
    File oldPrevalenceBaseFile = new File(oldPrevalenceBase);
    File[] files = oldPrevalenceBaseFile.listFiles();
    if (files != null) {
      for (int i = 0; i < files.length; i++) {
        files[i].delete();
      }
    }
    oldPrevalenceBaseFile.delete();

    new File(newPrevalenceBase).renameTo(oldPrevalenceBaseFile);
  }"
org.prevayler.cluster.ClusteredPrevayler.executeBroadcastedTransaction,"  public void executeBroadcastedTransaction(Transaction<? super P> transaction) {
    prevayler.execute(transaction);
  }
"
org.prevayler.util.SnapshotScheduleLogger.snapshotStarted,"  public void snapshotStarted(Prevayler<P> prevayler, long prevaylerDate, long systemDate) {
    System.out.println(""prevayler clock date when snapshot started: "" + new java.util.Date(prevaylerDate));
    System.out.println(""system clock date when snapshot started: "" + new java.util.Date(systemDate));
  }"
org.prevayler.util.SnapshotScheduleLogger.snapshotTaken,"  public void snapshotTaken(Prevayler<P> prevayler, long prevaylerDate, long systemDate) {
    System.out.println(""prevayler clock date when snapshot completed: "" + new java.util.Date(prevaylerDate));
    System.out.println(""system clock date when snapshot completed: "" + new java.util.Date(systemDate));
  }"
org.prevayler.util.SnapshotScheduleLogger.snapshotException,"  public void snapshotException(Prevayler<P> prevayler, Exception exception, long prevaylerDate, long systemDate) {
    System.out.println(""prevayler clock date when Exception occured: "" + new java.util.Date(prevaylerDate));
    System.out.println(""system clock when Exception occured: "" + new java.util.Date(systemDate));
    System.out.println(""the exception was: "" + exception);
  }"
org.prevayler.util.SnapshotScheduleLogger.snapshotError,"  public void snapshotError(Prevayler<P> prevayler, Error error, long prevaylerDate, long systemDate) {
    System.out.println(""prevayler clock date when Error occured: "" + new java.util.Date(prevaylerDate));
    System.out.println(""system clock date when Error occured: "" + new java.util.Date(systemDate));
    System.out.println(""the error was: "" + error);
  }"
org.prevayler.util.SnapshotScheduleLogger.snapshotShutdown,"  public void snapshotShutdown(Prevayler<P> prevayler, long prevaylerDate, long systemDate) {
    System.out.println(""prevayler clock date when shutting down SnapshotMaker: "" + new java.util.Date(prevaylerDate));
    System.out.println(""system clock date when shutting down SnapshotMaker: "" + new java.util.Date(systemDate));
  }
"
org.prevayler.util.SnapshotListener.snapshotStarted,"/**
* SnapshotScheduler will start making a snapshot immediately
* after having informed all listeners.
*
* @param prevayler     the Prevayler system that this SnapshotScheduler is working on.
* @param prevaylerDate the date of the prevayler clock in milliseconds when the snapshot begins.
* @param systemDate    the date of the system clock in milliseconds when the snapshot begins.
*/
"
org.prevayler.util.SnapshotListener.snapshotTaken,"/**
* SnapshotScheduler has completed making a snapshot.
*
* @param prevayler     the Prevayler system that this SnapshotScheduler is working on.
* @param prevaylerDate the date of the prevayler clock in milliseconds when the snapshot was completed.
* @param systemDate    the date of the system clock in milliseconds when the snapshot was completed.
*/
"
org.prevayler.util.SnapshotListener.snapshotException,"/**
* An Exception has occured while making the snapshot.
*
* @param prevayler     the Prevayler system that this SnapshotScheduler is working on.
* @param exception     the Exception. Note that since Java 1.4, this can contain a chain
*                      of linked causes, see Throwable.getCause() for more information.
* @param prevaylerDate the date of the prevayler clock in milliseconds when the Exception occured.
* @param systemDate    the date of the system clock in milliseconds when the Exception occured.
* @see java.lang.Exception
*/
"
org.prevayler.util.SnapshotListener.snapshotError,"/**
* An Error has occured while making the snapshot.
* Quoting from the documentation from Java class Error:
* ""An Error is a subclass of Throwable that indicates serious problems
* that a reasonable application should not try to catch.
* Most such errors are abnormal conditions. [...]""
* <p/>
* SnapshotScheduler will quit making snapshots whenever an Error occurs and die
* after having informed all listeners through this method.
*
* @param prevayler     the Prevayler system that this SnapshotScheduler is working on.
* @param error         the Error. Note that since Java 1.4, this can contain a chain
*                      of linked causes, see Throwable.getCause() for more information.
* @param prevaylerDate the date of the prevayler clock in milliseconds when the Error occured.
* @param systemDate    the date of the system clock in milliseconds when the Error occured.
* @see java.lang.Error
*/
"
org.prevayler.util.SnapshotListener.snapshotShutdown,"/**
* SnapshotScheduler is shutting down after a call to cancel().
*
* @param prevayler     the Prevayler system that this SnapshotScheduler is working on.
* @param prevaylerDate the date of the prevayler clock in milliseconds when shutting down SnapshotScheduler.
* @param systemDate    the date of the system clock in milliseconds when shutting down SnapshotScheduler.
*/
  public void snapshotShutdown(Prevayler<P> prevayler, long prevaylerDate, long systemDate);
"
org.prevayler.util.SnapshotScheduler.run,"/**
* Make a snapshot.
*/
  public void run() {
    snapshotStarted();

    try {

      prevayler.takeSnapshot();

    } catch (Exception e) {

      // This is likely a temporary problem, so keep running.
      snapshotException(e);

    } catch (Error e) {

      snapshotError(e);

      // This is likely fatal, so reassert. See Java documentation for classes Error and Throwable.
      throw e;
    }

    snapshotTaken();
  }"
org.prevayler.util.SnapshotScheduler.cancel,"/**
* Stop making snapshots. If a snapshot is being made at the time of this call
* it will be completed, but no further snapshots will be made.
*/
  public boolean cancel() {
    snapshotShutdown();
    return super.cancel();
  }"
org.prevayler.util.SnapshotScheduler.removeListener,"/**
* Remove the given listener from this SnapshotScheduler, no more
* notifications will occur to the given listener.
*
* @param listener listener to remove.
*/
  public void removeListener(SnapshotListener<P> listener) {
    listenerList.remove(listener);
  }"
org.prevayler.util.SnapshotScheduler.addListener,"/**
* Add the given listener to this SnapshotScheduler; the listener will be notified
* on the progress of making snapshots.
*
* @param listener listener to add.
*/
  public void addListener(SnapshotListener<P> listener) {
    listenerList.add(listener);
  }"
org.prevayler.util.SnapshotScheduler.snapshotStarted,"/**
* Inform all listeners that a new snapshot is about to be made immediately.
*/
  private void snapshotStarted() {
    long prevaylerDate = prevayler.clock().time().getTime();
    long systemDate = System.currentTimeMillis();

    Iterator<SnapshotListener<P>> i = listenerList.iterator();
    while (i.hasNext()) {
      i.next().snapshotStarted(prevayler, prevaylerDate, systemDate);
    }
  }"
org.prevayler.util.SnapshotScheduler.snapshotTaken,"/**
* Inform all interested listeners that a new snapshot has been made.
*/
  private void snapshotTaken() {
    long prevaylerDate = prevayler.clock().time().getTime();
    long systemDate = System.currentTimeMillis();

    Iterator<SnapshotListener<P>> i = listenerList.iterator();
    while (i.hasNext()) {
      i.next().snapshotTaken(prevayler, prevaylerDate, systemDate);
    }
  }"
org.prevayler.util.SnapshotScheduler.snapshotException,"/**
* Inform all listeners that an exception occured while making the snapshot.
*/
  private void snapshotException(Exception e) {
    long prevaylerDate = prevayler.clock().time().getTime();
    long systemDate = System.currentTimeMillis();

    Iterator<SnapshotListener<P>> i = listenerList.iterator();
    while (i.hasNext()) {
      i.next().snapshotException(prevayler, e, prevaylerDate, systemDate);
    }
  }"
org.prevayler.util.SnapshotScheduler.snapshotError,"/**
* Inform all listeners that an exception occured while making the snapshot.
*/
  private void snapshotError(Error e) {
    long prevaylerDate = prevayler.clock().time().getTime();
    long systemDate = System.currentTimeMillis();

    Iterator<SnapshotListener<P>> i = listenerList.iterator();
    while (i.hasNext()) {
      i.next().snapshotError(prevayler, e, prevaylerDate, systemDate);
    }
  }"
org.prevayler.util.SnapshotScheduler.snapshotShutdown,"/**
* Inform all listeners that SnapshotScheduler is shutting down.
*/
  private void snapshotShutdown() {
    long prevaylerDate = prevayler.clock().time().getTime();
    long systemDate = System.currentTimeMillis();

    Iterator<SnapshotListener<P>> i = listenerList.iterator();
    while (i.hasNext()) {
      i.next().snapshotShutdown(prevayler, prevaylerDate, systemDate);
    }
  }
"
org.prevayler.implementation.ReplicationTest.testServerFirst,"  public void testServerFirst() throws Exception {
    serverCrashRecover(0);
    clientCrashRecover(0);
    serverAppend(""a"", ""a"");
    serverAppend(""b"", ""ab"");
    clientAppend(""c"", ""abc"");
    clientAppend(""d"", ""abcd"");
    serverAppend(""e"", ""abcde"");

    clientCrashRecover(0);
    assertEquals(""abcde"", clientValue());

    clientAppend(""f"", ""abcdef"");
    serverAppend(""g"", ""abcdefg"");

    networkCrash();
    threadToRestartNetworkAfterAWhile().start();
    _server.execute(new Appendix(""h""));
    clientAppend(""i"", ""abcdefghi"");  //Blocks until the network is restarted.

    serverAppend(""j"", ""abcdefghij"");
    clientAppend(""k"", ""abcdefghijk"");
  }"
org.prevayler.implementation.ReplicationTest.networkCrash,"  private void networkCrash() {
    //TODO NETWORK_MOCK.crash();    Implement a FaultTolerantNetwork so Prevayler doesn't have to worry about it. (!!!!)
  }"
org.prevayler.implementation.ReplicationTest.threadToRestartNetworkAfterAWhile,"  private Thread threadToRestartNetworkAfterAWhile() {
    return new Thread() {
      public void run() {
        Cool.sleep(300);
        //TODO NETWORK_MOCK.recover();
      }
    };
  }"
org.prevayler.implementation.ReplicationTest.run,"      public void run() {
        Cool.sleep(300);
        //TODO NETWORK_MOCK.recover();
      }
    "
org.prevayler.implementation.ReplicationTest.testClientFirst,"  public void testClientFirst() throws Exception {
    serverCrashRecover(1);
    clientCrashRecover(1);
    clientAppend(""a"", ""a"");
    clientAppend(""b"", ""ab"");
    serverAppend(""c"", ""abc"");
  }

/* //TODO Test replication chaining.
  public void testChaining() throws Exception {
    serverCrashRecover(2);
    clientWithServerCrashRecover(2, 3);
    clientCrashRecover(3);
    clientAppend(""a"", ""a"");
    clientAppend(""b"", ""ab"");
    serverAppend(""c"", ""abc"");
  }"
org.prevayler.implementation.ReplicationTest.serverAppend,"  private void serverAppend(String appendix, String expectedResult) {
    append(_server, appendix, expectedResult);
  }"
org.prevayler.implementation.ReplicationTest.clientAppend,"  private void clientAppend(String appendix, String expectedResult) {
    append(_client, appendix, expectedResult);
  }"
org.prevayler.implementation.ReplicationTest.append,"  private void append(Prevayler<AppendingSystem> prevayler, String appendix, String expectedResult) {
    prevayler.execute(new Appendix(appendix));
    Cool.sleep(10);
    assertEquals(expectedResult, serverValue());
    assertEquals(expectedResult, clientValue());
  }"
org.prevayler.implementation.ReplicationTest.serverCrashRecover,"  private void serverCrashRecover(int portOffset) throws Exception {
    PrevaylerFactory<AppendingSystem> factory = factory(""server"");
    factory.configureReplicationServer(PrevaylerFactory.DEFAULT_REPLICATION_PORT + portOffset);
    factory.configureTransientMode(true);
    _server = factory.create();
  }"
org.prevayler.implementation.ReplicationTest.clientCrashRecover,"  private void clientCrashRecover(int portOffset) throws Exception {
    PrevaylerFactory<AppendingSystem> factory = factory(""client"");
    factory.configureReplicationClient(""localhost"", PrevaylerFactory.DEFAULT_REPLICATION_PORT + portOffset);
    _client = factory.create();
  }"
org.prevayler.implementation.ReplicationTest.factory,"  private PrevaylerFactory<AppendingSystem> factory(String directory) {
    PrevaylerFactory<AppendingSystem> factory = new PrevaylerFactory<AppendingSystem>();
    factory.configurePrevalentSystem(new AppendingSystem());
    factory.configurePrevalenceDirectory(_testDirectory + File.separator + directory);
    return factory;
  }"
org.prevayler.implementation.ReplicationTest.tearDown,"  protected void tearDown() throws Exception {
    _server = null;
    _client = null;
    super.tearDown();
  }"
org.prevayler.implementation.ReplicationTest.serverValue,"  private String serverValue() {
    return _server.prevalentSystem().value();
  }"
org.prevayler.implementation.ReplicationTest.clientValue,"  private String clientValue() {
    Cool.sleep(100);  //The client is notified asynchronously.
    return _client.prevalentSystem().value();
  }

"
org.prevayler.socketserver.util.Log.error,"/**
* Log an application error
*
* @param e       The exception object
* @param message The message to log
*/
  public static void error(Exception e, String message) {
    System.err.println(message);
    e.printStackTrace();
  }"
org.prevayler.socketserver.util.Log.message,"/**
* Method message. Log a message
*
* @param message The message to log
*/
  public static void message(String message) {
    System.out.println(message);
  }"
org.prevayler.socketserver.util.Log.debug,"/**
* Method message. Log a debug message
*
* @param message The message to log
*/
  public static void debug(String message) {
    System.out.println(message);
  }

"
org.prevayler.socketserver.util.Config.init,"  private void init() {
    // Init the default property values
    Properties props = getDefaultProps();

    // Create root app properties object
    properties = new Properties(props);

    // Try to load it from disk
    propertyFile = System.getProperty(""user.dir"") + ""/"" + propertyFile;
    try {
      properties.load(new FileInputStream(propertyFile));
    } catch (IOException e) {
      try {
        props.store(new FileOutputStream(propertyFile), getConfigHeader());
        properties.load(new FileInputStream(propertyFile));
      } catch (IOException e2) {
        Log.error(e, ""Could not save default properties"");
      }
    }

    configFile = this;
  }"
org.prevayler.socketserver.util.Config.getDefaultProps,"/**
* This method creates and initializes initializes a Properties object
* with the default values for all properties stored in the config file.
* It <b>must</b> be overriden in a derived class.
*
* @return Properties the default properties
*/
"
org.prevayler.socketserver.util.Config.getConfigHeader,"/**
* This method returns the string that is stored in the comment at the
* top of the config file.  It must be overridden in a derived class.
*/
"
org.prevayler.socketserver.util.Config.store,"/**
* Store the current configuration properties in the configuration file
*
* @throws IOException if an error happened while storing
*/
  public void store() throws IOException {
    properties.store(new FileOutputStream(propertyFile), getConfigHeader());
  }

"
org.prevayler.socketserver.example.server.TodoList.toArray,"  public Todo[] toArray() {
    Todo[] results = new Todo[todoList.size()];
    int i = 0;
    Iterator<Integer> iter = todoList.keySet().iterator();
    while (iter.hasNext()) {
      results[i] = todoList.get(iter.next());
      ++i;
    }
    return results;
  }"
org.prevayler.socketserver.example.server.TodoList.newTodo,"  public Todo newTodo() {
    int id = nextID;
    ++nextID;
    Todo todo = new Todo(id);
    todoList.put(id, todo);
    return todo;
  }"
org.prevayler.socketserver.example.server.TodoList.get,"  public Todo get(int id) {
    return todoList.get(id);
  }
"
org.prevayler.socketserver.example.server.Todo.getId,"/**
* Returns the id.
*
* @return int
*/
  public int getId() {
    return id;
  }"
org.prevayler.socketserver.example.server.Todo.getDesc,"/**
* Returns the desc.
*
* @return String
*/
  public String getDesc() {
    return desc;
  }"
org.prevayler.socketserver.example.server.Todo.setDesc,"/**
* Sets the desc.
*
* @param desc The desc to set
*/
  public void setDesc(String desc) {
    this.desc = desc;
  }

"
org.prevayler.socketserver.example.transactions.CreateTodoBean.executeAndQuery,"/**
* @see org.prevayler.util.TransactionWithQuery#executeAndQuery(Object, Date)
*/
  public Todo executeAndQuery(TodoList todoList, Date timestamp) throws Exception {
    Todo todo = todoList.newTodo();
    todo.setDesc(desc);

    // Notify interested clients that the list just changed
    // Note that much more complex notification schemes can be devised
    // than this.
    Notification.submit(senderID, ""ListChanged"", todoList);
    return todo;
  }

"
org.prevayler.socketserver.example.transactions.ListTodos.executeAndQuery,"/**
* @see org.prevayler.util.TransactionWithQuery#executeAndQuery(Object, Date)
*/
  public TodoList executeAndQuery(TodoList todoList, Date timestamp) throws Exception {
    return todoList;
  }

"
org.prevayler.socketserver.example.client.ClientConfig.getConfigHeader,"/**
* @see org.prevayler.socketserver.util.Config#getConfigHeader()
*/
  public String getConfigHeader() {
    return ""Todo client config"";
  }"
org.prevayler.socketserver.example.client.ClientConfig.getDefaultProps,"/**
* @see org.prevayler.socketserver.util.Config#getDefaultProps()
*/
  public Properties getDefaultProps() {
    // Init the default property values
    Properties props = new Properties();
    props.put(""BasePort"", ""7000"");
    props.put(""RemoteHost"", ""localhost"");
    return props;
  }

"
org.prevayler.socketserver.example.client.Main.printList,"  public static synchronized void printList(Object todoList) {
    TodoList theList = (TodoList) todoList;
    Todo[] items = theList.toArray();
    for (int i = 0; i < items.length; i++) {
      System.out.println(items[i].getId() + ""\t"" + items[i].getDesc());
    }
    System.out.println();
  }"
org.prevayler.socketserver.example.client.Main.toUpperCase,"  private static char toUpperCase(char ch) {
    String result = """";
    result += ch;
    result = result.toUpperCase();
    return result.toCharArray()[0];
  }"
org.prevayler.socketserver.example.client.Main.invalidResponse,"  private static boolean invalidResponse(char response) {
    boolean responseIsInvalid = true;
    for (int i = 0; i < responses.length && responseIsInvalid; i++) {
      if (responses[i] == response) {
        responseIsInvalid = false;
      }
    }
    return responseIsInvalid;
  }"
org.prevayler.socketserver.example.client.Main.printMenu,"  public static void printMenu() {
    System.out.println(""L)ist todos;  A)dd todo;  E)xit"");
  }"
org.prevayler.socketserver.example.client.Main.addTodo,"  public static void addTodo() {
    System.out.println(""Please enter the todo item and press enter"");
    String response = """";
    try {
      // Throw away any pending newline characters
      char nextChar;
      do {
        nextChar = (char) System.in.read();
      } while (nextChar == '\n' || nextChar == '\r');
      response += nextChar;

      // Read the rest of the input line
      while (true) {
        nextChar = (char) System.in.read();
        if (nextChar == '\n' || nextChar == '\r') break;
        response += nextChar;
      }
    } catch (Exception e) {
      Log.error(e, ""Unable to read user input"");
    }

    // Add the new todo item
    Remote<TodoList> remote =  Remote.getConnection();
    remote.execl(new CreateTodoBean(response), ""Unable to add Todo"");
  }"
org.prevayler.socketserver.example.client.Main.mainMenu,"  public static void mainMenu() {
    try {
      // Print the current todo list
      System.out.println();
      Remote<TodoList> remote = Remote.getConnection();
      printList(remote.execl(new ListTodos(), ""Unable to list todos""));

      // Display the menu the first time
      printMenu();

      while (true) {
        // Get the response
        char response;
        do {
          response = (char) System.in.read();

          if (response == '\n') {
            printMenu();
          }

          response = toUpperCase(response);
        } while (invalidResponse(response));

        // Process it
        switch (response) {
          case 'L':
            printList(remote.execl(new ListTodos(), ""Unable to list todos""));
            break;
          case 'A':
            addTodo();
            break;
          case 'E':
            return;
        }
      }
    } catch (Exception e) {
      Log.error(e, ""Error in main menu loop"");
    }
  }"
org.prevayler.socketserver.example.client.Main.main,"  public static void main(String[] args) {
    Config.propertyFile = ""Todo.ini"";
    new ClientConfig();

    // Get the config options
    int basePort = Integer.parseInt(Config.properties.getProperty(""BasePort""));
    String remoteHost = Config.properties.getProperty(""RemoteHost"");

    // Connect to the server
    try {
      Remote.connect(remoteHost, basePort);
    } catch (Exception e) {
      Log.error(e, ""Error connecting to remote host: "" + remoteHost);
      return;
    }

    Remote<TodoList> remote = Remote.getConnection();
    // Listen to interesting events
    try {
      remote.registerCallback(""ListChanged"", new IModelCallback() {
        public void happened(Long connectionID, String name, Object obj) {
          // We'll just re-print the list when a change happens.
          // Note that this will happen in a background thread.
          System.out.println();
          Main.printList(obj);
          Main.printMenu();
        }
      });
    } catch (Exception e) {
      Log.error(e, ""Unable to register callback"");
      return;
    }

    // Run the main loop
    mainMenu();

    // Close the connection
    try {
      remote.close();
    } catch (Exception e) {
      Log.error(e, ""Unable to close client connection"");
    }
  }
"
org.prevayler.socketserver.example.client.Main.happened,"        public void happened(Long connectionID, String name, Object obj) {
          // We'll just re-print the list when a change happens.
          // Note that this will happen in a background thread.
          System.out.println();
          Main.printList(obj);
          Main.printMenu();
        }
      });
    } catch (Exception e) {
      Log.error(e, ""Unable to register callback"");
      return;
    }

    // Run the main loop
    mainMenu();

    // Close the connection
    try {
      remote.close();
    "
org.prevayler.socketserver.server.Notification.submit,"/**
* Submit a callback message to be sent
*
* @param message The message to be sent
* @param obj     An object (usually a model object) containing information about what happened.
*/
  public static synchronized void submit(Long senderID, String message, Object obj) {
    NotificationThread client;

    Iterator<NotificationThread> i = clients.iterator();
    while (i.hasNext()) {
      client = i.next();
      Long id = client.getSocketId();
      if (client.isAlive()) {
        if (enabledCallbacks.containsKey(id)) {
          Map<String, Integer> callbacks = enabledCallbacks.get(id);
          if (callbacks.containsKey(message)) {
            client.submit(senderID, message, obj);
          }
        }
      } else {
        // If the thread has died (the client disconnected), remove it
        i.remove();

        // ...and remove any callbacks registered for it
        enabledCallbacks.remove(id);
      }
    }
  }"
org.prevayler.socketserver.server.Notification.registerCallback,"/**
* Method registerCallback.  Called internally from the CommandThread server.
*
* @param myId    The id of the client requesting to receive the callback
* @param message The message the client wants to receive
*/
  public static void registerCallback(long myId, String message) {
    Map<String, Integer> callbacks;
    Long id = myId;
    // Get the hash of enabled callbacks for this connection ID
    if (enabledCallbacks.containsKey(id)) {
      callbacks = enabledCallbacks.get(id);
    } else {
      callbacks = new HashMap<String, Integer>();
      enabledCallbacks.put(id, callbacks);
    }

    // If this message isn't already registered, register it
    if (!callbacks.containsKey(message)) {
      callbacks.put(message, 1);
    } else {
      Integer numInterested = callbacks.get(message);
      callbacks.put(message, numInterested.intValue() + 1);
    }
  }"
org.prevayler.socketserver.server.Notification.unregisterCallback,"/**
* Method unregisterCallback.  Called internally from the CommandThread server.
*
* @param myId    The connection id requesting disinterest
* @param message The message in which the connection is no longer interested
*/
  public static void unregisterCallback(long myId, String message) {
    Map<String, Integer> callbacks = null;
    Long id = myId;
    // Get the hash of enabled callbacks for this connection ID
    if (enabledCallbacks.containsKey(id)) {
      callbacks = enabledCallbacks.get(id);
    }

    // Decrement the count of interested parties in this callback or remove it if nobody is interested
    if (callbacks != null) {
      if (callbacks.containsKey(message)) {
        Integer numInterested = callbacks.get(message);

        // If nobody is interested, remove the callback
        if (numInterested.intValue() == 1) {
          callbacks.remove(message);
        }
        // Otherwise, decrement the number of interested parties
        else {
          callbacks.put(message, numInterested.intValue() - 1);
        }
      }
    }
  }"
org.prevayler.socketserver.server.Notification.run,"  public void run() {
    ServerSocket ss = null;
    boolean listening = true;

    // Listen for a client connection and dispatch a thread to handle it
    try {
      ss = new ServerSocket(port);
    } catch (IOException e) {
      Log.error(e, ""Couldn't open notification server port"");
      System.exit(-1);
    }

    while (listening) {
      try {
        NotificationThread client = new NotificationThread(ss.accept());
        clients.add(client);
        client.start();
      } catch (Exception e) {
        Log.error(e, ""Notification server error"");
      }
    }
    try {
      ss.close();
    } catch (IOException e) {
      Log.error(e, ""Error closing notification server socket"");
    }
  }


"
org.prevayler.socketserver.server.Reaper.getNextID,"/**
* Method getNextID.
*
* @return Long The next ID
*/
  protected static long getNextID() {
    return id++;
  }"
org.prevayler.socketserver.server.Reaper.registerCommandThread,"/**
* Method registerCommandThread.<p>
* Registers a command thread with the reaper and returns an ID
*
* @return Long The id that was generated
*/
  public static long registerCommandThread() {
    long id = getNextID();
    return id;
  }"
org.prevayler.socketserver.server.Reaper.registerNotificationThread,"/**
* Method registerNotificationThread.
* Registers a notification thread with an associated command thread ID
* with the reaper
*
* @param id     The ID of the associated command thread
* @param thread The notification thread
*/
  public static void registerNotificationThread(Long id, NotificationThread thread) {
    notificationThreads.put(id, thread);
  }"
org.prevayler.socketserver.server.Reaper.reap,"/**
* Method commandThreadDied.
* Tells the reaper to kill the associated notification thread because the
* command thread died.
*
* @param id The ID of the command thread that died.
*/
  public static void reap(Long id) {
    NotificationThread thread = notificationThreads.get(id);
    if (thread != null) {
      if (thread.isAlive())
        thread.interrupt();
    }
    notificationThreads.remove(id);
  }
"
org.prevayler.socketserver.server.NotificationThread.getSocketId,"/**
* Returns the socket id.
*
* @return long
*/
  public Long getSocketId() {
    return id;
  }"
org.prevayler.socketserver.server.NotificationThread.submit,"/**
* Submit a message to be sent to the client
*
* @param message
*/
  public synchronized void submit(Long senderId, String message, Object obj) {
    messageQueue.add(new Message(senderId, message, obj));
    notifyAll();
  }"
org.prevayler.socketserver.server.NotificationThread.getMessage,"* Get a message from the message queue to send
*/
  private synchronized Message getMessage() {
    Message result;
    try {
      result = messageQueue.get(0);
      messageQueue.remove(0);
    } catch (NoSuchElementException e) {
      result = null;
    }
    return result;
  }"
org.prevayler.socketserver.server.NotificationThread.checkWait,"* Is the message queue empty?  If so, wait for a message.
*/
  private synchronized void checkWait() throws Exception {
    if (messageQueue.isEmpty())
      wait();
  }"
org.prevayler.socketserver.server.NotificationThread.handleNotifications,"* Request handling loop
*/
  private void handleNotifications() throws Exception {
    // This loop is broken when thread.interrupt() is called by the Reaper
    while (true) {
      checkWait();
      Message message = getMessage();
      ObjectOutputStream o = new ObjectOutputStream(socket.getOutputStream());
      o.writeObject(message.message);
      o = new ObjectOutputStream(socket.getOutputStream());
      o.writeObject(message.senderId);
      o.writeObject(message.obj);
    }
  }"
org.prevayler.socketserver.server.NotificationThread.run,"* Start a request handling loop and log exceptions
*/
  public void run() {
    try {
      handleNotifications();
    } catch (Exception e) {
      try {
        socket.close();
      } catch (Exception e2) {
      }
    }
  }

"
org.prevayler.socketserver.server.SnapshotThread.run,"/**
* @see java.lang.Runnable#run()
*/
  public void run() {
    super.run();

    Log.message(""A system snapshot will be taken every 24h..."");
    try {
      while (true) {
        Thread.sleep(1000 * 60 * 60 * 24);
        prevayler.takeSnapshot();
        Log.message(""Snapshot taken at "" + new java.util.Date() + ""..."");
      }
    } catch (InterruptedException e) {
      Log.message(""Snapshot thread interrupted; thread shutting down"");
    } catch (Exception e) {
      Log.error(e, ""Fatal exception while taking snapshot"");
      System.exit(1);
    }
  }
"
org.prevayler.socketserver.server.Main.initPrevayler,"  private static void initPrevayler() throws Exception {
    // Set up the repository location
    //String prevalenceBase = System.getProperty(""user.dir"") + ""/prevalenceBase"";
    String prevalenceBase = ServerConfig.properties.getProperty(""Repository"");
    Log.message(""Snapshot/log file dir: "" + prevalenceBase);

    // Set up the default port
    port = Integer.parseInt(ServerConfig.properties.getProperty(""BasePort""));

    // Set up the root object class
    String rootObjectClassName = ServerConfig.properties.getProperty(""RootObjectClass"");
    Class<?> rootObjectClass = Class.forName(rootObjectClassName);

    // Create an instance of the root object class and start the server
    //prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.getDeclaredConstructor().newInstance(), prevalenceBase);
    PrevaylerFactory<Object> factory = new PrevaylerFactory<Object>();
    factory.configurePrevalentSystem(rootObjectClass.getDeclaredConstructor().newInstance());
    factory.configurePrevalenceDirectory(prevalenceBase);
    prevayler = factory.create();
    snapshotThread = new SnapshotThread<Object>(prevayler);
    snapshotThread.start();
  }"
org.prevayler.socketserver.server.Main.runNotificationServer,"  private static void runNotificationServer() {
    new Notification(port + 1).start();
  }"
org.prevayler.socketserver.server.Main.runCommandServer,"  private static void runCommandServer() throws Exception {
    ServerSocket ss = null;
    boolean listening = true;

    // Listen dynamically
    try {
      ss = new ServerSocket(port);
    } catch (IOException e) {
      Log.error(e, ""Couldn't open command server port: "" + port);
      System.exit(-1);
    }

    while (listening)
      new CommandThread<Object>(prevayler, ss.accept()).start();

    ss.close();
  }"
org.prevayler.socketserver.server.Main.main,"  public static void main(String[] args) {
    try {
      new ServerConfig();
      initPrevayler();
      runNotificationServer();
      runCommandServer();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

"
org.prevayler.socketserver.server.CommandThread.handleRequests,"* Request handling loop
*/
  private void handleRequests() throws Exception {
    boolean done = false;
    ObjectOutputStream o = null;
    ObjectInputStream i = null;

    // First send the connection ID back to the client
    o = new ObjectOutputStream(socket.getOutputStream());
    o.writeObject(Long.valueOf(myId));

    // Now read commands in a loop until the client is done.
    while (!done) {
      i = new ObjectInputStream(socket.getInputStream());
      Object t = i.readObject();
      if (t instanceof Disconnect) {
        socket.close();
        done = true;
        Reaper.reap(myId);
      } else if (t instanceof RegisterCallback) {
        Notification.registerCallback(myId, ((RegisterCallback) t).message);
      } else if (t instanceof UnregisterCallback) {
        Notification.unregisterCallback(myId, ((UnregisterCallback) t).message);
      } else {
        ((IRemoteTransaction) t).setSenderID(myId);
        Serializable result;
        @SuppressWarnings(""unchecked"")
        TransactionWithQuery<P, ?> transaction = (TransactionWithQuery<P, ?>) t;
        try {
          result = (Serializable) prevayler.execute(transaction);
        } catch (Exception e) {
          result = new ThrownException(e);
        }

        o = new ObjectOutputStream(socket.getOutputStream());
        o.writeObject(result);
      }
    }
  }"
org.prevayler.socketserver.server.CommandThread.run,"* Start a request handling loop and log exceptions
*/
  public void run() {
    try {
      handleRequests();
    } catch (Exception e) {
      Reaper.reap(myId);
      try {
        socket.close();
      } catch (Exception e2) {
      }
      e.printStackTrace();
    }
  }
"
org.prevayler.socketserver.server.ServerConfig.getConfigHeader,"/**
* @see org.prevayler.socketserver.util.Config#getConfigHeader()
*/
  public String getConfigHeader() {
    return ""Prevayler Server Config"";
  }"
org.prevayler.socketserver.server.ServerConfig.getDefaultProps,"/**
* @see org.prevayler.socketserver.util.Config#getDefaultProps()
*/
  public Properties getDefaultProps() {
    // Init the default property values
    Properties props = new Properties();
    props.setProperty(""BasePort"", ""6000"");
    props.setProperty(""Repository"", System.getProperty(""user.dir"") + ""/prevalenceBase"");
    props.setProperty(""RootObjectClass"", """");
    return props;
  }

"
org.prevayler.socketserver.transactions.RemoteTransaction.setSenderID,"/**
* Sets the connectionID.
*
* @param connectionID The connectionID to set
*/
  public void setSenderID(Long connectionID) {
    this.senderID = connectionID;
  }"
org.prevayler.socketserver.transactions.RemoteTransaction.executeAndQuery,
org.prevayler.socketserver.transactions.RemoteTransaction.executeOn,"  public void executeOn(P prevalentSystem, Date timestamp) {
    try {
      executeAndQuery(prevalentSystem, timestamp);
    } catch (Exception e) {
    }
  }
"
org.prevayler.socketserver.transactions.IRemoteTransaction.setSenderID,"/**
* Sets the connectionID.
*
* @param connectionID The connectionID to set
*/
  public void setSenderID(Long connectionID);

"
org.prevayler.socketserver.client.CallbackThread.registerCallback,"/**
* Method registerCallback.
*
* @param message  The message or """" for all messages
* @param callback The callback object
* @return A handle to the callback you just created
*/
  public synchronized Object registerCallback(String message, IModelCallback callback) {
    CallbackNode c = new CallbackNode(message, callback);
    callbacks.addLast(c);
    return c;
  }"
org.prevayler.socketserver.client.CallbackThread.unregisterCallback,"/**
* Express disinterest in previously interesting callbacks
*
* @param callback The handle to the callback that you got when you created it
*/
  public synchronized void unregisterCallback(CallbackNode callback) {
    Iterator<CallbackNode> i = callbacks.iterator();
    while (i.hasNext()) {
      if (i.next() == callback) {
        i.remove();
      }
    }
    callback.freed = true;
  }"
org.prevayler.socketserver.client.CallbackThread.getCallbackMessage,"/**
* Method getCallbackMessage. Returns the message string for a callback object
*
* @param callback The callback object
* @return String The message this callback will send
*/
  public String getCallbackMessage(CallbackNode callback) {
    return callback.message;
  }"
org.prevayler.socketserver.client.CallbackThread.checkCallbackFreed,"/**
* Method checkCallbackFreed.  Makes sure a callback isn't already freed
*
* @param callback
* @throws CallbackAlreadyFreedException
*/
  public void checkCallbackFreed(CallbackNode callback) throws CallbackAlreadyFreedException {
    if (callback.freed)
      throw new CallbackAlreadyFreedException(""Callback has already been freed: "" + callback.message);
  }"
org.prevayler.socketserver.client.CallbackThread.callCallbacks,"* We've got a message, now call all callbacks that need to hear about it
*/
  private synchronized void callCallbacks(Long senderID, String message, Object obj) {
    Iterator<CallbackNode> i = callbacks.iterator();
    while (i.hasNext()) {
      CallbackNode c = i.next();
      if (c.message.equals(message) || c.message == """") {
        c.callback.happened(senderID, message, obj);
      }
    }
  }"
org.prevayler.socketserver.client.CallbackThread.run,"/**
* Process callbacks
*/
  public void run() {
    while (true) {
      try {
        ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
        String message = (String) in.readObject();
        in = new ObjectInputStream(socket.getInputStream());
        Long senderID = (Long) in.readObject();
        Object obj = in.readObject();
        callCallbacks(senderID, message, obj);
      } catch (Exception e) {
        if (e instanceof EOFException) {
          // Do nothing, this is normal behavior on connection close
          break;
        } else if (e instanceof SocketException) {
          Log.debug(""Server disconnected"");
          Log.debug(e.toString());
          break;
        } else {
          Log.error(e, ""Unexpected exception"");
        }
      }
    }
  }
"
org.prevayler.socketserver.client.Remote.getConnection,"  public static <P> Remote<P> getConnection() {
    return (Remote<P>) conn;
  }"
org.prevayler.socketserver.client.Remote.setConnection,"  public static void setConnection(Remote<?> conn) {
    Remote.conn =  conn;
  }"
org.prevayler.socketserver.client.Remote.connect,"/**
* A convenience method to connect to an object store and initialize the
* global connection variable for the common case that there is only
* 1 remote object store in the app.
*/
  public static void connect(String host, int port) throws IOException, ClassNotFoundException {
    conn = new Remote<Object>(host, port);
  }"
org.prevayler.socketserver.client.Remote.getConnectionID,"/**
* Returns the connectionID.
*
* @return Long
*/
  public Long getConnectionID() {
    return connectionID;
  }"
org.prevayler.socketserver.client.Remote.exec,"/**
* Execute a Prevayler transaction on the remote object store
*
* @param transaction
* @return Serializable
* @throws Exception
*/
  public synchronized Serializable exec(Transaction<? super P> transaction) throws Exception {
    out = new ObjectOutputStream(socket.getOutputStream());
    out.writeObject(transaction);
    in = new ObjectInputStream(socket.getInputStream());
    Object result = in.readObject();
    if (result instanceof ThrownException) {
      ThrownException thrownException = (ThrownException) result;
      throw thrownException.exception;
    }
    return (Serializable) result;
  }"
org.prevayler.socketserver.client.Remote.execl,"/**
* Method exec_LogErr. Execute a Prevayler transaction; log exceptions
* and include errorMsg in the log.
*
* @param transaction The transaction to execute
* @param errorMsg    The error message to log if an error occurs
* @return Serializable the result of running the transaction
*/
  public Serializable execl(Transaction<? super P> transaction, String errorMsg) {
    Serializable result = null;
    try {
      result = exec(transaction);
    } catch (Exception e) {
      Log.error(e, errorMsg);
      result = null;
    }
    return result;
  }

  /**
   * FIXME: Needs an abstraction layer so it works with either Swing or SWT clients
   *
   * Method exec_LogErr_Dialog.  Execute a Prevayler transaction; log exceptions
   * and include errorMsg in the log.  If an exception occurs, also show errorMsg
   * using a MsgDialog.
   *
   * @param transaction The transaction to execute
   * @param errorMsg The error message to display, if necessary
   * @param shell The parent shell for the MessageDlg
   * @return Serializable The result of running the remote transaction
   */
//    public Serializable execld(Transaction transaction, String errorMsg) {
//        Serializable result = null;
//        try {
//            result = exec(transaction);
//        } catch (Exception e) {
//            Log.error(e, errorMsg);
//            result = null;
//        }
//        return result;
//    }"
org.prevayler.socketserver.client.Remote.registerCallback,"/**
* Register interest in callbacks with ""message"" message
*
* @param message  The message in which to register interest
* @param callback The object to call when the event occurs
*/
  public Object registerCallback(String message, IModelCallback callback) throws IOException {
    // Tell the client to be prepared to receive the message
    Object result;
    result = callbackThread.registerCallback(message, callback);

    // If it's not a wildcard callback, tell the server it's okay to send the message
    if (!message.equals("""")) {
      out = new ObjectOutputStream(socket.getOutputStream());
      out.writeObject(new RegisterCallback(message));
    }
    return result;
  }"
org.prevayler.socketserver.client.Remote.unregisterCallback,"/**
* Method unregisterCallback.  Express disinterest in a previously interesting callback
*
* @param callback The callback object received when registering the callback
*/
  public void unregisterCallback(CallbackNode callback) throws IOException, CallbackAlreadyFreedException {
    callbackThread.checkCallbackFreed(callback);
    String message = callbackThread.getCallbackMessage(callback);

    // If we're not unregistering a ""wildcard"" callback...
    if (!message.equals("""")) {
      // ...tell the server to stop sending this message
      out = new ObjectOutputStream(socket.getOutputStream());
      out.writeObject(new UnregisterCallback(message));
    }

    // Tell the client not to expect to receive it any longer
    callbackThread.unregisterCallback(callback);
  }"
org.prevayler.socketserver.client.Remote.close,"/**
* Close the connection to the remote server
*
* @throws Exception
*/
  public void close() throws Exception {
    out = new ObjectOutputStream(socket.getOutputStream());
    out.writeObject(new Disconnect());
    socket.close();
  }

"
org.prevayler.socketserver.client.IModelCallback.happened,"/**
* Called when the event in which interest was registered happened
*
* @param name The name of the event that happened
*/
  public abstract void happened(Long connectionID, String name, Object obj);
"
junkyard.BeanSetter.callSetter,"/**
* Method callSetter.
*
* @param object
* @throws Exception
*/
  protected void callSetter(Object object) throws Exception {
    for (int i = 0; i < propertyDescriptors.length; i++) {
      if (propertyDescriptors[i].getName().equals(field)) {
        propertyDescriptors[i].getWriteMethod().invoke(object, new Object[]{value});
        break;
      }
    }
  }"
junkyard.BeanSetter.lookup,"/**
* Look-up the object on which the property value will be set
*
* @param prevalentSystem the system on which to look up the object
*/
"
junkyard.BeanSetter.executeAndQuery,"/**
* @see org.prevayler.util.TransactionWithQuery#executeAndQuery(Object, Date)
*/
  public R executeAndQuery(P prevalentSystem, Date timestamp) throws Exception {
    X subject = lookup(prevalentSystem);
    callSetter(subject);
    return null;
  }
"
junkyard.TodoBeanSetter.lookup,"/**
* @see org.prevayler.socketserver.example.transactions.BeanSetter#lookup(Object)
*/
  protected Todo lookup(TodoList todoList) throws Exception {
    return todoList.get(id);
  }
"
org.prevayler.foundation.network.ObjectSocket.writeObject,
org.prevayler.foundation.network.ObjectSocket.readObject,
org.prevayler.foundation.network.ObjectSocket.close,"  void close() throws IOException;

"
org.prevayler.foundation.network.OldNetworkImpl.openSocket,"  public ObjectSocket openSocket(String serverIpAddress, int serverPort) throws IOException {
    return new ObjectSocketImpl(serverIpAddress, serverPort);
  }"
org.prevayler.foundation.network.OldNetworkImpl.openObjectServerSocket,"  public ObjectServerSocket openObjectServerSocket(int port) throws IOException {
    return new ObjectServerSocketImpl(port);
  }
"
org.prevayler.foundation.network.ObjectServerSocketImpl.accept,"  public ObjectSocket accept() throws IOException {
    return new ObjectSocketImpl(_serverSocket.accept());
  }"
org.prevayler.foundation.network.ObjectServerSocketImpl.close,"  public void close() throws IOException {
    _serverSocket.close();
  }
"
org.prevayler.foundation.network.ObjectServerSocket.accept,
org.prevayler.foundation.network.ObjectServerSocket.close,"  void close() throws IOException;
"
org.prevayler.foundation.network.ObjectSocketImpl.writeObject,"  public void writeObject(Object object) throws IOException {
    //TODO Consider eliminating the POBox and putting a buffer here.
    _outputStream.writeObject(object);
    _outputStream.reset();
    _outputStream.flush();

  }"
org.prevayler.foundation.network.ObjectSocketImpl.readObject,"  public Object readObject() throws IOException, ClassNotFoundException {
    return _inputStream.readObject();
  }"
org.prevayler.foundation.network.ObjectSocketImpl.close,"  public void close() throws IOException {
    _outputStream.close();
    _inputStream.close();
    _socket.close();
  }
"
org.prevayler.implementation.replication.ServerListener.run,"  public void run() {
    try {
      while (true) new ServerConnection<P>(_publisher, _serverSocket.accept());
    } catch (IOException iox) {
      iox.printStackTrace();
    }
  }
"
org.prevayler.implementation.replication.ClientPublisher.startListening,"  private void startListening() {
    Thread listener = new Thread() {
      public void run() {
        try {
          while (true) receiveTransactionFromServer();
        } catch (Exception ex) {
          ex.printStackTrace();
        }
      }
    };
    listener.setDaemon(true);
    listener.start();
  }"
org.prevayler.implementation.replication.ClientPublisher.run,"      public void run() {
        try {
          while (true) receiveTransactionFromServer();
        } catch (Exception ex) {
          ex.printStackTrace();
        }
      }
    "
org.prevayler.implementation.replication.ClientPublisher.subscribe,"  public synchronized void subscribe(TransactionSubscriber<P> subscriber, long initialTransaction) throws IOException, ClassNotFoundException {
    if (_subscriber != null)
      throw new UnsupportedOperationException(""The current implementation can only support one subscriber. Future implementations will support more."");
    _subscriber = subscriber;
    synchronized (_upToDateMonitor) {
      _server.writeObject(Long.valueOf(initialTransaction));
      wait(_upToDateMonitor);
    }
  }"
org.prevayler.implementation.replication.ClientPublisher.cancelSubscription,"  public void cancelSubscription(TransactionSubscriber<P> subscriber) {
    throw new UnsupportedOperationException(""Removing subscribers is not yet supported by the current implementation."");
  }"
org.prevayler.implementation.replication.ClientPublisher.publish,"  public synchronized void publish(Capsule<? super P, ? extends TransactionBase> capsule) {
    if (_subscriber == null)
      throw new IllegalStateException(""To publish a transaction, this ClientPublisher needs a registered subscriber."");
    synchronized (_myCapsuleMonitor) {
      _myCapsule = capsule;

      try {
        _server.writeObject(capsule);
      } catch (IOException iox) {
        iox.printStackTrace();
        while (true) Thread.yield();  //Remove all exceptions when using StubbornNetwork.
      }
      wait(_myCapsuleMonitor);

      throwEventualErrors();
    }
  }"
org.prevayler.implementation.replication.ClientPublisher.throwEventualErrors,"  private void throwEventualErrors() throws RuntimeException, Error {
    try {
      if (_myTransactionRuntimeException != null) throw _myTransactionRuntimeException;
      if (_myTransactionError != null) throw _myTransactionError;
    } finally {
      _myTransactionRuntimeException = null;
      _myTransactionError = null;
    }
  }"
org.prevayler.implementation.replication.ClientPublisher.receiveTransactionFromServer,"  private void receiveTransactionFromServer() throws IOException, ClassNotFoundException {
    Object transactionCandidate = _server.readObject();

    if (transactionCandidate.equals(ServerConnection.SUBSCRIBER_UP_TO_DATE)) {
      synchronized (_upToDateMonitor) {
        _upToDateMonitor.notify();
      }
      return;
    }

    if (transactionCandidate instanceof Date) {
      Date clockTick = (Date) transactionCandidate;
      _clock.advanceTo(clockTick);
      return;
    }

    if (transactionCandidate instanceof RuntimeException) {
      _myTransactionRuntimeException = (RuntimeException) transactionCandidate;
      notifyMyTransactionMonitor();
      return;
    }
    if (transactionCandidate instanceof Error) {
      _myTransactionError = (Error) transactionCandidate;
      notifyMyTransactionMonitor();
      return;
    }

    @SuppressWarnings(""unchecked"")
    TransactionTimestamp<P> transactionTimestamp = (TransactionTimestamp<P>) transactionCandidate;
    Date timestamp = transactionTimestamp.executionTime();
    long systemVersion = transactionTimestamp.systemVersion();

    _clock.advanceTo(timestamp);

    if (transactionTimestamp.capsule() == null) {
      _subscriber.receive(new TransactionTimestamp<P>(_myCapsule, systemVersion, timestamp));
      notifyMyTransactionMonitor();
      return;
    }

    _subscriber.receive(new TransactionTimestamp<P>(transactionTimestamp.capsule(), systemVersion, timestamp));
  }"
org.prevayler.implementation.replication.ClientPublisher.wait,"  private static void wait(Object monitor) {
    try {
      monitor.wait();
    } catch (InterruptedException ix) {
      throw new RuntimeException(""Unexpected InterruptedException."");
    }
  }"
org.prevayler.implementation.replication.ClientPublisher.notifyMyTransactionMonitor,"  private void notifyMyTransactionMonitor() {
    synchronized (_myCapsuleMonitor) {
      _myCapsuleMonitor.notify();
    }
  }"
org.prevayler.implementation.replication.ClientPublisher.clock,"  public Clock clock() {
    return _clock;
  }"
org.prevayler.implementation.replication.ClientPublisher.close,"  public void close() throws IOException {
    _server.close();
  }

"
org.prevayler.implementation.replication.ServerConnection.run,"  public void run() {
    try {
      long initialTransaction = ((Long) _remote.readObject()).longValue();

      POBox<P> poBox = new POBox<P>(this);
      _publisher.subscribe(poBox, initialTransaction);
      poBox.waitToEmpty();

      send(SUBSCRIBER_UP_TO_DATE);

      startSendingClockTicks();
      while (true) publishRemoteTransaction();
    } catch (IOException ex) {
      close();
    } catch (ClassNotFoundException ex) {
      close();
    }
  }"
org.prevayler.implementation.replication.ServerConnection.startSendingClockTicks,"  private void startSendingClockTicks() {
    _clockTickSender.setDaemon(true);
    _clockTickSender.start();
  }"
org.prevayler.implementation.replication.ServerConnection.createClockTickSender,"  private Thread createClockTickSender() {
    return new Thread() { //TODO Consider using TimerTask.
      public void run() {
        try {
          while (true) {
            synchronized (_remote) {
              _remote.writeObject(_publisher.clock().time());
            }
            Thread.sleep(1000);
          }
        } catch (InterruptedException ix) {
        } catch (IOException iox) {
          close();
        }
      }
    };
  }"
org.prevayler.implementation.replication.ServerConnection.run,"      public void run() {
        try {
          while (true) {
            synchronized (_remote) {
              _remote.writeObject(_publisher.clock().time());
            }
            Thread.sleep(1000);
          }
        } catch (InterruptedException ix) {
        } catch (IOException iox) {
          close();
        }
      }
    "
org.prevayler.implementation.replication.ServerConnection.publishRemoteTransaction,"  void publishRemoteTransaction() throws IOException, ClassNotFoundException {
    _remoteCapsule = (Capsule<P, ? extends TransactionBase>) _remote.readObject();
    try {
      _publisher.publish(_remoteCapsule);
    } catch (RuntimeException rx) {
      send(rx);
    } catch (Error error) {
      send(error);
    }
  }"
org.prevayler.implementation.replication.ServerConnection.receive,"  public void receive(TransactionTimestamp<? super P> tt) {

    if (tt.capsule() == _remoteCapsule)
      tt = new TransactionTimestamp<P>(null, tt.systemVersion(), tt.executionTime()); //TODO This is really ugly. It is using a null capsule inside the TransactionTimestamp to signal that the remote Capsule should be executed.

    try {
      synchronized (_remote) {
        _remote.writeObject(tt);
      }
    } catch (IOException ex) {
      close();
    }
  }"
org.prevayler.implementation.replication.ServerConnection.close,"  private synchronized void close() {
    _clockTickSender.interrupt();
    this.interrupt();
    _publisher.cancelSubscription(this);
  }"
org.prevayler.implementation.replication.ServerConnection.send,"  private void send(Object object) {
    synchronized (_remote) {
      try {
        _remote.writeObject(object);
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }

"
org.prevayler.examples.e102.Root.getEntities,"  public Map<String, Entity> getEntities() {
    return entities;
  }"
org.prevayler.examples.e102.Root.setEntities,"  public void setEntities(Map<String, Entity> entities) {
    this.entities = entities;
  }
"
org.prevayler.examples.e102.NonDeterministicCreateEntityTransaction.executeAndQuery,"  public Entity executeAndQuery(Root prevalentSystem, Date executionTime) throws Exception {

    Entity entity = new Entity();
    entity.setIdentity(UUID.randomUUID().toString()); // This line of code is non deterministic
    // since a new identity will be assigned to the object every time the journal is replayed at startup.
    // This will severely mess with your system.

    prevalentSystem.getEntities().put(entity.getIdentity(), entity);
    return entity;
  }

"
org.prevayler.examples.e102.E102Test.testFailing,"  public void testFailing() throws Exception {

    // this will fail as a new random UUID will be assigned to the entity within the transaction
    // and will thus change every time journal is replayed!
    runTest(new NonDeterministicCreateEntityTransaction());

  }"
org.prevayler.examples.e102.E102Test.testPassing,"  public void testPassing() throws Exception {
    // this will not fail as a new random UUID is passed down to and is serialized with the transaction
    // and will thus be used every time the journal is replayed.
    runTest(new DeterministicCreateEntityTransaction(UUID.randomUUID().toString()));

  }"
org.prevayler.examples.e102.E102Test.runTest,"  private void runTest(TransactionWithQuery<Root, Entity> createEntityTransaction) throws Exception {

    // Create or load existing prevalence layer from journal and/or snapshot.
    String dataPath = ""target/PrevalenceBase_"" + System.currentTimeMillis();
    Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath);

    try {
      Entity entity = prevayler.execute(createEntityTransaction);
      final String identityOfEntityWhenInitiallyCreated = entity.getIdentity();

      assertSame(""entity and query response is supposed to be the same instance"", entity, prevayler.execute(new Query<Root, Entity>() {
        private static final long serialVersionUID = 2345967443241959260L;

        public Entity query(Root prevalentSystem, Date executionTime) throws Exception {
          return prevalentSystem.getEntities().get(identityOfEntityWhenInitiallyCreated);
        }
      }));

      assertEquals(""only one entity is supposed to exist in the root"", 1, (int) prevayler.execute(new Query<Root, Integer>() {
        private static final long serialVersionUID = -3193756627974872039L;

        public Integer query(Root prevalentSystem, Date executionTime) throws Exception {
          return prevalentSystem.getEntities().size();
        }
      }));

      // close and reopen prevalence so the journal is replayed
      prevayler.close();
      prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath);

      assertEquals(""only one entity is supposed to exist in the root"", 1, (int) prevayler.execute(new Query<Root, Integer>() {
        private static final long serialVersionUID = -4739548462309688139L;

        public Integer query(Root prevalentSystem, Date executionTime) throws Exception {
          return prevalentSystem.getEntities().size();
        }
      }));

      String identityOfTheOnlyEntityInRoot = prevayler.execute(new Query<Root, String>() {
        private static final long serialVersionUID = -449826861014013447L;

        public String query(Root prevalentSystem, Date executionTime) throws Exception {
          return prevalentSystem.getEntities().values().iterator().next().getIdentity();
        }
      });

      // this will fail if the setting of identity is non deterministic
      assertEquals(identityOfEntityWhenInitiallyCreated, identityOfTheOnlyEntityInRoot);

    } finally {
      prevayler.close();

    }


  }


"
org.prevayler.examples.e102.E102Test.query,"        public Entity query(Root prevalentSystem, Date executionTime) throws Exception {
          return prevalentSystem.getEntities().get(identityOfEntityWhenInitiallyCreated);
        }
      "
org.prevayler.examples.e102.E102Test.query,"        public Integer query(Root prevalentSystem, Date executionTime) throws Exception {
          return prevalentSystem.getEntities().size();
        }
      "
org.prevayler.examples.e102.E102Test.query,"        public Integer query(Root prevalentSystem, Date executionTime) throws Exception {
          return prevalentSystem.getEntities().size();
        }
      "
org.prevayler.examples.e102.E102Test.query,"        public String query(Root prevalentSystem, Date executionTime) throws Exception {
          return prevalentSystem.getEntities().values().iterator().next().getIdentity();
        }
      "
org.prevayler.examples.e102.Entity.equals,"  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Entity entity = (Entity) o;

    if (identity != null ? !identity.equals(entity.identity) : entity.identity != null) return false;

    return true;
  }"
org.prevayler.examples.e102.Entity.hashCode,"  public int hashCode() {
    return identity != null ? identity.hashCode() : 0;
  }"
org.prevayler.examples.e102.Entity.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e102.Entity.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }

"
org.prevayler.examples.e102.DeterministicCreateEntityTransaction.executeAndQuery,"  public Entity executeAndQuery(Root prevalentSystem, Date executionTime) throws Exception {

    Entity entity = new Entity();
    entity.setIdentity(identity);
    prevalentSystem.getEntities().put(entity.getIdentity(), entity);

    return entity;
  }"
org.prevayler.examples.e102.DeterministicCreateEntityTransaction.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e102.DeterministicCreateEntityTransaction.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }
"
org.prevayler.examples.e105.UpdateEntityTextTransaction.executeOn,"  public void executeOn(Root prevalentSystem, Date executionTime) {
    prevalentSystem.getEntities().get(identity).setText(text);
  }"
org.prevayler.examples.e105.UpdateEntityTextTransaction.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e105.UpdateEntityTextTransaction.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }"
org.prevayler.examples.e105.UpdateEntityTextTransaction.getText,"  public String getText() {
    return text;
  }"
org.prevayler.examples.e105.UpdateEntityTextTransaction.setText,"  public void setText(String text) {
    this.text = text;
  }
"
org.prevayler.examples.e105.Root.getEntities,"  public Map<String, Entity> getEntities() {
    return entities;
  }"
org.prevayler.examples.e105.Root.setEntities,"  public void setEntities(Map<String, Entity> entities) {
    this.entities = entities;
  }
"
org.prevayler.examples.e105.CreateEntityTransaction.executeAndQuery,"  public Entity executeAndQuery(Root prevalentSystem, Date executionTime) throws Exception {
    Entity entity = new Entity();
    entity.setIdentity(identity);
    prevalentSystem.getEntities().put(entity.getIdentity(), entity);
    return entity;
  }"
org.prevayler.examples.e105.CreateEntityTransaction.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e105.CreateEntityTransaction.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }
"
org.prevayler.examples.e105.E105Test.testFailing,"  public void testFailing() throws Exception {
    // This will update Entity#text outside of a transaction,
    // hence the change will NOT be written to the journal and is lost when closing Prevayler.
    new AbstractTest() {
      @Override
      protected void updateEntity(Prevayler<Root> prevayler, Entity entity, String value) throws Exception {
        entity.setText(value);
      }
    }.runTest();
  }"
org.prevayler.examples.e105.E105Test.updateEntity,"      protected void updateEntity(Prevayler<Root> prevayler, Entity entity, String value) throws Exception {
        entity.setText(value);
      }
    "
org.prevayler.examples.e105.E105Test.testPassing,"  public void testPassing() throws Exception {
    // This will update Entity#text from within a transaction,
    // i.e. the change will be written to the journal and thus available after closing and restarting Prevayler.
    new AbstractTest() {
      @Override
      protected void updateEntity(Prevayler<Root> prevayler, Entity entity, String value) throws Exception {
        prevayler.execute(new UpdateEntityTextTransaction(entity.getIdentity(), value));
      }
    }.runTest();
  }"
org.prevayler.examples.e105.E105Test.updateEntity,"      protected void updateEntity(Prevayler<Root> prevayler, Entity entity, String value) throws Exception {
        prevayler.execute(new UpdateEntityTextTransaction(entity.getIdentity(), value));
      }
    "
org.prevayler.examples.e105.E105Test.testPassingDueToSnapshot,"  public void testPassingDueToSnapshot() throws Exception {
    // This will update Entity#text outside of a transaction
    // and then take a snapshot of the complete prevalent system.
    // Hence changes will NOT be written the the journal but still available in the latest snapshot
    // and thus still available after closing Prevayler.
    //
    // THIS IS NEITHER ENDORSED NOR RECOMMENDED USE OF PREVAYLER
    //
    // DON'T EVEN CONSIDER DOING THIS UNLESS YOU KNOW WHAT YOU ARE DOING,
    // IT IS HERE SIMPLY TO DEMONSTRATE THAT IT'S POSSIBLE.
    new AbstractTest() {
      @Override
      protected void updateEntity(Prevayler<Root> prevayler, Entity entity, String value) throws Exception {
        entity.setText(value);
        prevayler.takeSnapshot();
      }
    }.runTest();
  }"
org.prevayler.examples.e105.E105Test.updateEntity,"      protected void updateEntity(Prevayler<Root> prevayler, Entity entity, String value) throws Exception {
        entity.setText(value);
        prevayler.takeSnapshot();
      }
    "
org.prevayler.examples.e105.E105Test.runTest,"    protected void runTest() throws Exception {

      // Create or load existing prevalence layer from journal and/or snapshot.
      String dataPath = ""target/PrevalenceBase_"" + System.currentTimeMillis();
      Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath);

      try {
        final String identity = UUID.randomUUID().toString();
        Entity entity = prevayler.execute(new CreateEntityTransaction(identity));

        assertNull(""entity text values is supposed to be null after creation"", entity.getText());

        String value = ""A text value"";
        updateEntity(prevayler, entity, value);

        assertEquals(""entity text value is supposed to have been updated"", value, entity.getText());

        // close and reopen prevalence so the journal is replayed
        prevayler.close();
        prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath);

        entity = prevayler.execute(new Query<Root, Entity>() {
          private static final long serialVersionUID = -4272231312465955589L;

          public Entity query(Root prevalentSystem, Date executionTime) throws Exception {
            return prevalentSystem.getEntities().get(identity);
          }
        });
        assertEquals(""entity text value is supposed to have been updated after restart"", value, entity.getText());

      } finally {
        prevayler.close();

      }

    }"
org.prevayler.examples.e105.E105Test.query,"          public Entity query(Root prevalentSystem, Date executionTime) throws Exception {
            return prevalentSystem.getEntities().get(identity);
          }
        "
org.prevayler.examples.e105.E105Test.updateEntity,"    protected abstract void updateEntity(Prevayler<Root> prevayler, Entity entity, String value) throws Exception;

  "
org.prevayler.examples.e105.Entity.getText,"  public String getText() {
    return text;
  }"
org.prevayler.examples.e105.Entity.setText,"  public void setText(String text) {
    this.text = text;
  }"
org.prevayler.examples.e105.Entity.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e105.Entity.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }"
org.prevayler.examples.e105.Entity.equals,"  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Entity entity = (Entity) o;

    if (identity != null ? !identity.equals(entity.identity) : entity.identity != null) return false;

    return true;
  }"
org.prevayler.examples.e105.Entity.hashCode,"  public int hashCode() {
    return identity != null ? identity.hashCode() : 0;
  }
"
org.prevayler.examples.e104.NameChangeWithProblem.executeOn,"  public void executeOn(Club club, Date executionTime) {
    //The member field is now a deep clone because this transaction as serialized and deserialized by Prevayler.
    member.setName(newName); //The clone is being modified instead of the actual member inside the club.
  }

"
org.prevayler.examples.e104.E104Test.testInitiationProblem,"  public void testInitiationProblem() throws Exception {
    Member member = createMember(""John"");

    prevayler.execute(new NameChange(member, ""John S""));
    assertEquals(""John S"", member.name());

    prevayler.execute(new NameChangeWithProblem(member, ""John Smith""));
    assertEquals(""John S"", member.name()); //The name change did not work because transactions are serialized and deserialized by Prevayler, producing a deep clone. The person object in the transaction is no longer the object we passed in but a clone!

    prevayler.close();
  }"
org.prevayler.examples.e104.E104Test.createMember,"  private Member createMember(String name) throws Exception {
    return prevayler.execute(new MemberCreation(name));
  }"
org.prevayler.examples.e104.E104Test.initPrevayler,"  private static Prevayler<Club> initPrevayler() {
    String dataPath = ""target/PrevalenceBase_"" + System.currentTimeMillis();
    try {
      return PrevaylerFactory.createPrevayler(new Club(), dataPath);
    } catch (Exception e) {
      throw new IllegalStateException(e);
    }
  }

"
org.prevayler.examples.e103.Root.getEntities,"  public Map<String, Entity> getEntities() {
    return entities;
  }"
org.prevayler.examples.e103.Root.setEntities,"  public void setEntities(Map<String, Entity> entities) {
    this.entities = entities;
  }
"
org.prevayler.examples.e103.CreateEntityTransaction.executeAndQuery,"  public Entity executeAndQuery(Root prevalentSystem, Date executionTime) throws Exception {
    Entity entity = new Entity();
    entity.setIdentity(identity);
    entity.setCreated(executionTime.getTime());
    prevalentSystem.getEntities().put(entity.getIdentity(), entity);
    return entity;
  }"
org.prevayler.examples.e103.CreateEntityTransaction.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e103.CreateEntityTransaction.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }
"
org.prevayler.examples.e103.E103Test.testFailing,"  public void testFailing() throws Exception {
    runTest(new BadTimestampCreateEntityTransaction(UUID.randomUUID().toString()));
  }"
org.prevayler.examples.e103.E103Test.testPassing,"  public void testPassing() throws Exception {
    runTest(new CreateEntityTransaction(UUID.randomUUID().toString()));
  }"
org.prevayler.examples.e103.E103Test.runTest,"  private void runTest(TransactionWithQuery<Root, Entity> createEntityTransaction) throws Exception {
    String dataPath = ""target/E103TestData"";
    File dataDir = new File(dataPath);
    dataDir.mkdirs();
    for (File dataFile : dataDir.listFiles()) {
        assertTrue(dataFile.toString().endsWith("".journal""));
        dataFile.delete();
    }

    // Create or load existing prevalence layer from journal and/or snapshot.
    Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath);

    try {
      final Entity entity = prevayler.execute(createEntityTransaction);
      final long timestampWhenInitiallyCreated = entity.getCreated();

      // close and reopen prevalence so the journal is replayed
      prevayler.close();
      Thread.sleep(1);
      prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath);

      long timestampAfterRestart = prevayler.execute(new Query<Root, Long>() {
        private static final long serialVersionUID = 2206397764164885775L;

        public Long query(Root prevalentSystem, Date executionTime) throws Exception {
          return prevalentSystem.getEntities().get(entity.getIdentity()).getCreated();
        }
      });

      assertEquals(""timestamp should not have changed"", timestampWhenInitiallyCreated, timestampAfterRestart);

    } finally {
      prevayler.close();
    }
  }

"
org.prevayler.examples.e103.E103Test.query,"        public Long query(Root prevalentSystem, Date executionTime) throws Exception {
          return prevalentSystem.getEntities().get(entity.getIdentity()).getCreated();
        }
      "
org.prevayler.examples.e103.BadTimestampCreateEntityTransaction.executeAndQuery,"  public Entity executeAndQuery(Root prevalentSystem, Date executionTime) throws Exception {
    Entity entity = new Entity();
    entity.setIdentity(identity);
    entity.setCreated(System.currentTimeMillis()); // This line of code in bad
    // as it will set #created to time of when journal is replayed
    // rather than the initial execution time of the transaction.
    prevalentSystem.getEntities().put(entity.getIdentity(), entity);
    return entity;
  }"
org.prevayler.examples.e103.BadTimestampCreateEntityTransaction.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e103.BadTimestampCreateEntityTransaction.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }
"
org.prevayler.examples.e103.Entity.equals,"  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Entity entity = (Entity) o;

    if (identity != null ? !identity.equals(entity.identity) : entity.identity != null) return false;

    return true;
  }"
org.prevayler.examples.e103.Entity.hashCode,"  public int hashCode() {
    return identity != null ? identity.hashCode() : 0;
  }"
org.prevayler.examples.e103.Entity.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e103.Entity.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }"
org.prevayler.examples.e103.Entity.getCreated,"  public long getCreated() {
    return created;
  }"
org.prevayler.examples.e103.Entity.setCreated,"  public void setCreated(long created) {
    this.created = created;
  }
"
org.prevayler.examples.common.NameChange.executeOn,"  public void executeOn(Club club, Date executionTime) {
    club.member(number).setName(newName);
  }

"
org.prevayler.examples.common.Member.number,"  public int number() {
    return number;
  }"
org.prevayler.examples.common.Member.setName,"  public void setName(String newName) {
    name = newName;
  }"
org.prevayler.examples.common.Member.name,"  public String name() {
    return name;
  }

"
org.prevayler.examples.common.Club.member,"  public Member member(int number) {
    return members.get(number);
  }"
org.prevayler.examples.common.Club.createMember,"  public Member createMember(String name) {
    int number = members.size();
    Member ret = new Member(number, name);
    members.add(ret);
    return ret;
  }

"
org.prevayler.examples.common.MemberCreation.executeAndQuery,"  public Member executeAndQuery(Club club, Date executionTime) {
    return club.createMember(name);
  }

"
org.prevayler.examples.e101.Root.getPersons,"  public Map<String, Person> getPersons() {
    return persons;
  }"
org.prevayler.examples.e101.Root.setPersons,"  public void setPersons(Map<String, Person> persons) {
    this.persons = persons;
  }
"
org.prevayler.examples.e101.CreatePersonTransaction.executeAndQuery,"  public Person executeAndQuery(Root prevalentSystem, Date executionTime) throws Exception {
    Person entity = new Person();
    entity.setIdentity(identity);
    prevalentSystem.getPersons().put(entity.getIdentity(), entity);
    return entity;
  }"
org.prevayler.examples.e101.CreatePersonTransaction.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e101.CreatePersonTransaction.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }
"
org.prevayler.examples.e101.GetPerson.query,"  public Person query(Root prevalentSystem, Date executionTime) throws Exception {
    return prevalentSystem.getPersons().get(identity);
  }
"
org.prevayler.examples.e101.UpdatePersonNameTransaction.executeOn,"  public void executeOn(Root prevalentSystem, Date executionTime) {
    prevalentSystem.getPersons().get(identity).setName(name);
  }"
org.prevayler.examples.e101.UpdatePersonNameTransaction.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e101.UpdatePersonNameTransaction.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }"
org.prevayler.examples.e101.UpdatePersonNameTransaction.getName,"  public String getName() {
    return name;
  }"
org.prevayler.examples.e101.UpdatePersonNameTransaction.setName,"  public void setName(String name) {
    this.name = name;
  }
"
org.prevayler.examples.e101.E101Test.test,"  public void test() throws Exception {

    // Create or load existing prevalence layer from journal and/or snapshot.
    Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), ""target/PrevalenceBase_"" + System.currentTimeMillis());
    try {

      final Person person = prevayler.execute(new CreatePersonTransaction(UUID.randomUUID().toString()));

      final String nameOfPerson = ""John Doe"";

      prevayler.execute(new UpdatePersonNameTransaction(person.getIdentity(), nameOfPerson));
      assertEquals(nameOfPerson, person.getName());

      Person queryResponse = prevayler.execute(new GetPerson(person.getIdentity()));
      assertSame(""person and queryResponse are supposed to be the same object instance!"", person, queryResponse);

      Person removed = prevayler.execute(new DeletePersonTransaction(person.getIdentity()));
      assertSame(""person and removed are supposed to be the same object instance!"", person, removed);

      assertTrue(""There are not supposed to be any persons in the root at this point!"",
          prevayler.execute(new Query<Root, Boolean>() {
            private static final long serialVersionUID = -96319481126700055L;

            public Boolean query(Root prevalentSystem, Date executionTime) throws Exception {
              return prevalentSystem.getPersons().isEmpty();
            }
          }));

    } finally {
      prevayler.close();

    }

  }

"
org.prevayler.examples.e101.E101Test.query,"            public Boolean query(Root prevalentSystem, Date executionTime) throws Exception {
              return prevalentSystem.getPersons().isEmpty();
            }
          "
org.prevayler.examples.e101.Person.getName,"  public String getName() {
    return name;
  }"
org.prevayler.examples.e101.Person.setName,"  public void setName(String name) {
    this.name = name;
  }"
org.prevayler.examples.e101.Person.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e101.Person.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }"
org.prevayler.examples.e101.Person.equals,"  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Person person = (Person) o;

    if (identity != null ? !identity.equals(person.identity) : person.identity != null) return false;

    return true;
  }"
org.prevayler.examples.e101.Person.hashCode,"  public int hashCode() {
    return identity != null ? identity.hashCode() : 0;
  }
"
org.prevayler.examples.e101.DeletePersonTransaction.executeAndQuery,"  public Person executeAndQuery(Root prevalentSystem, Date executionTime) throws Exception {
    return prevalentSystem.getPersons().remove(identity);
  }"
org.prevayler.examples.e101.DeletePersonTransaction.getIdentity,"  public String getIdentity() {
    return identity;
  }"
org.prevayler.examples.e101.DeletePersonTransaction.setIdentity,"  public void setIdentity(String identity) {
    this.identity = identity;
  }
"
org.prevayler.service.Root.getCreated,"  public Long getCreated() {
    return created;
  }"
org.prevayler.service.Root.setCreated,"  public void setCreated(Long created) {
    this.created = created;
  }
"
org.prevayler.service.InitializeServiceTransaction.executeOn,"  public void executeOn(Root root, Date executionTime) {

    root.setCreated(executionTime.getTime());

  }


"
org.prevayler.service.Service.main,"  public static void main(String[] args) throws Exception {
    Service.getInstance().open();
    try {
      // todo execute your application
    } finally {
      Service.getInstance().close();
    }
  }"
org.prevayler.service.Service.getInstance,"  public static Service getInstance() {
    return instance;
  }"
org.prevayler.service.Service.getPrevayler,"  public Prevayler<Root> getPrevayler() {
    return prevayler;
  }"
org.prevayler.service.Service.open,"  public void open() throws Exception {
    prevayler = PrevaylerFactory.createPrevayler(new Root(), ""PrevalenceBase"");
    if (prevayler.prevalentSystem().getCreated() == null) {
      prevayler.execute(new InitializeServiceTransaction());
      prevayler.takeSnapshot();
    }
  }"
org.prevayler.service.Service.close,"  public void close() throws Exception {
    prevayler.close();
  }


"
org.prevayler.demos.scalability.RecordIterator.hasNext,"  public boolean hasNext() {
    return nextRecordId < numberOfRecords;
  }"
org.prevayler.demos.scalability.RecordIterator.next,"  public Record next() {
    indicateProgress();
    return new Record(nextRecordId++, _random);
  }"
org.prevayler.demos.scalability.RecordIterator.indicateProgress,"  private void indicateProgress() {
    if (nextRecordId == 0) {
      out(""Creating "" + numberOfRecords + "" objects..."");
      return;
    }
    if (nextRecordId % 100000 == 0) out("""" + nextRecordId + ""..."");
  }"
org.prevayler.demos.scalability.RecordIterator.out,"  static private void out(Object message) {
    System.out.println(message);
  }
"
org.prevayler.demos.scalability.QueryConnection.queryByName,"/**
* Returns the List of all Record with the given name.
*/
  public List<Record> queryByName(String name);

"
org.prevayler.demos.scalability.ScalabilityTestSubject.name,
org.prevayler.demos.scalability.ScalabilityTestSubject.replaceAllRecords,
org.prevayler.demos.scalability.ScalabilityTestSubject.createTestConnection,
org.prevayler.demos.scalability.ScalabilityTestSubject.reportResourcesUsed,"  public void reportResourcesUsed(PrintStream out);

"
org.prevayler.demos.scalability.TransactionConnection.performTransaction,"  public void performTransaction(Record recordToInsert, Record recordToUpdate, long idToDelete);

"
org.prevayler.demos.scalability.Main.main,"  static public void main(String[] args) {

    out(""\n============================================================="");
    out(""             Prevayler vs JDBC Scalability Tests             "");
    out(""=============================================================\n"");
    out(""If you have any trouble running the tests, just write to"");
    out(""prevayler-scalability@lists.sourceforge.net and we will be glad to help.\n"");

    try {
      out(""Reading the properties file:\n"" + propertiesFile().getAbsolutePath());
      out(""You can edit this file to configure the tests for the next run.\n"");

      properties.load(new FileInputStream(propertiesFile()));

      if (isPrevaylerQueryChosen()) runPrevaylerQuery();
      if (isPrevaylerTransactionChosen()) runPrevaylerTransaction();
      if (isJdbcQueryChosen()) runJdbcQuery();
      if (isJdbcTransactionChosen()) runJdbcTransaction();

      out(""\n\n\nFor better results, edit the properties file:"");
      out(propertiesFile().getAbsolutePath());
      out(""\nYou can publish your best results by mail to:"");
      out(""prevayler-scalability@lists.sourceforge.net. Please include info about your"");
      out(""processors (quantity, type, speed), compiler, VM, operating system and DBMS."");
      out("""");
      out(""Scalability test results are published on www.prevayler.org."");
      out(""See you there.\n"");
      out(""Klaus Wuestefeld and Daniel Santos.\n\n"");

    } catch (Exception ex) {
      ex.printStackTrace();
    } catch (OutOfMemoryError err) {
      ScalabilityTestRun.outOfMemory();
    }

  }"
org.prevayler.demos.scalability.Main.runPrevaylerQuery,"  static private void runPrevaylerQuery() throws Exception {
    new QueryTestRun(
        new PrevaylerQuerySubject(),
        numberOfObjects(),
        prevaylerQueryThreadsMin(),
        prevaylerQueryThreadsMax()
    );
  }"
org.prevayler.demos.scalability.Main.runPrevaylerTransaction,"  static private void runPrevaylerTransaction() throws Exception {
    PrevaylerTransactionSubject subject = new PrevaylerTransactionSubject(prevaylerTransactionLogDirectory(), prevaylerJournalSerializer());
    new TransactionTestRun(
        subject,
        numberOfObjects(),
        prevaylerTransactionThreadsMin(),
        prevaylerTransactionThreadsMax()
    );
    if (isPrevaylerTransactionConsistencyChecked()) {
      out(""Checking transaction log consistency."");
      if (!subject.isConsistent()) throw new RuntimeException(""Transaction log consistency check failed."");
      out(""Transaction log OK.\n"");
    }
  }"
org.prevayler.demos.scalability.Main.runJdbcQuery,"  static private void runJdbcQuery() {
    new QueryTestRun(
        new JDBCQuerySubject(jdbcDriverClassName(), jdbcConnectionURL(), jdbcUser(), jdbcPassword()),
        numberOfObjects(),
        jdbcQueryThreadsMin(),
        jdbcQueryThreadsMax()
    );
  }"
org.prevayler.demos.scalability.Main.runJdbcTransaction,"  static private void runJdbcTransaction() {
    new TransactionTestRun(
        new JDBCTransactionSubject(jdbcDriverClassName(), jdbcConnectionURL(), jdbcUser(), jdbcPassword()),
        numberOfObjects(),
        jdbcTransactionThreadsMin(),
        jdbcTransactionThreadsMax()
    );
  }"
org.prevayler.demos.scalability.Main.propertiesFile,"  static private File propertiesFile() throws IOException {
    File result = new File(""ScalabilityTest.properties"");
    if (!result.exists()) {
      out(""Creating the properties file."");
      createPropertiesFile(result);
    }
    return result;
  }"
org.prevayler.demos.scalability.Main.createPropertiesFile,"  static private void createPropertiesFile(File file) throws IOException {
    PrintStream stream = new PrintStream(new FileOutputStream(file));
    try {
      stream.println(
          ""###########################################################\n"" +
              ""#                                                         #\n"" +
              ""#      PREVAYLER VS JDBC SCALABILITY TEST PROPERTIES      #\n"" +
              ""#                                                         #\n"" +
              ""###########################################################\n"" +
              ""\n"" +
              ""NumberOfObjects = ONE_HUNDRED_THOUSAND\n"" +
              ""# NumberOfObjects = ONE_MILLION\n"" +
              ""# NumberOfObjects = TEN_MILLION\n"" +
              ""# NumberOfObjects = TWENTY_MILLION\n"" +
              ""#\n"" +
              ""# The results are only valid if both Prevayler and the\n"" +
              ""# database can run the tests without paging memory to disk.\n"" +
              ""#\n"" +
              ""# Running the tests with one hundred thousand objects\n"" +
              ""# (default option) requires approx. 128MB free RAM.\n"" +
              ""# The VM must be started with a sufficient maximum heap\n"" +
              ""# size or you will get an OutOfMemoryError.\n"" +
              ""#\n"" +
              ""# Example for Linux and Windows:  java -Xmx128000000 ...\n"" +
              ""#\n"" +
              ""# (This can be set with the scalability.jvmarg property\n"" +
              ""# in build.properties; see sample.build.properties for\n"" +
              ""# examples.)\n"" +
              ""#\n"" +
              ""# Running the tests with one million objects requires\n"" +
              ""# approx. 940MB free RAM.\n"" +
              ""# Running the tests with ten million objects requires\n"" +
              ""# approx. 9.4GB free RAM and a 64bit VM.\n"" +
              ""#\n"" +
              ""# IMPORTANT: Remember to shutdown all other non-vital\n"" +
              ""# processes before running the tests. Even the database\n"" +
              ""# process should be down while running the Prevayler tests\n"" +
              ""# that do not use it.\n"" +
              ""\n"" +
              ""\n"" +
              ""###########################################################\n"" +
              ""# PREVAYLER QUERY TEST\n"" +
              ""\n"" +
              ""RunPrevaylerQueryTest = YES\n"" +
              ""# RunPrevaylerQueryTest = NO\n"" +
              ""\n"" +
              ""PrevaylerQueryThreadsMinimum = 1\n"" +
              ""PrevaylerQueryThreadsMaximum = 5\n"" +
              ""# More threads can produce better results on\n"" +
              ""# multi-processor machines.\n"" +
              ""\n"" +
              ""\n"" +
              ""###########################################################\n"" +
              ""# PREVAYLER TRANSACTION TEST\n"" +
              ""\n"" +
              ""RunPrevaylerTransactionTest = YES\n"" +
              ""# RunPrevaylerTransactionTest = NO\n"" +
              ""\n"" +
              ""PrevaylerTransactionThreadsMinimum = 1\n"" +
              ""PrevaylerTransactionThreadsMaximum = 5\n"" +
              ""#\n"" +
              ""# More threads can produce better results on machines with\n"" +
              ""# multiple disks.\n"" +
              ""\n"" +
              ""TransactionTestCheckConsistency = YES\n"" +
              ""# TransactionTestCheckConsistency = NO\n"" +
              ""#\n"" +
              ""# Verifies the integrity of the journal files produced in\n"" +
              ""# your particular environment.\n"" +
              ""\n"" +
              ""TransactionLogDirectory = TransactionTest\n"" +
              ""#\n"" +
              ""# The full path name can be used. Example for Windows:\n"" +
              ""# TransactionLogDirectory1 = c:\\\\temp\\\\TransactionTest\n"" +
              ""# The back-slash (\\) is the escape character so you must\n"" +
              ""# use two back-slashes (\\\\).\n"" +
              ""\n"" +
              ""PrevaylerJournalSerializer = "" + JavaSerializer.class.getName() + ""\n"" +
              ""\n"" +
              ""\n"" +
              ""###########################################################\n"" +
              ""# JDBC QUERY TEST\n"" +
              ""\n"" +
              ""RunJdbcQueryTest = NO\n"" +
              ""# RunJdbcQueryTest = YES\n"" +
              ""\n"" +
              ""JdbcQueryThreadsMinimum = 1\n"" +
              ""JdbcQueryThreadsMaximum = 5\n"" +
              ""# More threads can produce better results on some machines.\n"" +
              ""\n"" +
              ""\n"" +
              ""###########################################################\n"" +
              ""# JDBC TRANSACTION TEST\n"" +
              ""\n"" +
              ""RunJdbcTransactionTest = NO\n"" +
              ""# RunJdbcTransactionTest = YES\n"" +
              ""\n"" +
              ""JdbcTransactionThreadsMinimum = 1\n"" +
              ""JdbcTransactionThreadsMaximum = 5\n"" +
              ""# More threads can produce better results on some machines.\n"" +
              ""\n"" +
              ""\n"" +
              ""###########################################################\n"" +
              ""# JDBC CONNECTION\n"" +
              ""# (necessary to run the JDBC tests)\n"" +
              ""\n"" +
              ""JdbcDriverClassName =\n"" +
              ""JdbcConnectionURL =\n"" +
              ""JdbcUser =\n"" +
              ""JdbcPassword =\n"" +
              ""# These two tables are necessary for the JDBC tests:\n"" +
              ""# QUERY_TEST and TRANSACTION_TEST.\n"" +
              ""# Both tables have the same column structure:\n"" +
              ""#    ID DECIMAL,\n"" +
              ""#    NAME VARCHAR2(8),\n"" +
              ""#    STRING1 VARCHAR2(1000),\n"" +
              ""#    BIGDECIMAL1 DECIMAL,\n"" +
              ""#    BIGDECIMAL2 DECIMAL,\n"" +
              ""#    DATE1 DATE,\n"" +
              ""#    DATE2 DATE.\n"" +
              ""\n"" +
              ""# IMPORTANT: For best results, create indices on the\n"" +
              ""# QUERY_TEST.NAME and TRANSACTION_TEST.ID columns.\n"" +
              ""# Do not create indices on any other column.\n""
      );
    } finally {
      stream.close();
    }
  }"
org.prevayler.demos.scalability.Main.numberOfObjects,"  static private int numberOfObjects() {
    String property = property(""NumberOfObjects"");
    if (""ONE_HUNDRED_THOUSAND"".equals(property)) return 100000;
    if (""ONE_MILLION"".equals(property)) return 1000000;
    if (""TEN_MILLION"".equals(property)) return 10000000;
    if (""TWENTY_MILLION"".equals(property)) return 20000000;
    throw new RuntimeException(""NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION, TEN_MILLION or TWENTY_MILLION."");
  }"
org.prevayler.demos.scalability.Main.isPrevaylerQueryChosen,"  static private boolean isPrevaylerQueryChosen() {
    return booleanProperty(""RunPrevaylerQueryTest"");
  }"
org.prevayler.demos.scalability.Main.prevaylerQueryThreadsMin,"  static private int prevaylerQueryThreadsMin() {
    return intProperty(""PrevaylerQueryThreadsMinimum"");
  }"
org.prevayler.demos.scalability.Main.prevaylerQueryThreadsMax,"  static private int prevaylerQueryThreadsMax() {
    return intProperty(""PrevaylerQueryThreadsMaximum"");
  }"
org.prevayler.demos.scalability.Main.isPrevaylerTransactionChosen,"  static private boolean isPrevaylerTransactionChosen() {
    return booleanProperty(""RunPrevaylerTransactionTest"");
  }"
org.prevayler.demos.scalability.Main.prevaylerTransactionThreadsMin,"  static private int prevaylerTransactionThreadsMin() {
    return intProperty(""PrevaylerTransactionThreadsMinimum"");
  }"
org.prevayler.demos.scalability.Main.prevaylerTransactionThreadsMax,"  static private int prevaylerTransactionThreadsMax() {
    return intProperty(""PrevaylerTransactionThreadsMaximum"");
  }"
org.prevayler.demos.scalability.Main.isPrevaylerTransactionConsistencyChecked,"  static private boolean isPrevaylerTransactionConsistencyChecked() {
    return booleanProperty(""TransactionTestCheckConsistency"");
  }"
org.prevayler.demos.scalability.Main.prevaylerTransactionLogDirectory,"  static private String prevaylerTransactionLogDirectory() {
    String result = property(""TransactionLogDirectory"");
    out(""\n\nPrevayler TransactionLog Directory: "" + result);
    return result;
  }"
org.prevayler.demos.scalability.Main.prevaylerJournalSerializer,"  static private String prevaylerJournalSerializer() {
    String result = properties.getProperty(""PrevaylerJournalSerializer"");
    if (result == null) result = JavaSerializer.class.getName();
    out(""\n\nPrevayler Journal Serializer: "" + result);
    return result;
  }"
org.prevayler.demos.scalability.Main.isJdbcQueryChosen,"  static private boolean isJdbcQueryChosen() {
    return booleanProperty(""RunJdbcQueryTest"");
  }"
org.prevayler.demos.scalability.Main.jdbcQueryThreadsMin,"  static private int jdbcQueryThreadsMin() {
    return intProperty(""JdbcQueryThreadsMinimum"");
  }"
org.prevayler.demos.scalability.Main.jdbcQueryThreadsMax,"  static private int jdbcQueryThreadsMax() {
    return intProperty(""JdbcQueryThreadsMaximum"");
  }"
org.prevayler.demos.scalability.Main.isJdbcTransactionChosen,"  static private boolean isJdbcTransactionChosen() {
    return booleanProperty(""RunJdbcTransactionTest"");
  }"
org.prevayler.demos.scalability.Main.jdbcTransactionThreadsMin,"  static private int jdbcTransactionThreadsMin() {
    return intProperty(""JdbcTransactionThreadsMinimum"");
  }"
org.prevayler.demos.scalability.Main.jdbcTransactionThreadsMax,"  static private int jdbcTransactionThreadsMax() {
    return intProperty(""JdbcTransactionThreadsMaximum"");
  }"
org.prevayler.demos.scalability.Main.jdbcDriverClassName,"  static private String jdbcDriverClassName() {
    return property(""JdbcDriverClassName"");
  }"
org.prevayler.demos.scalability.Main.jdbcConnectionURL,"  static private String jdbcConnectionURL() {
    return property(""JdbcConnectionURL"");
  }"
org.prevayler.demos.scalability.Main.jdbcUser,"  static private String jdbcUser() {
    return property(""JdbcUser"");
  }"
org.prevayler.demos.scalability.Main.jdbcPassword,"  static private String jdbcPassword() {
    return property(""JdbcPassword"");
  }"
org.prevayler.demos.scalability.Main.property,"  static private String property(String name) {
    String result = properties.getProperty(name);
    if (result == null) throw new RuntimeException(""Property "" + name + "" not found."");
    return result;
  }"
org.prevayler.demos.scalability.Main.intProperty,"  static private int intProperty(String name) {
    try {
      return Integer.valueOf(property(name));
    } catch (NumberFormatException nfx) {
      out(""NumberFormatException reading property "" + name);
      throw nfx;
    }
  }"
org.prevayler.demos.scalability.Main.booleanProperty,"  static private boolean booleanProperty(String name) {
    boolean result = ""yes"".equalsIgnoreCase(property(name));
    if (result) return true;
    out(""\n\n\n"" + name + "" property is set to "" + property(name) + ""."");
    out(""This test will be skipped (see properties file)."");
    return false;
  }"
org.prevayler.demos.scalability.Main.out,"  static private void out(Object message) {
    System.out.println(message);
  }
"
org.prevayler.demos.scalability.QueryTestRun.name,"  protected String name() {
    return ""Query Test"";
  }"
org.prevayler.demos.scalability.QueryTestRun.executeOperation,"  protected void executeOperation(QueryConnection connection, long operationSequence) {

    connection.queryByName(""NAME"" + (operationSequence % 10000));

  }
"
org.prevayler.demos.scalability.Record.getId,"  public long getId() {
    return id;
  }"
org.prevayler.demos.scalability.Record.getName,"  public String getName() {
    return name;
  }"
org.prevayler.demos.scalability.Record.getString1,"  public String getString1() {
    return string1;
  }"
org.prevayler.demos.scalability.Record.getBigDecimal1,"  public BigDecimal getBigDecimal1() {
    return bigDecimal1;
  }"
org.prevayler.demos.scalability.Record.getBigDecimal2,"  public BigDecimal getBigDecimal2() {
    return bigDecimal2;
  }"
org.prevayler.demos.scalability.Record.getDate1,"  public Date getDate1() {
    return new Date(date1);
  }"
org.prevayler.demos.scalability.Record.getDate2,"  public Date getDate2() {
    return new Date(date2);
  }"
org.prevayler.demos.scalability.Record.hashCode,"  public int hashCode() {
    return (int) (id
        + name.hashCode()
        + ("""" + string1).hashCode()
        + bigDecimal1.hashCode()
        + bigDecimal2.hashCode()
        + date1
        + date2
    );
  }"
org.prevayler.demos.scalability.Record.generateLargeString,"  static private String generateLargeString() {
    char[] chars = new char[980];
    Arrays.fill(chars, 'A');
    return new String(chars);
  }

"
org.prevayler.demos.scalability.ScalabilityTestRun.getResult,"/**
* @return Example: ""123.12 operations/second (12 threads)"".
*/
  public String getResult() {
    return toResultString(bestRoundOperationsPerSecond, bestRoundThreads);
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.getOperationsPerSecond,"  public double getOperationsPerSecond() {
    return bestRoundOperationsPerSecond;
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.prepare,"  protected void prepare() {
    subject.replaceAllRecords(numberOfObjects);
    System.gc();
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.name,"/**
* @return The name of the test to be executed. Example: ""Prevayler Query Test"".
*/
"
org.prevayler.demos.scalability.ScalabilityTestRun.performTest,"  private void performTest(int minThreads, int maxThreads) {

    int threads = minThreads;
    while (threads <= maxThreads) {
      double operationsPerSecond = performRound(threads);

      if (operationsPerSecond > bestRoundOperationsPerSecond) {
        bestRoundOperationsPerSecond = operationsPerSecond;
        bestRoundThreads = threads;
      }

      threads++;
    }
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.performRound,"/**
* @return The number of operations the test managed to execute per second with the given number of threads.
*/
  private double performRound(int threads) {
    long initialOperationCount = operationCount;
    StopWatch stopWatch = StopWatch.start();

    startThreads(threads);
    sleep();
    stopThreads();

    double secondsEllapsed = stopWatch.secondsEllapsed();
    double operationsPerSecond = (operationCount - initialOperationCount) / secondsEllapsed;

    out(""\nMemory used: "" + Runtime.getRuntime().totalMemory());
    subject.reportResourcesUsed(System.out);
    out(""Seconds ellapsed: "" + secondsEllapsed);
    out(""--------- Round Result: "" + toResultString(operationsPerSecond, threads));

    return operationsPerSecond;
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.startThreads,"  private void startThreads(int threads) {
    isRoundFinished = false;

    int i = 1;
    while (i <= threads) {
      startThread(lastOperation + i, threads);
      i++;
    }
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.startThread,"  private void startThread(final long startingOperation, final int operationIncrement) {
    (new Thread() {
      public void run() {
        try {
          C connection = acquireConnection();

          long operation = startingOperation;
          while (!isRoundFinished) {
            executeOperation(connection, operation);
            operation += operationIncrement;
          }

          synchronized (connectionCache) {
            connectionCache.add(connection);
            operationCount += (operation - startingOperation) / operationIncrement;
            if (lastOperation < operation) lastOperation = operation;
            activeRoundThreads--;
          }

        } catch (OutOfMemoryError err) {
          outOfMemory();
        }
      }
    }).start();

    activeRoundThreads++;
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.run,"      public void run() {
        try {
          C connection = acquireConnection();

          long operation = startingOperation;
          while (!isRoundFinished) {
            executeOperation(connection, operation);
            operation += operationIncrement;
          }

          synchronized (connectionCache) {
            connectionCache.add(connection);
            operationCount += (operation - startingOperation) / operationIncrement;
            if (lastOperation < operation) lastOperation = operation;
            activeRoundThreads--;
          }

        } catch (OutOfMemoryError err) {
          outOfMemory();
        }
      }
    "
org.prevayler.demos.scalability.ScalabilityTestRun.executeOperation,
org.prevayler.demos.scalability.ScalabilityTestRun.acquireConnection,"  private C acquireConnection() {
    synchronized (connectionCache) {
      return connectionCache.isEmpty()
          ? subject.createTestConnection()
          : connectionCache.remove(0);
    }
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.stopThreads,"  private void stopThreads() {
    isRoundFinished = true;
    while (activeRoundThreads != 0) {
      Thread.yield();
    }
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.toResultString,"  static private String toResultString(double operationsPerSecond, int threads) {
    String operations = new DecimalFormat(""0.00"").format(operationsPerSecond);
    return """" + operations + "" operations/second ("" + threads + "" threads)"";
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.outOfMemory,"  static void outOfMemory() {
    System.gc();
    out(
        ""\n\nOutOfMemoryError.\n"" +
            ""===========================================================\n"" +
            ""The VM must be started with a sufficient maximum heap size.\n"" +
            ""Example for Linux and Windows:  java -Xmx512000000 ...\n\n""
    );
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.sleep,"  static private void sleep() {
    Cool.sleep(ROUND_DURATION_MILLIS);
  }"
org.prevayler.demos.scalability.ScalabilityTestRun.out,"  static private void out(Object obj) {
    System.out.println(obj);
  }
"
org.prevayler.demos.scalability.TransactionTestRun.name,"  protected String name() {
    return ""Transaction Test"";
  }"
org.prevayler.demos.scalability.TransactionTestRun.prepare,"  protected void prepare() {
    super.prepare();
    halfTheObjects = numberOfObjects / 2;
  }"
org.prevayler.demos.scalability.TransactionTestRun.executeOperation,"/**
* Deletes records from id zero            to id halfTheObjects - 1.
* Updates records from id halfTheObjects  to id numberOfObjects - 1.
* Inserts records from id numberOfObjects to id numberOfObjects + halfTheObjects - 1.
* Every time halfTheObjects operations have completed, all ranges are shifted up by halfTheObjects.
* Example for one million objects:
* Deletes records from id 0000000 to id 0499999.
* Updates records from id 0500000 to id 0999999.
* Inserts records from id 1000000 to id 1499999.
* Every time 500000 operations have completed, all ranges are shifted up by 500000.
*/
  protected void executeOperation(TransactionConnection connection, long operationSequence) {
    Record recordToInsert = new Record(numberOfObjects + operationSequence);
    long idToDelete = spreadId(operationSequence);
    Record recordToUpdate = new Record(halfTheObjects + idToDelete);

    connection.performTransaction(recordToInsert, recordToUpdate, idToDelete);
  }"
org.prevayler.demos.scalability.TransactionTestRun.spreadId,"/**
* Spreads out the id values so that deletes and updates are not done contiguously.
*/
  private long spreadId(long id) {
    return (id / halfTheObjects) * halfTheObjects   //Step function.
        + ((id * 16807) % halfTheObjects);   //16807 == 7 * 7 * 7 * 7 * 7. 16807 is relatively prime to 50000, 500000 and 5000000. This guarantees that all ids in the range will be covered.
  }
"
org.prevayler.demos.scalability.jdbc.JDBCQuerySubject.createTestConnection,"  public QueryConnection createTestConnection() {
    return new JDBCQueryConnection(createConnection());
  }

"
org.prevayler.demos.scalability.jdbc.JDBCScalabilityConnection.table,
org.prevayler.demos.scalability.jdbc.JDBCScalabilityConnection.insert,"  protected void insert(Record recordToInsert) {
    try {
      insertStatement.setLong(1, recordToInsert.getId());
      insertStatement.setString(2, recordToInsert.getName());
      insertStatement.setString(3, recordToInsert.getString1());
      insertStatement.setBigDecimal(4, recordToInsert.getBigDecimal1());
      insertStatement.setBigDecimal(5, recordToInsert.getBigDecimal2());
      insertStatement.setDate(6, new java.sql.Date(recordToInsert.getDate1().getTime()));
      insertStatement.setDate(7, new java.sql.Date(recordToInsert.getDate2().getTime()));
      insertStatement.execute();
    } catch (SQLException sqlx) {
      dealWithSQLException(sqlx, ""inserting record"");
    }
  }"
org.prevayler.demos.scalability.jdbc.JDBCScalabilityConnection.prepare,"  protected PreparedStatement prepare(String statement) {
    try {
      return connection.prepareStatement(statement);
    } catch (SQLException sqlx) {
      dealWithSQLException(sqlx, ""preparing statement: "" + statement);
      return null;
    }
  }"
org.prevayler.demos.scalability.jdbc.JDBCScalabilityConnection.replaceAllRecords,"  void replaceAllRecords(int records) {
    RecordIterator newRecords = new RecordIterator(records);

    try {
      connection.createStatement().execute(""delete from "" + table());
    } catch (SQLException sqlx) {
      dealWithSQLException(sqlx, ""deleting all records from "" + table());
    }

    while (newRecords.hasNext()) {
      insert(newRecords.next());
    }

    try {
      connection.commit();
    } catch (SQLException sqlx) {
      dealWithSQLException(sqlx, ""commiting insertion of test records"");
    }
  }"
org.prevayler.demos.scalability.jdbc.JDBCScalabilityConnection.dealWithSQLException,"  static protected void dealWithSQLException(SQLException sqlx, String duringOperation) {
    sqlx.printStackTrace();
    throw new RuntimeException(""SQLException "" + duringOperation + ""."");
  }
"
org.prevayler.demos.scalability.jdbc.JDBCTransactionConnection.table,"  protected String table() {
    return ""TRANSACTION_TEST"";
  }"
org.prevayler.demos.scalability.jdbc.JDBCTransactionConnection.performTransaction,"  public void performTransaction(Record recordToInsert, Record recordToUpdate, long idToDelete) {
    insert(recordToInsert);
    update(recordToUpdate);
    delete(idToDelete);

    try {
      connection.commit();
    } catch (SQLException sqlx) {
      dealWithSQLException(sqlx, ""commiting transaction"");
    }
  }"
org.prevayler.demos.scalability.jdbc.JDBCTransactionConnection.update,"  private void update(Record recordToUpdate) {
    try {
      updateStatement.setString(1, recordToUpdate.getName());
      updateStatement.setString(2, recordToUpdate.getString1());
      updateStatement.setBigDecimal(3, recordToUpdate.getBigDecimal1());
      updateStatement.setBigDecimal(4, recordToUpdate.getBigDecimal2());
      updateStatement.setDate(5, new java.sql.Date(recordToUpdate.getDate1().getTime()));
      updateStatement.setDate(6, new java.sql.Date(recordToUpdate.getDate2().getTime()));
      updateStatement.setLong(7, recordToUpdate.getId());  //""...where ID=?""
      updateStatement.execute();
    } catch (SQLException sqlx) {
      dealWithSQLException(sqlx, ""updating record"");
    }
  }"
org.prevayler.demos.scalability.jdbc.JDBCTransactionConnection.delete,"  private void delete(long idToDelete) {
    try {
      deleteStatement.setLong(1, idToDelete);
      deleteStatement.execute();
    } catch (SQLException sqlx) {
      dealWithSQLException(sqlx, ""deleting record"");
    }
  }
"
org.prevayler.demos.scalability.jdbc.JDBCQueryConnection.table,"  protected String table() {
    return ""QUERY_TEST"";
  }"
org.prevayler.demos.scalability.jdbc.JDBCQueryConnection.queryByName,"  public List<Record> queryByName(String name) {
    List<Record> list = new ArrayList<Record>();
    try {
      selectStatement.setString(1, name);
      ResultSet resultSet = selectStatement.executeQuery();

      while (resultSet.next()) {
        list.add(new Record(resultSet.getLong(1), name, resultSet.getString(2), resultSet.getBigDecimal(3), resultSet.getBigDecimal(4), resultSet.getDate(5), resultSet.getDate(6)));
      }

    } catch (SQLException sqlex) {
      dealWithSQLException(sqlex, ""selecting record from "" + table());
    }

    return list;
  }
"
org.prevayler.demos.scalability.jdbc.JDBCTransactionSubject.createTestConnection,"  public TransactionConnection createTestConnection() {
    return new JDBCTransactionConnection(createConnection());
  }

"
org.prevayler.demos.scalability.jdbc.JDBCScalabilitySubject.name,"  public String name() {
    return ""JDBC"";
  }"
org.prevayler.demos.scalability.jdbc.JDBCScalabilitySubject.replaceAllRecords,"  public void replaceAllRecords(int records) {
    ((JDBCScalabilityConnection) createTestConnection()).replaceAllRecords(records);
  }"
org.prevayler.demos.scalability.jdbc.JDBCScalabilitySubject.createConnection,"  protected Connection createConnection() {
    try {

      return DriverManager.getConnection(connectionURL, user, password);

    } catch (SQLException sqlx) {
      sqlx.printStackTrace();
      throw new RuntimeException(""Exception while trying to connect: "" + sqlx);
    }
  }"
org.prevayler.demos.scalability.jdbc.JDBCScalabilitySubject.reportResourcesUsed,"  public void reportResourcesUsed(PrintStream out) {
  }

"
org.prevayler.demos.scalability.prevayler.TransactionSystem.performTransaction,"  public void performTransaction(Record recordToInsert, Record recordToUpdate, long idToDelete) {
    synchronized (recordsById) {
      put(recordToInsert);
      put(recordToUpdate);
      recordsById.remove(Long.valueOf(idToDelete));
    }
  }"
org.prevayler.demos.scalability.prevayler.TransactionSystem.put,"  private Object put(Record newRecord) {
    return recordsById.put(newRecord.getId(), newRecord);
  }"
org.prevayler.demos.scalability.prevayler.TransactionSystem.replaceAllRecords,"  public void replaceAllRecords(RecordIterator newRecords) {
    recordsById.clear();

    while (newRecords.hasNext()) {
      put(newRecords.next());
    }
  }"
org.prevayler.demos.scalability.prevayler.TransactionSystem.hashCode,"  public int hashCode() {
    return recordsById.hashCode();
  }
"
org.prevayler.demos.scalability.prevayler.PrevaylerQuerySubject.createTestConnection,"  public QueryConnection createTestConnection() {
    return new PrevaylerQueryConnection(prevayler.prevalentSystem());
  }"
org.prevayler.demos.scalability.prevayler.PrevaylerQuerySubject.reportResourcesUsed,"  public void reportResourcesUsed(PrintStream out) {
  }

"
org.prevayler.demos.scalability.prevayler.AllRecordsReplacement.executeOn,"  public void executeOn(S system, Date ignored) {
    system.replaceAllRecords(new RecordIterator(_records));
  }
"
org.prevayler.demos.scalability.prevayler.PrevaylerTransactionConnection.performTransaction,"  public void performTransaction(Record recordToInsert, Record recordToUpdate, long idToDelete) {
    try {

      prevayler.execute(new TestTransaction(recordToInsert, recordToUpdate, idToDelete));

    } catch (Exception ex) {
      ex.printStackTrace();
      throw new RuntimeException(""Unexpected Exception: "" + ex);
    }
  }
"
org.prevayler.demos.scalability.prevayler.PrevaylerQueryConnection.queryByName,"  public List<Record> queryByName(String name) {
    return querySystem.queryByName(name);
  }
"
org.prevayler.demos.scalability.prevayler.TestTransaction.executeOn,"  public void executeOn(TransactionSystem system, Date ignored) {
    system.performTransaction(recordToInsert, recordToUpdate, idToDelete);
  }
"
org.prevayler.demos.scalability.prevayler.QuerySystem.queryByName,"  public List<Record> queryByName(String name) {
    return recordsByName.get(name);
  }"
org.prevayler.demos.scalability.prevayler.QuerySystem.replaceAllRecords,"  public void replaceAllRecords(RecordIterator newRecords) {
    recordsByName.clear();

    while (newRecords.hasNext()) {
      put(newRecords.next());
    }

    makeReadOnly();
  }"
org.prevayler.demos.scalability.prevayler.QuerySystem.put,"  private void put(Record newRecord) {
    List<Record> records = queryByName(newRecord.getName());
    if (records == null) {
      records = new ArrayList<Record>();
      recordsByName.put(newRecord.getName(), records);
    }

    records.add(newRecord);
  }"
org.prevayler.demos.scalability.prevayler.QuerySystem.makeReadOnly,"/**
* This is necessary so that the clients cannot alter the Lists they receive as query results.
*/
  private void makeReadOnly() {
    Iterator<Map.Entry<String, List<Record>>> entries = recordsByName.entrySet().iterator();
    while (entries.hasNext()) {
      Map.Entry<String, List<Record>> entry = entries.next();
      entry.setValue(Collections.unmodifiableList(entry.getValue()));
    }
  }
"
org.prevayler.demos.scalability.prevayler.PrevalenceTest.delete,"  static public void delete(String dir) {
    delete(new File(dir));
  }"
org.prevayler.demos.scalability.prevayler.PrevalenceTest.delete,"  static private void delete(File file) {
    if (file.isDirectory()) deleteDirectoryContents(file);
    if (!file.delete()) {
      System.gc();
    }
  }"
org.prevayler.demos.scalability.prevayler.PrevalenceTest.deleteDirectoryContents,"  static private void deleteDirectoryContents(File directory) {
    File[] files = directory.listFiles(new PrevalenceFilter());
    if (files == null) return;
    for (int i = 0; i < files.length; i++) delete(files[i]);
  }"
org.prevayler.demos.scalability.prevayler.PrevalenceTest.accept,"    public boolean accept(File file) {
      return file.getName().endsWith(""journal"")
          || file.getName().endsWith(""snapshot"")
          || file.isDirectory();
    }
  "
org.prevayler.demos.scalability.prevayler.PrevaylerTransactionSubject.createTestConnection,"  public TransactionConnection createTestConnection() {
    return new PrevaylerTransactionConnection(prevayler);
  }"
org.prevayler.demos.scalability.prevayler.PrevaylerTransactionSubject.reportResourcesUsed,"  public void reportResourcesUsed(PrintStream out) {
    int totalSize = 0;
    File[] files = new File(_journalDirectory).listFiles();
    for (int i = 0; i < files.length; i++) {
      totalSize += files[i].length();
    }
    out.println(""Disk space used: "" + totalSize);
  }"
org.prevayler.demos.scalability.prevayler.PrevaylerTransactionSubject.isConsistent,"  public boolean isConsistent() throws Exception {
    int expectedResult = prevayler.prevalentSystem().hashCode();
    initializePrevayler();  //Will reload all transactions from the log files.
    return prevayler.prevalentSystem().hashCode() == expectedResult;
  }"
org.prevayler.demos.scalability.prevayler.PrevaylerTransactionSubject.initializePrevayler,"  private void initializePrevayler() throws Exception {
    PrevaylerFactory<TransactionSystem> factory = new PrevaylerFactory<TransactionSystem>();
    factory.configurePrevalentSystem(new TransactionSystem());
    factory.configurePrevalenceDirectory(_journalDirectory);
    factory.configureJournalSerializer(""journal"", (Serializer) Class.forName(_journalSerializer).getDeclaredConstructor().newInstance());
    prevayler = factory.create();  //No snapshot is generated by the test.
  }

"
org.prevayler.demos.scalability.prevayler.ScalabilitySystem.replaceAllRecords,"  void replaceAllRecords(RecordIterator newRecords);

"
org.prevayler.demos.scalability.prevayler.PrevaylerScalabilitySubject.name,"  public String name() {
    return ""Prevayler"";
  }"
org.prevayler.demos.scalability.prevayler.PrevaylerScalabilitySubject.replaceAllRecords,"  public void replaceAllRecords(int records) {
    try {

      prevayler.execute(new AllRecordsReplacement<S>(records));

    } catch (Exception ex) {
      ex.printStackTrace();
      throw new RuntimeException(""Unexpected Exception: "" + ex);
    }
  }

"
org.prevayler.demos.jxpath.ProjectManagementSystem.getProjects,"  public List<Project> getProjects() {
    return projects;
  }
"
org.prevayler.demos.jxpath.Main.usage,"/**
* Shows usage information.
*/
  public static void usage() {
    System.out.println(
        ""Usage: Main <list|proj|task|snap> <parameters>\n\n""
            + ""Parameters:\n""
            + ""    list:   <xpath expression>\n""
            + ""    proj:   <id> <name>\n""
            + ""    task:   <id> <name> <start> <end> <projectId>\n""
            + ""    snap\n\n""
            + ""Note: dates should be entered in a locale-sensitive format (your locale is ""
            + System.getProperty(""user.language"")
            + ""_""
            + System.getProperty(""user.country"")
            + "")."");
    System.exit(0);
  }"
org.prevayler.demos.jxpath.Main.main,"/**
* Main method -- please call me :)
*
* @param args command-line parameters
*/
  public static void main(String[] args) {

    try {

      Prevayler<ProjectManagementSystem> prevayler =
          PrevaylerFactory.createPrevayler(new ProjectManagementSystem(), ""demoJXPath"");

      if (args.length < 1) {
        usage();
      } else if (""list"".equalsIgnoreCase(args[0]) && args.length >= 2) {
        list(prevayler, args[1]);
      } else if (""proj"".equalsIgnoreCase(args[0]) && args.length >= 3) {
        addProject(prevayler, args[1], args[2]);
      } else if (""task"".equalsIgnoreCase(args[0]) && args.length >= 6) {
        addTask(prevayler, args[1], args[2], args[3], args[4], args[5]);
      } else if (""snap"".equalsIgnoreCase(args[0])) {
        prevayler.takeSnapshot();
      } else {
        usage();
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
  }"
org.prevayler.demos.jxpath.Main.list,"/**
* Lists an object graph using an XPath expression.
*
* @param prevayler PrevalentSystem to query
* @param xpathExp  XPath expression to use
*/
  private static void list(Prevayler<ProjectManagementSystem> prevayler, String xpathExp) {
    System.out.println(""Executing XPath expression..."");

    ProjectManagementSystem pms = prevayler.prevalentSystem();
    JXPathContext context = JXPathContext.newContext(pms);
    Iterator<?> i = context.iterate(xpathExp);

    while (i.hasNext()) {

      Object obj = i.next();
      System.out.println(obj.toString());
    }
  }"
org.prevayler.demos.jxpath.Main.addProject,"/**
* Adds a project.
*
* @param prevayler PrevalentSystem to change
* @param id        id of the project
* @param name      name of the project
*/
  private static void addProject(
      Prevayler<ProjectManagementSystem> prevayler,
      String id,
      String name)
      throws Exception {
    System.out.println(
        ""Adding project '"" + name + ""' (id '"" + id + ""')..."");

    Project p = new Project();
    p.setId(Integer.parseInt(id));
    p.setName(name);

    AddProject cmd = new AddProject();
    cmd.setProject(p);
    prevayler.execute(cmd);
  }"
org.prevayler.demos.jxpath.Main.addTask,"/**
* Adds a task.
*
* @param prevayler PrevalentSystem to change
* @param id        id of the tasl
* @param name      name of the task
* @param start     start date of the task
* @param end       end date of the task
* @param projectId project id to add this task to
*/
  private static void addTask(
      Prevayler<ProjectManagementSystem> prevayler,
      String id,
      String name,
      String start,
      String end,
      String projectId)
      throws Exception {
    System.out.println(
        ""Adding task '"" + id + ""' to project '"" + projectId + ""'..."");

    Task t = new Task();
    t.setId(Integer.parseInt(id));
    t.setName(name);
    t.setStart(SimpleDateFormat.getInstance().parse(start));
    t.setEnd(SimpleDateFormat.getInstance().parse(end));
    System.out.println(""Start: "" + t.getStart());
    System.out.println(""End:   "" + t.getEnd());

    AddTask cmd = new AddTask();
    cmd.setTask(t);
    cmd.setProjectId(Integer.parseInt(projectId));
    prevayler.execute(cmd);
  }
"
org.prevayler.demos.jxpath.model.Task.getEnd,"/**
* Returns the end.
*
* @return Date
*/
  public Date getEnd() {
    return end;
  }"
org.prevayler.demos.jxpath.model.Task.getName,"/**
* Returns the name.
*
* @return String
*/
  public String getName() {
    return name;
  }"
org.prevayler.demos.jxpath.model.Task.getStart,"/**
* Returns the start.
*
* @return Date
*/
  public Date getStart() {
    return start;
  }"
org.prevayler.demos.jxpath.model.Task.setEnd,"/**
* Sets the end.
*
* @param end The end to set
*/
  public void setEnd(Date end) {
    this.end = end;
  }"
org.prevayler.demos.jxpath.model.Task.setName,"/**
* Sets the name.
*
* @param name The name to set
*/
  public void setName(String name) {
    this.name = name;
  }"
org.prevayler.demos.jxpath.model.Task.setStart,"/**
* Sets the start.
*
* @param start The start to set
*/
  public void setStart(Date start) {
    this.start = start;
  }"
org.prevayler.demos.jxpath.model.Task.getId,"/**
* Returns the id.
*
* @return int
*/
  public int getId() {
    return id;
  }"
org.prevayler.demos.jxpath.model.Task.setId,"/**
* Sets the id.
*
* @param id The id to set
*/
  public void setId(int id) {
    this.id = id;
  }"
org.prevayler.demos.jxpath.model.Task.toString,"  public String toString() {
    return ""\n   Task Id: "" + id
        + ""\n      Name: "" + name
        + ""\nDate start: "" + start
        + ""\n  Date end: "" + end + ""\n"";
  }
"
org.prevayler.demos.jxpath.model.Project.getName,"/**
* Returns the name.
*
* @return String
*/
  public String getName() {

    return name;
  }"
org.prevayler.demos.jxpath.model.Project.getTasks,"/**
* Returns the tasks.
*
* @return Task[]
*/
  public List<Task> getTasks() {

    return tasks;
  }"
org.prevayler.demos.jxpath.model.Project.setName,"/**
* Sets the name.
*
* @param name The name to set
*/
  public void setName(String name) {
    this.name = name;
  }"
org.prevayler.demos.jxpath.model.Project.setTasks,"/**
* Sets the tasks.
*
* @param tasks The tasks to set
*/
  public void setTasks(List<Task> tasks) {
    this.tasks = tasks;
  }"
org.prevayler.demos.jxpath.model.Project.getId,"/**
* Returns the id.
*
* @return int
*/
  public int getId() {

    return id;
  }"
org.prevayler.demos.jxpath.model.Project.setId,"/**
* Sets the id.
*
* @param id The id to set
*/
  public void setId(int id) {
    this.id = id;
  }"
org.prevayler.demos.jxpath.model.Project.toString,"  public String toString() {
    return ""Project Id: "" + id
        + ""\n      Name: "" + name
        + ""\n     Tasks:...\n"" + tasks;
  }
"
org.prevayler.demos.jxpath.commands.AddTask.executeOn,"  public void executeOn(ProjectManagementSystem system, Date ignored) {
    if (task != null && projectId != Integer.MIN_VALUE) {

      List<Project> projects = system.getProjects();
      Iterator<Project> i = projects.iterator();
      while (i.hasNext()) {
        Project p = i.next();
        if (p.getId() == projectId) {
          List<Task> tasks = p.getTasks();
          if (tasks == null) {
            tasks = new ArrayList<Task>();
          }
          tasks.add(task);
          p.setTasks(tasks);
          break;
        }
      }
    } else {
      throw new RuntimeException(""No project to add -- please call setProject()"");
    }
  }"
org.prevayler.demos.jxpath.commands.AddTask.getProjectId,"/**
* Returns the projectId.
*
* @return int
*/
  public int getProjectId() {

    return projectId;
  }"
org.prevayler.demos.jxpath.commands.AddTask.getTask,"/**
* Returns the task.
*
* @return Task
*/
  public Task getTask() {

    return task;
  }"
org.prevayler.demos.jxpath.commands.AddTask.setProjectId,"/**
* Sets the projectId.
*
* @param projectId The projectId to set
*/
  public void setProjectId(int projectId) {
    this.projectId = projectId;
  }"
org.prevayler.demos.jxpath.commands.AddTask.setTask,"/**
* Sets the task.
*
* @param task The task to set
*/
  public void setTask(Task task) {
    this.task = task;
  }
"
org.prevayler.demos.jxpath.commands.AddProject.executeOn,"  public void executeOn(ProjectManagementSystem system, Date ignored) {
    if (project != null) {
      system.getProjects().add(project);
    } else {
      throw new RuntimeException(""No project to add -- please call setProject()"");
    }
  }"
org.prevayler.demos.jxpath.commands.AddProject.getProject,"/**
* Returns the project.
*
* @return Project
*/
  public Project getProject() {
    return project;
  }"
org.prevayler.demos.jxpath.commands.AddProject.setProject,"/**
* Sets the project.
*
* @param project The project to set
*/
  public void setProject(Project project) {
    this.project = project;
  }

"
org.prevayler.demos.demo1.NumberKeeper.keep,"  void keep(int nextNumber) {
    numbers.add(nextNumber);
  }"
org.prevayler.demos.demo1.NumberKeeper.numbers,"  List<Integer> numbers() {
    return numbers;
  }"
org.prevayler.demos.demo1.NumberKeeper.lastNumber,"  int lastNumber() {
    return numbers.isEmpty()
        ? 0
        : numbers.get(numbers.size() - 1);
  }

"
org.prevayler.demos.demo1.PrimeCalculator.start,"  void start() throws Exception {
    int largestPrime = 0;
    int primesFound = 0;
    int primeCandidate = _numberKeeper.lastNumber() == 0
        ? 2
        : _numberKeeper.lastNumber() + 1;

    while (primeCandidate <= Integer.MAX_VALUE) {
      if (isPrime(primeCandidate)) {

        _prevayler.execute(new NumberStorageTransaction(primeCandidate));

        largestPrime = primeCandidate;
        primesFound = _numberKeeper.numbers().size();
        System.out.println(""Primes found: "" + primesFound + "". Largest: "" + largestPrime);
      }

      primeCandidate++;
    }
  }"
org.prevayler.demos.demo1.PrimeCalculator.isPrime,"  private boolean isPrime(int candidate) {
      /*int factor = 2;
        candidate = candidate / 2;
        while (factor < candidate) {
          if (candidate % factor == 0) return false;
          factor++;
        }
        return true;*/

    if (candidate < 2) {
      return false;
    }
    if (candidate == 2) {
      return true;
    }
    if (candidate % 2 == 0) {
      return false;
    }

    int factor = 3;
    double square = Math.ceil(Math.sqrt(candidate));
    while (factor <= square) {
      if (candidate % factor == 0) return false;
      factor += 2;
    }
    return true;
  }

"
org.prevayler.demos.demo1.NumberStorageTransaction.executeOn,"  public void executeOn(NumberKeeper prevalentSystem, Date ignored) {
    prevalentSystem.keep(_numberToKeep);
  }
"
org.prevayler.demos.demo1.Main.main,"  public static void main(String[] args) throws Exception {
    printMessage();
    Prevayler<NumberKeeper> prevayler = PrevaylerFactory.createPrevayler(new NumberKeeper(), ""demo1"");
    new PrimeCalculator(prevayler).start();
  }"
org.prevayler.demos.demo1.Main.printMessage,"  static private void printMessage() throws Exception {
    System.out.println(""\nRobustness Reminder: You can kill this process at any time.\nWhen you restart the system, you will see that nothing was lost.\nPress Enter to continue.\n"");
    (new BufferedReader(new InputStreamReader(System.in))).readLine();
  }

"
org.prevayler.PrevaylerFactory.createPrevayler,"/**
* Creates a Prevayler that will use the given prevalenceBase directory to read
* and write its .snapshot and .journal files, using standard Java
* serialization. This requires that the Prevalent System and all Transaction
* implementations used by the Prevayler are Java-Serializable. <br>
* <br>
* <i>Example:</i> <br>
* <code>
* <br><i>//Your object:</i>
* <br>MyObjectToPersist newPrevalentSystem = new MyObjectToPersist();
* <br>String prevalenceBase = ""myDirectory"";
* <br><b>Prevayler&lt;MyObjectToPersist&gt; prevayler = PrevaylerFactory.createPrevayler(newPrevalentSystem, prevalenceBase);</b>
* <br></code>
*
* @param newPrevalentSystem The newly started, ""empty"" prevalent system that
*                           will be used as a starting point for every system
*                           startup, until the first snapshot is taken.
* @param prevalenceBase     The directory where the .snapshot files and
*                           .journal files will be read and written.
*/
  public static <P> Prevayler<P> createPrevayler(P newPrevalentSystem, String prevalenceBase) throws Exception {
    PrevaylerFactory<P> factory = new PrevaylerFactory<P>();
    factory.configurePrevalentSystem(newPrevalentSystem);
    factory.configurePrevalenceDirectory(prevalenceBase);
    return factory.create();
  }"
org.prevayler.PrevaylerFactory.createPrevayler,"/**
* Creates a Prevayler that will use a directory called ""PrevalenceBase"" under
* the current directory to read and write its .snapshot and .journal files,
* using standard Java serialization. This requires that the Prevalent System
* and all Transaction implementations used by the Prevayler are
* Java-Serializable.
*
* @param newPrevalentSystem The newly started, ""empty"" prevalent system that
*                           will be used as a starting point for every system
*                           startup, until the first snapshot is taken.
* @see #createPrevayler(Object, String)
*/
  public static <P> Prevayler<P> createPrevayler(P newPrevalentSystem) throws Exception {
    return createPrevayler(newPrevalentSystem, ""PrevalenceBase"");
  }"
org.prevayler.PrevaylerFactory.createCheckpointPrevayler,"/**
* Creates a Prevayler that will execute Transactions WITHOUT writing them to
* disk. Snapshots will work as ""checkpoints"" for the system, therefore. This is
* useful for stand-alone applications that have a ""Save"" button, for example.
* The Prevayler will use standard Java serialization for reading and writing
* its .snapshot files, which requires that the Prevalent System is
* Java-Serializable.
*
* @param newPrevalentSystem The newly started, ""empty"" prevalent system that
*                           will be used as a starting point for every system
*                           startup, until the first snapshot is taken.
* @param snapshotDirectory  The directory where the .snapshot files will be
*                           read and written.
* @see #createPrevayler(Object, String)
*/
  public static <P> Prevayler<P> createCheckpointPrevayler(P newPrevalentSystem, String snapshotDirectory) {
    PrevaylerFactory<P> factory = new PrevaylerFactory<P>();
    factory.configurePrevalentSystem(newPrevalentSystem);
    factory.configurePrevalenceDirectory(snapshotDirectory);
    factory.configureTransientMode(true);
    try {
      return factory.create();
    } catch (Exception e) {
      e.printStackTrace(); // Transient Prevayler creation should not fail.
      return null;
    }
  }"
org.prevayler.PrevaylerFactory.createTransientPrevayler,"/**
* Creates a Prevayler that will execute Transactions WITHOUT writing them to
* disk. This is useful for running automated tests or demos MUCH faster than
* with a regular Prevayler.
* <p/>
* Attempts to take snapshots on this transient Prevayler will throw an
* IOException.
*
* @param newPrevalentSystem The newly started, ""empty"" prevalent system.
* @see #createCheckpointPrevayler(Object, String)
*/
  public static <P> Prevayler<P> createTransientPrevayler(P newPrevalentSystem) {
    PrevaylerFactory<P> factory = new PrevaylerFactory<P>();
    factory.configurePrevalentSystem(newPrevalentSystem);
    factory.configureNullSnapshotManager(
        new NullSnapshotManager<P>(newPrevalentSystem, ""Transient Prevaylers are unable to take snapshots.""));
    factory.configureTransientMode(true);
    try {
      return factory.create();
    } catch (Exception e) {
      e.printStackTrace(); // Transient Prevayler creation should not fail.
      return null;
    }
  }"
org.prevayler.PrevaylerFactory.createTransientPrevayler,"  public static <P> Prevayler<P> createTransientPrevayler(P newPrevalentSystem, String snapshotDirectory) {
    return createCheckpointPrevayler(newPrevalentSystem, snapshotDirectory);
  }"
org.prevayler.PrevaylerFactory.clock,"  private Clock clock() {
    return _clock != null ? _clock : new MachineClock();
  }"
org.prevayler.PrevaylerFactory.configurePrevalentSystem,"/**
* Configures the prevalent system that will be used by the Prevayler created by
* this factory.
*
* @param newPrevalentSystem If the default Serializer is used, this
*                           prevalentSystem must be Serializable. If another
*                           Serializer is used, this prevalentSystem must be
*                           compatible with it.
* @see #configureSnapshotSerializer(String, Serializer)
*/
  public void configurePrevalentSystem(P newPrevalentSystem) {
    _prevalentSystem = newPrevalentSystem;
  }"
org.prevayler.PrevaylerFactory.configurePrevalenceDirectory,"/**
* Configures the directory where the created Prevayler will read and write its
* .journal and .snapshot files. The default is a directory called
* ""PrevalenceBase"" under the current directory.
*
* @param prevalenceDirectory Will be ignored for the .snapshot files if a
*                            SnapshotManager is configured.
*/
  public void configurePrevalenceDirectory(String prevalenceDirectory) {
    _prevalenceDirectory = prevalenceDirectory;
  }"
org.prevayler.PrevaylerFactory.configureTransactionDeepCopy,"/**
* Configures whether deep copies of transactions are executed instead of the
* transactions themselves, upon calling "".execute"" on the created Prevayler.
* The default is <code>true</code>.
*
* @param transactionDeepCopyMode <br>
*                                <br>
*                                If <code>false</code>, references passed in to
*                                transactions are used naturally, as they are
*                                during ordinary Java method calls, allowing
*                                their underlying objects to be changed inside
*                                transactions. However, any unrecoverable
*                                changes to the prevalent system and
*                                unrecoverable uses of reference equality
*                                inside transactions will not fail fast as they
*                                would upon recovery. <br>
*                                <br>
*                                If <code>true</code> (default), a deep copy of
*                                the transaction is executed each time. This
*                                allows any unrecoverable changes to the
*                                prevalent system and unrecoverable uses of
*                                reference equality inside transactions to fail
*                                fast as they would upon recovery. However, it
*                                only allows changes to deep copies of the
*                                objects passed in, not the original objects.
*/
  public void configureTransactionDeepCopy(boolean transactionDeepCopyMode) {
    _transactionDeepCopyMode = transactionDeepCopyMode;
  }"
org.prevayler.PrevaylerFactory.configureClock,"/**
* Configures the Clock that will be used by the created Prevayler. The Clock
* interface can be implemented by the application if it requires Prevayler to
* use a special time source other than the machine clock (default).
*/
  public void configureClock(Clock clock) {
    _clock = clock;
  }"
org.prevayler.PrevaylerFactory.configureMonitor,"/**
* Assigns a monitor object to receive notifications from Prevayler. This is
* useful for logging or sending eMails to system administrators, for example.
* If this method is not called or if null is passed as a parameter, a
* SimpleMonitor will be used to log notification on System.err.
*
* @param monitor the Monitor implementation to use.
* @see org.prevayler.foundation.monitor.SimpleMonitor
*/
  public void configureMonitor(Monitor monitor) {
    _monitor = monitor;
  }"
org.prevayler.PrevaylerFactory.configureTransientMode,"/**
* Determines whether the Prevayler created by this factory should be transient
* or persistent. The default is <code>false</code> (persistent).
*
* @param transientMode <br>
*                      <br>
*                      If <code>true</code>, a ""transient"" Prevayler will be
*                      created, which will execute its Transactions WITHOUT
*                      writing them to disk. This is useful for stand-alone
*                      applications which have a ""Save"" button, for example, or
*                      for running automated tests MUCH faster than with a
*                      persistent Prevayler. <br>
*                      <br>
*                      If <code>false</code> (default), a persistent Prevayler
*                      will be created.
*/
  public void configureTransientMode(boolean transientMode) {
    _transientMode = transientMode;
  }"
org.prevayler.PrevaylerFactory.configureReplicationClient,"/**
* Reserved for future implementation.
*/
  public void configureReplicationClient(String remoteServerIpAddress, int remoteServerPort) {
    _remoteServerIpAddress = remoteServerIpAddress;
    _remoteServerPort = remoteServerPort;
  }"
org.prevayler.PrevaylerFactory.configureReplicationServer,"/**
* Reserved for future implementation.
*/
  public void configureReplicationServer(int port) {
    _serverPort = port;
  }"
org.prevayler.PrevaylerFactory.configureNullSnapshotManager,"  private void configureNullSnapshotManager(NullSnapshotManager<P> snapshotManager) {
    _nullSnapshotManager = snapshotManager;
  }"
org.prevayler.PrevaylerFactory.configureJournalFileSizeThreshold,"/**
* Configures the size (in bytes) of the journal file. When the current journal
* exceeds this size, a new journal is created.
*/
  public void configureJournalFileSizeThreshold(long sizeInBytes) {
    _journalSizeThreshold = sizeInBytes;
  }"
org.prevayler.PrevaylerFactory.configureJournalFileAgeThreshold,"/**
* Sets the age (in milliseconds) of the journal file. When the current journal
* expires, a new journal is created.
*/
  public void configureJournalFileAgeThreshold(long ageInMilliseconds) {
    _journalAgeThreshold = ageInMilliseconds;
  }

  /**
   * Configures whether the journal will sync writes to disk. The default is
   * <code>true</code>.
   *
   * @param journalDiskSync <br>
   *                        <br>
   *                        If <code>false</code>, transactions may execute
   *                        without necessarily being written to the physical
   *                        disk. Transactions are still flushed to the operating
   *                        system before being executed, but
   *                        FileDescriptor.sync() is never called. This increases
   *                        transaction throughput dramatically, but allows
   *                        transactions to be lost if the system does not shut
   *                        down cleanly. Calling {@link Prevayler#close()} will
   *                        close the underlying journal file and therefore cause
   *                        all transactions to be written to disk. <br>
   *                        <br>
   *                        If <code>true</code> (default), every transaction is
   *                        forced to be written to the physical disk before it is
   *                        executed (using
   *                        {@link java.io.FileDescriptor#sync()}"
org.prevayler.PrevaylerFactory.configureJournalDiskSync,"/**
* Configures whether the journal will sync writes to disk. The default is
* <code>true</code>.
*
* @param journalDiskSync <br>
*                        <br>
*                        If <code>false</code>, transactions may execute
*                        without necessarily being written to the physical
*                        disk. Transactions are still flushed to the operating
*                        system before being executed, but
*                        FileDescriptor.sync() is never called. This increases
*                        transaction throughput dramatically, but allows
*                        transactions to be lost if the system does not shut
*                        down cleanly. Calling {@link Prevayler#close()} will
*                        close the underlying journal file and therefore cause
*                        all transactions to be written to disk. <br>
*                        <br>
*                        If <code>true</code> (default), every transaction is
*                        forced to be written to the physical disk before it is
*                        executed (using
*                        {@link java.io.FileDescriptor#sync()}). (Many
*                        transactions may be written at once, but no
*                        transaction will be executed before it is written to
*                        disk.)
*/
  public void configureJournalDiskSync(boolean journalDiskSync) {
    _journalDiskSync = journalDiskSync;
  }"
org.prevayler.PrevaylerFactory.configureJournalSerializer,"  public void configureJournalSerializer(JavaSerializer serializer) {
    configureJournalSerializer(""journal"", serializer);
  }"
org.prevayler.PrevaylerFactory.configureJournalSerializer,"  public void configureJournalSerializer(XStreamSerializer serializer) {
    configureJournalSerializer(""xstreamjournal"", serializer);
  }"
org.prevayler.PrevaylerFactory.configureJournalSerializer,"/**
* Configures the transaction journal Serializer to be used by the Prevayler
* created by this factory. Only one Serializer is supported at a time. If you
* want to change the Serializer of a system in production, you will have to
* take a snapshot first because the journal files written by the previous
* Serializer will not be read.
*/
  public void configureJournalSerializer(String suffix, Serializer serializer) {
    PrevaylerDirectory.checkValidJournalSuffix(suffix);

    if (_journalSerializer != null) {
      throw new IllegalStateException(""Read the javadoc to this method."");
    }

    _journalSerializer = serializer;
    _journalSuffix = suffix;
  }"
org.prevayler.PrevaylerFactory.configureSnapshotSerializer,"  public void configureSnapshotSerializer(JavaSerializer serializer) {
    configureSnapshotSerializer(""snapshot"", serializer);
  }"
org.prevayler.PrevaylerFactory.configureSnapshotSerializer,"  public void configureSnapshotSerializer(XStreamSerializer serializer) {
    configureSnapshotSerializer(""xstreamsnapshot"", serializer);
  }"
org.prevayler.PrevaylerFactory.configureSnapshotSerializer,"/**
* Configure a serialization strategy for snapshots. This may be called any
* number of times with different suffixes to configure different strategies for
* reading existing snapshots. The first call to this method establishes the
* <i>primary</i> strategy, which will be used for writing snapshots as well as
* for deep-copying the prevalent system whenever necessary.
*/
  public void configureSnapshotSerializer(String suffix, Serializer serializer) {
    PrevaylerDirectory.checkValidSnapshotSuffix(suffix);
    _snapshotSerializers.put(suffix, serializer);
    if (_primarySnapshotSuffix == null) {
      _primarySnapshotSuffix = suffix;
    }
  }"
org.prevayler.PrevaylerFactory.create,"/**
* Returns a Prevayler created according to what was defined by calls to the
* configuration methods above.
*
* @throws IOException            If there is trouble creating the Prevalence
*                                Base directory or reading a .journal or
*                                .snapshot file.
* @throws ClassNotFoundException If a class of a serialized Object is not found
*                                when reading a .journal or .snapshot file.
*/
  public Prevayler<P> create() throws Exception {
    GenericSnapshotManager<P> snapshotManager = snapshotManager();
    TransactionPublisher<P> publisher = publisher(snapshotManager);
    if (_serverPort != -1)
      new ServerListener<P>(publisher, new OldNetworkImpl(), _serverPort);
    return new PrevaylerImpl<P>(snapshotManager, publisher, journalSerializer(), _transactionDeepCopyMode);
  }"
org.prevayler.PrevaylerFactory.prevalenceDirectory,"  private String prevalenceDirectory() {
    return _prevalenceDirectory != null ? _prevalenceDirectory : ""Prevalence"";
  }"
org.prevayler.PrevaylerFactory.prevalentSystem,"  private P prevalentSystem() {
    if (_prevalentSystem == null)
      throw new IllegalStateException(""The prevalent system must be configured."");
    return _prevalentSystem;
  }"
org.prevayler.PrevaylerFactory.publisher,"  private TransactionPublisher<P> publisher(GenericSnapshotManager<P> snapshotManager) throws IOException {
    if (_remoteServerIpAddress != null)
      return new ClientPublisher<P>(new OldNetworkImpl(), _remoteServerIpAddress, _remoteServerPort);
    return new CentralPublisher<P>(clock(), journal());
  }"
org.prevayler.PrevaylerFactory.journal,"  private Journal<P> journal() throws IOException {
    if (_transientMode) {
      return new TransientJournal<P>();
    } else {
      PrevaylerDirectory directory = new PrevaylerDirectory(prevalenceDirectory());
      return new PersistentJournal<P>(directory, _journalSizeThreshold, _journalAgeThreshold, _journalDiskSync,
          journalSuffix(), monitor());
    }
  }"
org.prevayler.PrevaylerFactory.journalSerializer,"  private Serializer journalSerializer() {
    if (_journalSerializer != null)
      return _journalSerializer;
    return new JavaSerializer();
  }"
org.prevayler.PrevaylerFactory.journalSuffix,"  private String journalSuffix() {
    return _journalSuffix != null ? _journalSuffix : ""journal"";
  }"
org.prevayler.PrevaylerFactory.snapshotManager,"  private GenericSnapshotManager<P> snapshotManager() throws Exception {
    if (_nullSnapshotManager != null)
      return _nullSnapshotManager;

    PrevaylerDirectory directory = new PrevaylerDirectory(prevalenceDirectory());
    if (!_snapshotSerializers.isEmpty())
      return new GenericSnapshotManager<P>(_snapshotSerializers, _primarySnapshotSuffix, prevalentSystem(), directory,
          journalSerializer());

    String snapshotSuffix = ""snapshot"";
    JavaSerializer snapshotSerializer = new JavaSerializer();
    return new GenericSnapshotManager<P>(Collections.singletonMap(snapshotSuffix, snapshotSerializer), snapshotSuffix,
        prevalentSystem(), directory, journalSerializer());
  }"
org.prevayler.PrevaylerFactory.monitor,"  private Monitor monitor() {
    return _monitor != null ? _monitor : new SimpleMonitor(System.err);
  }
"
org.prevayler.contrib.facade.CampGuideTransactionHint.preExecute,"/**
* @see org.prevayler.contrib.facade.TransactionHint#preExecute(java.lang.Object, java.lang.reflect.Method, java.lang.Object[], java.util.Date)
*/
  public void preExecute(CampGuide p_prevalentSystem, Method p_method,
                         Object[] p_args, Date p_timestamp) throws Exception {
    p_prevalentSystem.setTransactionTime(p_timestamp);
  }

"
org.prevayler.contrib.facade.AnotherTest.testCampGuideSystem,"  public void testCampGuideSystem() throws Exception {
    CampGuide guide = 
        PrevaylerTransactionsFacade.create
            (CampGuide.class,
                PrevaylerFactory.createTransientPrevayler(new CampGuideImpl()),
                TransactionType.SIMPLE_DETERMINER,
                new CampGuideTransactionHint());

    addSite(guide, ""Hikers'delight"", CampSite.ON_SITE, 300, 100, CampSite.NOT_AVAILABLE, 2, 3, 15, 7);
    addSite(guide, ""Mountain view"", CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, 3, 3, 30, 6);
    addSite(guide, ""Middle of Nowhere"", CampSite.ON_SITE, CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, 3, 1, 15, 4);
    addSite(guide, ""Belle air"", CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, 2, 3, 40, 4);
    addSite(guide, ""Lakeview"", CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, CampSite.NOT_AVAILABLE, 3, 3, 25, 6);
    addSite(guide, ""Wild waters"", CampSite.ON_SITE, 500, 0, CampSite.NOT_AVAILABLE, 2, 2, 55, 7);
    addSite(guide, ""OpenAir Sports center"", CampSite.ON_SITE, CampSite.ON_SITE, 0, 300, 1, 0, 90, 13);
    addSite(guide, ""Central city campsite"", 100, 100, 400, 100, 0, 1, 70, 10);
    addSite(guide, ""Highhills outdoor resort"", CampSite.ON_SITE, 200, 0, CampSite.NOT_AVAILABLE, 1, 3, 120, 12);
    addSite(guide, ""Fred's Family Farm"", CampSite.ON_SITE, 150, 0, 100, 2, 2, 120, 18);
    addSite(guide, ""Holiday heaven"", CampSite.ON_SITE, 200, 0, 0, 1, 2, 150, 18);
    addSite(guide, ""Summer city"", 200, CampSite.ON_SITE, 0, 0, 0, 1, 720, 29);
    addSite(guide, ""Sunny sands"", CampSite.ON_SITE, CampSite.ON_SITE, 0, 200, 1, 1, 300, 34);
    addSite(guide, ""Surf-n-sleep"", CampSite.ON_SITE, CampSite.ON_SITE, 0, 0, 0, 1, 550, 30);
    addSite(guide, ""Dance and dream"", 50, CampSite.ON_SITE, 0, 0, 1, 1, 640, 32);
    addSite(guide, ""Sunset beach resort"", CampSite.ON_SITE, CampSite.ON_SITE, 0, 0, 0, 1, 800, 35);

    assertEquals(""Should have been 16 camp sites"", 16, guide.getCampSites().size());

    int i = 16;
    for (Iterator<CampSite> iter = guide.getCampSites().iterator(); iter.hasNext(); ) {
      CampSite site = iter.next();
      //System.out.println(site);
      site.setDistanceToSupermarket(50);
      //System.out.println(""updated: "" + site.getUpdated().getTime());
      //for (int b=100000000; b > 0; b--) {}
      guide.updateCampSite(site);
      //System.out.println(""updated: "" + guide.getCampSite(site.objectCode()).getUpdated().getTime());
      assertEquals(""object was updated, but created date should have stayed the same"", site.getCreated().getTime(), guide.getCampSite(site.objectCode()).getCreated().getTime());
      assertFalse(""object was updated, so time should have been different"", Long.valueOf(site.getUpdated().getTime()).equals(Long.valueOf(guide.getCampSite(site.objectCode()).getUpdated().getTime())));
      guide.removeCampSite(site);
      assertNull(""camp site removed, so should have been null"", guide.getCampSite(site.objectCode()));
      assertEquals(""Should have been "" + --i + "" camp sites"", i, guide.getCampSites().size());
    }
    assertEquals(""Should have been 0"", 0, guide.getCampSites().size());

    for (int j = 0; j < guide.getCampSites().size(); j++) {
      //System.out.println(((CampSite)guide.getCampSites().get(i)).getUpdated());
    }

  }"
org.prevayler.contrib.facade.AnotherTest.testTheBaptismProblem,"  public void testTheBaptismProblem() throws Exception {
    PrevaylerFactory<CampGuide> factory = new PrevaylerFactory<CampGuide>();
    factory.configureJournalSerializer(new XStreamSerializer());
    factory.configureSnapshotSerializer(new XStreamSerializer());
    factory.configureSnapshotSerializer(new JavaSerializer());
    factory.configurePrevalentSystem(new CampGuideImpl());
    Prevayler<CampGuide> prevayler = factory.create();
    CampGuide guide = 
        PrevaylerTransactionsFacade.create
            (CampGuide.class,
                prevayler,
                TransactionType.SIMPLE_DETERMINER,
                new CampGuideTransactionHint());

    if (guide.getCampSites().size() == 0) {
      System.out.println(""adding single site for testing"");
      addSite(guide, ""Hikers'delight"", CampSite.ON_SITE, 300, 100, CampSite.NOT_AVAILABLE, 2, 3, 15, 7);
    }

    for (Iterator<CampSite> iter = guide.getCampSites().iterator(); iter.hasNext(); ) {
      CampSite site = iter.next();
      assertTrue(""Baptism issue! Transaction doesn't reflect upated value"", date.getTimeInMillis() == site.getSomeDate().getTimeInMillis());
      System.out.println(site.getSomeDate().getTime());
      date.add(Calendar.DATE, 1); //move forward a day
      site.setSomeDate(date);
      guide.updateCampSite(site);
      System.out.println(site.getSomeDate().getTime());
      date.add(Calendar.DATE, -1); //move back to standard original date
      site.setSomeDate(date);
      guide.updateCampSite(site);
      System.out.println(site.getSomeDate().getTime());
    }

  }"
org.prevayler.contrib.facade.AnotherTest.addSite,"/**
* Adds a camp site with the given features to the given camp guide
*/
  private void addSite(CampGuide guide, String name,
                       int playground, int supermarket, int swimmingPool, int disco,
                       int quiet, int beauty, int size, int price) {
    CampSite site = new CampSite(name);
    site.setDistanceToPlayground(playground);
    site.setDistanceToSupermarket(supermarket);
    site.setDistanceToSwimmingPool(swimmingPool);
    site.setDistanceToDisco(disco);
    site.setQuietIndication(quiet);
    site.setBeautyIndication(beauty);
    site.setSize(size);
    site.setPriceIndication(price);
    site.setSomeDate(date);
    guide.addCampSite(site);
    //System.out.println(site.getUpdated());
  }

"
org.prevayler.contrib.facade.SmokeTest.storeSomething,
org.prevayler.contrib.facade.SmokeTest.oopsRuntime,
org.prevayler.contrib.facade.SmokeTest.oopsChecked,
org.prevayler.contrib.facade.SmokeTest.getData,"    String getData();
  "
org.prevayler.contrib.facade.SmokeTest.storeSomething,"    public void storeSomething(String p_data) {
      m_data = p_data;
    }"
org.prevayler.contrib.facade.SmokeTest.oopsRuntime,"    public void oopsRuntime(String p_data) {
      m_data = p_data;
      throw new RuntimeOops();
    }"
org.prevayler.contrib.facade.SmokeTest.oopsChecked,"    public void oopsChecked(String p_data)
        throws CheckedOops {
      m_data = p_data;
      throw new CheckedOops();
    }"
org.prevayler.contrib.facade.SmokeTest.getData,"    public String getData() {
      return m_data;
    }"
org.prevayler.contrib.facade.SmokeTest.testAndSeeIfItSmokes,"  public void testAndSeeIfItSmokes()
      throws Exception {
    Repository repo = 
        PrevaylerTransactionsFacade.create
            (Repository.class,
                PrevaylerFactory.createTransientPrevayler(new RepositoryImpl()));

    assertEquals(null, repo.getData());
    final String data = ""someData"";
    repo.storeSomething(data);
    assertEquals(data, repo.getData());

    final String otherData = ""other data"";
    try {
      repo.oopsRuntime(otherData);
      fail(""should have thrown RuntimeOops"");
    } catch (RuntimeOops expected) {
      System.currentTimeMillis();// ok
    }

    // previously when rollback was a feature in prevayler
    // this would have equaled data rather than otherData
    assertEquals(otherData, repo.getData());

    try {
      repo.oopsChecked(""more other data"");
      fail(""should have thrown CheckedOops"");
    } catch (CheckedOops expected) {
      //expected.printStackTrace();
      System.currentTimeMillis();// ok
    }

    //checked exception doesn't trigger rollback
    //it is assumed that checked exceptions are
    //expected and should be delbt with manually
    //where runtime exceptions are unexpected. As
    //such, internal code may not be prepared to
    //deal with them so Prevayler rolls back
    assertEquals(""more other data"", repo.getData());
  }
"
org.prevayler.contrib.facade.MethodInfoTest.testSimple,"  public void testSimple()
      throws Exception {
    Method m = String.class.getMethod(""length"", new Class<?>[0]);
    MethodInfo mi = new MethodInfo(m);
    assertEquals(""methods should be equal"", m, mi.getMethod());
  }
"
org.prevayler.contrib.facade.RandomGUID.getRandomGUID,"* Method to generate the random GUID
*/
  private void getRandomGUID(boolean secure) {
    MessageDigest md5 = null;
    StringBuffer sbValueBeforeMD5 = new StringBuffer();

    try {
      md5 = MessageDigest.getInstance(""MD5"");
    } catch (NoSuchAlgorithmException e) {
      System.out.println(""Error: "" + e);
    }

    try {
      long time = System.currentTimeMillis();
      long rand = 0;

      if (secure) {
        rand = mySecureRand.nextLong();
      } else {
        rand = myRand.nextLong();
      }

      // This StringBuffer can be a long as you need; the MD5
      // hash will always return 128 bits.  You can change
      // the seed to include anything you want here.
      // You could even stream a file through the MD5 making
      // the odds of guessing it at least as great as that
      // of guessing the contents of the file!
      sbValueBeforeMD5.append(s_id);
      sbValueBeforeMD5.append("":"");
      sbValueBeforeMD5.append(Long.toString(time));
      sbValueBeforeMD5.append("":"");
      sbValueBeforeMD5.append(Long.toString(rand));

      valueBeforeMD5 = sbValueBeforeMD5.toString();
      md5.update(valueBeforeMD5.getBytes());

      byte[] array = md5.digest();
      StringBuffer sb = new StringBuffer();
      for (int j = 0; j < array.length; ++j) {
        int b = array[j] & 0xFF;
        if (b < 0x10) sb.append('0');
        sb.append(Integer.toHexString(b));
      }

      valueAfterMD5 = sb.toString();

    } catch (Exception e) {
      System.out.println(""Error:"" + e);
    }
  }"
org.prevayler.contrib.facade.RandomGUID.toString,"* Convert to the standard format for GUID
* (Useful for SQL Server UniqueIdentifiers, etc.)
* Example: C2FEEEAC-CFCD-11D1-8B05-00600806D9B6
*/
  public String toString() {
    String raw = valueAfterMD5.toUpperCase();
    StringBuffer sb = new StringBuffer();
    sb.append(raw.substring(0, 8));
    sb.append(""-"");
    sb.append(raw.substring(8, 12));
    sb.append(""-"");
    sb.append(raw.substring(12, 16));
    sb.append(""-"");
    sb.append(raw.substring(16, 20));
    sb.append(""-"");
    sb.append(raw.substring(20));

    return sb.toString();
  }"
org.prevayler.contrib.facade.RandomGUID.main,"* Demonstraton and self test of class
*/
  public static void main(String args[]) {
    for (int i = 0; i < 100; i++) {
      RandomGUID myGUID = new RandomGUID();
      System.out.println(""Seeding String="" + myGUID.valueBeforeMD5);
      System.out.println(""rawGUID="" + myGUID.valueAfterMD5);
      System.out.println(""RandomGUID="" + myGUID.toString());
    }
  }
"
org.prevayler.contrib.facade.CampGuideImpl.addCampSite,"/**
* Adds the given camp site to this camp guide
*/
  public void addCampSite(CampSite site) {
    stampCampSite(site);
    campSites.put(site.objectCode(), site);
  }"
org.prevayler.contrib.facade.CampGuideImpl.updateCampSite,"  public void updateCampSite(CampSite site) {
    if (!campSites.containsKey(site.objectCode()))
      throw new RuntimeException(""Can't update non-existent camp site!  Try adding it first."");
    addCampSite(site);
  }"
org.prevayler.contrib.facade.CampGuideImpl.removeCampSite,"/**
* Removes the given cam site from this camp guide
*/
  public void removeCampSite(CampSite site) {
    campSites.remove(site.objectCode());
  }"
org.prevayler.contrib.facade.CampGuideImpl.getCampSite,"  public CampSite getCampSite(String objectCode) {
    return campSites.get(objectCode);
  }"
org.prevayler.contrib.facade.CampGuideImpl.getCampSites,"/**
* Returns all camp sites in this camp guide
*
* @return an unmodifiable set of camp sites
*/
  public Set<CampSite> getCampSites() {
    return Collections.unmodifiableSet(new HashSet<CampSite>(campSites.values()));
  }"
org.prevayler.contrib.facade.CampGuideImpl.setTransactionTime,"/**
* Set the current timestamp here in order for
* objects to get stamped as they are added to the
* prevalent system.  To work properly, this should be
* called from within a transaction, before the object
* is added to the system.  The value is not only
* transient, but also is reset to zero immediately
* after usage, so there should be no expectation of
* persisting this timestamp across transactions.  The
* value is for internal use anyway as there is no
* accessor method.
*
* @param timestamp
*/
  public void setTransactionTime(Date timestamp) {
    if (timestamp != null) {
      transaction_time = timestamp.getTime();
    }
  }"
org.prevayler.contrib.facade.CampGuideImpl.stampCampSite,"  private void stampCampSite(CampSite site) {
    if (this.transaction_time != 0) {
      site.setTimestamp(this.transaction_time);
      this.transaction_time = 0; //reset to zero after operation is done
    }
  }
"
org.prevayler.contrib.facade.CampSite.objectCode,"  public String objectCode() {
    return this.guid;
  }"
org.prevayler.contrib.facade.CampSite.getName,"/**
* Returns the name of the camp site
*/
  public String getName() {
    return name;
  }"
org.prevayler.contrib.facade.CampSite.setName,"/**
* Sets the name of the camp site
*/
  public void setName(String name) {
    this.name = name;
  }"
org.prevayler.contrib.facade.CampSite.getDistanceToPlayground,"/**
* Returns the distance to the nearest playground from this camp
* site.
*/
  public int getDistanceToPlayground() {
    return playground;
  }"
org.prevayler.contrib.facade.CampSite.setDistanceToPlayground,"/**
* Sets the distance to the nearest playground from this camp site.
*/
  public void setDistanceToPlayground(int playground) {
    this.playground = playground;
  }"
org.prevayler.contrib.facade.CampSite.getDistanceToSupermarket,"/**
* Returns the distance to the nearest supermarket from this camp
* site
*/
  public int getDistanceToSupermarket() {
    return supermarket;
  }"
org.prevayler.contrib.facade.CampSite.setDistanceToSupermarket,"/**
* Sets the distance to the nearest supermarket from this camp site
*/
  public void setDistanceToSupermarket(int supermarket) {
    this.supermarket = supermarket;
  }"
org.prevayler.contrib.facade.CampSite.getDistanceToSwimmingPool,"/**
* Returns the distance to the nearest swimming pool from this camp
* site
*/
  public int getDistanceToSwimmingPool() {
    return swimmingPool;
  }"
org.prevayler.contrib.facade.CampSite.setDistanceToSwimmingPool,"/**
* Sets the distance to the nearest swimming pool from this camp
* site
*/
  public void setDistanceToSwimmingPool(int swimmingPool) {
    this.swimmingPool = swimmingPool;
  }"
org.prevayler.contrib.facade.CampSite.getDistanceToDisco,"/**
* Returns the distance to the nearest discotheque from this camp
* site
*/
  public int getDistanceToDisco() {
    return disco;
  }"
org.prevayler.contrib.facade.CampSite.setDistanceToDisco,"/**
* Sets the distance to the nearest discotheque from this camp site
*/
  public void setDistanceToDisco(int disco) {
    this.disco = disco;
  }"
org.prevayler.contrib.facade.CampSite.getQuietIndication,"/**
* Returns the indication of how quiet the campsite is. Value
* between 0 (extremely noisy) and 3 (completely quiet), both
* inclusive
*/
  public int getQuietIndication() {
    return quiet;
  }"
org.prevayler.contrib.facade.CampSite.setQuietIndication,"/**
* Sets the indication of how quiet the campsite is. Value between
* 0 (extremely noisy) and 3 (completely quiet), both inclusive
*/
  public void setQuietIndication(int quiet) {
    this.quiet = quiet;
  }"
org.prevayler.contrib.facade.CampSite.getBeautyIndication,"/**
* Returns the indication of how beatiful the view from the campsite
* is. Value between 0 (nothing to see) and 3 (paradise on earth),
* both inclusive
*/
  public int getBeautyIndication() {
    return beauty;
  }"
org.prevayler.contrib.facade.CampSite.setBeautyIndication,"/**
* Sets the indication of how beatiful the view from the campsite
* is. Value between 0 (nothing to see) and 3 (paradise on earth),
* both inclusive
*/
  public void setBeautyIndication(int beauty) {
    this.beauty = beauty;
  }"
org.prevayler.contrib.facade.CampSite.getSize,"/**
* Returns the size of the camp site, the number of locations
*/
  public int getSize() {
    return size;
  }"
org.prevayler.contrib.facade.CampSite.setSize,"/**
* Sets the size of the camp site, the number of locations
*/
  public void setSize(int size) {
    this.size = size;
  }"
org.prevayler.contrib.facade.CampSite.getPriceIndication,"/**
* Returns a price indication of this camp site
*/
  public int getPriceIndication() {
    return price;
  }"
org.prevayler.contrib.facade.CampSite.setPriceIndication,"/**
* Sets a price indication of this camp site
*/
  public void setPriceIndication(int price) {
    this.price = price;
  }"
org.prevayler.contrib.facade.CampSite.setTimestamp,"/**
* Sets both created and updated fields as required.  There is no need
* to call this method outside of a Transaction in a Prevalent system,
* especially since it will simply be overwritten by the Transaction.
* The prevalent system, which should be in the same package, should set
* this.  It is package protected, so that's the only way it would work
* anyway.
*
* @param timestamp the current Date
*/
  void setTimestamp(long timestamp) {
    if (this.created == 0) this.created = timestamp;
    this.updated = timestamp;
  }

  /**
   * The date the current object was initially prevayled
   * (see {@link #setTimestamp}"
org.prevayler.contrib.facade.CampSite.getCreated,"/**
* The date the current object was initially prevayled
* (see {@link #setTimestamp}).  Returned objects are defensively copied to
* avoid accidental mutation.
*
* @return a new Date object or null if not yet set
*/
  public Date getCreated() {
    return (this.created != 0) ? new Date(this.created) : null;
  }"
org.prevayler.contrib.facade.CampSite.getUpdated,"/**
* The date the current object was updated.  Same as created date if not
* actually updated at a later time.
*
* @return a new Date object or null if not yet set
* @see #getCreated
*/
  public Date getUpdated() {
    return (this.updated != 0) ? new Date(this.updated) : null;
  }"
org.prevayler.contrib.facade.CampSite.setSomeDate,"/**
* @param someDate The someDate to set.
*/
  public void setSomeDate(Calendar someDate) {
    this.someDate = someDate;
  }"
org.prevayler.contrib.facade.CampSite.getSomeDate,"/**
* @return Returns the someDate.
*/
  public Calendar getSomeDate() {
    return someDate;
  }"
org.prevayler.contrib.facade.CampSite.toString,"  public String toString() {
    StringBuffer buffer = new StringBuffer();
    buffer.append(""[CampSite:"");
    buffer.append("" serialVersionUID: "");
    buffer.append(serialVersionUID);
    buffer.append("" NOT_AVAILABLE: "");
    buffer.append(NOT_AVAILABLE);
    buffer.append("" ON_SITE: "");
    buffer.append(ON_SITE);
    buffer.append("" name: "");
    buffer.append(name);
    buffer.append("" playground: "");
    buffer.append(playground);
    buffer.append("" supermarket: "");
    buffer.append(supermarket);
    buffer.append("" swimmingPool: "");
    buffer.append(swimmingPool);
    buffer.append("" disco: "");
    buffer.append(disco);
    buffer.append("" quiet: "");
    buffer.append(quiet);
    buffer.append("" beauty: "");
    buffer.append(beauty);
    buffer.append("" size: "");
    buffer.append(size);
    buffer.append("" price: "");
    buffer.append(price);
    buffer.append("" created: "");
    buffer.append(created);
    buffer.append("" updated: "");
    buffer.append(updated);
    buffer.append("" guid: "");
    buffer.append(guid);
    buffer.append("" someDate: "");
    buffer.append(someDate);
    buffer.append(""]"");
    return buffer.toString();
  }"
org.prevayler.contrib.facade.CampSite.equals,"/**
* Returns <code>true</code> if this <code>CampSite</code> is the same as the o argument.
*
* @return <code>true</code> if this <code>CampSite</code> is the same as the o argument.
*/
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null) {
      return false;
    }
    if (o.getClass() != getClass()) {
      return false;
    }
    CampSite castedObj = (CampSite) o;
    return ((this.name == null ? castedObj.name == null : this.name
        .equals(castedObj.name))
        && (this.playground == castedObj.playground)
        && (this.supermarket == castedObj.supermarket)
        && (this.swimmingPool == castedObj.swimmingPool)
        && (this.disco == castedObj.disco)
        && (this.quiet == castedObj.quiet)
        && (this.beauty == castedObj.beauty)
        && (this.size == castedObj.size)
        && (this.price == castedObj.price)
        && (this.created == castedObj.created)
        && (this.updated == castedObj.updated)
        && (this.guid == null ? castedObj.guid == null : this.guid
        .equals(castedObj.guid)) && (this.someDate == null
        ? castedObj.someDate == null
        : this.someDate.equals(castedObj.someDate)));
  }"
org.prevayler.contrib.facade.CampSite.hashCode,"/**
* Override hashCode.
*
* @return the Objects hashcode.
*/
  public int hashCode() {
    int hashCode = 1;
    hashCode = 31
        * hashCode
        + (int) (+serialVersionUID ^ (serialVersionUID >>> 32));
    hashCode = 31 * hashCode + NOT_AVAILABLE;
    hashCode = 31 * hashCode + ON_SITE;
    hashCode = 31 * hashCode + (name == null ? 0 : name.hashCode());
    hashCode = 31 * hashCode + playground;
    hashCode = 31 * hashCode + supermarket;
    hashCode = 31 * hashCode + swimmingPool;
    hashCode = 31 * hashCode + disco;
    hashCode = 31 * hashCode + quiet;
    hashCode = 31 * hashCode + beauty;
    hashCode = 31 * hashCode + size;
    hashCode = 31 * hashCode + price;
    hashCode = 31 * hashCode + (int) (+created ^ (created >>> 32));
    hashCode = 31 * hashCode + (int) (+updated ^ (updated >>> 32));
    hashCode = 31 * hashCode + (guid == null ? 0 : guid.hashCode());
    hashCode = 31 * hashCode + (someDate == null ? 0 : someDate.hashCode());
    return hashCode;
  }
"
org.prevayler.contrib.facade.CampGuide.addCampSite,"/**
* Adds the given camp site to this camp guide
*/
"
org.prevayler.contrib.facade.CampGuide.updateCampSite,"/**
* updates an existing campsite with new information
*
* @param site
*/
"
org.prevayler.contrib.facade.CampGuide.removeCampSite,"/**
* Removes the given camp site from this camp guide
*/
"
org.prevayler.contrib.facade.CampGuide.getCampSite,"/**
* @param objectCode
* @return a camp site given its globally unique identifier which is created at CampSite instantiation
*/
"
org.prevayler.contrib.facade.CampGuide.getCampSites,"/**
* Returns all camp sites in this camp guide
*/
"
org.prevayler.contrib.facade.CampGuide.setTransactionTime,"/**
* Sets the time of the current transaction in order
* to apply it to added objects (optional)
*/
  public void setTransactionTime(Date timestamp);
"
org.prevayler.contrib.facade.MethodInfo.getMethod,"/**
* ""Reconstitute"" (i.e., lookup reflectively) the
* <code>Method</code> represented by this object. Note that
* different results may occur if different
* <code>ClassLoader</code>s are used during construction and the
* invocation of this method.
*
* @return the <code>Method</code> represented by this object
* @throws the usual batch of reflection-based exceptions if
*             something goes wrong
*/
  public Method getMethod()
      throws Exception {
    Class<?>[] args = new Class<?>[m_argTypes.length];
    for (int i = 0; i < args.length; ++i) {
      args[i] = Class.forName(m_argTypes[i]);
    }
    return Class.forName(m_className).getMethod(m_name, args);
  }"
org.prevayler.contrib.facade.ProxyQuery.query,"  public Object query(P p_prevalentSystem, Date p_timestamp) throws Exception {
    return execute(p_prevalentSystem, p_timestamp);
  }

"
org.prevayler.contrib.facade.TransactionHint.preExecute,"        public void preExecute(Object p_prevalentSystem, Method p_method, Object[] p_args, Date p_timestamp) throws Exception {
        }
      "
org.prevayler.contrib.facade.TransactionHint.preExecute,"/**
* This method executes just before the transactional method is invoked,
* so it is a good place to put any generic code that needs to be executed
* before any transaction
*/
  public void preExecute(P p_prevalentSystem, Method p_method, Object[] p_args, Date p_timestamp) throws Exception;

"
org.prevayler.contrib.facade.MethodNameTransactionTypeDeterminer.determineTransactionType,"  public TransactionType determineTransactionType(Method p_method) {
    String name = p_method.getName();
    if (p_method.getReturnType() == Void.TYPE) {
      if (name.indexOf(""transient"") != -1 || name.indexOf(""Transient"") != -1) {
        //This is a guess, but a reasonable (and documented) one.  See more below about TransactionType.NOOP.
        return TransactionType.NOOP;
      }
      //This is, hardly, a guess but a certainty
      return TransactionType.TRANSACTION;
    } else if (name.startsWith(""fetch"")
        || name.startsWith(""find"")
        || name.startsWith(""get"")
        || name.startsWith(""retrieve"")) {
      //This is a guess, but a reasonable (and documented) one
      return TransactionType.QUERY;
    } else {
      if (name.equals(name.toLowerCase())) {
        //Avoid invoking prevayler at all for methods providing
        //access to the root of the system, useful for external
        //unsynchronized query access and avoiding double transactions
        //in the case that a transactional method calls the system
        //access method (eg. root(), system(), etc...).
        //This is a guess, but a reasonable (and documented) one.
        return TransactionType.NOOP;
      }

      //The catch-all fallback.  Can't go wrong here!
      return TransactionType.TRANSACTION_WITH_QUERY;
    }
  }

"
org.prevayler.contrib.facade.ProxyTransaction.executeOn,"  public void executeOn(P p_prevalentSystem, Date p_timestamp) {
    try {
      execute(p_prevalentSystem, p_timestamp);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

"
org.prevayler.contrib.facade.AbstractProxy.execute,"/**
* @since 0_2
*/
  protected Object execute(P p_prevalentSystem, Date p_timestamp)
      throws Exception {
    try {
      m_hint.preExecute(p_prevalentSystem, getMethod(), m_args, p_timestamp);
      return getMethod().invoke(p_prevalentSystem, m_args);
    } catch (RuntimeException e) {
      throw e;
    } catch (InvocationTargetException e) {
      Throwable e2 = e.getTargetException();
      if (e2 instanceof Exception) {
        throw (Exception) e2;
      } else {
        throw (Error) e2;
      }
    }
  }"
org.prevayler.contrib.facade.AbstractProxy.getMethod,"  private Method getMethod() throws Exception {
    return m_methodInfo.getMethod();
  }

"
org.prevayler.contrib.facade.ProxyTransactionWithQuery.executeAndQuery,"  public Object executeAndQuery(P p_prevalentSystem, Date p_timestamp) throws Exception {
    return execute(p_prevalentSystem, p_timestamp);
  }

"
org.prevayler.contrib.facade.TransactionType.determineTransactionType,"/**
* Given a <code>Method</code>, determine the appropriate
* <code>TransactionType</code> to be used in implemented a
* Prevayler for that method.
*
* @param p_method the <code>Method</code> in question
* @return the <code>TransactionType</code> appropriate for
*         that method.
*/
    TransactionType determineTransactionType(Method p_method);
  }

  /**
   * A minimal transaction type determiner which uses no heuristics. It
   * always returns a transaction type of {@link #TRANSACTION_WITH_QUERY"
org.prevayler.contrib.facade.TransactionType.determineTransactionType,"    public TransactionType determineTransactionType(Method p_method) {
      return TRANSACTION_WITH_QUERY;
    }
  };

  /**
   * A basic transaction type determiner which bases the transaction type on
   * the return type of methods: {@link #TRANSACTION} for void methods and
   * {@link #QUERY"
org.prevayler.contrib.facade.TransactionType.determineTransactionType,"    public TransactionType determineTransactionType(Method p_method) {
      return (p_method.getReturnType() != Void.TYPE)
          ? QUERY
          : TRANSACTION;
    }
  "
org.prevayler.contrib.facade.TransactionType.execute,"/**
* @since 0_2
*/
"
org.prevayler.contrib.facade.TransactionType.toString,"  public String toString() {
    return ""TransactionType{"" + m_name + ""}"";
  }"
org.prevayler.contrib.facade.TransactionType.execute,"/**
* @since 0_2
*/
        public <P> Object execute(Prevayler<? extends P> p_prevayler,
                                  Method p_method,
                                  Object[] p_args,
                                  TransactionHint<? super P> p_hint)
            throws Exception {
          return p_prevayler.execute(new ProxyQuery<P>(p_method, p_args, p_hint));
        }
      "
org.prevayler.contrib.facade.TransactionType.execute,"/**
* @since 0_2
*/
        public <P> Object execute(Prevayler<? extends P> p_prevayler,
                                  Method p_method,
                                  Object[] p_args,
                                  TransactionHint<? super P> p_hint)
            throws Exception {
          return p_prevayler.execute(new ProxyTransactionWithQuery<P>(p_method, p_args, p_hint));
        }
      "
org.prevayler.contrib.facade.TransactionType.execute,"/**
* @since 0_2
*/
        public <P> Object execute(Prevayler<? extends P> p_prevayler,
                                  Method p_method,
                                  Object[] p_args,
                                  TransactionHint<? super P> p_hint)
            throws Exception {
          p_prevayler.execute(new ProxyTransaction<P>(p_method, p_args, p_hint));
          return null;
        }
      "
org.prevayler.contrib.facade.TransactionType.execute,"        public <P> Object execute(Prevayler<? extends P> p_prevayler,
                                  Method p_method,
                                  Object[] p_args,
                                  TransactionHint<? super P> p_hint)
            throws Exception {
          return null;
        }
      "
org.prevayler.contrib.facade.PrevaylerTransactionsFacade.create,"/**
* defaults to using a {@link TransactionHint#NOOP_TRANSACTION_HINT}
*/
  public static <P> P create(Class<P> p_intf, Prevayler<? extends P> p_prevayler) {
    return create(p_intf,
        p_prevayler,
        TransactionType.SIMPLE_DETERMINER,
        TransactionHint.NOOP_TRANSACTION_HINT);
  }"
org.prevayler.contrib.facade.PrevaylerTransactionsFacade.create,"/**
* @since 0_2
*/
  public static <P> P create(final Class<P> p_intf,
                             final Prevayler<? extends P> p_prevayler,
                             final TransactionType.Determiner p_determiner,
                             final TransactionHint<? super P> p_hint) {
    return p_intf.cast(Proxy.newProxyInstance
        (p_intf.getClassLoader(),
            new Class<?>[]{p_intf},
            new InvocationHandler() {
              public Object invoke(Object p_proxy,
                                   Method p_method,
                                   Object[] p_args)
                  throws Throwable {
                return p_determiner.determineTransactionType(p_method)
                    .execute(p_prevayler, p_method, p_args, p_hint);
              }
            }));
  }
"
org.prevayler.contrib.facade.PrevaylerTransactionsFacade.invoke,"              public Object invoke(Object p_proxy,
                                   Method p_method,
                                   Object[] p_args)
                  throws Throwable {
                return p_determiner.determineTransactionType(p_method)
                    .execute(p_prevayler, p_method, p_args, p_hint);
              }
            "
org.prevayler.util.memento.MementoCollector.addMemento,"/**
* Add a memento to the memento collection.
*
* @param memento The memento to add.
*/
  public void addMemento(Memento memento);
"
org.prevayler.util.memento.MementoManagerCommand.executeAndQuery,"/**
* Executes this transaction on the received system. See org.prevayler.demos for examples.
* The returned object has to be Serializable in preparation for future versions of
* Prevayler that will provide fault-tolerance through system replicas.
* <p/>
* This method executes the actual transaction and restores the mementos if the execution fails.
*
* @param prevalentSystem The prevalent system on which to execute the transaction.
* @return The object returned by the execution of this transaction. Most commands simply return null.
*/
  public Account executeAndQuery(Bank prevalentSystem, Date timestamp) throws Exception {
    mementos = new HashMap<Memento, Memento>();
    try {
      return transaction.execute(this, prevalentSystem);
    } catch (Exception e) {
      // Something went wrong. Restore the mementos.
      Iterator<Memento> iterator;

      iterator = mementos.values().iterator();
      while (iterator.hasNext()) {
        Memento memento = iterator.next();
        memento.restore();
      }

      throw e;
    } finally {
      mementos = null;
    }
  }"
org.prevayler.util.memento.MementoManagerCommand.addMemento,"/**
* Add a memento to the memento collection. A memento will only be added if a memento
* with the same owner does not exist.
*
* @param memento The memento to add.
*/
  public void addMemento(Memento memento) {
    if (mementos.get(memento.getOwner()) == null) {
      mementos.put(memento, memento);
    }
  }"
org.prevayler.util.memento.Memento.restore,"/**
* Restore the values of the object to the values in this memento.
* <p/>
* It is very important that the implementation does not throw any checked and run-time exceptions.
*/
"
org.prevayler.util.memento.Memento.getOwner,"/**
* Get the object to which this memento belongs.
*
* @return The object to which this memento belongs.
*/
"
org.prevayler.util.memento.Memento.hashCode,"/**
* The hash code of this object. This is used in some sets and maps.
* <p/>
* As it is very important that only the first memento of an object gets stored, this method
* returns the identity hash code of the owner.
*
* @return The hash code of this memento.
*/
  public int hashCode() {
    return System.identityHashCode(getOwner());
  }"
org.prevayler.util.memento.Memento.equals,"/**
* Compare this memento with another. This is used in some sets and maps.
* <p/>
* As it is very important that only the first memento of an object gets stored, this method
* returns true if the class of the other object is the same (identity comparison) class as
* the class of this memento, and the owner of the other memento is the same (identity
* comparison) as the owner of this memento.
*
* @return true if the other memento is a memento for the same object, false otherwise.
*/
  public boolean equals(Object other) {
    boolean result = false;

    if (other.getClass() == getClass()) {
      Memento otherAsMemento;

      otherAsMemento = (Memento) other;

      result = otherAsMemento.getOwner() == getOwner();
    }

    return result;
  }
"
org.prevayler.util.memento.MementoTransaction.execute,"/**
* Executes this command on the received system. See prevayler.demos for examples.
* The returned object has to be Serializable in preparation for future versions of
* Prevayler that will provide fault-tolerance through system replicas.
*
* @param collector       The memento collector to which to add the mementos. A memento
*                        collector instead of a Prevayler instance is passed, so the command will not easily
*                        invoke subcommands through the prevayler (which is not allowed).
* @param prevalentSystem The system on which to execute the command.
* @return The object returned by the execution of this command. Most commands simply return null.
*/
  public Account execute(MementoCollector collector, Bank prevalentSystem) throws Exception {
    findObjects(prevalentSystem);

    checkPrecondition();

    createMementos(collector);

    return execute(collector);
  }"
org.prevayler.util.memento.MementoTransaction.findObjects,"/**
* Find the objects this command modifies.
*
* @param prevalentSystem The prevalent system in which to find the objects.
*/
"
org.prevayler.util.memento.MementoTransaction.checkPrecondition,"/**
* Check the precondition.
*/
"
org.prevayler.util.memento.MementoTransaction.createMementos,"/**
* Create mementos for all objects which (possibly) get modified.
*
* @param collector The memento collector to which to add the mementos.
*/
"
org.prevayler.util.memento.MementoTransaction.execute,"/**
* Execute the actual command.
*
* @param collector The memento collector which can be used to execute subcommands.
* @return The object returned by the execution of this command. Most commands simply return null.
*/
  protected abstract Account execute(MementoCollector collector) throws Exception;
"
org.prevayler.demos.memento.TestErrorRecoveryWithMementos.main,"  public static void main(String[] args) {
    try {

      run();

    } catch (Exception ex) {
      ex.printStackTrace();
    }
  }"
org.prevayler.demos.memento.TestErrorRecoveryWithMementos.run,"  public static void run() throws Exception {
    Account account1 = null, account2 = null;

    System.out.println(""*** Creating account 1"");
    MementoTransaction command = new AccountCreation(""Owner 1"");
    account1 = execute(command);

    System.out.println(""*** Creating account 2"");
    command = new AccountCreation(""Owner 2"");
    account2 = execute(command);

    System.out.println(""*** Depositing 500 into account 1"");
    command = new Deposit(account1, 500);
    execute(command);

    System.out.println(""*** Transferring 200 from account 1 into account 2"");
    command = new Transfer(account1.number(), account2.number(), 200);
    execute(command);

    System.out.println(""*** Deleting account 1"");
    command = new AccountDeletion(account1);
    execute(command);

    System.out.println(""*** Deleting account 1"");
    command = new AccountDeletion(account2);
    execute(command);

    prevayler.takeSnapshot();
  }"
org.prevayler.demos.memento.TestErrorRecoveryWithMementos.execute,"  private static Account execute(MementoTransaction command) {
    try {
      return new MementoManagerCommand(command).executeAndQuery(prevayler.prevalentSystem(), prevayler.clock().time());
    } catch (Exception exception) {
      System.out.println(""FAILURE!"");
      exception.printStackTrace(System.out);
    } finally {
      System.out.println(bank.toString());
    }
    return null;
  }
"
org.prevayler.demos.memento.Account.restore,"    protected void restore() {
      Account.this.holder = holder;
      Account.this.balance = balance;
      Account.this.transactionHistory.clear();
      Account.this.transactionHistory.addAll(transactionHistory);
    }"
org.prevayler.demos.memento.Account.getOwner,"    protected Object getOwner() {
      return Account.this;
    }
  }

  /**
   * Create a memento of the current state.
   */
  public void createMemento(MementoCollector collector) {
    collector.addMemento(new AccountMemento());
  }

  public long number() {
    return number;
  }

  public String toString() { //Returns something like ""00123 - John Smith""
    return numberString() + "" - "" + holder + "" - "" + balance;
  }

  public String numberString() {
    return numberString(number);
  }

  static String numberString(long number) {
    return (new java.text.DecimalFormat(""00000"").format(number));
  }

  public String holder() {
    return holder;
  }

  public void holder(String holder) throws InvalidHolder {
    verify(holder);
    this.holder = holder;
  }

  public long balance() {
    return balance;
  }

  public void deposit(long amount, Date timestamp) throws InvalidAmount {
    verify(amount);
    register(amount, timestamp);
  }

  public void withdraw(long amount, Date timestamp) throws InvalidAmount {
    verify(amount);
    register(-amount, timestamp);
  }

  private void register(long amount, Date timestamp) {
    balance += amount;
    transactionHistory.add(new Transaction(amount, timestamp));
  }

  private void verify(long amount) throws InvalidAmount {
    if (amount <= 0) throw new InvalidAmount(""Amount must be greater than zero."");
    if (amount > 10000) throw new InvalidAmount(""Amount maximum (10000) exceeded."");
  }

  public List<Transaction> transactionHistory() {
    return transactionHistory;
  }

  public class InvalidAmount extends Exception {
    private static final long serialVersionUID = 1L;

    public InvalidAmount(String message) {
      super(message);
    }
  }

  private void verify(String holder) throws InvalidHolder {
    if (holder == null || holder.equals("""")) throw new InvalidHolder();
  }

  public class InvalidHolder extends Exception {
    private static final long serialVersionUID = 1L;

    public InvalidHolder() {
      super(""Invalid holder name."");
    }
  }

  private class Transaction implements java.io.Serializable {
    private static final long serialVersionUID = 1L;

    private final long amount;
    private final Date timestamp;

    private Transaction(long amount, Date timestamp) {
      this.amount = amount;
      this.timestamp = timestamp;
    }

    public String toString() {
      return timestampString() + ""      Amount: "" + amount;
    }

    private String timestampString() {
      return new java.text.SimpleDateFormat(""yyyy/MM/dd  hh:mm:ss.SSS"").format(timestamp);
    }


  "
org.prevayler.demos.memento.Account.createMemento,"/**
* Create a memento of the current state.
*/
  public void createMemento(MementoCollector collector) {
    collector.addMemento(new AccountMemento());
  }"
org.prevayler.demos.memento.Account.number,"  public long number() {
    return number;
  }"
org.prevayler.demos.memento.Account.toString,"  public String toString() { //Returns something like ""00123 - John Smith""
    return numberString() + "" - "" + holder + "" - "" + balance;
  }"
org.prevayler.demos.memento.Account.numberString,"  public String numberString() {
    return numberString(number);
  }"
org.prevayler.demos.memento.Account.numberString,"  static String numberString(long number) {
    return (new java.text.DecimalFormat(""00000"").format(number));
  }"
org.prevayler.demos.memento.Account.holder,"  public String holder() {
    return holder;
  }"
org.prevayler.demos.memento.Account.holder,"  public void holder(String holder) throws InvalidHolder {
    verify(holder);
    this.holder = holder;
  }"
org.prevayler.demos.memento.Account.balance,"  public long balance() {
    return balance;
  }"
org.prevayler.demos.memento.Account.deposit,"  public void deposit(long amount, Date timestamp) throws InvalidAmount {
    verify(amount);
    register(amount, timestamp);
  }"
org.prevayler.demos.memento.Account.withdraw,"  public void withdraw(long amount, Date timestamp) throws InvalidAmount {
    verify(amount);
    register(-amount, timestamp);
  }"
org.prevayler.demos.memento.Account.register,"  private void register(long amount, Date timestamp) {
    balance += amount;
    transactionHistory.add(new Transaction(amount, timestamp));
  }"
org.prevayler.demos.memento.Account.verify,"  private void verify(long amount) throws InvalidAmount {
    if (amount <= 0) throw new InvalidAmount(""Amount must be greater than zero."");
    if (amount > 10000) throw new InvalidAmount(""Amount maximum (10000) exceeded."");
  }"
org.prevayler.demos.memento.Account.transactionHistory,"  public List<Transaction> transactionHistory() {
    return transactionHistory;
  }"
org.prevayler.demos.memento.Account.verify,"  private void verify(String holder) throws InvalidHolder {
    if (holder == null || holder.equals("""")) throw new InvalidHolder();
  }"
org.prevayler.demos.memento.Account.toString,"    public String toString() {
      return timestampString() + ""      Amount: "" + amount;
    }"
org.prevayler.demos.memento.Account.timestampString,"    private String timestampString() {
      return new java.text.SimpleDateFormat(""yyyy/MM/dd  hh:mm:ss.SSS"").format(timestamp);
    }


  "
org.prevayler.demos.memento.Bank.restore,"    protected void restore() {
      Bank.this.nextAccountNumber = nextAccountNumber;
      Bank.this.accountsByNumber.clear();
      Bank.this.accountsByNumber.putAll(accountsByNumber);
    }"
org.prevayler.demos.memento.Bank.getOwner,"    protected Object getOwner() {
      return Bank.this;
    }
  }

  /**
   * Create a memento of the current state.
   */
  public void createMemento(MementoCollector collector) {
    collector.addMemento(new BankMemento());
  }

  public Account createAccount(String holder) throws Account.InvalidHolder {
    Account account = new Account(nextAccountNumber, holder);
    accountsByNumber.put(nextAccountNumber++, account);

    return account;
  }

  public void deleteAccount(long number) throws AccountNotFound {
    findAccount(number);
    accountsByNumber.remove(Long.valueOf(number));
  }

  public List<Account> accounts() {
    List<Account> accounts = new ArrayList<Account>(accountsByNumber.values());

    Collections.sort(accounts, new Comparator<Account>() {
      public int compare(Account acc1, Account acc2) {
        return acc1.number() < acc2.number() ? -1 : 1;
      }
    });

    return accounts;
  }

  public Account findAccount(long number) throws AccountNotFound {
    Account account = searchAccount(number);
    if (account == null) throw new AccountNotFound(number);
    return account;
  }

  public void transfer(long sourceNumber, long destinationNumber, long amount, Date timestamp) throws AccountNotFound, Account.InvalidAmount {
    Account source = findAccount(sourceNumber);
    Account destination = findAccount(destinationNumber);

    source.withdraw(amount, timestamp);
    destination.deposit(amount, timestamp);
  }

  private Account searchAccount(long number) {
    return accountsByNumber.get(Long.valueOf(number));
  }

  public class AccountNotFound extends Exception {
    private static final long serialVersionUID = 4463910784646858052L;

    AccountNotFound(long number) {
      super(""Account not found: "" + Account.numberString(number) + "".\nMight have been deleted."");
    }
  }

  public String toString() {
    StringWriter stringWriter = new StringWriter();
    PrintWriter writer = new PrintWriter(stringWriter);
    Iterator<Account> iterator;

    iterator = accountsByNumber.values().iterator();
    while (iterator.hasNext()) {
      writer.println(iterator.next());
    }

    writer.flush();

    return stringWriter.toString();
  "
org.prevayler.demos.memento.Bank.createMemento,"/**
* Create a memento of the current state.
*/
  public void createMemento(MementoCollector collector) {
    collector.addMemento(new BankMemento());
  }"
org.prevayler.demos.memento.Bank.createAccount,"  public Account createAccount(String holder) throws Account.InvalidHolder {
    Account account = new Account(nextAccountNumber, holder);
    accountsByNumber.put(nextAccountNumber++, account);

    return account;
  }"
org.prevayler.demos.memento.Bank.deleteAccount,"  public void deleteAccount(long number) throws AccountNotFound {
    findAccount(number);
    accountsByNumber.remove(Long.valueOf(number));
  }"
org.prevayler.demos.memento.Bank.accounts,"  public List<Account> accounts() {
    List<Account> accounts = new ArrayList<Account>(accountsByNumber.values());

    Collections.sort(accounts, new Comparator<Account>() {
      public int compare(Account acc1, Account acc2) {
        return acc1.number() < acc2.number() ? -1 : 1;
      }
    });

    return accounts;
  }"
org.prevayler.demos.memento.Bank.compare,"      public int compare(Account acc1, Account acc2) {
        return acc1.number() < acc2.number() ? -1 : 1;
      }
    "
org.prevayler.demos.memento.Bank.findAccount,"  public Account findAccount(long number) throws AccountNotFound {
    Account account = searchAccount(number);
    if (account == null) throw new AccountNotFound(number);
    return account;
  }"
org.prevayler.demos.memento.Bank.transfer,"  public void transfer(long sourceNumber, long destinationNumber, long amount, Date timestamp) throws AccountNotFound, Account.InvalidAmount {
    Account source = findAccount(sourceNumber);
    Account destination = findAccount(destinationNumber);

    source.withdraw(amount, timestamp);
    destination.deposit(amount, timestamp);
  }"
org.prevayler.demos.memento.Bank.searchAccount,"  private Account searchAccount(long number) {
    return accountsByNumber.get(Long.valueOf(number));
  }"
org.prevayler.demos.memento.Bank.toString,"  public String toString() {
    StringWriter stringWriter = new StringWriter();
    PrintWriter writer = new PrintWriter(stringWriter);
    Iterator<Account> iterator;

    iterator = accountsByNumber.values().iterator();
    while (iterator.hasNext()) {
      writer.println(iterator.next());
    }

    writer.flush();

    return stringWriter.toString();
  }

"
org.prevayler.demos.memento.commands.Deposit.findObjects,"  protected void findObjects(Bank prevalentSystem) throws Exception {
    if (JOptionPane.showConfirmDialog(null, ""Fail at Deposit::findObjects?"", ""Prevayler with rollback"", JOptionPane.YES_NO_OPTION) == 0) {
      throw new RuntimeException();
    }

    account = prevalentSystem.findAccount(accountNumber);
  }"
org.prevayler.demos.memento.commands.Deposit.checkPrecondition,"  protected void checkPrecondition() {
    if (JOptionPane.showConfirmDialog(null, ""Fail at Deposit::checkPrecondition?"", ""Prevayler with rollback"", JOptionPane.YES_NO_OPTION) == 0) {
      throw new RuntimeException();
    }

  }"
org.prevayler.demos.memento.commands.Deposit.createMementos,"  protected void createMementos(MementoCollector collector) {
    if (JOptionPane.showConfirmDialog(null, ""Fail at Deposit::createMemento?"", ""Prevayler with rollback"", JOptionPane.YES_NO_OPTION) == 0) {
      throw new RuntimeException();
    }

    account.createMemento(collector);
  }"
org.prevayler.demos.memento.commands.Deposit.execute,"  protected Account execute(MementoCollector collector) throws Exception {
    if (JOptionPane.showConfirmDialog(null, ""Fail at Deposit::execute?"", ""Prevayler with rollback"", JOptionPane.YES_NO_OPTION) == 0) {
      throw new RuntimeException();
    }

    account.deposit(amount, new Date()); //dummy'ed date to make things work

    System.out.println(""* Deposited "" + amount + "" into account "" + account.numberString());

    return null;
  }

"
org.prevayler.demos.memento.commands.AccountDeletion.findObjects,"  protected void findObjects(Bank prevalentSystem) {
    bank = prevalentSystem;
  }"
org.prevayler.demos.memento.commands.AccountDeletion.checkPrecondition,"  protected void checkPrecondition() {
  }"
org.prevayler.demos.memento.commands.AccountDeletion.createMementos,"  protected void createMementos(MementoCollector collector) {
    bank.createMemento(collector);
  }"
org.prevayler.demos.memento.commands.AccountDeletion.execute,"  protected Account execute(MementoCollector collector) throws Bank.AccountNotFound {
    bank.deleteAccount(accountNumber);
    return null;
  }
"
org.prevayler.demos.memento.commands.Withdrawal.findObjects,"  protected void findObjects(Bank prevalentSystem) throws Exception {
    if (JOptionPane.showConfirmDialog(null, ""Fail at Withdrawal::findObjects?"", ""Prevayler with rollback"", JOptionPane.YES_NO_OPTION) == 0) {
      throw new RuntimeException();
    }

    account = prevalentSystem.findAccount(accountNumber);
  }"
org.prevayler.demos.memento.commands.Withdrawal.checkPrecondition,"  protected void checkPrecondition() throws Exception {
    if (JOptionPane.showConfirmDialog(null, ""Fail at Withdrawal::checkPrecondition?"", ""Prevayler with rollback"", JOptionPane.YES_NO_OPTION) == 0) {
      throw new RuntimeException();
    }

    if (account.balance() < amount) {
      throw account.new InvalidAmount(""Can not withdraw more than the balance"");
    }
  }"
org.prevayler.demos.memento.commands.Withdrawal.createMementos,"  protected void createMementos(MementoCollector collector) {
    if (JOptionPane.showConfirmDialog(null, ""Fail at Withdrawal::createMemento?"", ""Prevayler with rollback"", JOptionPane.YES_NO_OPTION) == 0) {
      throw new RuntimeException();
    }

    account.createMemento(collector);
  }"
org.prevayler.demos.memento.commands.Withdrawal.execute,"  protected Account execute(MementoCollector collector) throws Exception {
    if (JOptionPane.showConfirmDialog(null, ""Fail at Withdrawal::execute?"", ""Prevayler with rollback"", JOptionPane.YES_NO_OPTION) == 0) {
      throw new RuntimeException();
    }

    account.withdraw(amount, new Date()); //dummy'ed date to make things work

    System.out.println(""* Withdrew "" + amount + "" from account "" + account.numberString());

    return null;
  }

"
org.prevayler.demos.memento.commands.AccountCreation.findObjects,"  protected void findObjects(Bank prevalentSystem) {
    bank = prevalentSystem;
  }"
org.prevayler.demos.memento.commands.AccountCreation.checkPrecondition,"  protected void checkPrecondition() {
  }"
org.prevayler.demos.memento.commands.AccountCreation.createMementos,"  protected void createMementos(MementoCollector collector) {
    bank.createMemento(collector);
  }"
org.prevayler.demos.memento.commands.AccountCreation.execute,"  protected Account execute(MementoCollector collector) throws Account.InvalidHolder {
    return bank.createAccount(holder);
  }
"
org.prevayler.demos.memento.commands.Transfer.findObjects,"  protected void findObjects(Bank prevalentSystem) throws Exception {
    bank = prevalentSystem;
  }"
org.prevayler.demos.memento.commands.Transfer.checkPrecondition,"  protected void checkPrecondition() {
  }"
org.prevayler.demos.memento.commands.Transfer.createMementos,"  protected void createMementos(MementoCollector collector) {
  }"
org.prevayler.demos.memento.commands.Transfer.execute,"  protected Account execute(MementoCollector collector) throws Exception {
    MementoTransaction command = new Withdrawal(sourceNumber, amount);
    command.execute(collector, bank);

    command = new Deposit(destinationNumber, amount);
    command.execute(collector, bank);

    return null;
  }

"
org.prevayler.foundation.monitor.Log4jMonitor.info,"  protected void info(Class<?> clazz, String message) {
    log(clazz, Level.INFO, message, null);
  }"
org.prevayler.foundation.monitor.Log4jMonitor.error,"  protected void error(Class<?> clazz, String message, Exception ex) {
    log(clazz, Level.ERROR, message, ex);
  }"
org.prevayler.foundation.monitor.Log4jMonitor.isInfoEnabled,"  protected boolean isInfoEnabled(Class<?> clazz) {
    return logger(clazz).isInfoEnabled();
  }"
org.prevayler.foundation.monitor.Log4jMonitor.logger,"  private Logger logger(Class<?> clazz) {
    return Logger.getLogger(clazz);
  }"
org.prevayler.foundation.monitor.Log4jMonitor.log,"  private void log(Class<?> clazz, Level level, String message, Exception ex) {
    logger(clazz).log(callerFQCN, level, message, ex);
  }
"
org.prevayler.foundation.serialization.XStreamSerializer.initialValue,"    protected XStream initialValue() {
      return createXStream();
    }
  "
org.prevayler.foundation.serialization.XStreamSerializer.getXStream,"  private XStream getXStream() {
    return _xstreams.get();
  }"
org.prevayler.foundation.serialization.XStreamSerializer.writeObject,"  public void writeObject(OutputStream stream, Object object) throws IOException {
    OutputStreamWriter writer = _encoding == null ? new OutputStreamWriter(stream) : new OutputStreamWriter(stream, _encoding);
    getXStream().toXML(object, writer);
    writer.flush();
  }"
org.prevayler.foundation.serialization.XStreamSerializer.readObject,"  public Object readObject(InputStream stream) throws IOException, ClassNotFoundException {
    return getXStream().fromXML(_encoding == null ? new InputStreamReader(stream) : new InputStreamReader(stream, _encoding));
  }"
org.prevayler.foundation.serialization.XStreamSerializer.createXStream,"/**
* Create a new XStream instance. This must be a new instance because XStream instances are not threadsafe.
*/
  protected XStream createXStream() {
    return new XStream();
  }

"
