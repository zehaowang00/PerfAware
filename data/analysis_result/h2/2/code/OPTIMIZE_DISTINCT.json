{
    "performance_sensitive": "Yes",
    "config_name": "OPTIMIZE_DISTINCT",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "@Override\n    public void prepare() {\n        if (isPrepared) {\n            // sometimes a subquery is prepared twice (CREATE TABLE AS SELECT)\n            return;\n        }\n        if (!checkInit) {\n            throw DbException.getInternalError(\"not initialized\");\n        }\n        if (orderList != null) {\n            prepareOrder(orderList, expressions.size());\n        }\n        ExpressionNames expressionNames = session.getMode().expressionNames;\n        if (expressionNames == ExpressionNames.ORIGINAL_SQL || expressionNames == ExpressionNames.POSTGRESQL_STYLE) {\n            optimizeExpressionsAndPreserveAliases();\n        } else {\n            for (int i = 0; i < expressions.size(); i++) {\n                expressions.set(i, expressions.get(i).optimize(session));\n            }\n        }\n        if (sort != null) {\n            cleanupOrder();\n        }\n        if (condition != null) {\n            condition = condition.optimizeCondition(session);\n            if (condition != null) {\n                for (TableFilter f : filters) {\n                    // outer joins: must not add index conditions such as\n                    // \"c is null\" - example:\n                    // create table parent(p int primary key) as select 1;\n                    // create table child(c int primary key, pc int);\n                    // insert into child values(2, 1);\n                    // select p, c from parent\n                    // left outer join child on p = pc where c is null;\n                    if (!f.isJoinOuter() && !f.isJoinOuterIndirect()) {\n                        condition.createIndexConditions(session, f);\n                    }\n                }\n            }\n        }\n        if (isGroupQuery && groupIndex == null && havingIndex < 0 && qualifyIndex < 0 && condition == null\n                && filters.size() == 1) {\n            isQuickAggregateQuery = isEverything(ExpressionVisitor.getOptimizableVisitor(filters.get(0).getTable()));\n        }\n        cost = preparePlan(session.isParsingCreateView());\n        if (distinct && session.getDatabase().getSettings().optimizeDistinct &&\n                !isGroupQuery && filters.size() == 1 &&\n                expressions.size() == 1 && condition == null) {\n            Expression expr = expressions.get(0);\n            expr = expr.getNonAliasExpression();\n            if (expr instanceof ExpressionColumn) {\n                Column column = ((ExpressionColumn) expr).getColumn();\n                int selectivity = column.getSelectivity();\n                Index columnIndex = topTableFilter.getTable().\n                        getIndexForColumn(column, false, true);\n                if (columnIndex != null &&\n                        selectivity != Constants.SELECTIVITY_DEFAULT &&\n                        selectivity < 20) {\n                    Index current = topTableFilter.getIndex();\n                    // if another index is faster\n                    if (current == null || current.getIndexType().isScan() || columnIndex == current) {\n                        topTableFilter.setIndex(columnIndex);\n                        isDistinctQuery = true;\n                    }\n                }\n            }\n        }\n        if (sort != null && !isQuickAggregateQuery && !isGroupQuery) {\n            Index index = getSortIndex();\n            Index current = topTableFilter.getIndex();\n            if (index != null && current != null) {\n                if (current.getIndexType().isScan() || current == index) {\n                    topTableFilter.setIndex(index);\n                    if (!topTableFilter.hasInComparisons()) {\n                        // in(select ...) and in(1,2,3) may return the key in\n                        // another order\n                        sortUsingIndex = true;\n                    }\n                } else if (index.getIndexColumns() != null\n                        && index.getIndexColumns().length >= current\n                                .getIndexColumns().length) {\n                    IndexColumn[] sortColumns = index.getIndexColumns();\n                    IndexColumn[] currentColumns = current.getIndexColumns();\n                    boolean swapIndex = false;\n                    for (int i = 0; i < currentColumns.length; i++) {\n                        if (sortColumns[i].column != currentColumns[i].column) {\n                            swapIndex = false;\n                            break;\n                        }\n                        if (sortColumns[i].sortType != currentColumns[i].sortType) {\n                            swapIndex = true;\n                        }\n                    }\n                    if (swapIndex) {\n                        topTableFilter.setIndex(index);\n                        sortUsingIndex = true;\n                    }\n                }\n            }\n            if (sortUsingIndex && isForUpdate && !topTableFilter.getIndex().isRowIdIndex()) {\n                sortUsingIndex = false;\n            }\n        }\n        if (!isQuickAggregateQuery && isGroupQuery) {\n            Index index = getGroupSortedIndex();\n            if (index != null) {\n                Index current = topTableFilter.getIndex();\n                if (current != null && (current.getIndexType().isScan() || current == index)) {\n                    topTableFilter.setIndex(index);\n                    isGroupSortedQuery = true;\n                }\n            }\n        }\n        expressionArray = expressions.toArray(new Expression[0]);\n        isPrepared = true;\n    }\n\n    "
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `OPTIMIZE_DISTINCT` configuration directly influences the performance of queries involving distinct operations. When `optimizeDistinct` is enabled, the code checks the selectivity of the column and potentially sets a more efficient index for distinct queries. This can lead to significant performance variations, especially in large datasets where distinct operations can be time-consuming. The decision to use a faster index based on selectivity can greatly reduce execution time, making this configuration critical for performance optimization in scenarios involving distinct queries."
        }
    ]
}