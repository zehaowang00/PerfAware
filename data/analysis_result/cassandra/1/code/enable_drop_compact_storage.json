{
    "performance_sensitive": "Yes",
    "config_name": "enable_drop_compact_storage",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "public Keyspaces apply(Keyspaces schema) throws UnknownHostException\n    {\n        KeyspaceMetadata keyspace = schema.getNullable(keyspaceName);\n\n        TableMetadata table = null == keyspace\n                            ? null\n                            : keyspace.getTableOrViewNullable(tableName);\n\n        if (null == table)\n            throw ire(\"Table '%s.%s' doesn't exist\", keyspaceName, tableName);\n\n        if (table.isView())\n            throw ire(\"Cannot use ALTER TABLE on a materialized view; use ALTER MATERIALIZED VIEW instead\");\n\n        return schema.withAddedOrUpdated(apply(keyspace, table));\n    }\n\n    \npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            throw ire(\"Altering column types is no longer supported\");\n        }\n    }\npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            TableMetadata.Builder tableBuilder = table.unbuild();\n            Views.Builder viewsBuilder = keyspace.views.unbuild();\n            newColumns.forEach(c -> addColumn(keyspace, table, c, tableBuilder, viewsBuilder));\n            TableMetadata tableMetadata = tableBuilder.build();\n            tableMetadata.validate();\n\n            return keyspace.withSwapped(keyspace.tables.withSwapped(tableMetadata))\n                           .withSwapped(viewsBuilder.build());\n        }\n\n        \npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            TableMetadata.Builder builder = table.unbuild();\n            removedColumns.forEach(c -> dropColumn(keyspace, table, c, builder));\n            return keyspace.withSwapped(keyspace.tables.withSwapped(builder.build()));\n        }\n\n        \npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            TableMetadata.Builder tableBuilder = table.unbuild();\n            Views.Builder viewsBuilder = keyspace.views.unbuild();\n            renamedColumns.forEach((o, n) -> renameColumn(keyspace, table, o, n, tableBuilder, viewsBuilder));\n\n            return keyspace.withSwapped(keyspace.tables.withSwapped(tableBuilder.build()))\n                           .withSwapped(viewsBuilder.build());\n        }\n\n        \npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            attrs.validate();\n\n            TableParams params = attrs.asAlteredTableParams(table.params);\n\n            if (table.isCounter() && params.defaultTimeToLive > 0)\n                throw ire(\"Cannot set default_time_to_live on a table with counters\");\n\n            if (!isEmpty(keyspace.views.forTable(table.id)) && params.gcGraceSeconds == 0)\n            {\n                throw ire(\"Cannot alter gc_grace_seconds of the base table of a \" +\n                          \"materialized view to 0, since this value is used to TTL \" +\n                          \"undelivered updates. Setting gc_grace_seconds too low might \" +\n                          \"cause undelivered updates to expire \" +\n                          \"before being replayed.\");\n            }\n\n            if (keyspace.createReplicationStrategy().hasTransientReplicas()\n                && params.readRepair != ReadRepairStrategy.NONE)\n            {\n                throw ire(\"read_repair must be set to 'NONE' for transiently replicated keyspaces\");\n            }\n\n            return keyspace.withSwapped(keyspace.tables.withSwapped(table.withSwapped(params)));\n        }\n    }\npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            if (!DatabaseDescriptor.enableDropCompactStorage())\n                throw new InvalidRequestException(\"DROP COMPACT STORAGE is disabled. Enable in cassandra.yaml to use.\");\n\n            if (!table.isCompactTable())\n                throw AlterTableStatement.ire(\"Cannot DROP COMPACT STORAGE on table without COMPACT STORAGE\");\n\n            validateCanDropCompactStorage();\n\n            Set<Flag> flags = table.isCounter()\n                            ? ImmutableSet.of(Flag.COMPOUND, Flag.COUNTER)\n                            : ImmutableSet.of(Flag.COMPOUND);\n\n            return keyspace.withSwapped(keyspace.tables.withSwapped(table.withSwapped(flags)));\n        }\n\n        "
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: enabling or disabling the drop compact storage feature can significantly impact performance, particularly in terms of memory usage and data retrieval efficiency. Compact storage affects how data is stored and accessed in Cassandra, and operations that involve dropping compact storage can lead to extensive data restructuring, which is time-intensive and can consume considerable memory resources. Therefore, this configuration directly influences system-level performance variations."
        }
    ]
}