{
    "performance_sensitive": "Yes",
    "config_name": "request_timeout_in_ms",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "/**\n     * @return the minimum configured {read, write, range, truncate, misc} timeout\n     */\npublic static long getMinRpcTimeout(TimeUnit unit)\n    {\n        return Longs.min(getRpcTimeout(unit),\n                         getReadRpcTimeout(unit),\n                         getRangeRpcTimeout(unit),\n                         getWriteRpcTimeout(unit),\n                         getCounterWriteRpcTimeout(unit),\n                         getTruncateRpcTimeout(unit));\n    }\n\n    \n/**\n * Messages for the handshake phase of the internode protocol.\n *\n * The modern handshake is composed of 2 messages: Initiate and Accept\n * <p>\n * The legacy handshake is composed of 3 messages, the first being sent by the initiator of the connection. The other\n * side then answer with the 2nd message. At that point, if a version mismatch is detected by the connection initiator,\n * it will simply disconnect and reconnect with a more appropriate version. But if the version is acceptable, the connection\n * initiator sends the third message of the protocol, after which it considers the connection ready.\n */\nclass HandshakeProtocol\n{\n    static final long TIMEOUT_MILLIS = 3 * DatabaseDescriptor.getRpcTimeout(MILLISECONDS);\n\n    /**\n     * The initial message sent when a node creates a new connection to a remote peer. This message contains:\n     *   1) the {@link Message#PROTOCOL_MAGIC} number (4 bytes).\n     *   2) the connection flags (4 bytes), which encodes:\n     *      - the version the initiator thinks should be used for the connection (in practice, either the initiator\n     *        version if it's the first time we connect to that remote since startup, or the last version known for that\n     *        peer otherwise).\n     *      - the \"mode\" of the connection: whether it is for streaming or for messaging.\n     *      - whether compression should be used or not (if it is, compression is enabled _after_ the last message of the\n     *        handshake has been sent).\n     *   3) the connection initiator's broadcast address\n     *   4) a CRC protecting the message from corruption\n     * <p>\n     * More precisely, connection flags:\n     * <pre>\n     * {@code\n     *                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n     *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     * |C C C M C      |    REQUEST    |      MIN      |      MAX      |\n     * |A A M O R      |    VERSION    |   SUPPORTED   |   SUPPORTED   |\n     * |T T P D C      |  (DEPRECATED) |    VERSION    |    VERSION    |\n     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     * }\n     * </pre>\n     * CAT - QOS category, 2 bits: SMALL, LARGE, URGENT, or LEGACY (unset)\n     * CMP - compression enabled bit\n     * MOD - connection mode; if the bit is on, the connection is for streaming; if the bit is off, it is for inter-node messaging.\n     * CRC - crc enabled bit\n     * VERSION - {@link org.apache.cassandra.net.MessagingService#current_version}\n     */\n    static class Initiate\n    {\n        /** Contains the PROTOCOL_MAGIC (int) and the flags (int). */\n        private static final int MIN_LENGTH = 8;\n        private static final int MAX_LENGTH = 12 + InetAddressAndPort.Serializer.MAXIMUM_SIZE;\n\n        @Deprecated // this is ignored by post40 nodes, i.e. if maxMessagingVersion is set\n        final int requestMessagingVersion;\n        // the messagingVersion bounds the sender will accept to initiate a connection;\n        // if the remote peer supports any, the newest supported version will be selected; otherwise the nearest supported version\n        final AcceptVersions acceptVersions;\n        final ConnectionType type;\n        final Framing framing;\n        final InetAddressAndPort from;\n\n        Initiate(int requestMessagingVersion, AcceptVersions acceptVersions, ConnectionType type, Framing framing, InetAddressAndPort from)\n        {\n            this.requestMessagingVersion = requestMessagingVersion;\n            this.acceptVersions = acceptVersions;\n            this.type = type;\n            this.framing = framing;\n            this.from = from;\n        }\n\n        @VisibleForTesting\n        int encodeFlags()\n        {\n            int flags = 0;\n            if (type.isMessaging())\n                flags |= type.twoBitID();\n            if (type.isStreaming())\n                flags |= 1 << 3;\n\n            // framing id is split over 2nd and 4th bits, for backwards compatibility\n            flags |= ((framing.id & 1) << 2) | ((framing.id & 2) << 3);\n            flags |= (requestMessagingVersion << 8);\n\n            if (requestMessagingVersion < VERSION_40 || acceptVersions.max < VERSION_40)\n                return flags; // for testing, permit serializing as though we are pre40\n\n            flags |= (acceptVersions.min << 16);\n            flags |= (acceptVersions.max << 24);\n            return flags;\n        }\n\n        ByteBuf encode()\n        {\n            ByteBuffer buffer = BufferPools.forNetworking().get(MAX_LENGTH, BufferType.OFF_HEAP);\n            try (DataOutputBufferFixed out = new DataOutputBufferFixed(buffer))\n            {\n                out.writeInt(Message.PROTOCOL_MAGIC);\n                out.writeInt(encodeFlags());\n\n                if (requestMessagingVersion >= VERSION_40 && acceptVersions.max >= VERSION_40)\n                {\n                    inetAddressAndPortSerializer.serialize(from, out, requestMessagingVersion);\n                    out.writeInt(computeCrc32(buffer, 0, buffer.position()));\n                }\n                buffer.flip();\n                return GlobalBufferPoolAllocator.wrap(buffer);\n            }\n            catch (IOException e)\n            {\n                throw new IllegalStateException(e);\n            }\n        }\n\n        static Initiate maybeDecode(ByteBuf buf) throws IOException\n        {\n            if (buf.readableBytes() < MIN_LENGTH)\n                return null;\n\n            ByteBuffer nio = buf.nioBuffer();\n            int start = nio.position();\n            try (DataInputBuffer in = new DataInputBuffer(nio, false))\n            {\n                validateLegacyProtocolMagic(in.readInt());\n                int flags = in.readInt();\n\n                int requestedMessagingVersion = getBits(flags, 8, 8);\n                int minMessagingVersion = getBits(flags, 16, 8);\n                int maxMessagingVersion = getBits(flags, 24, 8);\n                int framingBits = getBits(flags, 2, 1) | (getBits(flags, 4, 1) << 1);\n                Framing framing = Framing.forId(framingBits);\n\n                boolean isStream = getBits(flags, 3, 1) == 1;\n\n                ConnectionType type = isStream\n                                    ? ConnectionType.STREAMING\n                                    : ConnectionType.fromId(getBits(flags, 0, 2));\n\n                InetAddressAndPort from = null;\n\n                if (requestedMessagingVersion >= VERSION_40 && maxMessagingVersion >= MessagingService.VERSION_40)\n                {\n                    from = inetAddressAndPortSerializer.deserialize(in, requestedMessagingVersion);\n\n                    int computed = computeCrc32(nio, start, nio.position());\n                    int read = in.readInt();\n                    if (read != computed)\n                        throw new InvalidCrc(read, computed);\n                }\n\n                buf.skipBytes(nio.position() - start);\n                return new Initiate(requestedMessagingVersion,\n                                    minMessagingVersion == 0 && maxMessagingVersion == 0\n                                        ? null : new AcceptVersions(minMessagingVersion, maxMessagingVersion),\n                                    type, framing, from);\n\n            }\n            catch (EOFException e)\n            {\n                return null;\n            }\n        }\n\n        @VisibleForTesting\n        @Override\n        public boolean equals(Object other)\n        {\n            if (!(other instanceof Initiate))\n                return false;\n\n            Initiate that = (Initiate)other;\n            return    this.type == that.type\n                   && this.framing == that.framing\n                   && this.requestMessagingVersion == that.requestMessagingVersion\n                   && Objects.equals(this.acceptVersions, that.acceptVersions);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(\"Initiate(request: %d, min: %d, max: %d, type: %s, framing: %b, from: %s)\",\n                                 requestMessagingVersion,\n                                 acceptVersions == null ? requestMessagingVersion : acceptVersions.min,\n                                 acceptVersions == null ? requestMessagingVersion : acceptVersions.max,\n                                 type, framing, from);\n        }\n    }\n\n\n    /**\n     * The second message of the handshake, sent by the node receiving the {@link Initiate} back to the\n     * connection initiator.\n     *\n     * This message contains\n     *   1) the messaging version of the peer sending this message\n     *   2) the negotiated messaging version if one could be accepted by both peers,\n     *      or if not the closest version that this peer could support to the ones requested\n     *   3) a CRC protectingn the integrity of the message\n     *\n     * Note that the pre40 equivalent of this message contains ONLY the messaging version of the peer.\n     */\n    static class Accept\n    {\n        /** The messaging version sent by the receiving peer (int). */\n        private static final int MAX_LENGTH = 12;\n\n        final int useMessagingVersion;\n        final int maxMessagingVersion;\n\n        Accept(int useMessagingVersion, int maxMessagingVersion)\n        {\n            this.useMessagingVersion = useMessagingVersion;\n            this.maxMessagingVersion = maxMessagingVersion;\n        }\n\n        ByteBuf encode(ByteBufAllocator allocator)\n        {\n            ByteBuf buffer = allocator.directBuffer(MAX_LENGTH);\n            buffer.clear();\n            buffer.writeInt(maxMessagingVersion);\n            buffer.writeInt(useMessagingVersion);\n            buffer.writeInt(computeCrc32(buffer, 0, 8));\n            return buffer;\n        }\n\n        /**\n         * Respond to pre40 nodes only with our current messagingVersion\n         */\n        static ByteBuf respondPre40(int messagingVersion, ByteBufAllocator allocator)\n        {\n            ByteBuf buffer = allocator.directBuffer(4);\n            buffer.clear();\n            buffer.writeInt(messagingVersion);\n            return buffer;\n        }\n\n        static Accept maybeDecode(ByteBuf in, int handshakeMessagingVersion) throws InvalidCrc\n        {\n            int readerIndex = in.readerIndex();\n            if (in.readableBytes() < 4)\n                return null;\n            int maxMessagingVersion = in.readInt();\n            int useMessagingVersion = 0;\n\n            // if the other node is pre-4.0, it will respond only with its maxMessagingVersion\n            if (maxMessagingVersion < VERSION_40 || handshakeMessagingVersion < VERSION_40)\n                return new Accept(useMessagingVersion, maxMessagingVersion);\n\n            if (in.readableBytes() < 8)\n            {\n                in.readerIndex(readerIndex);\n                return null;\n            }\n            useMessagingVersion = in.readInt();\n\n            // verify crc\n            int computed = computeCrc32(in, readerIndex, readerIndex + 8);\n            int read = in.readInt();\n            if (read != computed)\n                throw new InvalidCrc(read, computed);\n\n            return new Accept(useMessagingVersion, maxMessagingVersion);\n        }\n\n        @VisibleForTesting\n        @Override\n        public boolean equals(Object other)\n        {\n            return other instanceof Accept\n                   && this.useMessagingVersion == ((Accept) other).useMessagingVersion\n                   && this.maxMessagingVersion == ((Accept) other).maxMessagingVersion;\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(\"Accept(use: %d, max: %d)\", useMessagingVersion, maxMessagingVersion);\n        }\n    }\n\n    /**\n     * The third message of the handshake, sent by pre40 nodes on reception of {@link Accept}.\n     * This message contains:\n     *   1) The connection initiator's {@link org.apache.cassandra.net.MessagingService#current_version} (4 bytes).\n     *      This indicates the max messaging version supported by this node.\n     *   2) The connection initiator's broadcast address as encoded by {@link InetAddressAndPort.Serializer}.\n     *      This can be either 7 bytes for an IPv4 address, or 19 bytes for an IPv6 one, post40.\n     *      This can be either 5 bytes for an IPv4 address, or 17 bytes for an IPv6 one, pre40.\n     * <p>\n     * This message concludes the legacy handshake protocol.\n     */\n    static class ConfirmOutboundPre40\n    {\n        private static final int MAX_LENGTH = 4 + InetAddressAndPort.Serializer.MAXIMUM_SIZE;\n\n        final int maxMessagingVersion;\n        final InetAddressAndPort from;\n\n        ConfirmOutboundPre40(int maxMessagingVersion, InetAddressAndPort from)\n        {\n            this.maxMessagingVersion = maxMessagingVersion;\n            this.from = from;\n        }\n\n        ByteBuf encode()\n        {\n            ByteBuffer buffer = BufferPools.forNetworking().get(MAX_LENGTH, BufferType.OFF_HEAP);\n            try (DataOutputBufferFixed out = new DataOutputBufferFixed(buffer))\n            {\n                out.writeInt(maxMessagingVersion);\n                // pre-4.0 nodes should only receive the address, never port, and it's ok to hardcode VERSION_30\n                inetAddressAndPortSerializer.serialize(from, out, VERSION_30);\n                buffer.flip();\n                return GlobalBufferPoolAllocator.wrap(buffer);\n            }\n            catch (IOException e)\n            {\n                throw new IllegalStateException(e);\n            }\n        }\n\n        @SuppressWarnings(\"resource\")\n        static ConfirmOutboundPre40 maybeDecode(ByteBuf in)\n        {\n            ByteBuffer nio = in.nioBuffer();\n            int start = nio.position();\n            DataInputPlus input = new DataInputBuffer(nio, false);\n            try\n            {\n                int version = input.readInt();\n                InetAddressAndPort address = inetAddressAndPortSerializer.deserialize(input, version);\n                in.skipBytes(nio.position() - start);\n                return new ConfirmOutboundPre40(version, address);\n            }\n            catch (EOFException e)\n            {\n                // makes the assumption we didn't have enough bytes to deserialize an IPv6 address,\n                // as we only check the MIN_LENGTH of the buf.\n                return null;\n            }\n            catch (IOException e)\n            {\n                throw new IllegalStateException(e);\n            }\n        }\n\n        @VisibleForTesting\n        @Override\n        public boolean equals(Object other)\n        {\n            if (!(other instanceof ConfirmOutboundPre40))\n                return false;\n\n            ConfirmOutboundPre40 that = (ConfirmOutboundPre40) other;\n            return this.maxMessagingVersion == that.maxMessagingVersion\n                   && Objects.equals(this.from, that.from);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(\"ConfirmOutboundPre40(maxMessagingVersion: %d; address: %s)\", maxMessagingVersion, from);\n        }\n    }\n\n    private static int getBits(int packed, int start, int count)\n    {\n        return (packed >>> start) & ~(-1 << count);\n    }\n\n}\n\npublic UUID prepareForRepair(UUID parentRepairSession, InetAddressAndPort coordinator, Set<InetAddressAndPort> endpoints, RepairOption options, boolean isForcedRepair, List<ColumnFamilyStore> columnFamilyStores)\n    {\n        if (!verifyCompactionsPendingThreshold(parentRepairSession, options.getPreviewKind()))\n            failRepair(parentRepairSession, \"Rejecting incoming repair, pending compactions above threshold\"); // failRepair throws exception\n\n        long repairedAt = getRepairedAt(options, isForcedRepair);\n        registerParentRepairSession(parentRepairSession, coordinator, columnFamilyStores, options.getRanges(), options.isIncremental(), repairedAt, options.isGlobal(), options.getPreviewKind());\n        final CountDownLatch prepareLatch = new CountDownLatch(endpoints.size());\n        final AtomicBoolean status = new AtomicBoolean(true);\n        final Set<String> failedNodes = Collections.synchronizedSet(new HashSet<String>());\n        RequestCallback callback = new RequestCallback()\n        {\n            @Override\n            public void onResponse(Message msg)\n            {\n                prepareLatch.countDown();\n            }\n\n            @Override\n            public void onFailure(InetAddressAndPort from, RequestFailureReason failureReason)\n            {\n                status.set(false);\n                failedNodes.add(from.toString());\n                prepareLatch.countDown();\n            }\n\n            @Override\n            public boolean invokeOnFailure()\n            {\n                return true;\n            }\n        };\n\n        List<TableId> tableIds = new ArrayList<>(columnFamilyStores.size());\n        for (ColumnFamilyStore cfs : columnFamilyStores)\n            tableIds.add(cfs.metadata.id);\n\n        for (InetAddressAndPort neighbour : endpoints)\n        {\n            if (FailureDetector.instance.isAlive(neighbour))\n            {\n                PrepareMessage message = new PrepareMessage(parentRepairSession, tableIds, options.getRanges(), options.isIncremental(), repairedAt, options.isGlobal(), options.getPreviewKind());\n                Message<RepairMessage> msg = Message.out(PREPARE_MSG, message);\n                MessagingService.instance().sendWithCallback(msg, neighbour, callback);\n            }\n            else\n            {\n                // we pre-filter the endpoints we want to repair for forced incremental repairs. So if any of the\n                // remaining ones go down, we still want to fail so we don't create repair sessions that can't complete\n                if (isForcedRepair && !options.isIncremental())\n                {\n                    prepareLatch.countDown();\n                }\n                else\n                {\n                    // bailout early to avoid potentially waiting for a long time.\n                    failRepair(parentRepairSession, \"Endpoint not alive: \" + neighbour);\n                }\n\n            }\n        }\n        try\n        {\n            if (!prepareLatch.await(DatabaseDescriptor.getRpcTimeout(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS))\n                failRepair(parentRepairSession, \"Did not get replies from all endpoints.\");\n        }\n        catch (InterruptedException e)\n        {\n            failRepair(parentRepairSession, \"Interrupted while waiting for prepare repair response.\");\n        }\n\n        if (!status.get())\n        {\n            failRepair(parentRepairSession, \"Got negative replies from endpoints \" + failedNodes);\n        }\n\n        return parentRepairSession;\n    }\n\n    \n/**\n     * initiate a request/response session with each live node to check whether or not everybody is using the same\n     * migration id. This is useful for determining if a schema change has propagated through the cluster. Disagreement\n     * is assumed if any node fails to respond.\n     */\npublic static Map<String, List<String>> describeSchemaVersions(boolean withPort)\n    {\n        final String myVersion = Schema.instance.getVersion().toString();\n        final Map<InetAddressAndPort, UUID> versions = new ConcurrentHashMap<>();\n        final Set<InetAddressAndPort> liveHosts = Gossiper.instance.getLiveMembers();\n        final CountDownLatch latch = new CountDownLatch(liveHosts.size());\n\n        RequestCallback<UUID> cb = message ->\n        {\n            // record the response from the remote node.\n            versions.put(message.from(), message.payload);\n            latch.countDown();\n        };\n        // an empty message acts as a request to the SchemaVersionVerbHandler.\n        Message message = Message.out(Verb.SCHEMA_VERSION_REQ, noPayload);\n        for (InetAddressAndPort endpoint : liveHosts)\n            MessagingService.instance().sendWithCallback(message, endpoint, cb);\n\n        try\n        {\n            // wait for as long as possible. timeout-1s if possible.\n            latch.await(DatabaseDescriptor.getRpcTimeout(NANOSECONDS), NANOSECONDS);\n        }\n        catch (InterruptedException ex)\n        {\n            throw new AssertionError(\"This latch shouldn't have been interrupted.\");\n        }\n\n        // maps versions to hosts that are on that version.\n        Map<String, List<String>> results = new HashMap<String, List<String>>();\n        Iterable<InetAddressAndPort> allHosts = Iterables.concat(Gossiper.instance.getLiveMembers(), Gossiper.instance.getUnreachableMembers());\n        for (InetAddressAndPort host : allHosts)\n        {\n            UUID version = versions.get(host);\n            String stringVersion = version == null ? UNREACHABLE : version.toString();\n            List<String> hosts = results.get(stringVersion);\n            if (hosts == null)\n            {\n                hosts = new ArrayList<String>();\n                results.put(stringVersion, hosts);\n            }\n            hosts.add(host.getHostAddress(withPort));\n        }\n\n        // we're done: the results map is ready to return to the client.  the rest is just debug logging:\n        if (results.get(UNREACHABLE) != null)\n            logger.debug(\"Hosts not in agreement. Didn't get a response from everybody: {}\", StringUtils.join(results.get(UNREACHABLE), \",\"));\n        for (Map.Entry<String, List<String>> entry : results.entrySet())\n        {\n            // check for version disagreement. log the hosts that don't agree.\n            if (entry.getKey().equals(UNREACHABLE) || entry.getKey().equals(myVersion))\n                continue;\n            for (String host : entry.getValue())\n                logger.debug(\"{} disagrees ({})\", host, entry.getKey());\n        }\n        if (results.size() == 1)\n            logger.debug(\"Schemas are in agreement.\");\n\n        return results;\n    }\n\n    \npublic Long getRpcTimeout() { return DatabaseDescriptor.getRpcTimeout(MILLISECONDS); }\n    \npublic long getRpcTimeout()\n    {\n        return DatabaseDescriptor.getRpcTimeout(MILLISECONDS);\n    }\n\n    \n/**\n     * Sends a notification to a node indicating we have finished replicating data.\n     *\n     * @param remote node to send notification to\n     */\nprivate void sendReplicationNotification(InetAddressAndPort remote)\n    {\n        // notify the remote token\n        Message msg = Message.out(REPLICATION_DONE_REQ, noPayload);\n        IFailureDetector failureDetector = FailureDetector.instance;\n        if (logger.isDebugEnabled())\n            logger.debug(\"Notifying {} of replication completion\\n\", remote);\n        while (failureDetector.isAlive(remote))\n        {\n            AsyncOneResponse ior = new AsyncOneResponse();\n            MessagingService.instance().sendWithCallback(msg, remote, ior);\n\n            if (!ior.awaitUninterruptibly(DatabaseDescriptor.getRpcTimeout(NANOSECONDS), NANOSECONDS))\n                continue; // try again if we timeout\n\n            if (!ior.isSuccess())\n                throw new AssertionError(ior.cause());\n\n            return;\n        }\n    }\n\n    "
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `request_timeout_in_ms` directly influences the time taken for RPC (Remote Procedure Call) operations, which are critical for inter-node communication in a distributed system. The method `getMinRpcTimeout` aggregates various timeout values, and if these timeouts are set too high or too low, it can lead to significant delays or premature timeouts in communication, impacting overall system performance. Given that these timeouts can affect the responsiveness and stability of the system, they are classified as performance-sensitive configurations."
        }
    ]
}