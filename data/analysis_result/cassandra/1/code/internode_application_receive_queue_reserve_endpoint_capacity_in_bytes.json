{
    "performance_sensitive": "Yes",
    "config_name": "internode_application_receive_queue_reserve_endpoint_capacity_in_bytes",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "/**\n * MessagingService implements all internode communication - with the exception of SSTable streaming (for now).\n *\n * Specifically, it's responsible for dispatch of outbound messages to other nodes and routing of inbound messages\n * to their appropriate {@link IVerbHandler}.\n *\n * <h2>Using MessagingService: sending requests and responses</h2>\n *\n * The are two ways to send a {@link Message}, and you should pick one depending on the desired behaviour:\n *  1. To send a request that expects a response back, use\n *     {@link #sendWithCallback(Message, InetAddressAndPort, RequestCallback)} method. Once a response\n *     message is received, {@link RequestCallback#onResponse(Message)} method will be invoked on the\n *     provided callback - in case of a success response. In case of a failure response (see {@link Verb#FAILURE_RSP}),\n *     or if a response doesn't arrive within verb's configured expiry time,\n *     {@link RequestCallback#onFailure(InetAddressAndPort, RequestFailureReason)} will be invoked instead.\n *  2. To send a response back, or a message that expects no response, use {@link #send(Message, InetAddressAndPort)}\n *     method.\n *\n * See also: {@link Message#out(Verb, Object)}, {@link Message#responseWith(Object)},\n * and {@link Message#failureResponse(RequestFailureReason)}.\n *\n * <h2>Using MessagingService: handling a request</h2>\n *\n * As described in the previous section, to handle responses you only need to implement {@link RequestCallback}\n * interface - so long as your response verb handler is the default {@link ResponseVerbHandler}.\n *\n * There are two steps you need to perform to implement request handling:\n *  1. Create a {@link IVerbHandler} to process incoming requests and responses for the new type (if applicable).\n *  2. Add a new {@link Verb} to the enum for the new request type, and, if applicable, one for the response message.\n *\n * MessagingService will now automatically invoke your handler whenever a {@link Message} with this verb arrives.\n *\n * <h1>Architecture of MessagingService</h1>\n *\n * <h2>QOS</h2>\n *\n * Since our messaging protocol is TCP-based, and also doesn't yet support interleaving messages with each other,\n * we need a way to prevent head-of-line blocking adversely affecting all messages - in particular, large messages\n * being in the way of smaller ones. To achive that (somewhat), we maintain three messaging connections to and\n * from each peer:\n * - one for large messages - defined as being larger than {@link OutboundConnections#LARGE_MESSAGE_THRESHOLD}\n *   (65KiB by default)\n * - one for small messages - defined as smaller than that threshold\n * - and finally, a connection for urgent messages - usually small and/or that are important to arrive\n *   promptly, e.g. gossip-related ones\n *\n * <h2>Wire format and framing</h2>\n *\n * Small messages are grouped together into frames, and large messages are split over multiple frames.\n * Framing provides application-level integrity protection to otherwise raw streams of data - we use\n * CRC24 for frame headers and CRC32 for the entire payload. LZ4 is optionally used for compression.\n *\n * You can find the on-wire format description of individual messages in the comments for\n * {@link Message.Serializer}, alongside with format evolution notes.\n * For the list and descriptions of available frame decoders see {@link FrameDecoder} comments. You can\n * find wire format documented in the javadoc of {@link FrameDecoder} implementations:\n * see {@link FrameDecoderCrc} and {@link FrameDecoderLZ4} in particular.\n *\n * <h2>Architecture of outbound messaging</h2>\n *\n * {@link OutboundConnection} is the core class implementing outbound connection logic, with\n * {@link OutboundConnection#enqueue(Message)} being its main entry point. The connections are initiated\n * by {@link OutboundConnectionInitiator}.\n *\n * Netty pipeline for outbound messaging connections generally consists of the following handlers:\n *\n * [(optional) SslHandler] <- [FrameEncoder]\n *\n * {@link OutboundConnection} handles the entire lifetime of a connection: from the very first handshake\n * to any necessary reconnects if necessary.\n *\n * Message-delivery flow varies depending on the connection type.\n *\n * For {@link ConnectionType#SMALL_MESSAGES} and {@link ConnectionType#URGENT_MESSAGES},\n * {@link Message} serialization and delivery occurs directly on the event loop.\n * See {@link OutboundConnection.EventLoopDelivery} for details.\n *\n * For {@link ConnectionType#LARGE_MESSAGES}, to ensure that servicing large messages doesn't block\n * timely service of other requests, message serialization is offloaded to a companion thread pool\n * ({@link SocketFactory#synchronousWorkExecutor}). Most of the work will be performed by\n * {@link AsyncChannelOutputPlus}. Please see {@link OutboundConnection.LargeMessageDelivery}\n * for details.\n *\n * To prevent fast clients, or slow nodes on the other end of the connection from overwhelming\n * a host with enqueued, unsent messages on heap, we impose strict limits on how much memory enqueued,\n * undelivered messages can claim.\n *\n * Every individual connection gets an exclusive permit quota to use - 4MiB by default; every endpoint\n * (group of large, small, and urgent connection) is capped at, by default, at 128MiB of undelivered messages,\n * and a global limit of 512MiB is imposed on all endpoints combined.\n *\n * On an attempt to {@link OutboundConnection#enqueue(Message)}, the connection will attempt to allocate\n * permits for message-size number of bytes from its exclusive quota; if successful, it will add the\n * message to the queue; if unsuccessful, it will need to allocate remainder from both endpoint and lobal\n * reserves, and if it fails to do so, the message will be rejected, and its callbacks, if any,\n * immediately expired.\n *\n * For a more detailed description please see the docs and comments of {@link OutboundConnection}.\n *\n * <h2>Architecture of inbound messaging</h2>\n *\n * {@link InboundMessageHandler} is the core class implementing inbound connection logic, paired\n * with {@link FrameDecoder}. Inbound connections are initiated by {@link InboundConnectionInitiator}.\n * The primary entry points to these classes are {@link FrameDecoder#channelRead(ShareableBytes)}\n * and {@link InboundMessageHandler#process(FrameDecoder.Frame)}.\n *\n * Netty pipeline for inbound messaging connections generally consists of the following handlers:\n *\n * [(optional) SslHandler] -> [FrameDecoder] -> [InboundMessageHandler]\n *\n * {@link FrameDecoder} is responsible for decoding incoming frames and work stashing; {@link InboundMessageHandler}\n * then takes decoded frames from the decoder and processes the messages contained in them.\n *\n * The flow differs between small and large messages. Small ones are deserialized immediately, and only\n * then scheduled on the right thread pool for the {@link Verb} for execution. Large messages, OTOH,\n * aren't deserialized until they are just about to be executed on the appropriate {@link Stage}.\n *\n * Similarly to outbound handling, inbound messaging imposes strict memory utilisation limits on individual\n * endpoints and on global aggregate consumption, and implements simple flow control, to prevent a single\n * fast endpoint from overwhelming a host.\n *\n * Every individual connection gets an exclusive permit quota to use - 4MiB by default; every endpoint\n * (group of large, small, and urgent connection) is capped at, by default, at 128MiB of unprocessed messages,\n * and a global limit of 512MiB is imposed on all endpoints combined.\n *\n * On arrival of a message header, the handler will attempt to allocate permits for message-size number\n * of bytes from its exclusive quota; if successful, it will proceed to deserializing and processing the message.\n * If unsuccessful, the handler will attempt to allocate the remainder from its endpoint and global reserve;\n * if either allocation is unsuccessful, the handler will cease any further frame processing, and tell\n * {@link FrameDecoder} to stop reading from the network; subsequently, it will put itself on a special\n * {@link org.apache.cassandra.net.InboundMessageHandler.WaitQueue}, to be reactivated once more permits\n * become available.\n *\n * For a more detailed description please see the docs and comments of {@link InboundMessageHandler} and\n * {@link FrameDecoder}.\n *\n * <h2>Observability</h2>\n *\n * MessagingService exposes diagnostic counters for both outbound and inbound directions - received and sent\n * bytes and message counts, overload bytes and message count, error bytes and error counts, and many more.\n *\n * See {@link org.apache.cassandra.metrics.InternodeInboundMetrics} and\n * {@link org.apache.cassandra.metrics.InternodeOutboundMetrics} for JMX-exposed counters.\n *\n * We also provide {@code system_views.internode_inbound} and {@code system_views.internode_outbound} virtual tables -\n * implemented in {@link org.apache.cassandra.db.virtual.InternodeInboundTable} and\n * {@link org.apache.cassandra.db.virtual.InternodeOutboundTable} respectively.\n */\npublic final class MessagingService extends MessagingServiceMBeanImpl\n{\n    private static final Logger logger = LoggerFactory.getLogger(MessagingService.class);\n\n    // 8 bits version, so don't waste versions\n    public static final int VERSION_30 = 10;\n    public static final int VERSION_3014 = 11;\n    public static final int VERSION_40 = 12;\n    public static final int minimum_version = VERSION_30;\n    public static final int current_version = VERSION_40;\n    static AcceptVersions accept_messaging = new AcceptVersions(minimum_version, current_version);\n    static AcceptVersions accept_streaming = new AcceptVersions(current_version, current_version);\n\n    public enum Version\n    {\n        VERSION_30(10),\n        VERSION_3014(11),\n        VERSION_40(12);\n\n        public final int value;\n\n        Version(int value)\n        {\n            this.value = value;\n        }\n    }\n\n    private static class MSHandle\n    {\n        public static final MessagingService instance = new MessagingService(false);\n    }\n\n    public static MessagingService instance()\n    {\n        return MSHandle.instance;\n    }\n\n    public final SocketFactory socketFactory = new SocketFactory();\n    public final LatencySubscribers latencySubscribers = new LatencySubscribers();\n    public final RequestCallbacks callbacks = new RequestCallbacks(this);\n\n    // a public hook for filtering messages intended for delivery to this node\n    public final InboundSink inboundSink = new InboundSink(this);\n\n    // the inbound global reserve limits and associated wait queue\n    private final InboundMessageHandlers.GlobalResourceLimits inboundGlobalReserveLimits = new InboundMessageHandlers.GlobalResourceLimits(\n        new ResourceLimits.Concurrent(DatabaseDescriptor.getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes()));\n\n    // the socket bindings we accept incoming connections on\n    private final InboundSockets inboundSockets = new InboundSockets(new InboundConnectionSettings()\n                                                                     .withHandlers(this::getInbound)\n                                                                     .withSocketFactory(socketFactory));\n\n    // a public hook for filtering messages intended for delivery to another node\n    public final OutboundSink outboundSink = new OutboundSink(this::doSend);\n\n    final ResourceLimits.Limit outboundGlobalReserveLimit =\n        new ResourceLimits.Concurrent(DatabaseDescriptor.getInternodeApplicationSendQueueReserveGlobalCapacityInBytes());\n\n    private volatile boolean isShuttingDown;\n\n    @VisibleForTesting\n    MessagingService(boolean testOnly)\n    {\n        super(testOnly);\n        OutboundConnections.scheduleUnusedConnectionMonitoring(this, ScheduledExecutors.scheduledTasks, 1L, TimeUnit.HOURS);\n    }\n\n    /**\n     * Send a non-mutation message to a given endpoint. This method specifies a callback\n     * which is invoked with the actual response.\n     *\n     * @param message message to be sent.\n     * @param to      endpoint to which the message needs to be sent\n     * @param cb      callback interface which is used to pass the responses or\n     *                suggest that a timeout occurred to the invoker of the send().\n     */\n    public void sendWithCallback(Message message, InetAddressAndPort to, RequestCallback cb)\n    {\n        sendWithCallback(message, to, cb, null);\n    }\n\n    public void sendWithCallback(Message message, InetAddressAndPort to, RequestCallback cb, ConnectionType specifyConnection)\n    {\n        callbacks.addWithExpiration(cb, message, to);\n        if (cb.invokeOnFailure() && !message.callBackOnFailure())\n            message = message.withCallBackOnFailure();\n        send(message, to, specifyConnection);\n    }\n\n    /**\n     * Send a mutation message or a Paxos Commit to a given endpoint. This method specifies a callback\n     * which is invoked with the actual response.\n     * Also holds the message (only mutation messages) to determine if it\n     * needs to trigger a hint (uses StorageProxy for that).\n     *\n     * @param message message to be sent.\n     * @param to      endpoint to which the message needs to be sent\n     * @param handler callback interface which is used to pass the responses or\n     *                suggest that a timeout occurred to the invoker of the send().\n     */\n    public void sendWriteWithCallback(Message message, Replica to, AbstractWriteResponseHandler<?> handler, boolean allowHints)\n    {\n        assert message.callBackOnFailure();\n        callbacks.addWithExpiration(handler, message, to, handler.consistencyLevel(), allowHints);\n        send(message, to.endpoint(), null);\n    }\n\n    /**\n     * Send a message to a given endpoint. This method adheres to the fire and forget\n     * style messaging.\n     *\n     * @param message messages to be sent.\n     * @param to      endpoint to which the message needs to be sent\n     */\n    public void send(Message message, InetAddressAndPort to)\n    {\n        send(message, to, null);\n    }\n\n    public void send(Message message, InetAddressAndPort to, ConnectionType specifyConnection)\n    {\n        if (logger.isTraceEnabled())\n        {\n            logger.trace(\"{} sending {} to {}@{}\", FBUtilities.getBroadcastAddressAndPort(), message.verb(), message.id(), to);\n\n            if (to.equals(FBUtilities.getBroadcastAddressAndPort()))\n                logger.trace(\"Message-to-self {} going over MessagingService\", message);\n        }\n\n        outboundSink.accept(message, to, specifyConnection);\n    }\n\n    private void doSend(Message message, InetAddressAndPort to, ConnectionType specifyConnection)\n    {\n        // expire the callback if the message failed to enqueue (failed to establish a connection or exceeded queue capacity)\n        while (true)\n        {\n            OutboundConnections connections = getOutbound(to);\n            try\n            {\n                connections.enqueue(message, specifyConnection);\n                return;\n            }\n            catch (ClosedChannelException e)\n            {\n                if (isShuttingDown)\n                    return; // just drop the message, and let others clean up\n\n                // remove the connection and try again\n                channelManagers.remove(to, connections);\n            }\n        }\n    }\n\n    void markExpiredCallback(InetAddressAndPort addr)\n    {\n        OutboundConnections conn = channelManagers.get(addr);\n        if (conn != null)\n            conn.incrementExpiredCallbackCount();\n    }\n\n    /**\n     * Only to be invoked once we believe the endpoint will never be contacted again.\n     *\n     * We close the connection after a five minute delay, to give asynchronous operations a chance to terminate\n     */\n    public void closeOutbound(InetAddressAndPort to)\n    {\n        OutboundConnections pool = channelManagers.get(to);\n        if (pool != null)\n            pool.scheduleClose(5L, MINUTES, true)\n                .addListener(future -> channelManagers.remove(to, pool));\n    }\n\n    /**\n     * Only to be invoked once we believe the connections will never be used again.\n     */\n    void closeOutboundNow(OutboundConnections connections)\n    {\n        connections.close(true).addListener(\n            future -> channelManagers.remove(connections.template().to, connections)\n        );\n    }\n\n    /**\n     * Only to be invoked once we believe the connections will never be used again.\n     */\n    public void removeInbound(InetAddressAndPort from)\n    {\n        InboundMessageHandlers handlers = messageHandlers.remove(from);\n        if (null != handlers)\n            handlers.releaseMetrics();\n    }\n\n    /**\n     * Closes any current open channel/connection to the endpoint, but does not cause any message loss, and we will\n     * try to re-establish connections immediately\n     */\n    public void interruptOutbound(InetAddressAndPort to)\n    {\n        OutboundConnections pool = channelManagers.get(to);\n        if (pool != null)\n            pool.interrupt();\n    }\n\n    /**\n     * Reconnect to the peer using the given {@code addr}. Outstanding messages in each channel will be sent on the\n     * current channel. Typically this function is used for something like EC2 public IP addresses which need to be used\n     * for communication between EC2 regions.\n     *\n     * @param address IP Address to identify the peer\n     * @param preferredAddress IP Address to use (and prefer) going forward for connecting to the peer\n     */\n    @SuppressWarnings(\"UnusedReturnValue\")\n    public Future<Void> maybeReconnectWithNewIp(InetAddressAndPort address, InetAddressAndPort preferredAddress)\n    {\n        if (!SystemKeyspace.updatePreferredIP(address, preferredAddress))\n            return null;\n\n        OutboundConnections messagingPool = channelManagers.get(address);\n        if (messagingPool != null)\n            return messagingPool.reconnectWithNewIp(preferredAddress);\n\n        return null;\n    }\n\n    /**\n     * Wait for callbacks and don't allow any more to be created (since they could require writing hints)\n     */\n    public void shutdown()\n    {\n        shutdown(1L, MINUTES, true, true);\n    }\n\n    public void shutdown(long timeout, TimeUnit units, boolean shutdownGracefully, boolean shutdownExecutors)\n    {\n        if (isShuttingDown)\n        {\n            logger.info(\"Shutdown was already called\");\n            return;\n        }\n\n        isShuttingDown = true;\n        logger.info(\"Waiting for messaging service to quiesce\");\n        // We may need to schedule hints on the mutation stage, so it's erroneous to shut down the mutation stage first\n        assert !MUTATION.executor().isShutdown();\n\n        if (shutdownGracefully)\n        {\n            callbacks.shutdownGracefully();\n            List<Future<Void>> closing = new ArrayList<>();\n            for (OutboundConnections pool : channelManagers.values())\n                closing.add(pool.close(true));\n\n            long deadline = System.nanoTime() + units.toNanos(timeout);\n            maybeFail(() -> new FutureCombiner(closing).get(timeout, units),\n                      () -> {\n                          List<ExecutorService> inboundExecutors = new ArrayList<>();\n                          inboundSockets.close(synchronizedList(inboundExecutors)::add).get();\n                          ExecutorUtils.awaitTermination(1L, TimeUnit.MINUTES, inboundExecutors);\n                      },\n                      () -> {\n                          if (shutdownExecutors)\n                              shutdownExecutors(deadline);\n                      },\n                      () -> callbacks.awaitTerminationUntil(deadline),\n                      inboundSink::clear,\n                      outboundSink::clear);\n        }\n        \npublic int applicationSendQueueReserveEndpointCapacityInBytes()\n    {\n        return applicationSendQueueReserveEndpointCapacityInBytes != null ? applicationSendQueueReserveEndpointCapacityInBytes\n                                                                          : DatabaseDescriptor.getInternodeApplicationReceiveQueueReserveEndpointCapacityInBytes();\n    }\n\n    "
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `internode_application_receive_queue_reserve_endpoint_capacity_in_bytes` directly impacts the memory allocation for inbound message handling. Given that this configuration sets limits on the amount of memory that can be reserved for processing incoming messages, it can lead to significant performance variations. If the limit is too low, it may result in message processing delays or dropped messages, which can severely affect the overall system performance, especially under high load conditions. Therefore, its impact on memory management and message processing makes it a critical performance-sensitive configuration."
        }
    ]
}