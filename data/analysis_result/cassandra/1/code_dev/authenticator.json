{
    "performance_sensitive": "Yes",
    "config_name": "authenticator",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "private void authenticate()\n    {\n        if (!StorageService.instance.isAuthSetupComplete())\n            throw new AuthenticationException(\"Cannot login as server authentication setup is not yet completed\");\n\n        IAuthenticator authenticator = DatabaseDescriptor.getAuthenticator();\n        Map<String, String> credentials = new HashMap<>();\n        credentials.put(PasswordAuthenticator.USERNAME_KEY, username);\n        credentials.put(PasswordAuthenticator.PASSWORD_KEY, String.valueOf(password));\n        AuthenticatedUser user = authenticator.legacyAuthenticate(credentials);\n        // Only actual users should be allowed to authenticate for JMX\n        if (user.isAnonymous() || user.isSystem())\n            throw new AuthenticationException(String.format(\"Invalid user %s\", user.getName()));\n\n        // The LOGIN privilege is required to authenticate - c.f. ClientState::login\n        if (!DatabaseDescriptor.getRoleManager().canLogin(user.getPrimaryRole()))\n            throw new AuthenticationException(user.getName() + \" is not permitted to log in\");\n    }\n\n    \npublic CassandraRoleManager()\n    {\n        supportedOptions = DatabaseDescriptor.getAuthenticator().getClass() == PasswordAuthenticator.class\n                         ? ImmutableSet.of(Option.LOGIN, Option.SUPERUSER, Option.PASSWORD)\n                         : ImmutableSet.of(Option.LOGIN, Option.SUPERUSER);\n        alterableOptions = DatabaseDescriptor.getAuthenticator().getClass().equals(PasswordAuthenticator.class)\n                         ? ImmutableSet.of(Option.PASSWORD)\n                         : ImmutableSet.<Option>of();\n    }\n\n    \npublic class NetworkAuthCache extends AuthCache<RoleResource, DCPermissions>\n{\n    public NetworkAuthCache(INetworkAuthorizer authorizer)\n    {\n        super(\"NetworkAuthCache\",\n              DatabaseDescriptor::setRolesValidity,\n              DatabaseDescriptor::getRolesValidity,\n              DatabaseDescriptor::setRolesUpdateInterval,\n              DatabaseDescriptor::getRolesUpdateInterval,\n              DatabaseDescriptor::setRolesCacheMaxEntries,\n              DatabaseDescriptor::getRolesCacheMaxEntries,\n              authorizer::authorize,\n              () -> DatabaseDescriptor.getAuthenticator().requireAuthentication());\n    }\n}\n\npublic class Roles\n{\n    private static final Logger logger = LoggerFactory.getLogger(Roles.class);\n\n    private static final Role NO_ROLE = new Role(\"\", false, false, Collections.emptyMap(), Collections.emptySet());\n\n    private static RolesCache cache;\n    static\n    {\n        initRolesCache(DatabaseDescriptor.getRoleManager(),\n                       () -> DatabaseDescriptor.getAuthenticator().requireAuthentication());\n    }\n\n    @VisibleForTesting\n    public static void initRolesCache(IRoleManager roleManager, BooleanSupplier enableCache)\n    {\n        if (cache != null)\n            cache.unregisterMBean();\n        cache = new RolesCache(roleManager, enableCache);\n    }\n\n    @VisibleForTesting\n    public static void clearCache()\n    {\n        cache.invalidate();\n    }\n\n    /**\n     * Identify all roles granted to the supplied Role, including both directly granted\n     * and inherited roles.\n     * This method is used where we mainly just care about *which* roles are granted to a given role,\n     * including when looking up or listing permissions for a role on a given resource.\n     *\n     * @param primaryRole the Role\n     * @return set of all granted Roles for the primary Role\n     */\n    public static Set<RoleResource> getRoles(RoleResource primaryRole)\n    {\n        return cache.getRoleResources(primaryRole);\n    }\n\n    /**\n     * Get detailed info on all the roles granted to the role identified by the supplied RoleResource.\n     * This includes superuser status and login privileges for the primary role and all roles granted directly\n     * to it or inherited.\n     * The returnred roles may be cached if roles_validity_in_ms > 0\n     * This method is used where we need to know specific attributes of the collection of granted roles, i.e.\n     * when checking for superuser status which may be inherited from *any* granted role.\n     *\n     * @param primaryRole identifies the role\n     * @return set of detailed info for all of the roles granted to the primary\n     */\n    public static Set<Role> getRoleDetails(RoleResource primaryRole)\n    {\n        return cache.getRoles(primaryRole);\n    }\n\n    /**\n     * Returns true if the supplied role or any other role granted to it\n     * (directly or indirectly) has superuser status.\n     *\n     * @param role the primary role\n     * @return true if the role has superuser status, false otherwise\n     */\n    public static boolean hasSuperuserStatus(RoleResource role)\n    {\n        try\n        {\n            for (Role r : getRoleDetails(role))\n                if (r.isSuper)\n                    return true;\n\n            return false;\n        }\n        catch (RequestExecutionException e)\n        {\n            logger.debug(\"Failed to authorize {} for super-user permission\", role.getRoleName());\n            throw new UnauthorizedException(\"Unable to perform authorization of super-user permission: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Returns true if the supplied role has the login privilege. This cannot be inherited, so\n     * returns true iff the named role has that bit set.\n     * @param role the role identifier\n     * @return true if the role has the canLogin privilege, false otherwise\n     */\n    public static boolean canLogin(final RoleResource role)\n    {\n        try\n        {\n            for (Role r : getRoleDetails(role))\n                if (r.resource.equals(role))\n                    return r.canLogin;\n\n            return false;\n        }\n        catch (RequestExecutionException e)\n        {\n            logger.debug(\"Failed to authorize {} for login permission\", role.getRoleName());\n            throw new UnauthorizedException(\"Unable to perform authorization of login permission: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Returns the map of custom options for the named role. These options are not inherited from granted roles, but\n     * are set directly.\n     * @param role the role identifier\n     * @return map of option_name -> value. If no options are set for the named role, the map will be empty\n     * but never null.\n     */\n    public static Map<String, String> getOptions(RoleResource role)\n    {\n        for (Role r : getRoleDetails(role))\n            if (r.resource.equals(role))\n                return r.options;\n\n        return NO_ROLE.options;\n    }\n\n   /**\n    * Return the NullObject Role instance which can be safely used to indicate no information is available\n    * when querying for a specific named role.\n    * @return singleton null role object\n    */\n   public static Role nullRole()\n   {\n       return NO_ROLE;\n   }\n\n   /**\n    * Just a convenience method which compares a role instance with the null object version, indicating if the\n    * return from some query/lookup method was a valid Role or indicates that the role does not exist.\n    * @param role\n    * @return true if the supplied role is the null role instance, false otherwise.\n    */\n   public static boolean isNullRole(Role role)\n   {\n       return NO_ROLE.equals(role);\n   }\n\n\n   /**\n    * Constructs a Role object from a RoleResource, using the methods of the supplied IRoleManager.\n    * This is used by the default implementation of IRoleManager#getRoleDetails so that IRoleManager impls\n    * which don't implement an optimized getRoleDetails remain compatible. Depending on the IRoleManager\n    * implementation this could be quite heavyweight, so should not be used on any hot path.\n    *\n    * @param resource identifies the role\n    * @param roleManager provides lookup functions to retrieve role info\n    * @return Role object including superuser status, login privilege, custom options and the set of roles\n    * granted to identified role.\n    */\n   public static Role fromRoleResource(RoleResource resource, IRoleManager roleManager)\n   {\n       return new Role(resource.getName(),\n                       roleManager.isSuper(resource),\n                       roleManager.canLogin(resource),\n                       roleManager.getCustomOptions(resource),\n                       roleManager.getRoles(resource, false)\n                                  .stream()\n                                  .map(RoleResource::getRoleName)\n                                  .collect(Collectors.toSet()));\n   }\n}\n\npublic void validateTransportsCanStart()\n    {\n        // We only start transports if bootstrap has completed and we're not in survey mode, OR if we are in\n        // survey mode and streaming has completed but we're not using auth.\n        // OR if we have not joined the ring yet.\n        if (StorageService.instance.hasJoined())\n        {\n            if (StorageService.instance.isSurveyMode())\n            {\n                if (StorageService.instance.isBootstrapMode() || DatabaseDescriptor.getAuthenticator().requireAuthentication())\n                {\n                    throw new IllegalStateException(\"Not starting client transports in write_survey mode as it's bootstrapping or \" +\n                                                    \"auth is enabled\");\n                }\n            }\n            else\n            {\n                if (!SystemKeyspace.bootstrapComplete())\n                {\n                    throw new IllegalStateException(\"Node is not yet bootstrapped completely. Use nodetool to check bootstrap\" +\n                                                    \" state and resume. For more, see `nodetool help bootstrap`\");\n                }\n            }\n        }\n    }\n\n    \nprotected ClientState(InetSocketAddress remoteAddress)\n    {\n        this.isInternal = false;\n        this.remoteAddress = remoteAddress;\n        if (!DatabaseDescriptor.getAuthenticator().requireAuthentication())\n            this.user = AuthenticatedUser.ANONYMOUS_USER;\n    }\n\n    \npublic void ensureIsSuperuser(String message)\n    {\n        if (DatabaseDescriptor.getAuthenticator().requireAuthentication() && (user == null || !user.isSuper()))\n            throw new UnauthorizedException(message);\n    }\n\n    \n/**\n * State related to a client connection.\n */\npublic class ClientState\n{\n    private static final Logger logger = LoggerFactory.getLogger(ClientState.class);\n\n    private static final Set<IResource> READABLE_SYSTEM_RESOURCES = new HashSet<>();\n    private static final Set<IResource> PROTECTED_AUTH_RESOURCES = new HashSet<>();\n\n    static\n    {\n        // We want these system cfs to be always readable to authenticated users since many tools rely on them\n        // (nodetool, cqlsh, bulkloader, etc.)\n        for (String cf : Arrays.asList(SystemKeyspace.LOCAL, SystemKeyspace.LEGACY_PEERS, SystemKeyspace.PEERS_V2))\n            READABLE_SYSTEM_RESOURCES.add(DataResource.table(SchemaConstants.SYSTEM_KEYSPACE_NAME, cf));\n\n        // make all schema tables readable by default (required by the drivers)\n        SchemaKeyspaceTables.ALL.forEach(table -> READABLE_SYSTEM_RESOURCES.add(DataResource.table(SchemaConstants.SCHEMA_KEYSPACE_NAME, table)));\n\n        // make all virtual schema tables readable by default as well\n        VirtualSchemaKeyspace.instance.tables().forEach(t -> READABLE_SYSTEM_RESOURCES.add(t.metadata().resource));\n\n        // neither clients nor tools need authentication/authorization\n        if (DatabaseDescriptor.isDaemonInitialized())\n        {\n            PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getAuthenticator().protectedResources());\n            PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getAuthorizer().protectedResources());\n            PROTECTED_AUTH_RESOURCES.addAll(DatabaseDescriptor.getRoleManager().protectedResources());\n        }\n    }\n\n    // Current user for the session\n    private volatile AuthenticatedUser user;\n    private volatile String keyspace;\n    private volatile boolean issuedPreparedStatementsUseWarning;\n\n    private static final QueryHandler cqlQueryHandler;\n    static\n    {\n        QueryHandler handler = QueryProcessor.instance;\n        String customHandlerClass = System.getProperty(\"cassandra.custom_query_handler_class\");\n        if (customHandlerClass != null)\n        {\n            try\n            {\n                handler = FBUtilities.construct(customHandlerClass, \"QueryHandler\");\n                logger.info(\"Using {} as query handler for native protocol queries (as requested with -Dcassandra.custom_query_handler_class)\", customHandlerClass);\n            }\n            catch (Exception e)\n            {\n                logger.error(\"Cannot use class {} as query handler\", customHandlerClass, e);\n                JVMStabilityInspector.killCurrentJVM(e, true);\n            }\n        }\n        cqlQueryHandler = handler;\n    }\n\n    // isInternal is used to mark ClientState as used by some internal component\n    // that should have an ability to modify system keyspace.\n    public final boolean isInternal;\n\n    // The remote address of the client - null for internal clients.\n    private final InetSocketAddress remoteAddress;\n\n    // Driver String for the client\n    private volatile String driverName;\n    private volatile String driverVersion;\n\n    // The biggest timestamp that was returned by getTimestamp/assigned to a query. This is global to ensure that the\n    // timestamp assigned are strictly monotonic on a node, which is likely what user expect intuitively (more likely,\n    // most new user will intuitively expect timestamp to be strictly monotonic cluster-wise, but while that last part\n    // is unrealistic expectation, doing it node-wise is easy).\n    private static final AtomicLong lastTimestampMicros = new AtomicLong(0);\n\n    /**\n     * Construct a new, empty ClientState for internal calls.\n     */\n    private ClientState()\n    {\n        this.isInternal = true;\n        this.remoteAddress = null;\n    }\n\n    protected ClientState(InetSocketAddress remoteAddress)\n    {\n        this.isInternal = false;\n        this.remoteAddress = remoteAddress;\n        if (!DatabaseDescriptor.getAuthenticator().requireAuthentication())\n            this.user = AuthenticatedUser.ANONYMOUS_USER;\n    }\n\n    protected ClientState(ClientState source)\n    {\n        this.isInternal = source.isInternal;\n        this.remoteAddress = source.remoteAddress;\n        this.user = source.user;\n        this.keyspace = source.keyspace;\n        this.driverName = source.driverName;\n        this.driverVersion = source.driverVersion;\n    }\n\n    /**\n     * @return a ClientState object for internal C* calls (not limited by any kind of auth).\n     */\n    public static ClientState forInternalCalls()\n    {\n        return new ClientState();\n    }\n\n    public static ClientState forInternalCalls(String keyspace)\n    {\n        ClientState state = new ClientState();\n        state.setKeyspace(keyspace);\n        return state;\n    }\n\n    /**\n     * @return a ClientState object for external clients (native protocol users).\n     */\n    public static ClientState forExternalCalls(SocketAddress remoteAddress)\n    {\n        return new ClientState((InetSocketAddress)remoteAddress);\n    }\n\n    /**\n     * Clone this ClientState object, but use the provided keyspace instead of the\n     * keyspace in this ClientState object.\n     *\n     * @return a new ClientState object if the keyspace argument is non-null. Otherwise do not clone\n     *   and return this ClientState object.\n     */\n    public ClientState cloneWithKeyspaceIfSet(String keyspace)\n    {\n        if (keyspace == null)\n            return this;\n        ClientState clientState = new ClientState(this);\n        clientState.setKeyspace(keyspace);\n        return clientState;\n    }\n\n    /**\n     * This clock guarantees that updates for the same ClientState will be ordered\n     * in the sequence seen, even if multiple updates happen in the same millisecond.\n     */\n    public static long getTimestamp()\n    {\n        while (true)\n        {\n            long current = System.currentTimeMillis() * 1000;\n            long last = lastTimestampMicros.get();\n            long tstamp = last >= current ? last + 1 : current;\n            if (lastTimestampMicros.compareAndSet(last, tstamp))\n                return tstamp;\n        }\n    }\n\n    /**\n     * Returns a timestamp suitable for paxos given the timestamp of the last known commit (or in progress update).\n     * <p>\n     * Paxos ensures that the timestamp it uses for commits respects the serial order of those commits. It does so\n     * by having each replica reject any proposal whose timestamp is not strictly greater than the last proposal it\n     * accepted. So in practice, which timestamp we use for a given proposal doesn't affect correctness but it does\n     * affect the chance of making progress (if we pick a timestamp lower than what has been proposed before, our\n     * new proposal will just get rejected).\n     * <p>\n     * As during the prepared phase replica send us the last propose they accepted, a first option would be to take\n     * the maximum of those last accepted proposal timestamp plus 1 (and use a default value, say 0, if it's the\n     * first known proposal for the partition). This would most work (giving commits the timestamp 0, 1, 2, ...\n     * in the order they are commited) up to 2 important caveats:\n     *   1) it would give a very poor experience when Paxos and non-Paxos updates are mixed in the same partition,\n     *      since paxos operations wouldn't be using microseconds timestamps. And while you shouldn't theoretically\n     *      mix the 2 kind of operations, this would still be pretty unintuitive. And what if you started writing\n     *      normal updates and realize later you should switch to Paxos to enforce a property you want?\n     *   2) this wouldn't actually be safe due to the expiration set on the Paxos state table.\n     * <p>\n     * So instead, we initially chose to use the current time in microseconds as for normal update. Which works in\n     * general but mean that clock skew creates unavailability periods for Paxos updates (either a node has his clock\n     * in the past and he may no be able to get commit accepted until its clock catch up, or a node has his clock in\n     * the future and then once one of its commit his accepted, other nodes ones won't be until they catch up). This\n     * is ok for small clock skew (few ms) but can be pretty bad for large one.\n     * <p>\n     * Hence our current solution: we mix both approaches. That is, we compare the timestamp of the last known\n     * accepted proposal and the local time. If the local time is greater, we use it, thus keeping paxos timestamps\n     * locked to the current time in general (making mixing Paxos and non-Paxos more friendly, and behaving correctly\n     * when the paxos state expire (as long as your maximum clock skew is lower than the Paxos state expiration\n     * time)). Otherwise (the local time is lower than the last proposal, meaning that this last proposal was done\n     * with a clock in the future compared to the local one), we use the last proposal timestamp plus 1, ensuring\n     * progress.\n     *\n     * @param minTimestampToUse the max timestamp of the last proposal accepted by replica having responded\n     * to the prepare phase of the paxos round this is for. In practice, that's the minimum timestamp this method\n     * may return.\n     * @return a timestamp suitable for a Paxos proposal (using the reasoning described above). Note that\n     * contrarily to the {@link #getTimestamp()} method, the return value is not guaranteed to be unique (nor\n     * monotonic) across calls since it can return it's argument (so if the same argument is passed multiple times,\n     * it may be returned multiple times). Note that we still ensure Paxos \"ballot\" are unique (for different\n     * proposal) by (securely) randomizing the non-timestamp part of the UUID.\n     */\n    public long getTimestampForPaxos(long minTimestampToUse)\n    {\n        while (true)\n        {\n            long current = Math.max(System.currentTimeMillis() * 1000, minTimestampToUse);\n            long last = lastTimestampMicros.get();\n            long tstamp = last >= current ? last + 1 : current;\n            // Note that if we ended up picking minTimestampMicrosToUse (it was \"in the future\"), we don't\n            // want to change the local clock, otherwise a single node in the future could corrupt the clock\n            // of all nodes and for all inserts (since non-paxos inserts also use lastTimestampMicros).\n            // See CASSANDRA-11991\n            if (tstamp == minTimestampToUse || lastTimestampMicros.compareAndSet(last, tstamp))\n                return tstamp;\n        }\n    }\n\n    public Optional<String> getDriverName()\n    {\n        return Optional.ofNullable(driverName);\n    }\n\n    public Optional<String> getDriverVersion()\n    {\n        return Optional.ofNullable(driverVersion);\n    }\n\n    public void setDriverName(String driverName)\n    {\n        this.driverName = driverName;\n    }\n\n    public void setDriverVersion(String driverVersion)\n    {\n        this.driverVersion = driverVersion;\n    }\n\n    public static QueryHandler getCQLQueryHandler()\n    {\n        return cqlQueryHandler;\n    }\n\n    public InetSocketAddress getRemoteAddress()\n    {\n        return remoteAddress;\n    }\n\n    InetAddress getClientAddress()\n    {\n        return isInternal ? null : remoteAddress.getAddress();\n    }\n\n    public String getRawKeyspace()\n    {\n        return keyspace;\n    }\n\n    public String getKeyspace() throws InvalidRequestException\n    {\n        if (keyspace == null)\n            throw new InvalidRequestException(\"No keyspace has been specified. USE a keyspace, or explicitly specify keyspace.tablename\");\n        return keyspace;\n    }\n\n    public void setKeyspace(String ks)\n    {\n        // Skip keyspace validation for non-authenticated users. Apparently, some client libraries\n        // call set_keyspace() before calling login(), and we have to handle that.\n        if (user != null && Schema.instance.getKeyspaceMetadata(ks) == null)\n            throw new InvalidRequestException(\"Keyspace '\" + ks + \"' does not exist\");\n        keyspace = ks;\n    }\n\n    /**\n     * Attempts to login the given user.\n     */\n    public void login(AuthenticatedUser user)\n    {\n        if (user.isAnonymous() || canLogin(user))\n            this.user = user;\n        else\n            throw new AuthenticationException(String.format(\"%s is not permitted to log in\", user.getName()));\n    }\n\n    private boolean canLogin(AuthenticatedUser user)\n    {\n        try\n        {\n            return user.canLogin();\n        }\n        catch (RequestExecutionException | RequestValidationException e)\n        {\n            throw new AuthenticationException(\"Unable to perform authentication: \" + e.getMessage(), e);\n        }\n    }\n\n    public void ensureAllKeyspacesPermission(Permission perm)\n    {\n        if (isInternal)\n            return;\n        validateLogin();\n        ensurePermission(perm, DataResource.root());\n    }\n\n    public void ensureKeyspacePermission(String keyspace, Permission perm)\n    {\n        ensurePermission(keyspace, perm, DataResource.keyspace(keyspace));\n    }\n\n    public void ensureTablePermission(String keyspace, String table, Permission perm)\n    {\n        ensurePermission(keyspace, perm, DataResource.table(keyspace, table));\n    }\n\n    public void ensureTablePermission(TableMetadataRef tableRef, Permission perm)\n    {\n        ensureTablePermission(tableRef.get(), perm);\n    }\n\n    public void ensureTablePermission(TableMetadata table, Permission perm)\n    {\n        ensurePermission(table.keyspace, perm, table.resource);\n    }\n\n    private void ensurePermission(String keyspace, Permission perm, DataResource resource)\n    {\n        validateKeyspace(keyspace);\n\n        if (isInternal)\n            return;\n\n        validateLogin();\n\n        preventSystemKSSchemaModification(keyspace, resource, perm);\n\n        if ((perm == Permission.SELECT) && READABLE_SYSTEM_RESOURCES.contains(resource))\n            return;\n\n        if (PROTECTED_AUTH_RESOURCES.contains(resource))\n            if ((perm == Permission.CREATE) || (perm == Permission.ALTER) || (perm == Permission.DROP))\n                throw new UnauthorizedException(String.format(\"%s schema is protected\", resource));\n        ensurePermission(perm, resource);\n    }\n\n    public void ensurePermission(Permission perm, IResource resource)\n    {\n        if (!DatabaseDescriptor.getAuthorizer().requireAuthorization())\n            return;\n\n        // Access to built in functions is unrestricted\n        if(resource instanceof FunctionResource && resource.hasParent())\n            if (((FunctionResource)resource).getKeyspace().equals(SchemaConstants.SYSTEM_KEYSPACE_NAME))\n                return;\n\n        ensurePermissionOnResourceChain(perm, resource);\n    }\n\n    // Convenience method called from authorize method of CQLStatement\n    // Also avoids needlessly creating lots of FunctionResource objects\n    public void ensurePermission(Permission permission, Function function)\n    {\n        // Save creating a FunctionResource is we don't need to\n        if (!DatabaseDescriptor.getAuthorizer().requireAuthorization())\n            return;\n\n        // built in functions are always available to all\n        if (function.isNative())\n            return;\n\n        ensurePermissionOnResourceChain(permission, FunctionResource.function(function.name().keyspace,\n                                                                              function.name().name,\n                                                                              function.argTypes()));\n    }\n\n    private void ensurePermissionOnResourceChain(Permission perm, IResource resource)\n    {\n        for (IResource r : Resources.chain(resource))\n            if (authorize(r).contains(perm))\n                return;\n\n        throw new UnauthorizedException(String.format(\"User %s has no %s permission on %s or any of its parents\",\n                                                      user.getName(),\n                                                      perm,\n                                                      resource));\n    }\n\n    private void preventSystemKSSchemaModification(String keyspace, DataResource resource, Permission perm)\n    {\n        // we only care about DDL statements\n        if (perm != Permission.ALTER && perm != Permission.DROP && perm != Permission.CREATE)\n            return;\n\n        // prevent ALL local system keyspace modification\n        if (SchemaConstants.isLocalSystemKeyspace(keyspace))\n            throw new UnauthorizedException(keyspace + \" keyspace is not user-modifiable.\");\n\n        if (SchemaConstants.isReplicatedSystemKeyspace(keyspace))\n        {\n            // allow users with sufficient privileges to alter replication params of replicated system keyspaces\n            if (perm == Permission.ALTER && resource.isKeyspaceLevel())\n                return;\n\n            // prevent all other modifications of replicated system keyspaces\n            throw new UnauthorizedException(String.format(\"Cannot %s %s\", perm, resource));\n        }\n    }\n\n    public void validateLogin()\n    {\n        if (user == null)\n        {\n            throw new UnauthorizedException(\"You have not logged in\");\n        }\n        else if (!user.hasLocalAccess())\n        {\n            throw new UnauthorizedException(String.format(\"You do not have access to this datacenter (%s)\", Datacenters.thisDatacenter()));\n        }\n    }\n\n    public void ensureNotAnonymous()\n    {\n        validateLogin();\n        if (user.isAnonymous())\n            throw new UnauthorizedException(\"You have to be logged in and not anonymous to perform this request\");\n    }\n\n    public void ensureIsSuperuser(String message)\n    {\n        if (DatabaseDescriptor.getAuthenticator().requireAuthentication() && (user == null || !user.isSuper()))\n            throw new UnauthorizedException(message);\n    }\n\n    public void warnAboutUseWithPreparedStatements(MD5Digest statementId, String preparedKeyspace)\n    {\n        if (!issuedPreparedStatementsUseWarning)\n        {\n            ClientWarn.instance.warn(String.format(\"`USE <keyspace>` with prepared statements is considered to be an anti-pattern due to ambiguity in non-qualified table names. \" +\n                                                   \"Please consider removing instances of `Session#setKeyspace(<keyspace>)`, `Session#execute(\\\"USE <keyspace>\\\")` and `cluster.newSession(<keyspace>)` from your code, and \" +\n                                                   \"always use fully qualified table names (e.g. <keyspace>.<table>). \" +\n                                                   \"Keyspace used: %s, statement keyspace: %s, statement id: %s\", getRawKeyspace(), preparedKeyspace, statementId));\n            issuedPreparedStatementsUseWarning = true;\n        }\n    }\n\n    private static void validateKeyspace(String keyspace)\n    {\n        if (keyspace == null)\n            throw new InvalidRequestException(\"You have not set a keyspace for this session\");\n    }\n\n    public AuthenticatedUser getUser()\n    {\n        return user;\n    }\n\n    private Set<Permission> authorize(IResource resource)\n    {\n        return user.getPermissions(resource);\n    }\n\n}\n\n@VisibleForTesting\n    public void doAuthSetup(boolean setUpSchema)\n    {\n        if (!authSetupCalled.getAndSet(true))\n        {\n            if (setUpSchema)\n            {\n                Optional<Mutation> mutation = evolveSystemKeyspace(AuthKeyspace.metadata(), AuthKeyspace.GENERATION);\n                mutation.ifPresent(value -> FBUtilities.waitOnFuture(MigrationManager.announceWithoutPush(Collections.singleton(value))));\n            }\n\n            DatabaseDescriptor.getRoleManager().setup();\n            DatabaseDescriptor.getAuthenticator().setup();\n            DatabaseDescriptor.getAuthorizer().setup();\n            DatabaseDescriptor.getNetworkAuthorizer().setup();\n            Schema.instance.registerListener(new AuthSchemaChangeListener());\n            authSetupComplete = true;\n        }\n    }\n\n    \npublic IAuthenticator.SaslNegotiator getSaslNegotiator(QueryState queryState)\n    {\n        if (saslNegotiator == null)\n            saslNegotiator = DatabaseDescriptor.getAuthenticator()\n                                               .newSaslNegotiator(queryState.getClientAddress(), certificates());\n        return saslNegotiator;\n    }\n\n    \n@Override\n    protected Message.Response execute(QueryState state, long queryStartNanoTime, boolean traceRequest)\n    {\n        String cqlVersion = options.get(CQL_VERSION);\n        if (cqlVersion == null)\n            throw new ProtocolException(\"Missing value CQL_VERSION in STARTUP message\");\n\n        try\n        {\n            if (new CassandraVersion(cqlVersion).compareTo(new CassandraVersion(\"2.99.0\")) < 0)\n                throw new ProtocolException(String.format(\"CQL version %s is not supported by the binary protocol (supported version are >= 3.0.0)\", cqlVersion));\n        }\n        catch (IllegalArgumentException e)\n        {\n            throw new ProtocolException(e.getMessage());\n        }\n\n        if (options.containsKey(COMPRESSION))\n        {\n            String compression = options.get(COMPRESSION).toLowerCase();\n            if (compression.equals(\"snappy\"))\n            {\n                if (Compressor.SnappyCompressor.instance == null)\n                    throw new ProtocolException(\"This instance does not support Snappy compression\");\n\n                if (getSource().header.version.isGreaterOrEqualTo(ProtocolVersion.V5))\n                    throw new ProtocolException(\"Snappy compression is not supported in protocol V5\");\n\n                connection.setCompressor(Compressor.SnappyCompressor.instance);\n            }\n            else if (compression.equals(\"lz4\"))\n            {\n                connection.setCompressor(Compressor.LZ4Compressor.instance);\n            }\n            else\n            {\n                throw new ProtocolException(String.format(\"Unknown compression algorithm: %s\", compression));\n            }\n        }\n\n        connection.setThrowOnOverload(\"1\".equals(options.get(THROW_ON_OVERLOAD)));\n\n        ClientState clientState = state.getClientState();\n        String driverName = options.get(DRIVER_NAME);\n        if (null != driverName)\n        {\n            clientState.setDriverName(driverName);\n            clientState.setDriverVersion(options.get(DRIVER_VERSION));\n        }\n\n        if (DatabaseDescriptor.getAuthenticator().requireAuthentication())\n            return new AuthenticateMessage(DatabaseDescriptor.getAuthenticator().getClass().getName());\n        else\n            return new ReadyMessage();\n    }\n\n    "
        },
        {
            "sender": "Developer Filter",
            "content": "Filter of the code context that is related to configuration: ```java\nprivate void authenticate()\n{\n    if (!StorageService.instance.isAuthSetupComplete())\n        throw new AuthenticationException(\"Cannot login as server authentication setup is not yet completed\");\n\n    IAuthenticator authenticator = DatabaseDescriptor.getAuthenticator();\n    Map<String, String> credentials = new HashMap<>();\n    credentials.put(PasswordAuthenticator.USERNAME_KEY, username);\n    credentials.put(PasswordAuthenticator.PASSWORD_KEY, String.valueOf(password));\n    AuthenticatedUser user = authenticator.legacyAuthenticate(credentials);\n    // Only actual users should be allowed to authenticate for JMX\n    if (user.isAnonymous() || user.isSystem())\n        throw new AuthenticationException(String.format(\"Invalid user %s\", user.getName()));\n\n    // The LOGIN privilege is required to authenticate - c.f. ClientState::login\n    if (!DatabaseDescriptor.getRoleManager().canLogin(user.getPrimaryRole()))\n        throw new AuthenticationException(user.getName() + \" is not permitted to log in\");\n}\n\npublic CassandraRoleManager()\n{\n    supportedOptions = DatabaseDescriptor.getAuthenticator().getClass() == PasswordAuthenticator.class\n                     ? ImmutableSet.of(Option.LOGIN, Option.SUPERUSER, Option.PASSWORD)\n                     : ImmutableSet.of(Option.LOGIN, Option.SUPERUSER);\n    alterableOptions = DatabaseDescriptor.getAuthenticator().getClass().equals(PasswordAuthenticator.class)\n                     ? ImmutableSet.of(Option.PASSWORD)\n                     : ImmutableSet.<Option>of();\n}\n\npublic class NetworkAuthCache extends AuthCache<RoleResource, DCPermissions>\n{\n    public NetworkAuthCache(INetworkAuthorizer authorizer)\n    {\n        super(\"NetworkAuthCache\",\n              DatabaseDescriptor::setRolesValidity,\n              DatabaseDescriptor::getRolesValidity,\n              DatabaseDescriptor::setRolesUpdateInterval,\n              DatabaseDescriptor::getRolesUpdateInterval,\n              DatabaseDescriptor::setRolesCacheMaxEntries,\n              DatabaseDescriptor::getRolesCacheMaxEntries,\n              authorizer::authorize,\n              () -> DatabaseDescriptor.getAuthenticator().requireAuthentication());\n    }\n}\n\n@VisibleForTesting\npublic void doAuthSetup(boolean setUpSchema)\n{\n    if (!authSetupCalled.getAndSet(true))\n    {\n        if (setUpSchema)\n        {\n            Optional<Mutation> mutation = evolveSystemKeyspace(AuthKeyspace.metadata(), AuthKeyspace.GENERATION);\n            mutation.ifPresent(value -> FBUtilities.waitOnFuture(MigrationManager.announceWithoutPush(Collections.singleton(value))));\n        }\n\n        DatabaseDescriptor.getRoleManager().setup();\n        DatabaseDescriptor.getAuthenticator().setup();\n        DatabaseDescriptor.getAuthorizer().setup();\n        DatabaseDescriptor.getNetworkAuthorizer().setup();\n        Schema.instance.registerListener(new AuthSchemaChangeListener());\n        authSetupComplete = true;\n    }\n}\n\npublic IAuthenticator.SaslNegotiator getSaslNegotiator(QueryState queryState)\n{\n    if (saslNegotiator == null)\n        saslNegotiator = DatabaseDescriptor.getAuthenticator()\n                                           .newSaslNegotiator(queryState.getClientAddress(), certificates());\n    return saslNegotiator;\n}\n\n@Override\nprotected Message.Response execute(QueryState state, long queryStartNanoTime, boolean traceRequest)\n{\n    if (DatabaseDescriptor.getAuthenticator().requireAuthentication())\n        return new AuthenticateMessage(DatabaseDescriptor.getAuthenticator().getClass().getName());\n    else\n        return new ReadyMessage();\n}\n```"
        },
        {
            "sender": "Developer summary",
            "content": "Summary of the extracted code context: ### Summary of the Authenticator Configuration\n\nThe **authenticator** configuration plays a critical role in managing user authentication within the system. Its primary purpose is to ensure that only authorized users can access the system's resources, thereby enforcing security protocols.\n\n#### Key Components and Dependencies:\n1. **IAuthenticator Interface**: This is the core component that defines the methods for user authentication. The system retrieves the specific implementation of this interface through `DatabaseDescriptor.getAuthenticator()`, which can vary based on the authentication mechanism configured (e.g., `PasswordAuthenticator`).\n\n2. **Authentication Process**: The `authenticate()` method initiates the authentication process. It first checks if the authentication setup is complete. If not, an exception is thrown. It then collects user credentials and invokes the `legacyAuthenticate()` method of the authenticator to validate these credentials. The method ensures that the user is not anonymous or a system user and verifies that the user has the necessary login privileges through the `RoleManager`.\n\n3. **CassandraRoleManager**: This class is responsible for managing roles and permissions. It defines supported and alterable options based on the type of authenticator being used. This interaction ensures that the role management aligns with the authentication mechanism.\n\n4. **NetworkAuthCache**: This component caches authentication-related data to improve efficiency. It interacts with the authenticator to determine if authentication is required and manages the validity and update intervals for roles.\n\n5. **Auth Setup**: The `doAuthSetup()` method is crucial for initializing the authentication framework. It sets up the necessary components, including the role manager, authenticator, authorizer, and network authorizer. This setup is essential for the system to function correctly and securely.\n\n6. **SaslNegotiator**: The `getSaslNegotiator()` method retrieves a SASL negotiator from the authenticator, which is used for handling SASL-based authentication mechanisms, further enhancing the system's security capabilities.\n\n7. **Message Handling**: In the `execute()` method, the system checks if authentication is required before proceeding with any operations. If authentication is necessary, it prepares an `AuthenticateMessage`, ensuring that the client is aware of the authentication requirements.\n\n#### Interaction with Other Parts of the System:\nThe authenticator interacts closely with the **StorageService**, **RoleManager**, and **Schema** components. It ensures that user roles are validated and that the system's security policies are enforced consistently across all operations. The configuration is integral to maintaining a secure environment by preventing unauthorized access and ensuring that only users with the appropriate permissions can perform specific actions within the system.\n\nIn summary, the authenticator configuration is a foundational element of the system's security architecture, coordinating user authentication and authorization processes while interacting with various components to enforce security policies effectively."
        },
        {
            "sender": "performance agent sensitivity",
            "content": "{\"Role\": \"You are a Performance Sensitivity Agent responsible for determining if a configuration is performance-sensitive within a software system.\", \"Requirement\": \"Using developer-provided information as a secondary reference, analyze the configuration-related code to determine if it is performance-sensitive. Focus exclusively on configurations with substantial system-level performance impact due to time-intensive or memory-intensive operations. Only configurations that directly cause significant performance variations through extremely time-consuming or memory-heavy operations should be classified as performance-sensitive. Minor or moderate impacts should not be considered.\", \"Output Format\": \"Respond strictly in one of the following formats: 'The configuration is Performance Sensitive: reason' or 'The configuration is Performance Insensitive: reason'. No other response format is acceptable. Provide a concise yet clear and detailed reason for your classification.\", \"configuration_name\": \"authenticator\", \"code_context\": \"```java\\nprivate void authenticate()\\n{\\n    if (!StorageService.instance.isAuthSetupComplete())\\n        throw new AuthenticationException(\\\"Cannot login as server authentication setup is not yet completed\\\");\\n\\n    IAuthenticator authenticator = DatabaseDescriptor.getAuthenticator();\\n    Map<String, String> credentials = new HashMap<>();\\n    credentials.put(PasswordAuthenticator.USERNAME_KEY, username);\\n    credentials.put(PasswordAuthenticator.PASSWORD_KEY, String.valueOf(password));\\n    AuthenticatedUser user = authenticator.legacyAuthenticate(credentials);\\n    // Only actual users should be allowed to authenticate for JMX\\n    if (user.isAnonymous() || user.isSystem())\\n        throw new AuthenticationException(String.format(\\\"Invalid user %s\\\", user.getName()));\\n\\n    // The LOGIN privilege is required to authenticate - c.f. ClientState::login\\n    if (!DatabaseDescriptor.getRoleManager().canLogin(user.getPrimaryRole()))\\n        throw new AuthenticationException(user.getName() + \\\" is not permitted to log in\\\");\\n}\\n\\npublic CassandraRoleManager()\\n{\\n    supportedOptions = DatabaseDescriptor.getAuthenticator().getClass() == PasswordAuthenticator.class\\n                     ? ImmutableSet.of(Option.LOGIN, Option.SUPERUSER, Option.PASSWORD)\\n                     : ImmutableSet.of(Option.LOGIN, Option.SUPERUSER);\\n    alterableOptions = DatabaseDescriptor.getAuthenticator().getClass().equals(PasswordAuthenticator.class)\\n                     ? ImmutableSet.of(Option.PASSWORD)\\n                     : ImmutableSet.<Option>of();\\n}\\n\\npublic class NetworkAuthCache extends AuthCache<RoleResource, DCPermissions>\\n{\\n    public NetworkAuthCache(INetworkAuthorizer authorizer)\\n    {\\n        super(\\\"NetworkAuthCache\\\",\\n              DatabaseDescriptor::setRolesValidity,\\n              DatabaseDescriptor::getRolesValidity,\\n              DatabaseDescriptor::setRolesUpdateInterval,\\n              DatabaseDescriptor::getRolesUpdateInterval,\\n              DatabaseDescriptor::setRolesCacheMaxEntries,\\n              DatabaseDescriptor::getRolesCacheMaxEntries,\\n              authorizer::authorize,\\n              () -> DatabaseDescriptor.getAuthenticator().requireAuthentication());\\n    }\\n}\\n\\n@VisibleForTesting\\npublic void doAuthSetup(boolean setUpSchema)\\n{\\n    if (!authSetupCalled.getAndSet(true))\\n    {\\n        if (setUpSchema)\\n        {\\n            Optional<Mutation> mutation = evolveSystemKeyspace(AuthKeyspace.metadata(), AuthKeyspace.GENERATION);\\n            mutation.ifPresent(value -> FBUtilities.waitOnFuture(MigrationManager.announceWithoutPush(Collections.singleton(value))));\\n        }\\n\\n        DatabaseDescriptor.getRoleManager().setup();\\n        DatabaseDescriptor.getAuthenticator().setup();\\n        DatabaseDescriptor.getAuthorizer().setup();\\n        DatabaseDescriptor.getNetworkAuthorizer().setup();\\n        Schema.instance.registerListener(new AuthSchemaChangeListener());\\n        authSetupComplete = true;\\n    }\\n}\\n\\npublic IAuthenticator.SaslNegotiator getSaslNegotiator(QueryState queryState)\\n{\\n    if (saslNegotiator == null)\\n        saslNegotiator = DatabaseDescriptor.getAuthenticator()\\n                                           .newSaslNegotiator(queryState.getClientAddress(), certificates());\\n    return saslNegotiator;\\n}\\n\\n@Override\\nprotected Message.Response execute(QueryState state, long queryStartNanoTime, boolean traceRequest)\\n{\\n    if (DatabaseDescriptor.getAuthenticator().requireAuthentication())\\n        return new AuthenticateMessage(DatabaseDescriptor.getAuthenticator().getClass().getName());\\n    else\\n        return new ReadyMessage();\\n}\\n```\\n\\n--- Summary by Developer ---\\n### Summary of the Authenticator Configuration\\n\\nThe **authenticator** configuration plays a critical role in managing user authentication within the system. Its primary purpose is to ensure that only authorized users can access the system's resources, thereby enforcing security protocols.\\n\\n#### Key Components and Dependencies:\\n1. **IAuthenticator Interface**: This is the core component that defines the methods for user authentication. The system retrieves the specific implementation of this interface through `DatabaseDescriptor.getAuthenticator()`, which can vary based on the authentication mechanism configured (e.g., `PasswordAuthenticator`).\\n\\n2. **Authentication Process**: The `authenticate()` method initiates the authentication process. It first checks if the authentication setup is complete. If not, an exception is thrown. It then collects user credentials and invokes the `legacyAuthenticate()` method of the authenticator to validate these credentials. The method ensures that the user is not anonymous or a system user and verifies that the user has the necessary login privileges through the `RoleManager`.\\n\\n3. **CassandraRoleManager**: This class is responsible for managing roles and permissions. It defines supported and alterable options based on the type of authenticator being used. This interaction ensures that the role management aligns with the authentication mechanism.\\n\\n4. **NetworkAuthCache**: This component caches authentication-related data to improve efficiency. It interacts with the authenticator to determine if authentication is required and manages the validity and update intervals for roles.\\n\\n5. **Auth Setup**: The `doAuthSetup()` method is crucial for initializing the authentication framework. It sets up the necessary components, including the role manager, authenticator, authorizer, and network authorizer. This setup is essential for the system to function correctly and securely.\\n\\n6. **SaslNegotiator**: The `getSaslNegotiator()` method retrieves a SASL negotiator from the authenticator, which is used for handling SASL-based authentication mechanisms, further enhancing the system's security capabilities.\\n\\n7. **Message Handling**: In the `execute()` method, the system checks if authentication is required before proceeding with any operations. If authentication is necessary, it prepares an `AuthenticateMessage`, ensuring that the client is aware of the authentication requirements.\\n\\n#### Interaction with Other Parts of the System:\\nThe authenticator interacts closely with the **StorageService**, **RoleManager**, and **Schema** components. It ensures that user roles are validated and that the system's security policies are enforced consistently across all operations. The configuration is integral to maintaining a secure environment by preventing unauthorized access and ensuring that only users with the appropriate permissions can perform specific actions within the system.\\n\\nIn summary, the authenticator configuration is a foundational element of the system's security architecture, coordinating user authentication and authorization processes while interacting with various components to enforce security policies effectively.\"}"
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `authenticate()` method involves a call to `legacyAuthenticate()` which can be time-intensive due to the need to validate user credentials against potentially large datasets. Additionally, the interaction with the `RoleManager` to check login privileges can further contribute to performance overhead, especially under high load or with numerous concurrent authentication requests. The setup and caching mechanisms in `doAuthSetup()` and `NetworkAuthCache` also imply that improper configuration or excessive load could lead to significant memory usage and processing time, impacting overall system performance."
        }
    ]
}