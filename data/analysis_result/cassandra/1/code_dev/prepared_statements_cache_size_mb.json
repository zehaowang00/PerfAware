{
    "performance_sensitive": "Yes",
    "config_name": "prepared_statements_cache_size_mb",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "@VisibleForTesting\n    public static ResultMessage.Prepared storePreparedStatement(String queryString, String keyspace, Prepared prepared)\n    throws InvalidRequestException\n    {\n        // Concatenate the current keyspace so we don't mix prepared statements between keyspace (#5352).\n        // (if the keyspace is null, queryString has to have a fully-qualified keyspace so it's fine.\n        long statementSize = ObjectSizes.measureDeep(prepared.statement);\n        // don't execute the statement if it's bigger than the allowed threshold\n        if (statementSize > capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))\n            throw new InvalidRequestException(String.format(\"Prepared statement of size %d bytes is larger than allowed maximum of %d MB: %s...\",\n                                                            statementSize,\n                                                            DatabaseDescriptor.getPreparedStatementsCacheSizeMB(),\n                                                            queryString.substring(0, 200)));\n        MD5Digest statementId = computeId(queryString, keyspace);\n        Prepared previous = preparedStatements.get(statementId, (ignored_) -> prepared);\n        if (previous == prepared)\n            SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);\n\n        SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);\n        ResultSet.PreparedMetadata preparedMetadata = ResultSet.PreparedMetadata.fromPrepared(prepared.statement);\n        ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.fromPrepared(prepared.statement);\n        return new ResultMessage.Prepared(statementId, resultMetadata.getResultMetadataId(), preparedMetadata, resultMetadata);\n    }\n\n    \npublic class QueryProcessor implements QueryHandler\n{\n    public static final CassandraVersion CQL_VERSION = new CassandraVersion(\"3.4.5\");\n\n    // See comments on QueryProcessor #prepare\n    public static final CassandraVersion NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_30 = new CassandraVersion(\"3.0.26\");\n    public static final CassandraVersion NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_3X = new CassandraVersion(\"3.11.12\");\n    public static final CassandraVersion NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_40 = new CassandraVersion(\"4.0.2\");\n\n    public static final QueryProcessor instance = new QueryProcessor();\n\n    private static final Logger logger = LoggerFactory.getLogger(QueryProcessor.class);\n\n    private static final Cache<MD5Digest, Prepared> preparedStatements;\n\n    // A map for prepared statements used internally (which we don't want to mix with user statement, in particular we don't\n    // bother with expiration on those.\n    private static final ConcurrentMap<String, Prepared> internalStatements = new ConcurrentHashMap<>();\n\n    // Direct calls to processStatement do not increment the preparedStatementsExecuted/regularStatementsExecuted\n    // counters. Callers of processStatement are responsible for correctly notifying metrics\n    public static final CQLMetrics metrics = new CQLMetrics();\n\n    private static final AtomicInteger lastMinuteEvictionsCount = new AtomicInteger(0);\n\n    static\n    {\n        preparedStatements = Caffeine.newBuilder()\n                             .executor(MoreExecutors.directExecutor())\n                             .maximumWeight(capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))\n                             .weigher(QueryProcessor::measure)\n                             .removalListener((key, prepared, cause) -> {\n                                 MD5Digest md5Digest = (MD5Digest) key;\n                                 if (cause.wasEvicted())\n                                 {\n                                     metrics.preparedStatementsEvicted.inc();\n                                     lastMinuteEvictionsCount.incrementAndGet();\n                                     SystemKeyspace.removePreparedStatement(md5Digest);\n                                 }\n                             }).build();\n\n        ScheduledExecutors.scheduledTasks.scheduleAtFixedRate(() -> {\n            long count = lastMinuteEvictionsCount.getAndSet(0);\n            if (count > 0)\n                logger.warn(\"{} prepared statements discarded in the last minute because cache limit reached ({} MB)\",\n                            count,\n                            DatabaseDescriptor.getPreparedStatementsCacheSizeMB());\n        }, 1, 1, TimeUnit.MINUTES);\n\n        logger.info(\"Initialized prepared statement caches with {} MB\",\n                    DatabaseDescriptor.getPreparedStatementsCacheSizeMB());\n    }\n\n    private static long capacityToBytes(long cacheSizeMB)\n    {\n        return cacheSizeMB * 1024 * 1024;\n    }\n\n    public static int preparedStatementsCount()\n    {\n        return preparedStatements.asMap().size();\n    }\n\n    // Work around initialization dependency\n    private enum InternalStateInstance\n    {\n        INSTANCE;\n\n        private final ClientState clientState;\n\n        InternalStateInstance()\n        {\n            clientState = ClientState.forInternalCalls(SchemaConstants.SYSTEM_KEYSPACE_NAME);\n        }\n    }\n\n    public void preloadPreparedStatements()\n    {\n        int count = SystemKeyspace.loadPreparedStatements((id, query, keyspace) -> {\n            try\n            {\n                ClientState clientState = ClientState.forInternalCalls();\n                if (keyspace != null)\n                    clientState.setKeyspace(keyspace);\n\n                Prepared prepared = parseAndPrepare(query, clientState, false);\n                preparedStatements.put(id, prepared);\n\n                // Preload `null` statement for non-fully qualified statements, since it can't be parsed if loaded from cache and will be dropped\n                if (!prepared.fullyQualified)\n                    preparedStatements.get(computeId(query, null), (ignored_) -> prepared);\n                return true;\n            }\n            catch (RequestValidationException e)\n            {\n                JVMStabilityInspector.inspectThrowable(e);\n                logger.warn(String.format(\"Prepared statement recreation error, removing statement: %s %s %s\", id, query, keyspace));\n                SystemKeyspace.removePreparedStatement(id);\n                return false;\n            }\n        });\n        logger.info(\"Preloaded {} prepared statements\", count);\n    }\n\n\n    /**\n     * Clears the prepared statement cache.\n     * @param memoryOnly {@code true} if only the in memory caches must be cleared, {@code false} otherwise.\n     */\n    @VisibleForTesting\n    public static void clearPreparedStatements(boolean memoryOnly)\n    {\n        preparedStatements.invalidateAll();\n        if (!memoryOnly)\n            SystemKeyspace.resetPreparedStatements();\n    }\n\n    @VisibleForTesting\n    public static ConcurrentMap<String, Prepared> getInternalStatements()\n    {\n        return internalStatements;\n    }\n\n    @VisibleForTesting\n    public static QueryState internalQueryState()\n    {\n        return new QueryState(InternalStateInstance.INSTANCE.clientState);\n    }\n\n    private QueryProcessor()\n    {\n        Schema.instance.registerListener(new StatementInvalidatingListener());\n    }\n\n    @VisibleForTesting\n    public void evictPrepared(MD5Digest id)\n    {\n        preparedStatements.invalidate(id);\n        SystemKeyspace.removePreparedStatement(id);\n    }\n\n    public HashMap<MD5Digest, Prepared> getPreparedStatements()\n    {\n        return new HashMap<>(preparedStatements.asMap());\n    }\n\n    public Prepared getPrepared(MD5Digest id)\n    {\n        return preparedStatements.getIfPresent(id);\n    }\n\n    public static void validateKey(ByteBuffer key) throws InvalidRequestException\n    {\n        if (key == null || key.remaining() == 0)\n        {\n            throw new InvalidRequestException(\"Key may not be empty\");\n        }\n        if (key == ByteBufferUtil.UNSET_BYTE_BUFFER)\n            throw new InvalidRequestException(\"Key may not be unset\");\n\n        // check that key can be handled by FBUtilities.writeShortByteArray\n        if (key.remaining() > FBUtilities.MAX_UNSIGNED_SHORT)\n        {\n            throw new InvalidRequestException(\"Key length of \" + key.remaining() +\n                                              \" is longer than maximum of \" + FBUtilities.MAX_UNSIGNED_SHORT);\n        }\n    }\n\n    public ResultMessage processStatement(CQLStatement statement, QueryState queryState, QueryOptions options, long queryStartNanoTime)\n    throws RequestExecutionException, RequestValidationException\n    {\n        logger.trace(\"Process {} @CL.{}\", statement, options.getConsistency());\n        ClientState clientState = queryState.getClientState();\n        statement.authorize(clientState);\n        statement.validate(clientState);\n\n        ResultMessage result = options.getConsistency() == ConsistencyLevel.NODE_LOCAL\n                             ? processNodeLocalStatement(statement, queryState, options)\n                             : statement.execute(queryState, options, queryStartNanoTime);\n\n        return result == null ? new ResultMessage.Void() : result;\n    }\n\n    private ResultMessage processNodeLocalStatement(CQLStatement statement, QueryState queryState, QueryOptions options)\n    {\n        if (!ENABLE_NODELOCAL_QUERIES.getBoolean())\n            throw new InvalidRequestException(\"NODE_LOCAL consistency level is highly dangerous and should be used only for debugging purposes\");\n\n        if (statement instanceof BatchStatement || statement instanceof ModificationStatement)\n            return processNodeLocalWrite(statement, queryState, options);\n        else if (statement instanceof SelectStatement)\n            return processNodeLocalSelect((SelectStatement) statement, queryState, options);\n        else\n            throw new InvalidRequestException(\"NODE_LOCAL consistency level can only be used with BATCH, UPDATE, INSERT, DELETE, and SELECT statements\");\n    }\n\n    private ResultMessage processNodeLocalWrite(CQLStatement statement, QueryState queryState, QueryOptions options)\n    {\n        ClientRequestMetrics  levelMetrics = ClientRequestsMetricsHolder.writeMetricsForLevel(ConsistencyLevel.NODE_LOCAL);\n        ClientRequestMetrics globalMetrics = ClientRequestsMetricsHolder.writeMetrics;\n\n        long startTime = System.nanoTime();\n        try\n        {\n            return statement.executeLocally(queryState, options);\n        }\n        finally\n        {\n            long latency = System.nanoTime() - startTime;\n             levelMetrics.addNano(latency);\n            globalMetrics.addNano(latency);\n        }\n    }\n\n    private ResultMessage processNodeLocalSelect(SelectStatement statement, QueryState queryState, QueryOptions options)\n    {\n        ClientRequestMetrics  levelMetrics = ClientRequestsMetricsHolder.readMetricsForLevel(ConsistencyLevel.NODE_LOCAL);\n        ClientRequestMetrics globalMetrics = ClientRequestsMetricsHolder.readMetrics;\n\n        if (StorageService.instance.isBootstrapMode() && !SchemaConstants.isLocalSystemKeyspace(statement.keyspace()))\n        {\n            levelMetrics.unavailables.mark();\n            globalMetrics.unavailables.mark();\n            throw new IsBootstrappingException();\n        }\n\n        long startTime = System.nanoTime();\n        try\n        {\n            return statement.executeLocally(queryState, options);\n        }\n        finally\n        {\n            long latency = System.nanoTime() - startTime;\n             levelMetrics.addNano(latency);\n            globalMetrics.addNano(latency);\n        }\n    }\n\n    public static ResultMessage process(String queryString, ConsistencyLevel cl, QueryState queryState, long queryStartNanoTime)\n    throws RequestExecutionException, RequestValidationException\n    {\n        QueryOptions options = QueryOptions.forInternalCalls(cl, Collections.<ByteBuffer>emptyList());\n        CQLStatement statement = instance.parse(queryString, queryState, options);\n        return instance.process(statement, queryState, options, queryStartNanoTime);\n    }\n\n    public CQLStatement parse(String queryString, QueryState queryState, QueryOptions options)\n    {\n        return getStatement(queryString, queryState.getClientState().cloneWithKeyspaceIfSet(options.getKeyspace()));\n    }\n\n    public ResultMessage process(CQLStatement statement,\n                                 QueryState state,\n                                 QueryOptions options,\n                                 Map<String, ByteBuffer> customPayload,\n                                 long queryStartNanoTime) throws RequestExecutionException, RequestValidationException\n    {\n        return process(statement, state, options, queryStartNanoTime);\n    }\n\n    public ResultMessage process(CQLStatement prepared, QueryState queryState, QueryOptions options, long queryStartNanoTime)\n    throws RequestExecutionException, RequestValidationException\n    {\n        options.prepare(prepared.getBindVariables());\n        if (prepared.getBindVariables().size() != options.getValues().size())\n            throw new InvalidRequestException(\"Invalid amount of bind variables\");\n\n        if (!queryState.getClientState().isInternal)\n            metrics.regularStatementsExecuted.inc();\n\n        return processStatement(prepared, queryState, options, queryStartNanoTime);\n    }\n\n    public static CQLStatement parseStatement(String queryStr, ClientState clientState) throws RequestValidationException\n    {\n        return getStatement(queryStr, clientState);\n    }\n\n    public static UntypedResultSet process(String query, ConsistencyLevel cl) throws RequestExecutionException\n    {\n        return process(query, cl, Collections.<ByteBuffer>emptyList());\n    }\n\n    public static UntypedResultSet process(String query, ConsistencyLevel cl, List<ByteBuffer> values) throws RequestExecutionException\n    {\n        QueryState queryState = QueryState.forInternalCalls();\n        QueryOptions options = QueryOptions.forInternalCalls(cl, values);\n        CQLStatement statement = instance.parse(query, queryState, options);\n        ResultMessage result = instance.process(statement, queryState, options, System.nanoTime());\n        if (result instanceof ResultMessage.Rows)\n            return UntypedResultSet.create(((ResultMessage.Rows)result).result);\n        else\n            return null;\n    }\n\n    @VisibleForTesting\n    public static QueryOptions makeInternalOptions(CQLStatement prepared, Object[] values)\n    {\n        return makeInternalOptions(prepared, values, ConsistencyLevel.ONE);\n    }\n\n    private static QueryOptions makeInternalOptions(CQLStatement prepared, Object[] values, ConsistencyLevel cl)\n    {\n        if (prepared.getBindVariables().size() != values.length)\n            throw new IllegalArgumentException(String.format(\"Invalid number of values. Expecting %d but got %d\", prepared.getBindVariables().size(), values.length));\n\n        List<ByteBuffer> boundValues = new ArrayList<>(values.length);\n        for (int i = 0; i < values.length; i++)\n        {\n            Object value = values[i];\n            AbstractType type = prepared.getBindVariables().get(i).type;\n            boundValues.add(value instanceof ByteBuffer || value == null ? (ByteBuffer)value : type.decompose(value));\n        }\n        return QueryOptions.forInternalCalls(cl, boundValues);\n    }\n\n    public static Prepared prepareInternal(String query) throws RequestValidationException\n    {\n        Prepared prepared = internalStatements.get(query);\n        if (prepared != null)\n            return prepared;\n\n        prepared = parseAndPrepare(query, internalQueryState().getClientState(), true);\n        internalStatements.put(query, prepared);\n        return prepared;\n    }\n\n    public static Prepared parseAndPrepare(String query, ClientState clientState, boolean isInternal) throws RequestValidationException\n    {\n        CQLStatement.Raw raw = parseStatement(query);\n\n        boolean fullyQualified = false;\n        String keyspace = null;\n\n        // Set keyspace for statement that require login\n        if (raw instanceof QualifiedStatement)\n        {\n            QualifiedStatement qualifiedStatement = ((QualifiedStatement) raw);\n            fullyQualified = qualifiedStatement.isFullyQualified();\n            qualifiedStatement.setKeyspace(clientState);\n            keyspace = qualifiedStatement.keyspace();\n        }\n\n        // Note: if 2 threads prepare the same query, we'll live so don't bother synchronizing\n        CQLStatement statement = raw.prepare(clientState);\n        statement.validate(clientState);\n\n        if (isInternal)\n            return new Prepared(statement, \"\", fullyQualified, keyspace);\n        else\n            return new Prepared(statement, query, fullyQualified, keyspace);\n    }\n\n    public static UntypedResultSet executeInternal(String query, Object... values)\n    {\n        Prepared prepared = prepareInternal(query);\n        ResultMessage result = prepared.statement.executeLocally(internalQueryState(), makeInternalOptions(prepared.statement, values));\n        if (result instanceof ResultMessage.Rows)\n            return UntypedResultSet.create(((ResultMessage.Rows)result).result);\n        else\n            return null;\n    }\n\n    public static UntypedResultSet execute(String query, ConsistencyLevel cl, Object... values)\n    throws RequestExecutionException\n    {\n        return execute(query, cl, internalQueryState(), values);\n    }\n\n    public static UntypedResultSet execute(String query, ConsistencyLevel cl, QueryState state, Object... values)\n    throws RequestExecutionException\n    {\n        try\n        {\n            Prepared prepared = prepareInternal(query);\n            ResultMessage result = prepared.statement.execute(state, makeInternalOptions(prepared.statement, values, cl), System.nanoTime());\n            if (result instanceof ResultMessage.Rows)\n                return UntypedResultSet.create(((ResultMessage.Rows)result).result);\n            else\n                return null;\n        }\n        catch (RequestValidationException e)\n        {\n            throw new RuntimeException(\"Error validating \" + query, e);\n        }\n    }\n\n    public static UntypedResultSet executeInternalWithPaging(String query, int pageSize, Object... values)\n    {\n        Prepared prepared = prepareInternal(query);\n        if (!(prepared.statement instanceof SelectStatement))\n            throw new IllegalArgumentException(\"Only SELECTs can be paged\");\n\n        SelectStatement select = (SelectStatement)prepared.statement;\n        QueryPager pager = select.getQuery(makeInternalOptions(prepared.statement, values), FBUtilities.nowInSeconds()).getPager(null, ProtocolVersion.CURRENT);\n        return UntypedResultSet.create(select, pager, pageSize);\n    }\n\n    /**\n     * Same than executeLocally, but to use for queries we know are only executed once so that the\n     * created statement object is not cached.\n     */\n    public static UntypedResultSet executeOnceInternal(String query, Object... values)\n    {\n        return executeOnceInternal(internalQueryState(), query, values);\n    }\n\n    /**\n     * Execute an internal query with the provided {@code nowInSec} and {@code timestamp} for the {@code QueryState}.\n     * <p>This method ensure that the statement will not be cached in the prepared statement cache.</p>\n     */\n    @VisibleForTesting\n    public static UntypedResultSet executeOnceInternalWithNowAndTimestamp(int nowInSec, long timestamp, String query, Object... values)\n    {\n        QueryState queryState = new QueryState(InternalStateInstance.INSTANCE.clientState, timestamp, nowInSec);\n        return executeOnceInternal(queryState, query, values);\n    }\n\n    private static UntypedResultSet executeOnceInternal(QueryState queryState, String query, Object... values)\n    {\n        CQLStatement statement = parseStatement(query, queryState.getClientState());\n        statement.validate(queryState.getClientState());\n        ResultMessage result = statement.executeLocally(queryState, makeInternalOptions(statement, values));\n        if (result instanceof ResultMessage.Rows)\n            return UntypedResultSet.create(((ResultMessage.Rows)result).result);\n        else\n            return null;\n    }\n\n    /**\n     * A special version of executeLocally that takes the time used as \"now\" for the query in argument.\n     * Note that this only make sense for Selects so this only accept SELECT statements and is only useful in rare\n     * cases.\n     */\n    public static UntypedResultSet executeInternalWithNow(int nowInSec, long queryStartNanoTime, String query, Object... values)\n    {\n        Prepared prepared = prepareInternal(query);\n        assert prepared.statement instanceof SelectStatement;\n        SelectStatement select = (SelectStatement)prepared.statement;\n        ResultMessage result = select.executeInternal(internalQueryState(), makeInternalOptions(prepared.statement, values), nowInSec, queryStartNanoTime);\n        assert result instanceof ResultMessage.Rows;\n        return UntypedResultSet.create(((ResultMessage.Rows)result).result);\n    }\n\n    public static UntypedResultSet resultify(String query, RowIterator partition)\n    {\n        return resultify(query, PartitionIterators.singletonIterator(partition));\n    }\n\n    public static UntypedResultSet resultify(String query, PartitionIterator partitions)\n    {\n        try (PartitionIterator iter = partitions)\n        {\n            SelectStatement ss = (SelectStatement) getStatement(query, null);\n            ResultSet cqlRows = ss.process(iter, FBUtilities.nowInSeconds());\n            return UntypedResultSet.create(cqlRows);\n        }\n    }\n\n    public ResultMessage.Prepared prepare(String query,\n                                          ClientState clientState,\n                                          Map<String, ByteBuffer> customPayload) throws RequestValidationException\n    {\n        return prepare(query, clientState);\n    }\n\n    private volatile boolean newPreparedStatementBehaviour = false;\n    public boolean useNewPreparedStatementBehaviour()\n    {\n        if (newPreparedStatementBehaviour || DatabaseDescriptor.getForceNewPreparedStatementBehaviour())\n            return true;\n\n        synchronized (this)\n        {\n            CassandraVersion minVersion = Gossiper.instance.getMinVersion(DatabaseDescriptor.getWriteRpcTimeout(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS);\n            if (minVersion != null &&\n                ((minVersion.major == 3 && minVersion.minor == 0 && minVersion.compareTo(NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_30) >= 0) ||\n                 (minVersion.major == 3 && minVersion.minor > 0 && minVersion.compareTo(NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_3X) >= 0) ||\n                 (minVersion.compareTo(NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_40, true) >= 0)))\n            {\n                logger.info(\"Fully upgraded to at least {}\", minVersion);\n                newPreparedStatementBehaviour = true;\n            }\n\n            return newPreparedStatementBehaviour;\n        }\n    }\n\n    /**\n     * This method got slightly out of hand, but this is with best intentions: to allow users to be upgraded from any\n     * prior version, and help implementers avoid previous mistakes by clearly separating fully qualified and non-fully\n     * qualified statement behaviour.\n     *\n     * Basically we need to handle 4 different hashes here;\n     * 1. fully qualified query with keyspace\n     * 2. fully qualified query without keyspace\n     * 3. unqualified query with keyspace\n     * 4. unqualified query without keyspace\n     *\n     * The correct combination to return is 2/3 - the problem is during upgrades (assuming upgrading from < 3.0.26)\n     * - Existing clients have hash 1 or 3\n     * - Query prepared on a 3.0.25/3.11.12/4.0.2 instance needs to return hash 1/3 to be able to execute it on a 3.0.25 instance\n     * - This is handled by the useNewPreparedStatementBehaviour flag - while there still are 3.0.25 instances in\n     *   the cluster we always return hash 1/3\n     * - Once fully upgraded we start returning hash 2/3, this will cause a prepared statement id mismatch for existing\n     *   clients, but they will be able to continue using the old prepared statement id after that exception since we\n     *   store the query both with and without keyspace.\n     */\n    public ResultMessage.Prepared prepare(String queryString, ClientState clientState)\n    {\n        boolean useNewPreparedStatementBehaviour = useNewPreparedStatementBehaviour();\n        MD5Digest hashWithoutKeyspace = computeId(queryString, null);\n        MD5Digest hashWithKeyspace = computeId(queryString, clientState.getRawKeyspace());\n        Prepared cachedWithoutKeyspace = preparedStatements.getIfPresent(hashWithoutKeyspace);\n        Prepared cachedWithKeyspace = preparedStatements.getIfPresent(hashWithKeyspace);\n        // We assume it is only safe to return cached prepare if we have both instances\n        boolean safeToReturnCached = cachedWithoutKeyspace != null && cachedWithKeyspace != null;\n\n        if (safeToReturnCached)\n        {\n            if (useNewPreparedStatementBehaviour)\n            {\n                if (cachedWithoutKeyspace.fullyQualified) // For fully qualified statements, we always skip keyspace to avoid digest switching\n                    return createResultMessage(hashWithoutKeyspace, cachedWithoutKeyspace);\n\n                if (clientState.getRawKeyspace() != null && !cachedWithKeyspace.fullyQualified) // For non-fully qualified statements, we always include keyspace to avoid ambiguity\n                    return createResultMessage(hashWithKeyspace, cachedWithKeyspace);\n\n            }\n            else // legacy caches, pre-CASSANDRA-15252 behaviour\n            {\n                return createResultMessage(hashWithKeyspace, cachedWithKeyspace);\n            }\n        }\n        else\n        {\n            // Make sure the missing one is going to be eventually re-prepared\n            evictPrepared(hashWithKeyspace);\n            evictPrepared(hashWithoutKeyspace);\n        }\n\n        Prepared prepared = parseAndPrepare(queryString, clientState, false);\n        CQLStatement statement = prepared.statement;\n\n        int boundTerms = statement.getBindVariables().size();\n        if (boundTerms > FBUtilities.MAX_UNSIGNED_SHORT)\n            throw new InvalidRequestException(String.format(\"Too many markers(?). %d markers exceed the allowed maximum of %d\", boundTerms, FBUtilities.MAX_UNSIGNED_SHORT));\n\n        if (prepared.fullyQualified)\n        {\n            ResultMessage.Prepared qualifiedWithoutKeyspace = storePreparedStatement(queryString, null, prepared);\n            ResultMessage.Prepared qualifiedWithKeyspace = null;\n            if (clientState.getRawKeyspace() != null)\n                qualifiedWithKeyspace = storePreparedStatement(queryString, clientState.getRawKeyspace(), prepared);\n\n            if (!useNewPreparedStatementBehaviour && qualifiedWithKeyspace != null)\n                return qualifiedWithKeyspace;\n\n            return qualifiedWithoutKeyspace;\n        }\n        else\n        {\n            clientState.warnAboutUseWithPreparedStatements(hashWithKeyspace, clientState.getRawKeyspace());\n\n            ResultMessage.Prepared nonQualifiedWithKeyspace = storePreparedStatement(queryString, clientState.getRawKeyspace(), prepared);\n            ResultMessage.Prepared nonQualifiedWithNullKeyspace = storePreparedStatement(queryString, null, prepared);\n            if (!useNewPreparedStatementBehaviour)\n                return nonQualifiedWithNullKeyspace;\n\n            return nonQualifiedWithKeyspace;\n        }\n    }\n\n    private static MD5Digest computeId(String queryString, String keyspace)\n    {\n        String toHash = keyspace == null ? queryString : keyspace + queryString;\n        return MD5Digest.compute(toHash);\n    }\n\n    @VisibleForTesting\n    public static ResultMessage.Prepared getStoredPreparedStatement(String queryString, String clientKeyspace)\n    throws InvalidRequestException\n    {\n        MD5Digest statementId = computeId(queryString, clientKeyspace);\n        Prepared existing = preparedStatements.getIfPresent(statementId);\n        if (existing == null)\n            return null;\n\n        checkTrue(queryString.equals(existing.rawCQLStatement),\n                String.format(\"MD5 hash collision: query with the same MD5 hash was already prepared. \\n Existing: '%s'\", existing.rawCQLStatement));\n\n        return createResultMessage(statementId, existing);\n    }\n\n    @VisibleForTesting\n    private static ResultMessage.Prepared createResultMessage(MD5Digest statementId, Prepared existing)\n    throws InvalidRequestException\n    {\n        ResultSet.PreparedMetadata preparedMetadata = ResultSet.PreparedMetadata.fromPrepared(existing.statement);\n        ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.fromPrepared(existing.statement);\n        return new ResultMessage.Prepared(statementId, resultMetadata.getResultMetadataId(), preparedMetadata, resultMetadata);\n    }\n\n    @VisibleForTesting\n    public static ResultMessage.Prepared storePreparedStatement(String queryString, String keyspace, Prepared prepared)\n    throws InvalidRequestException\n    {\n        // Concatenate the current keyspace so we don't mix prepared statements between keyspace (#5352).\n        // (if the keyspace is null, queryString has to have a fully-qualified keyspace so it's fine.\n        long statementSize = ObjectSizes.measureDeep(prepared.statement);\n        // don't execute the statement if it's bigger than the allowed threshold\n        if (statementSize > capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))\n            throw new InvalidRequestException(String.format(\"Prepared statement of size %d bytes is larger than allowed maximum of %d MB: %s...\",\n                                                            statementSize,\n                                                            DatabaseDescriptor.getPreparedStatementsCacheSizeMB(),\n                                                            queryString.substring(0, 200)));\n        MD5Digest statementId = computeId(queryString, keyspace);\n        Prepared previous = preparedStatements.get(statementId, (ignored_) -> prepared);\n        if (previous == prepared)\n            SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);\n\n        SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);\n        ResultSet.PreparedMetadata preparedMetadata = ResultSet.PreparedMetadata.fromPrepared(prepared.statement);\n        ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.fromPrepared(prepared.statement);\n        return new ResultMessage.Prepared(statementId, resultMetadata.getResultMetadataId(), preparedMetadata, resultMetadata);\n    }\n\n    public ResultMessage processPrepared(CQLStatement statement,\n                                         QueryState state,\n                                         QueryOptions options,\n                                         Map<String, ByteBuffer> customPayload,\n                                         long queryStartNanoTime)\n                                                 throws RequestExecutionException, RequestValidationException\n    {\n        return processPrepared(statement, state, options, queryStartNanoTime);\n    }\n\n    public ResultMessage processPrepared(CQLStatement statement, QueryState queryState, QueryOptions options, long queryStartNanoTime)\n    throws RequestExecutionException, RequestValidationException\n    {\n        List<ByteBuffer> variables = options.getValues();\n        // Check to see if there are any bound variables to verify\n        if (!(variables.isEmpty() && statement.getBindVariables().isEmpty()))\n        {\n            if (variables.size() != statement.getBindVariables().size())\n                throw new InvalidRequestException(String.format(\"there were %d markers(?) in CQL but %d bound variables\",\n                                                                statement.getBindVariables().size(),\n                                                                variables.size()));\n\n            // at this point there is a match in count between markers and variables that is non-zero\n            if (logger.isTraceEnabled())\n                for (int i = 0; i < variables.size(); i++)\n                    logger.trace(\"[{}] '{}'\", i+1, variables.get(i));\n        }\n\n        metrics.preparedStatementsExecuted.inc();\n        return processStatement(statement, queryState, options, queryStartNanoTime);\n    }\n\n    public ResultMessage processBatch(BatchStatement statement,\n                                      QueryState state,\n                                      BatchQueryOptions options,\n                                      Map<String, ByteBuffer> customPayload,\n                                      long queryStartNanoTime)\n                                              throws RequestExecutionException, RequestValidationException\n    {\n        return processBatch(statement, state, options, queryStartNanoTime);\n    }\n\n    public ResultMessage processBatch(BatchStatement batch, QueryState queryState, BatchQueryOptions options, long queryStartNanoTime)\n    throws RequestExecutionException, RequestValidationException\n    {\n        ClientState clientState = queryState.getClientState().cloneWithKeyspaceIfSet(options.getKeyspace());\n        batch.authorize(clientState);\n        batch.validate();\n        batch.validate(clientState);\n        return batch.execute(queryState, options, queryStartNanoTime);\n    }\n\n    public static CQLStatement getStatement(String queryStr, ClientState clientState)\n    throws RequestValidationException\n    {\n        Tracing.trace(\"Parsing {}\", queryStr);\n        CQLStatement.Raw statement = parseStatement(queryStr);\n\n        // Set keyspace for statement that require login\n        if (statement instanceof QualifiedStatement)\n            ((QualifiedStatement) statement).setKeyspace(clientState);\n\n        Tracing.trace(\"Preparing statement\");\n        return statement.prepare(clientState);\n    }\n\n    public static <T extends CQLStatement.Raw> T parseStatement(String queryStr, Class<T> klass, String type) throws SyntaxException\n    {\n        try\n        {\n            CQLStatement.Raw stmt = parseStatement(queryStr);\n\n            if (!klass.isAssignableFrom(stmt.getClass()))\n                throw new IllegalArgumentException(\"Invalid query, must be a \" + type + \" statement but was: \" + stmt.getClass());\n\n            return klass.cast(stmt);\n        }\n        catch (RequestValidationException e)\n        {\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n    public static CQLStatement.Raw parseStatement(String queryStr) throws SyntaxException\n    {\n        try\n        {\n            return CQLFragmentParser.parseAnyUnhandled(CqlParser::query, queryStr);\n        }\n        catch (CassandraException ce)\n        {\n            throw ce;\n        }\n        catch (RuntimeException re)\n        {\n            logger.error(String.format(\"The statement: [%s] could not be parsed.\", queryStr), re);\n            throw new SyntaxException(String.format(\"Failed parsing statement: [%s] reason: %s %s\",\n                                                    queryStr,\n                                                    re.getClass().getSimpleName(),\n                                                    re.getMessage()));\n        }\n        catch (RecognitionException e)\n        {\n            throw new SyntaxException(\"Invalid or malformed CQL query string: \" + e.getMessage());\n        }\n    }\n\n    private static int measure(Object key, Prepared value)\n    {\n        return Ints.checkedCast(ObjectSizes.measureDeep(key) + ObjectSizes.measureDeep(value));\n    }\n\n    /**\n     * Clear our internal statmeent cache for test purposes.\n     */\n    @VisibleForTesting\n    public static void clearInternalStatementsCache()\n    {\n        internalStatements.clear();\n    }\n\n    @VisibleForTesting\n    public static void clearPreparedStatementsCache()\n    {\n        preparedStatements.asMap().clear();\n    }\n\n    private static class StatementInvalidatingListener extends SchemaChangeListener\n    {\n        private static void removeInvalidPreparedStatements(String ksName, String cfName)\n        {\n            removeInvalidPreparedStatements(internalStatements.values().iterator(), ksName, cfName);\n            removeInvalidPersistentPreparedStatements(preparedStatements.asMap().entrySet().iterator(), ksName, cfName);\n        }\n\n        private static void removeInvalidPreparedStatementsForFunction(String ksName, String functionName)\n        {\n            Predicate<Function> matchesFunction = f -> ksName.equals(f.name().keyspace) && functionName.equals(f.name().name);\n\n            for (Iterator<Map.Entry<MD5Digest, Prepared>> iter = preparedStatements.asMap().entrySet().iterator();\n                 iter.hasNext();)\n            {\n                Map.Entry<MD5Digest, Prepared> pstmt = iter.next();\n                if (Iterables.any(pstmt.getValue().statement.getFunctions(), matchesFunction))\n                {\n                    SystemKeyspace.removePreparedStatement(pstmt.getKey());\n                    iter.remove();\n                }\n            }\n\n\n            Iterators.removeIf(internalStatements.values().iterator(),\n                               statement -> Iterables.any(statement.statement.getFunctions(), matchesFunction));\n        }\n\n        private static void removeInvalidPersistentPreparedStatements(Iterator<Map.Entry<MD5Digest, Prepared>> iterator,\n                                                                      String ksName, String cfName)\n        {\n            while (iterator.hasNext())\n            {\n                Map.Entry<MD5Digest, Prepared> entry = iterator.next();\n                if (shouldInvalidate(ksName, cfName, entry.getValue().statement))\n                {\n                    SystemKeyspace.removePreparedStatement(entry.getKey());\n                    iterator.remove();\n                }\n            }\n        }\n\n        private static void removeInvalidPreparedStatements(Iterator<Prepared> iterator, String ksName, String cfName)\n        {\n            while (iterator.hasNext())\n            {\n                if (shouldInvalidate(ksName, cfName, iterator.next().statement))\n                    iterator.remove();\n            }\n        }\n\n        private static boolean shouldInvalidate(String ksName, String cfName, CQLStatement statement)\n        {\n            String statementKsName;\n            String statementCfName;\n\n            if (statement instanceof ModificationStatement)\n            {\n                ModificationStatement modificationStatement = ((ModificationStatement) statement);\n                statementKsName = modificationStatement.keyspace();\n                statementCfName = modificationStatement.columnFamily();\n            }\n            else if (statement instanceof SelectStatement)\n            {\n                SelectStatement selectStatement = ((SelectStatement) statement);\n                statementKsName = selectStatement.keyspace();\n                statementCfName = selectStatement.columnFamily();\n            }\n            else if (statement instanceof BatchStatement)\n            {\n                BatchStatement batchStatement = ((BatchStatement) statement);\n                for (ModificationStatement stmt : batchStatement.getStatements())\n                {\n                    if (shouldInvalidate(ksName, cfName, stmt))\n                        return true;\n                }\n                return false;\n            }\n            else\n            {\n                return false;\n            }\n\n            return ksName.equals(statementKsName) && (cfName == null || cfName.equals(statementCfName));\n        }\n\n        public void onCreateFunction(String ksName, String functionName, List<AbstractType<?>> argTypes)\n        {\n            onCreateFunctionInternal(ksName, functionName, argTypes);\n        }\n\n        public void onCreateAggregate(String ksName, String aggregateName, List<AbstractType<?>> argTypes)\n        {\n            onCreateFunctionInternal(ksName, aggregateName, argTypes);\n        }\n\n        private static void onCreateFunctionInternal(String ksName, String functionName, List<AbstractType<?>> argTypes)\n        {\n            // in case there are other overloads, we have to remove all overloads since argument type\n            // matching may change (due to type casting)\n            if (Schema.instance.getKeyspaceMetadata(ksName).functions.get(new FunctionName(ksName, functionName)).size() > 1)\n                removeInvalidPreparedStatementsForFunction(ksName, functionName);\n        }\n\n        public void onAlterTable(String ksName, String cfName, boolean affectsStatements)\n        {\n            logger.trace(\"Column definitions for {}.{} changed, invalidating related prepared statements\", ksName, cfName);\n            if (affectsStatements)\n                removeInvalidPreparedStatements(ksName, cfName);\n        }\n\n        public void onAlterFunction(String ksName, String functionName, List<AbstractType<?>> argTypes)\n        {\n            // Updating a function may imply we've changed the body of the function, so we need to invalid statements so that\n            // the new definition is picked (the function is resolved at preparation time).\n            // TODO: if the function has multiple overload, we could invalidate only the statement refering to the overload\n            // that was updated. This requires a few changes however and probably doesn't matter much in practice.\n            removeInvalidPreparedStatementsForFunction(ksName, functionName);\n        }\n\n        public void onAlterAggregate(String ksName, String aggregateName, List<AbstractType<?>> argTypes)\n        {\n            // Updating a function may imply we've changed the body of the function, so we need to invalid statements so that\n            // the new definition is picked (the function is resolved at preparation time).\n            // TODO: if the function has multiple overload, we could invalidate only the statement refering to the overload\n            // that was updated. This requires a few changes however and probably doesn't matter much in practice.\n            removeInvalidPreparedStatementsForFunction(ksName, aggregateName);\n        }\n\n        public void onDropKeyspace(String ksName)\n        {\n            logger.trace(\"Keyspace {} was dropped, invalidating related prepared statements\", ksName);\n            removeInvalidPreparedStatements(ksName, null);\n        }\n\n        public void onDropTable(String ksName, String cfName)\n        {\n            logger.trace(\"Table {}.{} was dropped, invalidating related prepared statements\", ksName, cfName);\n            removeInvalidPreparedStatements(ksName, cfName);\n        }\n\n        public void onDropFunction(String ksName, String functionName, List<AbstractType<?>> argTypes)\n        {\n            removeInvalidPreparedStatementsForFunction(ksName, functionName);\n        }\n\n        public void onDropAggregate(String ksName, String aggregateName, List<AbstractType<?>> argTypes)\n        {\n            removeInvalidPreparedStatementsForFunction(ksName, aggregateName);\n        }\n    }\n}\n\npublic class QueryProcessor implements QueryHandler\n{\n    public static final CassandraVersion CQL_VERSION = new CassandraVersion(\"3.4.5\");\n\n    // See comments on QueryProcessor #prepare\n    public static final CassandraVersion NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_30 = new CassandraVersion(\"3.0.26\");\n    public static final CassandraVersion NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_3X = new CassandraVersion(\"3.11.12\");\n    public static final CassandraVersion NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_40 = new CassandraVersion(\"4.0.2\");\n\n    public static final QueryProcessor instance = new QueryProcessor();\n\n    private static final Logger logger = LoggerFactory.getLogger(QueryProcessor.class);\n\n    private static final Cache<MD5Digest, Prepared> preparedStatements;\n\n    // A map for prepared statements used internally (which we don't want to mix with user statement, in particular we don't\n    // bother with expiration on those.\n    private static final ConcurrentMap<String, Prepared> internalStatements = new ConcurrentHashMap<>();\n\n    // Direct calls to processStatement do not increment the preparedStatementsExecuted/regularStatementsExecuted\n    // counters. Callers of processStatement are responsible for correctly notifying metrics\n    public static final CQLMetrics metrics = new CQLMetrics();\n\n    private static final AtomicInteger lastMinuteEvictionsCount = new AtomicInteger(0);\n\n    static\n    {\n        preparedStatements = Caffeine.newBuilder()\n                             .executor(MoreExecutors.directExecutor())\n                             .maximumWeight(capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))\n                             .weigher(QueryProcessor::measure)\n                             .removalListener((key, prepared, cause) -> {\n                                 MD5Digest md5Digest = (MD5Digest) key;\n                                 if (cause.wasEvicted())\n                                 {\n                                     metrics.preparedStatementsEvicted.inc();\n                                     lastMinuteEvictionsCount.incrementAndGet();\n                                     SystemKeyspace.removePreparedStatement(md5Digest);\n                                 }\n                             }).build();\n\n        ScheduledExecutors.scheduledTasks.scheduleAtFixedRate(() -> {\n            long count = lastMinuteEvictionsCount.getAndSet(0);\n            if (count > 0)\n                logger.warn(\"{} prepared statements discarded in the last minute because cache limit reached ({} MB)\",\n                            count,\n                            DatabaseDescriptor.getPreparedStatementsCacheSizeMB());\n        }, 1, 1, TimeUnit.MINUTES);\n\n        logger.info(\"Initialized prepared statement caches with {} MB\",\n                    DatabaseDescriptor.getPreparedStatementsCacheSizeMB());\n    }\n\n    private static long capacityToBytes(long cacheSizeMB)\n    {\n        return cacheSizeMB * 1024 * 1024;\n    }\n\n    public static int preparedStatementsCount()\n    {\n        return preparedStatements.asMap().size();\n    }\n\n    // Work around initialization dependency\n    private enum InternalStateInstance\n    {\n        INSTANCE;\n\n        private final ClientState clientState;\n\n        InternalStateInstance()\n        {\n            clientState = ClientState.forInternalCalls(SchemaConstants.SYSTEM_KEYSPACE_NAME);\n        }\n    }\n\n    public void preloadPreparedStatements()\n    {\n        int count = SystemKeyspace.loadPreparedStatements((id, query, keyspace) -> {\n            try\n            {\n                ClientState clientState = ClientState.forInternalCalls();\n                if (keyspace != null)\n                    clientState.setKeyspace(keyspace);\n\n                Prepared prepared = parseAndPrepare(query, clientState, false);\n                preparedStatements.put(id, prepared);\n\n                // Preload `null` statement for non-fully qualified statements, since it can't be parsed if loaded from cache and will be dropped\n                if (!prepared.fullyQualified)\n                    preparedStatements.get(computeId(query, null), (ignored_) -> prepared);\n                return true;\n            }\n            catch (RequestValidationException e)\n            {\n                JVMStabilityInspector.inspectThrowable(e);\n                logger.warn(String.format(\"Prepared statement recreation error, removing statement: %s %s %s\", id, query, keyspace));\n                SystemKeyspace.removePreparedStatement(id);\n                return false;\n            }\n        });\n        logger.info(\"Preloaded {} prepared statements\", count);\n    }\n\n\n    /**\n     * Clears the prepared statement cache.\n     * @param memoryOnly {@code true} if only the in memory caches must be cleared, {@code false} otherwise.\n     */\n    @VisibleForTesting\n    public static void clearPreparedStatements(boolean memoryOnly)\n    {\n        preparedStatements.invalidateAll();\n        if (!memoryOnly)\n            SystemKeyspace.resetPreparedStatements();\n    }\n\n    @VisibleForTesting\n    public static ConcurrentMap<String, Prepared> getInternalStatements()\n    {\n        return internalStatements;\n    }\n\n    @VisibleForTesting\n    public static QueryState internalQueryState()\n    {\n        return new QueryState(InternalStateInstance.INSTANCE.clientState);\n    }\n\n    private QueryProcessor()\n    {\n        Schema.instance.registerListener(new StatementInvalidatingListener());\n    }\n\n    @VisibleForTesting\n    public void evictPrepared(MD5Digest id)\n    {\n        preparedStatements.invalidate(id);\n        SystemKeyspace.removePreparedStatement(id);\n    }\n\n    public HashMap<MD5Digest, Prepared> getPreparedStatements()\n    {\n        return new HashMap<>(preparedStatements.asMap());\n    }\n\n    public Prepared getPrepared(MD5Digest id)\n    {\n        return preparedStatements.getIfPresent(id);\n    }\n\n    public static void validateKey(ByteBuffer key) throws InvalidRequestException\n    {\n        if (key == null || key.remaining() == 0)\n        {\n            throw new InvalidRequestException(\"Key may not be empty\");\n        }\n        if (key == ByteBufferUtil.UNSET_BYTE_BUFFER)\n            throw new InvalidRequestException(\"Key may not be unset\");\n\n        // check that key can be handled by FBUtilities.writeShortByteArray\n        if (key.remaining() > FBUtilities.MAX_UNSIGNED_SHORT)\n        {\n            throw new InvalidRequestException(\"Key length of \" + key.remaining() +\n                                              \" is longer than maximum of \" + FBUtilities.MAX_UNSIGNED_SHORT);\n        }\n    }\n\n    public ResultMessage processStatement(CQLStatement statement, QueryState queryState, QueryOptions options, long queryStartNanoTime)\n    throws RequestExecutionException, RequestValidationException\n    {\n        logger.trace(\"Process {} @CL.{}\", statement, options.getConsistency());\n        ClientState clientState = queryState.getClientState();\n        statement.authorize(clientState);\n        statement.validate(clientState);\n\n        ResultMessage result = options.getConsistency() == ConsistencyLevel.NODE_LOCAL\n                             ? processNodeLocalStatement(statement, queryState, options)\n                             : statement.execute(queryState, options, queryStartNanoTime);\n\n        return result == null ? new ResultMessage.Void() : result;\n    }\n\n    private ResultMessage processNodeLocalStatement(CQLStatement statement, QueryState queryState, QueryOptions options)\n    {\n        if (!ENABLE_NODELOCAL_QUERIES.getBoolean())\n            throw new InvalidRequestException(\"NODE_LOCAL consistency level is highly dangerous and should be used only for debugging purposes\");\n\n        if (statement instanceof BatchStatement || statement instanceof ModificationStatement)\n            return processNodeLocalWrite(statement, queryState, options);\n        else if (statement instanceof SelectStatement)\n            return processNodeLocalSelect((SelectStatement) statement, queryState, options);\n        else\n            throw new InvalidRequestException(\"NODE_LOCAL consistency level can only be used with BATCH, UPDATE, INSERT, DELETE, and SELECT statements\");\n    }\n\n    private ResultMessage processNodeLocalWrite(CQLStatement statement, QueryState queryState, QueryOptions options)\n    {\n        ClientRequestMetrics  levelMetrics = ClientRequestsMetricsHolder.writeMetricsForLevel(ConsistencyLevel.NODE_LOCAL);\n        ClientRequestMetrics globalMetrics = ClientRequestsMetricsHolder.writeMetrics;\n\n        long startTime = System.nanoTime();\n        try\n        {\n            return statement.executeLocally(queryState, options);\n        }\n        finally\n        {\n            long latency = System.nanoTime() - startTime;\n             levelMetrics.addNano(latency);\n            globalMetrics.addNano(latency);\n        }\n    }\n\n    private ResultMessage processNodeLocalSelect(SelectStatement statement, QueryState queryState, QueryOptions options)\n    {\n        ClientRequestMetrics  levelMetrics = ClientRequestsMetricsHolder.readMetricsForLevel(ConsistencyLevel.NODE_LOCAL);\n        ClientRequestMetrics globalMetrics = ClientRequestsMetricsHolder.readMetrics;\n\n        if (StorageService.instance.isBootstrapMode() && !SchemaConstants.isLocalSystemKeyspace(statement.keyspace()))\n        {\n            levelMetrics.unavailables.mark();\n            globalMetrics.unavailables.mark();\n            throw new IsBootstrappingException();\n        }\n\n        long startTime = System.nanoTime();\n        try\n        {\n            return statement.executeLocally(queryState, options);\n        }\n        finally\n        {\n            long latency = System.nanoTime() - startTime;\n             levelMetrics.addNano(latency);\n            globalMetrics.addNano(latency);\n        }\n    }\n\n    public static ResultMessage process(String queryString, ConsistencyLevel cl, QueryState queryState, long queryStartNanoTime)\n    throws RequestExecutionException, RequestValidationException\n    {\n        QueryOptions options = QueryOptions.forInternalCalls(cl, Collections.<ByteBuffer>emptyList());\n        CQLStatement statement = instance.parse(queryString, queryState, options);\n        return instance.process(statement, queryState, options, queryStartNanoTime);\n    }\n\n    public CQLStatement parse(String queryString, QueryState queryState, QueryOptions options)\n    {\n        return getStatement(queryString, queryState.getClientState().cloneWithKeyspaceIfSet(options.getKeyspace()));\n    }\n\n    public ResultMessage process(CQLStatement statement,\n                                 QueryState state,\n                                 QueryOptions options,\n                                 Map<String, ByteBuffer> customPayload,\n                                 long queryStartNanoTime) throws RequestExecutionException, RequestValidationException\n    {\n        return process(statement, state, options, queryStartNanoTime);\n    }\n\n    public ResultMessage process(CQLStatement prepared, QueryState queryState, QueryOptions options, long queryStartNanoTime)\n    throws RequestExecutionException, RequestValidationException\n    {\n        options.prepare(prepared.getBindVariables());\n        if (prepared.getBindVariables().size() != options.getValues().size())\n            throw new InvalidRequestException(\"Invalid amount of bind variables\");\n\n        if (!queryState.getClientState().isInternal)\n            metrics.regularStatementsExecuted.inc();\n\n        return processStatement(prepared, queryState, options, queryStartNanoTime);\n    }\n\n    public static CQLStatement parseStatement(String queryStr, ClientState clientState) throws RequestValidationException\n    {\n        return getStatement(queryStr, clientState);\n    }\n\n    public static UntypedResultSet process(String query, ConsistencyLevel cl) throws RequestExecutionException\n    {\n        return process(query, cl, Collections.<ByteBuffer>emptyList());\n    }\n\n    public static UntypedResultSet process(String query, ConsistencyLevel cl, List<ByteBuffer> values) throws RequestExecutionException\n    {\n        QueryState queryState = QueryState.forInternalCalls();\n        QueryOptions options = QueryOptions.forInternalCalls(cl, values);\n        CQLStatement statement = instance.parse(query, queryState, options);\n        ResultMessage result = instance.process(statement, queryState, options, System.nanoTime());\n        if (result instanceof ResultMessage.Rows)\n            return UntypedResultSet.create(((ResultMessage.Rows)result).result);\n        else\n            return null;\n    }\n\n    @VisibleForTesting\n    public static QueryOptions makeInternalOptions(CQLStatement prepared, Object[] values)\n    {\n        return makeInternalOptions(prepared, values, ConsistencyLevel.ONE);\n    }\n\n    private static QueryOptions makeInternalOptions(CQLStatement prepared, Object[] values, ConsistencyLevel cl)\n    {\n        if (prepared.getBindVariables().size() != values.length)\n            throw new IllegalArgumentException(String.format(\"Invalid number of values. Expecting %d but got %d\", prepared.getBindVariables().size(), values.length));\n\n        List<ByteBuffer> boundValues = new ArrayList<>(values.length);\n        for (int i = 0; i < values.length; i++)\n        {\n            Object value = values[i];\n            AbstractType type = prepared.getBindVariables().get(i).type;\n            boundValues.add(value instanceof ByteBuffer || value == null ? (ByteBuffer)value : type.decompose(value));\n        }\n        return QueryOptions.forInternalCalls(cl, boundValues);\n    }\n\n    public static Prepared prepareInternal(String query) throws RequestValidationException\n    {\n        Prepared prepared = internalStatements.get(query);\n        if (prepared != null)\n            return prepared;\n\n        prepared = parseAndPrepare(query, internalQueryState().getClientState(), true);\n        internalStatements.put(query, prepared);\n        return prepared;\n    }\n\n    public static Prepared parseAndPrepare(String query, ClientState clientState, boolean isInternal) throws RequestValidationException\n    {\n        CQLStatement.Raw raw = parseStatement(query);\n\n        boolean fullyQualified = false;\n        String keyspace = null;\n\n        // Set keyspace for statement that require login\n        if (raw instanceof QualifiedStatement)\n        {\n            QualifiedStatement qualifiedStatement = ((QualifiedStatement) raw);\n            fullyQualified = qualifiedStatement.isFullyQualified();\n            qualifiedStatement.setKeyspace(clientState);\n            keyspace = qualifiedStatement.keyspace();\n        }\n\n        // Note: if 2 threads prepare the same query, we'll live so don't bother synchronizing\n        CQLStatement statement = raw.prepare(clientState);\n        statement.validate(clientState);\n\n        if (isInternal)\n            return new Prepared(statement, \"\", fullyQualified, keyspace);\n        else\n            return new Prepared(statement, query, fullyQualified, keyspace);\n    }\n\n    public static UntypedResultSet executeInternal(String query, Object... values)\n    {\n        Prepared prepared = prepareInternal(query);\n        ResultMessage result = prepared.statement.executeLocally(internalQueryState(), makeInternalOptions(prepared.statement, values));\n        if (result instanceof ResultMessage.Rows)\n            return UntypedResultSet.create(((ResultMessage.Rows)result).result);\n        else\n            return null;\n    }\n\n    public static UntypedResultSet execute(String query, ConsistencyLevel cl, Object... values)\n    throws RequestExecutionException\n    {\n        return execute(query, cl, internalQueryState(), values);\n    }\n\n    public static UntypedResultSet execute(String query, ConsistencyLevel cl, QueryState state, Object... values)\n    throws RequestExecutionException\n    {\n        try\n        {\n            Prepared prepared = prepareInternal(query);\n            ResultMessage result = prepared.statement.execute(state, makeInternalOptions(prepared.statement, values, cl), System.nanoTime());\n            if (result instanceof ResultMessage.Rows)\n                return UntypedResultSet.create(((ResultMessage.Rows)result).result);\n            else\n                return null;\n        }\n        catch (RequestValidationException e)\n        {\n            throw new RuntimeException(\"Error validating \" + query, e);\n        }\n    }\n\n    public static UntypedResultSet executeInternalWithPaging(String query, int pageSize, Object... values)\n    {\n        Prepared prepared = prepareInternal(query);\n        if (!(prepared.statement instanceof SelectStatement))\n            throw new IllegalArgumentException(\"Only SELECTs can be paged\");\n\n        SelectStatement select = (SelectStatement)prepared.statement;\n        QueryPager pager = select.getQuery(makeInternalOptions(prepared.statement, values), FBUtilities.nowInSeconds()).getPager(null, ProtocolVersion.CURRENT);\n        return UntypedResultSet.create(select, pager, pageSize);\n    }\n\n    /**\n     * Same than executeLocally, but to use for queries we know are only executed once so that the\n     * created statement object is not cached.\n     */\n    public static UntypedResultSet executeOnceInternal(String query, Object... values)\n    {\n        return executeOnceInternal(internalQueryState(), query, values);\n    }\n\n    /**\n     * Execute an internal query with the provided {@code nowInSec} and {@code timestamp} for the {@code QueryState}.\n     * <p>This method ensure that the statement will not be cached in the prepared statement cache.</p>\n     */\n    @VisibleForTesting\n    public static UntypedResultSet executeOnceInternalWithNowAndTimestamp(int nowInSec, long timestamp, String query, Object... values)\n    {\n        QueryState queryState = new QueryState(InternalStateInstance.INSTANCE.clientState, timestamp, nowInSec);\n        return executeOnceInternal(queryState, query, values);\n    }\n\n    private static UntypedResultSet executeOnceInternal(QueryState queryState, String query, Object... values)\n    {\n        CQLStatement statement = parseStatement(query, queryState.getClientState());\n        statement.validate(queryState.getClientState());\n        ResultMessage result = statement.executeLocally(queryState, makeInternalOptions(statement, values));\n        if (result instanceof ResultMessage.Rows)\n            return UntypedResultSet.create(((ResultMessage.Rows)result).result);\n        else\n            return null;\n    }\n\n    /**\n     * A special version of executeLocally that takes the time used as \"now\" for the query in argument.\n     * Note that this only make sense for Selects so this only accept SELECT statements and is only useful in rare\n     * cases.\n     */\n    public static UntypedResultSet executeInternalWithNow(int nowInSec, long queryStartNanoTime, String query, Object... values)\n    {\n        Prepared prepared = prepareInternal(query);\n        assert prepared.statement instanceof SelectStatement;\n        SelectStatement select = (SelectStatement)prepared.statement;\n        ResultMessage result = select.executeInternal(internalQueryState(), makeInternalOptions(prepared.statement, values), nowInSec, queryStartNanoTime);\n        assert result instanceof ResultMessage.Rows;\n        return UntypedResultSet.create(((ResultMessage.Rows)result).result);\n    }\n\n    public static UntypedResultSet resultify(String query, RowIterator partition)\n    {\n        return resultify(query, PartitionIterators.singletonIterator(partition));\n    }\n\n    public static UntypedResultSet resultify(String query, PartitionIterator partitions)\n    {\n        try (PartitionIterator iter = partitions)\n        {\n            SelectStatement ss = (SelectStatement) getStatement(query, null);\n            ResultSet cqlRows = ss.process(iter, FBUtilities.nowInSeconds());\n            return UntypedResultSet.create(cqlRows);\n        }\n    }\n\n    public ResultMessage.Prepared prepare(String query,\n                                          ClientState clientState,\n                                          Map<String, ByteBuffer> customPayload) throws RequestValidationException\n    {\n        return prepare(query, clientState);\n    }\n\n    private volatile boolean newPreparedStatementBehaviour = false;\n    public boolean useNewPreparedStatementBehaviour()\n    {\n        if (newPreparedStatementBehaviour || DatabaseDescriptor.getForceNewPreparedStatementBehaviour())\n            return true;\n\n        synchronized (this)\n        {\n            CassandraVersion minVersion = Gossiper.instance.getMinVersion(DatabaseDescriptor.getWriteRpcTimeout(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS);\n            if (minVersion != null &&\n                ((minVersion.major == 3 && minVersion.minor == 0 && minVersion.compareTo(NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_30) >= 0) ||\n                 (minVersion.major == 3 && minVersion.minor > 0 && minVersion.compareTo(NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_3X) >= 0) ||\n                 (minVersion.compareTo(NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_40, true) >= 0)))\n            {\n                logger.info(\"Fully upgraded to at least {}\", minVersion);\n                newPreparedStatementBehaviour = true;\n            }\n\n            return newPreparedStatementBehaviour;\n        }\n    }\n\n    /**\n     * This method got slightly out of hand, but this is with best intentions: to allow users to be upgraded from any\n     * prior version, and help implementers avoid previous mistakes by clearly separating fully qualified and non-fully\n     * qualified statement behaviour.\n     *\n     * Basically we need to handle 4 different hashes here;\n     * 1. fully qualified query with keyspace\n     * 2. fully qualified query without keyspace\n     * 3. unqualified query with keyspace\n     * 4. unqualified query without keyspace\n     *\n     * The correct combination to return is 2/3 - the problem is during upgrades (assuming upgrading from < 3.0.26)\n     * - Existing clients have hash 1 or 3\n     * - Query prepared on a 3.0.25/3.11.12/4.0.2 instance needs to return hash 1/3 to be able to execute it on a 3.0.25 instance\n     * - This is handled by the useNewPreparedStatementBehaviour flag - while there still are 3.0.25 instances in\n     *   the cluster we always return hash 1/3\n     * - Once fully upgraded we start returning hash 2/3, this will cause a prepared statement id mismatch for existing\n     *   clients, but they will be able to continue using the old prepared statement id after that exception since we\n     *   store the query both with and without keyspace.\n     */\n    public ResultMessage.Prepared prepare(String queryString, ClientState clientState)\n    {\n        boolean useNewPreparedStatementBehaviour = useNewPreparedStatementBehaviour();\n        MD5Digest hashWithoutKeyspace = computeId(queryString, null);\n        MD5Digest hashWithKeyspace = computeId(queryString, clientState.getRawKeyspace());\n        Prepared cachedWithoutKeyspace = preparedStatements.getIfPresent(hashWithoutKeyspace);\n        Prepared cachedWithKeyspace = preparedStatements.getIfPresent(hashWithKeyspace);\n        // We assume it is only safe to return cached prepare if we have both instances\n        boolean safeToReturnCached = cachedWithoutKeyspace != null && cachedWithKeyspace != null;\n\n        if (safeToReturnCached)\n        {\n            if (useNewPreparedStatementBehaviour)\n            {\n                if (cachedWithoutKeyspace.fullyQualified) // For fully qualified statements, we always skip keyspace to avoid digest switching\n                    return createResultMessage(hashWithoutKeyspace, cachedWithoutKeyspace);\n\n                if (clientState.getRawKeyspace() != null && !cachedWithKeyspace.fullyQualified) // For non-fully qualified statements, we always include keyspace to avoid ambiguity\n                    return createResultMessage(hashWithKeyspace, cachedWithKeyspace);\n\n            }\n            else // legacy caches, pre-CASSANDRA-15252 behaviour\n            {\n                return createResultMessage(hashWithKeyspace, cachedWithKeyspace);\n            }\n        }\n        else\n        {\n            // Make sure the missing one is going to be eventually re-prepared\n            evictPrepared(hashWithKeyspace);\n            evictPrepared(hashWithoutKeyspace);\n        }\n\n        Prepared prepared = parseAndPrepare(queryString, clientState, false);\n        CQLStatement statement = prepared.statement;\n\n        int boundTerms = statement.getBindVariables().size();\n        if (boundTerms > FBUtilities.MAX_UNSIGNED_SHORT)\n            throw new InvalidRequestException(String.format(\"Too many markers(?). %d markers exceed the allowed maximum of %d\", boundTerms, FBUtilities.MAX_UNSIGNED_SHORT));\n\n        if (prepared.fullyQualified)\n        {\n            ResultMessage.Prepared qualifiedWithoutKeyspace = storePreparedStatement(queryString, null, prepared);\n            ResultMessage.Prepared qualifiedWithKeyspace = null;\n            if (clientState.getRawKeyspace() != null)\n                qualifiedWithKeyspace = storePreparedStatement(queryString, clientState.getRawKeyspace(), prepared);\n\n            if (!useNewPreparedStatementBehaviour && qualifiedWithKeyspace != null)\n                return qualifiedWithKeyspace;\n\n            return qualifiedWithoutKeyspace;\n        }\n        else\n        {\n            clientState.warnAboutUseWithPreparedStatements(hashWithKeyspace, clientState.getRawKeyspace());\n\n            ResultMessage.Prepared nonQualifiedWithKeyspace = storePreparedStatement(queryString, clientState.getRawKeyspace(), prepared);\n            ResultMessage.Prepared nonQualifiedWithNullKeyspace = storePreparedStatement(queryString, null, prepared);\n            if (!useNewPreparedStatementBehaviour)\n                return nonQualifiedWithNullKeyspace;\n\n            return nonQualifiedWithKeyspace;\n        }\n    }\n\n    private static MD5Digest computeId(String queryString, String keyspace)\n    {\n        String toHash = keyspace == null ? queryString : keyspace + queryString;\n        return MD5Digest.compute(toHash);\n    }\n\n    @VisibleForTesting\n    public static ResultMessage.Prepared getStoredPreparedStatement(String queryString, String clientKeyspace)\n    throws InvalidRequestException\n    {\n        MD5Digest statementId = computeId(queryString, clientKeyspace);\n        Prepared existing = preparedStatements.getIfPresent(statementId);\n        if (existing == null)\n            return null;\n\n        checkTrue(queryString.equals(existing.rawCQLStatement),\n                String.format(\"MD5 hash collision: query with the same MD5 hash was already prepared. \\n Existing: '%s'\", existing.rawCQLStatement));\n\n        return createResultMessage(statementId, existing);\n    }\n\n    @VisibleForTesting\n    private static ResultMessage.Prepared createResultMessage(MD5Digest statementId, Prepared existing)\n    throws InvalidRequestException\n    {\n        ResultSet.PreparedMetadata preparedMetadata = ResultSet.PreparedMetadata.fromPrepared(existing.statement);\n        ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.fromPrepared(existing.statement);\n        return new ResultMessage.Prepared(statementId, resultMetadata.getResultMetadataId(), preparedMetadata, resultMetadata);\n    }\n\n    @VisibleForTesting\n    public static ResultMessage.Prepared storePreparedStatement(String queryString, String keyspace, Prepared prepared)\n    throws InvalidRequestException\n    {\n        // Concatenate the current keyspace so we don't mix prepared statements between keyspace (#5352).\n        // (if the keyspace is null, queryString has to have a fully-qualified keyspace so it's fine.\n        long statementSize = ObjectSizes.measureDeep(prepared.statement);\n        // don't execute the statement if it's bigger than the allowed threshold\n        if (statementSize > capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))\n            throw new InvalidRequestException(String.format(\"Prepared statement of size %d bytes is larger than allowed maximum of %d MB: %s...\",\n                                                            statementSize,\n                                                            DatabaseDescriptor.getPreparedStatementsCacheSizeMB(),\n                                                            queryString.substring(0, 200)));\n        MD5Digest statementId = computeId(queryString, keyspace);\n        Prepared previous = preparedStatements.get(statementId, (ignored_) -> prepared);\n        if (previous == prepared)\n            SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);\n\n        SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);\n        ResultSet.PreparedMetadata preparedMetadata = ResultSet.PreparedMetadata.fromPrepared(prepared.statement);\n        ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.fromPrepared(prepared.statement);\n        return new ResultMessage.Prepared(statementId, resultMetadata.getResultMetadataId(), preparedMetadata, resultMetadata);\n    }\n\n    public ResultMessage processPrepared(CQLStatement statement,\n                                         QueryState state,\n                                         QueryOptions options,\n                                         Map<String, ByteBuffer> customPayload,\n                                         long queryStartNanoTime)\n                                                 throws RequestExecutionException, RequestValidationException\n    {\n        return processPrepared(statement, state, options, queryStartNanoTime);\n    }\n\n    public ResultMessage processPrepared(CQLStatement statement, QueryState queryState, QueryOptions options, long queryStartNanoTime)\n    throws RequestExecutionException, RequestValidationException\n    {\n        List<ByteBuffer> variables = options.getValues();\n        // Check to see if there are any bound variables to verify\n        if (!(variables.isEmpty() && statement.getBindVariables().isEmpty()))\n        {\n            if (variables.size() != statement.getBindVariables().size())\n                throw new InvalidRequestException(String.format(\"there were %d markers(?) in CQL but %d bound variables\",\n                                                                statement.getBindVariables().size(),\n                                                                variables.size()));\n\n            // at this point there is a match in count between markers and variables that is non-zero\n            if (logger.isTraceEnabled())\n                for (int i = 0; i < variables.size(); i++)\n                    logger.trace(\"[{}] '{}'\", i+1, variables.get(i));\n        }\n\n        metrics.preparedStatementsExecuted.inc();\n        return processStatement(statement, queryState, options, queryStartNanoTime);\n    }\n\n    public ResultMessage processBatch(BatchStatement statement,\n                                      QueryState state,\n                                      BatchQueryOptions options,\n                                      Map<String, ByteBuffer> customPayload,\n                                      long queryStartNanoTime)\n                                              throws RequestExecutionException, RequestValidationException\n    {\n        return processBatch(statement, state, options, queryStartNanoTime);\n    }\n\n    public ResultMessage processBatch(BatchStatement batch, QueryState queryState, BatchQueryOptions options, long queryStartNanoTime)\n    throws RequestExecutionException, RequestValidationException\n    {\n        ClientState clientState = queryState.getClientState().cloneWithKeyspaceIfSet(options.getKeyspace());\n        batch.authorize(clientState);\n        batch.validate();\n        batch.validate(clientState);\n        return batch.execute(queryState, options, queryStartNanoTime);\n    }\n\n    public static CQLStatement getStatement(String queryStr, ClientState clientState)\n    throws RequestValidationException\n    {\n        Tracing.trace(\"Parsing {}\", queryStr);\n        CQLStatement.Raw statement = parseStatement(queryStr);\n\n        // Set keyspace for statement that require login\n        if (statement instanceof QualifiedStatement)\n            ((QualifiedStatement) statement).setKeyspace(clientState);\n\n        Tracing.trace(\"Preparing statement\");\n        return statement.prepare(clientState);\n    }\n\n    public static <T extends CQLStatement.Raw> T parseStatement(String queryStr, Class<T> klass, String type) throws SyntaxException\n    {\n        try\n        {\n            CQLStatement.Raw stmt = parseStatement(queryStr);\n\n            if (!klass.isAssignableFrom(stmt.getClass()))\n                throw new IllegalArgumentException(\"Invalid query, must be a \" + type + \" statement but was: \" + stmt.getClass());\n\n            return klass.cast(stmt);\n        }\n        catch (RequestValidationException e)\n        {\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n    public static CQLStatement.Raw parseStatement(String queryStr) throws SyntaxException\n    {\n        try\n        {\n            return CQLFragmentParser.parseAnyUnhandled(CqlParser::query, queryStr);\n        }\n        catch (CassandraException ce)\n        {\n            throw ce;\n        }\n        catch (RuntimeException re)\n        {\n            logger.error(String.format(\"The statement: [%s] could not be parsed.\", queryStr), re);\n            throw new SyntaxException(String.format(\"Failed parsing statement: [%s] reason: %s %s\",\n                                                    queryStr,\n                                                    re.getClass().getSimpleName(),\n                                                    re.getMessage()));\n        }\n        catch (RecognitionException e)\n        {\n            throw new SyntaxException(\"Invalid or malformed CQL query string: \" + e.getMessage());\n        }\n    }\n\n    private static int measure(Object key, Prepared value)\n    {\n        return Ints.checkedCast(ObjectSizes.measureDeep(key) + ObjectSizes.measureDeep(value));\n    }\n\n    /**\n     * Clear our internal statmeent cache for test purposes.\n     */\n    @VisibleForTesting\n    public static void clearInternalStatementsCache()\n    {\n        internalStatements.clear();\n    }\n\n    @VisibleForTesting\n    public static void clearPreparedStatementsCache()\n    {\n        preparedStatements.asMap().clear();\n    }\n\n    private static class StatementInvalidatingListener extends SchemaChangeListener\n    {\n        private static void removeInvalidPreparedStatements(String ksName, String cfName)\n        {\n            removeInvalidPreparedStatements(internalStatements.values().iterator(), ksName, cfName);\n            removeInvalidPersistentPreparedStatements(preparedStatements.asMap().entrySet().iterator(), ksName, cfName);\n        }\n\n        private static void removeInvalidPreparedStatementsForFunction(String ksName, String functionName)\n        {\n            Predicate<Function> matchesFunction = f -> ksName.equals(f.name().keyspace) && functionName.equals(f.name().name);\n\n            for (Iterator<Map.Entry<MD5Digest, Prepared>> iter = preparedStatements.asMap().entrySet().iterator();\n                 iter.hasNext();)\n            {\n                Map.Entry<MD5Digest, Prepared> pstmt = iter.next();\n                if (Iterables.any(pstmt.getValue().statement.getFunctions(), matchesFunction))\n                {\n                    SystemKeyspace.removePreparedStatement(pstmt.getKey());\n                    iter.remove();\n                }\n            }\n\n\n            Iterators.removeIf(internalStatements.values().iterator(),\n                               statement -> Iterables.any(statement.statement.getFunctions(), matchesFunction));\n        }\n\n        private static void removeInvalidPersistentPreparedStatements(Iterator<Map.Entry<MD5Digest, Prepared>> iterator,\n                                                                      String ksName, String cfName)\n        {\n            while (iterator.hasNext())\n            {\n                Map.Entry<MD5Digest, Prepared> entry = iterator.next();\n                if (shouldInvalidate(ksName, cfName, entry.getValue().statement))\n                {\n                    SystemKeyspace.removePreparedStatement(entry.getKey());\n                    iterator.remove();\n                }\n            }\n        }\n\n        private static void removeInvalidPreparedStatements(Iterator<Prepared> iterator, String ksName, String cfName)\n        {\n            while (iterator.hasNext())\n            {\n                if (shouldInvalidate(ksName, cfName, iterator.next().statement))\n                    iterator.remove();\n            }\n        }\n\n        private static boolean shouldInvalidate(String ksName, String cfName, CQLStatement statement)\n        {\n            String statementKsName;\n            String statementCfName;\n\n            if (statement instanceof ModificationStatement)\n            {\n                ModificationStatement modificationStatement = ((ModificationStatement) statement);\n                statementKsName = modificationStatement.keyspace();\n                statementCfName = modificationStatement.columnFamily();\n            }\n            else if (statement instanceof SelectStatement)\n            {\n                SelectStatement selectStatement = ((SelectStatement) statement);\n                statementKsName = selectStatement.keyspace();\n                statementCfName = selectStatement.columnFamily();\n            }\n            else if (statement instanceof BatchStatement)\n            {\n                BatchStatement batchStatement = ((BatchStatement) statement);\n                for (ModificationStatement stmt : batchStatement.getStatements())\n                {\n                    if (shouldInvalidate(ksName, cfName, stmt))\n                        return true;\n                }\n                return false;\n            }\n            else\n            {\n                return false;\n            }\n\n            return ksName.equals(statementKsName) && (cfName == null || cfName.equals(statementCfName));\n        }\n\n        public void onCreateFunction(String ksName, String functionName, List<AbstractType<?>> argTypes)\n        {\n            onCreateFunctionInternal(ksName, functionName, argTypes);\n        }\n\n        public void onCreateAggregate(String ksName, String aggregateName, List<AbstractType<?>> argTypes)\n        {\n            onCreateFunctionInternal(ksName, aggregateName, argTypes);\n        }\n\n        private static void onCreateFunctionInternal(String ksName, String functionName, List<AbstractType<?>> argTypes)\n        {\n            // in case there are other overloads, we have to remove all overloads since argument type\n            // matching may change (due to type casting)\n            if (Schema.instance.getKeyspaceMetadata(ksName).functions.get(new FunctionName(ksName, functionName)).size() > 1)\n                removeInvalidPreparedStatementsForFunction(ksName, functionName);\n        }\n\n        public void onAlterTable(String ksName, String cfName, boolean affectsStatements)\n        {\n            logger.trace(\"Column definitions for {}.{} changed, invalidating related prepared statements\", ksName, cfName);\n            if (affectsStatements)\n                removeInvalidPreparedStatements(ksName, cfName);\n        }\n\n        public void onAlterFunction(String ksName, String functionName, List<AbstractType<?>> argTypes)\n        {\n            // Updating a function may imply we've changed the body of the function, so we need to invalid statements so that\n            // the new definition is picked (the function is resolved at preparation time).\n            // TODO: if the function has multiple overload, we could invalidate only the statement refering to the overload\n            // that was updated. This requires a few changes however and probably doesn't matter much in practice.\n            removeInvalidPreparedStatementsForFunction(ksName, functionName);\n        }\n\n        public void onAlterAggregate(String ksName, String aggregateName, List<AbstractType<?>> argTypes)\n        {\n            // Updating a function may imply we've changed the body of the function, so we need to invalid statements so that\n            // the new definition is picked (the function is resolved at preparation time).\n            // TODO: if the function has multiple overload, we could invalidate only the statement refering to the overload\n            // that was updated. This requires a few changes however and probably doesn't matter much in practice.\n            removeInvalidPreparedStatementsForFunction(ksName, aggregateName);\n        }\n\n        public void onDropKeyspace(String ksName)\n        {\n            logger.trace(\"Keyspace {} was dropped, invalidating related prepared statements\", ksName);\n            removeInvalidPreparedStatements(ksName, null);\n        }\n\n        public void onDropTable(String ksName, String cfName)\n        {\n            logger.trace(\"Table {}.{} was dropped, invalidating related prepared statements\", ksName, cfName);\n            removeInvalidPreparedStatements(ksName, cfName);\n        }\n\n        public void onDropFunction(String ksName, String functionName, List<AbstractType<?>> argTypes)\n        {\n            removeInvalidPreparedStatementsForFunction(ksName, functionName);\n        }\n\n        public void onDropAggregate(String ksName, String aggregateName, List<AbstractType<?>> argTypes)\n        {\n            removeInvalidPreparedStatementsForFunction(ksName, aggregateName);\n        }\n    }\n}\n"
        },
        {
            "sender": "Developer Filter",
            "content": "Filter of the code context that is related to configuration: ```java\n@VisibleForTesting\npublic static ResultMessage.Prepared storePreparedStatement(String queryString, String keyspace, Prepared prepared)\nthrows InvalidRequestException\n{\n    // Concatenate the current keyspace so we don't mix prepared statements between keyspace (#5352).\n    // (if the keyspace is null, queryString has to have a fully-qualified keyspace so it's fine.\n    long statementSize = ObjectSizes.measureDeep(prepared.statement);\n    // don't execute the statement if it's bigger than the allowed threshold\n    if (statementSize > capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))\n        throw new InvalidRequestException(String.format(\"Prepared statement of size %d bytes is larger than allowed maximum of %d MB: %s...\",\n                                                        statementSize,\n                                                        DatabaseDescriptor.getPreparedStatementsCacheSizeMB(),\n                                                        queryString.substring(0, 200)));\n    MD5Digest statementId = computeId(queryString, keyspace);\n    Prepared previous = preparedStatements.get(statementId, (ignored_) -> prepared);\n    if (previous == prepared)\n        SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);\n\n    SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);\n    ResultSet.PreparedMetadata preparedMetadata = ResultSet.PreparedMetadata.fromPrepared(prepared.statement);\n    ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.fromPrepared(prepared.statement);\n    return new ResultMessage.Prepared(statementId, resultMetadata.getResultMetadataId(), preparedMetadata, resultMetadata);\n}\n\nprivate static long capacityToBytes(long cacheSizeMB)\n{\n    return cacheSizeMB * 1024 * 1024;\n}\n\nstatic\n{\n    preparedStatements = Caffeine.newBuilder()\n                         .executor(MoreExecutors.directExecutor())\n                         .maximumWeight(capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))\n                         .weigher(QueryProcessor::measure)\n                         .removalListener((key, prepared, cause) -> {\n                             MD5Digest md5Digest = (MD5Digest) key;\n                             if (cause.wasEvicted())\n                             {\n                                 metrics.preparedStatementsEvicted.inc();\n                                 lastMinuteEvictionsCount.incrementAndGet();\n                                 SystemKeyspace.removePreparedStatement(md5Digest);\n                             }\n                         }).build();\n\n    logger.info(\"Initialized prepared statement caches with {} MB\",\n                DatabaseDescriptor.getPreparedStatementsCacheSizeMB());\n}\n```"
        },
        {
            "sender": "Developer summary",
            "content": "Summary of the extracted code context: The configuration parameter `prepared_statements_cache_size_mb` defines the maximum size of the cache allocated for storing prepared statements in the system. Its primary purpose is to manage the storage of prepared statements efficiently, ensuring that the system can handle multiple queries without re-parsing them, which can be resource-intensive.\n\n### Key Components and Functionality:\n1. **Storage Management**: The cache size is utilized to limit the memory footprint of prepared statements. The size is converted from megabytes to bytes using the `capacityToBytes` method, which multiplies the size in MB by 1,024,000. This conversion is crucial for setting the maximum weight of the cache in bytes.\n\n2. **Prepared Statement Handling**: The `storePreparedStatement` method is responsible for adding prepared statements to the cache. It first checks the size of the statement against the configured maximum size. If the statement exceeds this limit, an `InvalidRequestException` is thrown, preventing oversized statements from being stored.\n\n3. **Cache Implementation**: The cache is implemented using Caffeine, a high-performance caching library. The configuration initializes the cache with a specified maximum weight, and it includes a removal listener that tracks evictions. When a prepared statement is evicted due to cache size limits, it updates metrics and removes the statement from the system keyspace.\n\n4. **Keyspace Management**: The configuration also ensures that prepared statements are stored in a way that prevents mixing between different keyspaces. This is achieved by concatenating the keyspace with the query string to compute a unique identifier for each prepared statement.\n\n### Interactions with Other Parts of the System:\n- **DatabaseDescriptor**: This class provides the method to retrieve the configured maximum size for the prepared statements cache, ensuring that the cache operates within the defined limits.\n  \n- **SystemKeyspace**: This component is responsible for writing and managing the prepared statements in the database. Whenever a prepared statement is successfully stored, it is also written to the system keyspace for persistence.\n\n- **Metrics Tracking**: The configuration interacts with a metrics system that tracks the number of prepared statements evicted from the cache, allowing for monitoring of cache usage.\n\nIn summary, the `prepared_statements_cache_size_mb` configuration plays a critical role in managing the lifecycle and storage of prepared statements, ensuring efficient query processing while maintaining system integrity and resource management."
        },
        {
            "sender": "performance agent sensitivity",
            "content": "{\"Role\": \"You are a Performance Sensitivity Agent responsible for determining if a configuration is performance-sensitive within a software system.\", \"Requirement\": \"Using developer-provided information as a secondary reference, analyze the configuration-related code to determine if it is performance-sensitive. Focus exclusively on configurations with substantial system-level performance impact due to time-intensive or memory-intensive operations. Only configurations that directly cause significant performance variations through extremely time-consuming or memory-heavy operations should be classified as performance-sensitive. Minor or moderate impacts should not be considered.\", \"Output Format\": \"Respond strictly in one of the following formats: 'The configuration is Performance Sensitive: reason' or 'The configuration is Performance Insensitive: reason'. No other response format is acceptable. Provide a concise yet clear and detailed reason for your classification.\", \"configuration_name\": \"prepared_statements_cache_size_mb\", \"code_context\": \"```java\\n@VisibleForTesting\\npublic static ResultMessage.Prepared storePreparedStatement(String queryString, String keyspace, Prepared prepared)\\nthrows InvalidRequestException\\n{\\n    // Concatenate the current keyspace so we don't mix prepared statements between keyspace (#5352).\\n    // (if the keyspace is null, queryString has to have a fully-qualified keyspace so it's fine.\\n    long statementSize = ObjectSizes.measureDeep(prepared.statement);\\n    // don't execute the statement if it's bigger than the allowed threshold\\n    if (statementSize > capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))\\n        throw new InvalidRequestException(String.format(\\\"Prepared statement of size %d bytes is larger than allowed maximum of %d MB: %s...\\\",\\n                                                        statementSize,\\n                                                        DatabaseDescriptor.getPreparedStatementsCacheSizeMB(),\\n                                                        queryString.substring(0, 200)));\\n    MD5Digest statementId = computeId(queryString, keyspace);\\n    Prepared previous = preparedStatements.get(statementId, (ignored_) -> prepared);\\n    if (previous == prepared)\\n        SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);\\n\\n    SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);\\n    ResultSet.PreparedMetadata preparedMetadata = ResultSet.PreparedMetadata.fromPrepared(prepared.statement);\\n    ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.fromPrepared(prepared.statement);\\n    return new ResultMessage.Prepared(statementId, resultMetadata.getResultMetadataId(), preparedMetadata, resultMetadata);\\n}\\n\\nprivate static long capacityToBytes(long cacheSizeMB)\\n{\\n    return cacheSizeMB * 1024 * 1024;\\n}\\n\\nstatic\\n{\\n    preparedStatements = Caffeine.newBuilder()\\n                         .executor(MoreExecutors.directExecutor())\\n                         .maximumWeight(capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))\\n                         .weigher(QueryProcessor::measure)\\n                         .removalListener((key, prepared, cause) -> {\\n                             MD5Digest md5Digest = (MD5Digest) key;\\n                             if (cause.wasEvicted())\\n                             {\\n                                 metrics.preparedStatementsEvicted.inc();\\n                                 lastMinuteEvictionsCount.incrementAndGet();\\n                                 SystemKeyspace.removePreparedStatement(md5Digest);\\n                             }\\n                         }).build();\\n\\n    logger.info(\\\"Initialized prepared statement caches with {} MB\\\",\\n                DatabaseDescriptor.getPreparedStatementsCacheSizeMB());\\n}\\n```\\n\\n--- Summary by Developer ---\\nThe configuration parameter `prepared_statements_cache_size_mb` defines the maximum size of the cache allocated for storing prepared statements in the system. Its primary purpose is to manage the storage of prepared statements efficiently, ensuring that the system can handle multiple queries without re-parsing them, which can be resource-intensive.\\n\\n### Key Components and Functionality:\\n1. **Storage Management**: The cache size is utilized to limit the memory footprint of prepared statements. The size is converted from megabytes to bytes using the `capacityToBytes` method, which multiplies the size in MB by 1,024,000. This conversion is crucial for setting the maximum weight of the cache in bytes.\\n\\n2. **Prepared Statement Handling**: The `storePreparedStatement` method is responsible for adding prepared statements to the cache. It first checks the size of the statement against the configured maximum size. If the statement exceeds this limit, an `InvalidRequestException` is thrown, preventing oversized statements from being stored.\\n\\n3. **Cache Implementation**: The cache is implemented using Caffeine, a high-performance caching library. The configuration initializes the cache with a specified maximum weight, and it includes a removal listener that tracks evictions. When a prepared statement is evicted due to cache size limits, it updates metrics and removes the statement from the system keyspace.\\n\\n4. **Keyspace Management**: The configuration also ensures that prepared statements are stored in a way that prevents mixing between different keyspaces. This is achieved by concatenating the keyspace with the query string to compute a unique identifier for each prepared statement.\\n\\n### Interactions with Other Parts of the System:\\n- **DatabaseDescriptor**: This class provides the method to retrieve the configured maximum size for the prepared statements cache, ensuring that the cache operates within the defined limits.\\n  \\n- **SystemKeyspace**: This component is responsible for writing and managing the prepared statements in the database. Whenever a prepared statement is successfully stored, it is also written to the system keyspace for persistence.\\n\\n- **Metrics Tracking**: The configuration interacts with a metrics system that tracks the number of prepared statements evicted from the cache, allowing for monitoring of cache usage.\\n\\nIn summary, the `prepared_statements_cache_size_mb` configuration plays a critical role in managing the lifecycle and storage of prepared statements, ensuring efficient query processing while maintaining system integrity and resource management.\"}"
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `prepared_statements_cache_size_mb` directly impacts memory usage and performance by controlling the maximum size of the cache for prepared statements. If this cache is too small, it can lead to frequent evictions of prepared statements, causing the system to re-parse queries that could have been reused, which is a time-intensive operation. Additionally, the memory footprint of the cache is critical; if the cache exceeds the configured size, it can lead to memory pressure on the system, affecting overall performance. Thus, improper configuration can lead to significant performance degradation due to increased query processing time and memory management overhead."
        }
    ]
}