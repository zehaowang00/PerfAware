{
    "performance_sensitive": "Yes",
    "config_name": "streaming_connections_per_host",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "public ListenableFuture<StreamState> bootstrap(StreamStateStore stateStore, boolean useStrictConsistency)\n    {\n        logger.trace(\"Beginning bootstrap process\");\n\n        RangeStreamer streamer = new RangeStreamer(tokenMetadata,\n                                                   tokens,\n                                                   address,\n                                                   StreamOperation.BOOTSTRAP,\n                                                   useStrictConsistency,\n                                                   DatabaseDescriptor.getEndpointSnitch(),\n                                                   stateStore,\n                                                   true,\n                                                   DatabaseDescriptor.getStreamingConnectionsPerHost());\n        final List<String> nonLocalStrategyKeyspaces = Schema.instance.getNonLocalStrategyKeyspaces();\n        if (nonLocalStrategyKeyspaces.isEmpty())\n            logger.debug(\"Schema does not contain any non-local keyspaces to stream on bootstrap\");\n        for (String keyspaceName : nonLocalStrategyKeyspaces)\n        {\n            AbstractReplicationStrategy strategy = Keyspace.open(keyspaceName).getReplicationStrategy();\n            streamer.addRanges(keyspaceName, strategy.getPendingAddressRanges(tokenMetadata, tokens, address));\n        }\n\n        StreamResultFuture bootstrapStreamResult = streamer.fetchAsync();\n        bootstrapStreamResult.addEventListener(new StreamEventHandler()\n        {\n            private final AtomicInteger receivedFiles = new AtomicInteger();\n            private final AtomicInteger totalFilesToReceive = new AtomicInteger();\n\n            @Override\n            public void handleStreamEvent(StreamEvent event)\n            {\n                switch (event.eventType)\n                {\n                    case STREAM_PREPARED:\n                        StreamEvent.SessionPreparedEvent prepared = (StreamEvent.SessionPreparedEvent) event;\n                        int currentTotal = totalFilesToReceive.addAndGet((int) prepared.session.getTotalFilesToReceive());\n                        ProgressEvent prepareProgress = new ProgressEvent(ProgressEventType.PROGRESS, receivedFiles.get(), currentTotal, \"prepare with \" + prepared.session.peer + \" complete\");\n                        fireProgressEvent(\"bootstrap\", prepareProgress);\n                        break;\n\n                    case FILE_PROGRESS:\n                        StreamEvent.ProgressEvent progress = (StreamEvent.ProgressEvent) event;\n                        if (progress.progress.isCompleted())\n                        {\n                            int received = receivedFiles.incrementAndGet();\n                            ProgressEvent currentProgress = new ProgressEvent(ProgressEventType.PROGRESS, received, totalFilesToReceive.get(), \"received file \" + progress.progress.fileName);\n                            fireProgressEvent(\"bootstrap\", currentProgress);\n                        }\n                        break;\n\n                    case STREAM_COMPLETE:\n                        StreamEvent.SessionCompleteEvent completeEvent = (StreamEvent.SessionCompleteEvent) event;\n                        ProgressEvent completeProgress = new ProgressEvent(ProgressEventType.PROGRESS, receivedFiles.get(), totalFilesToReceive.get(), \"session with \" + completeEvent.peer + \" complete\");\n                        fireProgressEvent(\"bootstrap\", completeProgress);\n                        break;\n                }\n            }\n\n            @Override\n            public void onSuccess(StreamState streamState)\n            {\n                ProgressEventType type;\n                String message;\n\n                if (streamState.hasFailedSession())\n                {\n                    type = ProgressEventType.ERROR;\n                    message = \"Some bootstrap stream failed\";\n                }\n                else\n                {\n                    type = ProgressEventType.SUCCESS;\n                    message = \"Bootstrap streaming success\";\n                }\n                ProgressEvent currentProgress = new ProgressEvent(type, receivedFiles.get(), totalFilesToReceive.get(), message);\n                fireProgressEvent(\"bootstrap\", currentProgress);\n            }\n\n            @Override\n            public void onFailure(Throwable throwable)\n            {\n                ProgressEvent currentProgress = new ProgressEvent(ProgressEventType.ERROR, receivedFiles.get(), totalFilesToReceive.get(), throwable.getMessage());\n                fireProgressEvent(\"bootstrap\", currentProgress);\n            }\n        });\n        return bootstrapStreamResult;\n    }\n\n    \npublic void rebuild(String sourceDc)\n    {\n        rebuild(sourceDc, null, null, null);\n    }\n\n    \npublic void rebuild(String sourceDc, String keyspace, String tokens, String specificSources)\n    {\n        // check ongoing rebuild\n        if (!isRebuilding.compareAndSet(false, true))\n        {\n            throw new IllegalStateException(\"Node is still rebuilding. Check nodetool netstats.\");\n        }\n\n        // check the arguments\n        if (keyspace == null && tokens != null)\n        {\n            throw new IllegalArgumentException(\"Cannot specify tokens without keyspace.\");\n        }\n\n        logger.info(\"rebuild from dc: {}, {}, {}\", sourceDc == null ? \"(any dc)\" : sourceDc,\n                    keyspace == null ? \"(All keyspaces)\" : keyspace,\n                    tokens == null ? \"(All tokens)\" : tokens);\n\n        try\n        {\n            RangeStreamer streamer = new RangeStreamer(tokenMetadata,\n                                                       null,\n                                                       FBUtilities.getBroadcastAddressAndPort(),\n                                                       StreamOperation.REBUILD,\n                                                       useStrictConsistency && !replacing,\n                                                       DatabaseDescriptor.getEndpointSnitch(),\n                                                       streamStateStore,\n                                                       false,\n                                                       DatabaseDescriptor.getStreamingConnectionsPerHost());\n            if (sourceDc != null)\n                streamer.addSourceFilter(new RangeStreamer.SingleDatacenterFilter(DatabaseDescriptor.getEndpointSnitch(), sourceDc));\n\n            if (keyspace == null)\n            {\n                for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())\n                    streamer.addRanges(keyspaceName, getLocalReplicas(keyspaceName));\n            }\n            else if (tokens == null)\n            {\n                streamer.addRanges(keyspace, getLocalReplicas(keyspace));\n            }\n            else\n            {\n                Token.TokenFactory factory = getTokenFactory();\n                List<Range<Token>> ranges = new ArrayList<>();\n                Pattern rangePattern = Pattern.compile(\"\\\\(\\\\s*(-?\\\\w+)\\\\s*,\\\\s*(-?\\\\w+)\\\\s*\\\\]\");\n                try (Scanner tokenScanner = new Scanner(tokens))\n                {\n                    while (tokenScanner.findInLine(rangePattern) != null)\n                    {\n                        MatchResult range = tokenScanner.match();\n                        Token startToken = factory.fromString(range.group(1));\n                        Token endToken = factory.fromString(range.group(2));\n                        logger.info(\"adding range: ({},{}]\", startToken, endToken);\n                        ranges.add(new Range<>(startToken, endToken));\n                    }\n                    if (tokenScanner.hasNext())\n                        throw new IllegalArgumentException(\"Unexpected string: \" + tokenScanner.next());\n                }\n\n                // Ensure all specified ranges are actually ranges owned by this host\n                RangesAtEndpoint localReplicas = getLocalReplicas(keyspace);\n                RangesAtEndpoint.Builder streamRanges = new RangesAtEndpoint.Builder(FBUtilities.getBroadcastAddressAndPort(), ranges.size());\n                for (Range<Token> specifiedRange : ranges)\n                {\n                    boolean foundParentRange = false;\n                    for (Replica localReplica : localReplicas)\n                    {\n                        if (localReplica.contains(specifiedRange))\n                        {\n                            streamRanges.add(localReplica.decorateSubrange(specifiedRange));\n                            foundParentRange = true;\n                            break;\n                        }\n                    }\n                    if (!foundParentRange)\n                    {\n                        throw new IllegalArgumentException(String.format(\"The specified range %s is not a range that is owned by this node. Please ensure that all token ranges specified to be rebuilt belong to this node.\", specifiedRange.toString()));\n                    }\n                }\n\n                if (specificSources != null)\n                {\n                    String[] stringHosts = specificSources.split(\",\");\n                    Set<InetAddressAndPort> sources = new HashSet<>(stringHosts.length);\n                    for (String stringHost : stringHosts)\n                    {\n                        try\n                        {\n                            InetAddressAndPort endpoint = InetAddressAndPort.getByName(stringHost);\n                            if (FBUtilities.getBroadcastAddressAndPort().equals(endpoint))\n                            {\n                                throw new IllegalArgumentException(\"This host was specified as a source for rebuilding. Sources for a rebuild can only be other nodes in the cluster.\");\n                            }\n                            sources.add(endpoint);\n                        }\n                        catch (UnknownHostException ex)\n                        {\n                            throw new IllegalArgumentException(\"Unknown host specified \" + stringHost, ex);\n                        }\n                    }\n                    streamer.addSourceFilter(new RangeStreamer.AllowedSourcesFilter(sources));\n                }\n\n                streamer.addRanges(keyspace, streamRanges.build());\n            }\n\n            StreamResultFuture resultFuture = streamer.fetchAsync();\n            // wait for result\n            resultFuture.get();\n        }\n        catch (InterruptedException e)\n        {\n            throw new RuntimeException(\"Interrupted while waiting on rebuild streaming\");\n        }\n        catch (ExecutionException e)\n        {\n            // This is used exclusively through JMX, so log the full trace but only throw a simple RTE\n            logger.error(\"Error while rebuilding node\", e.getCause());\n            throw new RuntimeException(\"Error while rebuilding node: \" + e.getCause().getMessage());\n        }\n        finally\n        {\n            // rebuild is done (successfully or not)\n            isRebuilding.set(false);\n        }\n    }\n\n    "
        },
        {
            "sender": "Developer Filter",
            "content": "Filter of the code context that is related to configuration: ```java\npublic ListenableFuture<StreamState> bootstrap(StreamStateStore stateStore, boolean useStrictConsistency)\n{\n    logger.trace(\"Beginning bootstrap process\");\n\n    RangeStreamer streamer = new RangeStreamer(tokenMetadata,\n                                               tokens,\n                                               address,\n                                               StreamOperation.BOOTSTRAP,\n                                               useStrictConsistency,\n                                               DatabaseDescriptor.getEndpointSnitch(),\n                                               stateStore,\n                                               true,\n                                               DatabaseDescriptor.getStreamingConnectionsPerHost());\n    final List<String> nonLocalStrategyKeyspaces = Schema.instance.getNonLocalStrategyKeyspaces();\n    if (nonLocalStrategyKeyspaces.isEmpty())\n        logger.debug(\"Schema does not contain any non-local keyspaces to stream on bootstrap\");\n    for (String keyspaceName : nonLocalStrategyKeyspaces)\n    {\n        AbstractReplicationStrategy strategy = Keyspace.open(keyspaceName).getReplicationStrategy();\n        streamer.addRanges(keyspaceName, strategy.getPendingAddressRanges(tokenMetadata, tokens, address));\n    }\n\n    StreamResultFuture bootstrapStreamResult = streamer.fetchAsync();\n    bootstrapStreamResult.addEventListener(new StreamEventHandler()\n    {\n        private final AtomicInteger receivedFiles = new AtomicInteger();\n        private final AtomicInteger totalFilesToReceive = new AtomicInteger();\n\n        @Override\n        public void handleStreamEvent(StreamEvent event)\n        {\n            switch (event.eventType)\n            {\n                case STREAM_PREPARED:\n                    StreamEvent.SessionPreparedEvent prepared = (StreamEvent.SessionPreparedEvent) event;\n                    int currentTotal = totalFilesToReceive.addAndGet((int) prepared.session.getTotalFilesToReceive());\n                    ProgressEvent prepareProgress = new ProgressEvent(ProgressEventType.PROGRESS, receivedFiles.get(), currentTotal, \"prepare with \" + prepared.session.peer + \" complete\");\n                    fireProgressEvent(\"bootstrap\", prepareProgress);\n                    break;\n\n                case FILE_PROGRESS:\n                    StreamEvent.ProgressEvent progress = (StreamEvent.ProgressEvent) event;\n                    if (progress.progress.isCompleted())\n                    {\n                        int received = receivedFiles.incrementAndGet();\n                        ProgressEvent currentProgress = new ProgressEvent(ProgressEventType.PROGRESS, received, totalFilesToReceive.get(), \"received file \" + progress.progress.fileName);\n                        fireProgressEvent(\"bootstrap\", currentProgress);\n                    }\n                    break;\n\n                case STREAM_COMPLETE:\n                    StreamEvent.SessionCompleteEvent completeEvent = (StreamEvent.SessionCompleteEvent) event;\n                    ProgressEvent completeProgress = new ProgressEvent(ProgressEventType.PROGRESS, receivedFiles.get(), totalFilesToReceive.get(), \"session with \" + completeEvent.peer + \" complete\");\n                    fireProgressEvent(\"bootstrap\", completeProgress);\n                    break;\n            }\n        }\n\n        @Override\n        public void onSuccess(StreamState streamState)\n        {\n            ProgressEventType type;\n            String message;\n\n            if (streamState.hasFailedSession())\n            {\n                type = ProgressEventType.ERROR;\n                message = \"Some bootstrap stream failed\";\n            }\n            else\n            {\n                type = ProgressEventType.SUCCESS;\n                message = \"Bootstrap streaming success\";\n            }\n            ProgressEvent currentProgress = new ProgressEvent(type, receivedFiles.get(), totalFilesToReceive.get(), message);\n            fireProgressEvent(\"bootstrap\", currentProgress);\n        }\n\n        @Override\n        public void onFailure(Throwable throwable)\n        {\n            ProgressEvent currentProgress = new ProgressEvent(ProgressEventType.ERROR, receivedFiles.get(), totalFilesToReceive.get(), throwable.getMessage());\n            fireProgressEvent(\"bootstrap\", currentProgress);\n        }\n    });\n    return bootstrapStreamResult;\n}\n\npublic void rebuild(String sourceDc, String keyspace, String tokens, String specificSources)\n{\n    // check ongoing rebuild\n    if (!isRebuilding.compareAndSet(false, true))\n    {\n        throw new IllegalStateException(\"Node is still rebuilding. Check nodetool netstats.\");\n    }\n\n    // check the arguments\n    if (keyspace == null && tokens != null)\n    {\n        throw new IllegalArgumentException(\"Cannot specify tokens without keyspace.\");\n    }\n\n    logger.info(\"rebuild from dc: {}, {}, {}\", sourceDc == null ? \"(any dc)\" : sourceDc,\n                keyspace == null ? \"(All keyspaces)\" : keyspace,\n                tokens == null ? \"(All tokens)\" : tokens);\n\n    try\n    {\n        RangeStreamer streamer = new RangeStreamer(tokenMetadata,\n                                                   null,\n                                                   FBUtilities.getBroadcastAddressAndPort(),\n                                                   StreamOperation.REBUILD,\n                                                   useStrictConsistency && !replacing,\n                                                   DatabaseDescriptor.getEndpointSnitch(),\n                                                   streamStateStore,\n                                                   false,\n                                                   DatabaseDescriptor.getStreamingConnectionsPerHost());\n        if (sourceDc != null)\n            streamer.addSourceFilter(new RangeStreamer.SingleDatacenterFilter(DatabaseDescriptor.getEndpointSnitch(), sourceDc));\n\n        if (keyspace == null)\n        {\n            for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())\n                streamer.addRanges(keyspaceName, getLocalReplicas(keyspaceName));\n        }\n        else if (tokens == null)\n        {\n            streamer.addRanges(keyspace, getLocalReplicas(keyspace));\n        }\n        else\n        {\n            Token.TokenFactory factory = getTokenFactory();\n            List<Range<Token>> ranges = new ArrayList<>();\n            Pattern rangePattern = Pattern.compile(\"\\\\(\\\\s*(-?\\\\w+)\\\\s*,\\\\s*(-?\\\\w+)\\\\s*\\\\]\");\n            try (Scanner tokenScanner = new Scanner(tokens))\n            {\n                while (tokenScanner.findInLine(rangePattern) != null)\n                {\n                    MatchResult range = tokenScanner.match();\n                    Token startToken = factory.fromString(range.group(1));\n                    Token endToken = factory.fromString(range.group(2));\n                    logger.info(\"adding range: ({},{}]\", startToken, endToken);\n                    ranges.add(new Range<>(startToken, endToken));\n                }\n                if (tokenScanner.hasNext())\n                    throw new IllegalArgumentException(\"Unexpected string: \" + tokenScanner.next());\n            }\n\n            // Ensure all specified ranges are actually ranges owned by this host\n            RangesAtEndpoint localReplicas = getLocalReplicas(keyspace);\n            RangesAtEndpoint.Builder streamRanges = new RangesAtEndpoint.Builder(FBUtilities.getBroadcastAddressAndPort(), ranges.size());\n            for (Range<Token> specifiedRange : ranges)\n            {\n                boolean foundParentRange = false;\n                for (Replica localReplica : localReplicas)\n                {\n                    if (localReplica.contains(specifiedRange))\n                    {\n                        streamRanges.add(localReplica.decorateSubrange(specifiedRange));\n                        foundParentRange = true;\n                        break;\n                    }\n                }\n                if (!foundParentRange)\n                {\n                    throw new IllegalArgumentException(String.format(\"The specified range %s is not a range that is owned by this node. Please ensure that all token ranges specified to be rebuilt belong to this node.\", specifiedRange.toString()));\n                }\n            }\n\n            if (specificSources != null)\n            {\n                String[] stringHosts = specificSources.split(\",\");\n                Set<InetAddressAndPort> sources = new HashSet<>(stringHosts.length);\n                for (String stringHost : stringHosts)\n                {\n                    try\n                    {\n                        InetAddressAndPort endpoint = InetAddressAndPort.getByName(stringHost);\n                        if (FBUtilities.getBroadcastAddressAndPort().equals(endpoint))\n                        {\n                            throw new IllegalArgumentException(\"This host was specified as a source for rebuilding. Sources for a rebuild can only be other nodes in the cluster.\");\n                        }\n                        sources.add(endpoint);\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        throw new IllegalArgumentException(\"Unknown host specified \" + stringHost, ex);\n                    }\n                }\n                streamer.addSourceFilter(new RangeStreamer.AllowedSourcesFilter(sources));\n            }\n\n            streamer.addRanges(keyspace, streamRanges.build());\n        }\n\n        StreamResultFuture resultFuture = streamer.fetchAsync();\n        // wait for result\n        resultFuture.get();\n    }\n    catch (InterruptedException e)\n    {\n        throw new RuntimeException(\"Interrupted while waiting on rebuild streaming\");\n    }\n    catch (ExecutionException e)\n    {\n        // This is used exclusively through JMX, so log the full trace but only throw a simple RTE\n        logger.error(\"Error while rebuilding node\", e.getCause());\n        throw new RuntimeException(\"Error while rebuilding node: \" + e.getCause().getMessage());\n    }\n    finally\n    {\n        // rebuild is done (successfully or not)\n        isRebuilding.set(false);\n    }\n}\n```"
        },
        {
            "sender": "Developer summary",
            "content": "Summary of the extracted code context: ### Summary of Configuration: `streaming_connections_per_host`\n\nThe `streaming_connections_per_host` configuration parameter plays a crucial role in managing the streaming operations within the system, specifically during the bootstrap and rebuild processes of a distributed data store. This parameter dictates the number of concurrent streaming connections that can be established to other nodes in the cluster during these operations.\n\n#### Purpose and Functionality\n- **Bootstrap Process**: In the `bootstrap` method, the `streaming_connections_per_host` value is passed to the `RangeStreamer` constructor. This indicates how many simultaneous connections can be made to other nodes while streaming data to initialize the state of a new or recovering node. The bootstrap process involves gathering data from non-local keyspaces and requires efficient data transfer to ensure that the new node can quickly become operational.\n\n- **Rebuild Process**: Similarly, in the `rebuild` method, the same configuration is utilized when creating a `RangeStreamer` instance. This method is invoked when a node needs to rebuild its data from a specified data center or set of sources. The `streaming_connections_per_host` parameter ensures that the node can establish multiple connections to fetch the required data concurrently, thereby enhancing the efficiency of the rebuild operation.\n\n#### Key Components and Dependencies\n- **RangeStreamer**: This is the primary component that utilizes the `streaming_connections_per_host` configuration. It orchestrates the streaming of data between nodes, managing the connections and the data transfer process.\n\n- **DatabaseDescriptor**: This class is responsible for retrieving the configuration values, including `streaming_connections_per_host`. It acts as a central repository for various configuration settings that influence the behavior of the data store.\n\n- **StreamStateStore**: This component is involved in maintaining the state of the streaming operation, ensuring that the progress can be tracked and managed effectively during both bootstrap and rebuild processes.\n\n#### Interaction with Other Parts of the System\n- The `streaming_connections_per_host` configuration interacts with the overall data streaming mechanism, influencing how data is transferred between nodes. It is essential for ensuring that the system can handle multiple connections efficiently, which is vital for maintaining data consistency and availability during operations that involve significant data movement.\n\n- Additionally, the configuration affects how the system responds to network conditions and the load on individual nodes, as it determines the maximum number of simultaneous connections that can be utilized for streaming operations.\n\nIn summary, the `streaming_connections_per_host` configuration is a fundamental parameter that governs the concurrency of data streaming operations in the system, facilitating efficient data transfer during critical processes such as bootstrapping and rebuilding nodes in a distributed environment."
        },
        {
            "sender": "performance agent sensitivity",
            "content": "{\"Role\": \"You are a Performance Sensitivity Agent responsible for determining if a configuration is performance-sensitive within a software system.\", \"Requirement\": \"Using developer-provided information as a secondary reference, analyze the configuration-related code to determine if it is performance-sensitive. Focus exclusively on configurations with substantial system-level performance impact due to time-intensive or memory-intensive operations. Only configurations that directly cause significant performance variations through extremely time-consuming or memory-heavy operations should be classified as performance-sensitive. Minor or moderate impacts should not be considered.\", \"Output Format\": \"Respond strictly in one of the following formats: 'The configuration is Performance Sensitive: reason' or 'The configuration is Performance Insensitive: reason'. No other response format is acceptable. Provide a concise yet clear and detailed reason for your classification.\", \"configuration_name\": \"streaming_connections_per_host\", \"code_context\": \"```java\\npublic ListenableFuture<StreamState> bootstrap(StreamStateStore stateStore, boolean useStrictConsistency)\\n{\\n    logger.trace(\\\"Beginning bootstrap process\\\");\\n\\n    RangeStreamer streamer = new RangeStreamer(tokenMetadata,\\n                                               tokens,\\n                                               address,\\n                                               StreamOperation.BOOTSTRAP,\\n                                               useStrictConsistency,\\n                                               DatabaseDescriptor.getEndpointSnitch(),\\n                                               stateStore,\\n                                               true,\\n                                               DatabaseDescriptor.getStreamingConnectionsPerHost());\\n    final List<String> nonLocalStrategyKeyspaces = Schema.instance.getNonLocalStrategyKeyspaces();\\n    if (nonLocalStrategyKeyspaces.isEmpty())\\n        logger.debug(\\\"Schema does not contain any non-local keyspaces to stream on bootstrap\\\");\\n    for (String keyspaceName : nonLocalStrategyKeyspaces)\\n    {\\n        AbstractReplicationStrategy strategy = Keyspace.open(keyspaceName).getReplicationStrategy();\\n        streamer.addRanges(keyspaceName, strategy.getPendingAddressRanges(tokenMetadata, tokens, address));\\n    }\\n\\n    StreamResultFuture bootstrapStreamResult = streamer.fetchAsync();\\n    bootstrapStreamResult.addEventListener(new StreamEventHandler()\\n    {\\n        private final AtomicInteger receivedFiles = new AtomicInteger();\\n        private final AtomicInteger totalFilesToReceive = new AtomicInteger();\\n\\n        @Override\\n        public void handleStreamEvent(StreamEvent event)\\n        {\\n            switch (event.eventType)\\n            {\\n                case STREAM_PREPARED:\\n                    StreamEvent.SessionPreparedEvent prepared = (StreamEvent.SessionPreparedEvent) event;\\n                    int currentTotal = totalFilesToReceive.addAndGet((int) prepared.session.getTotalFilesToReceive());\\n                    ProgressEvent prepareProgress = new ProgressEvent(ProgressEventType.PROGRESS, receivedFiles.get(), currentTotal, \\\"prepare with \\\" + prepared.session.peer + \\\" complete\\\");\\n                    fireProgressEvent(\\\"bootstrap\\\", prepareProgress);\\n                    break;\\n\\n                case FILE_PROGRESS:\\n                    StreamEvent.ProgressEvent progress = (StreamEvent.ProgressEvent) event;\\n                    if (progress.progress.isCompleted())\\n                    {\\n                        int received = receivedFiles.incrementAndGet();\\n                        ProgressEvent currentProgress = new ProgressEvent(ProgressEventType.PROGRESS, received, totalFilesToReceive.get(), \\\"received file \\\" + progress.progress.fileName);\\n                        fireProgressEvent(\\\"bootstrap\\\", currentProgress);\\n                    }\\n                    break;\\n\\n                case STREAM_COMPLETE:\\n                    StreamEvent.SessionCompleteEvent completeEvent = (StreamEvent.SessionCompleteEvent) event;\\n                    ProgressEvent completeProgress = new ProgressEvent(ProgressEventType.PROGRESS, receivedFiles.get(), totalFilesToReceive.get(), \\\"session with \\\" + completeEvent.peer + \\\" complete\\\");\\n                    fireProgressEvent(\\\"bootstrap\\\", completeProgress);\\n                    break;\\n            }\\n        }\\n\\n        @Override\\n        public void onSuccess(StreamState streamState)\\n        {\\n            ProgressEventType type;\\n            String message;\\n\\n            if (streamState.hasFailedSession())\\n            {\\n                type = ProgressEventType.ERROR;\\n                message = \\\"Some bootstrap stream failed\\\";\\n            }\\n            else\\n            {\\n                type = ProgressEventType.SUCCESS;\\n                message = \\\"Bootstrap streaming success\\\";\\n            }\\n            ProgressEvent currentProgress = new ProgressEvent(type, receivedFiles.get(), totalFilesToReceive.get(), message);\\n            fireProgressEvent(\\\"bootstrap\\\", currentProgress);\\n        }\\n\\n        @Override\\n        public void onFailure(Throwable throwable)\\n        {\\n            ProgressEvent currentProgress = new ProgressEvent(ProgressEventType.ERROR, receivedFiles.get(), totalFilesToReceive.get(), throwable.getMessage());\\n            fireProgressEvent(\\\"bootstrap\\\", currentProgress);\\n        }\\n    });\\n    return bootstrapStreamResult;\\n}\\n\\npublic void rebuild(String sourceDc, String keyspace, String tokens, String specificSources)\\n{\\n    // check ongoing rebuild\\n    if (!isRebuilding.compareAndSet(false, true))\\n    {\\n        throw new IllegalStateException(\\\"Node is still rebuilding. Check nodetool netstats.\\\");\\n    }\\n\\n    // check the arguments\\n    if (keyspace == null && tokens != null)\\n    {\\n        throw new IllegalArgumentException(\\\"Cannot specify tokens without keyspace.\\\");\\n    }\\n\\n    logger.info(\\\"rebuild from dc: {}, {}, {}\\\", sourceDc == null ? \\\"(any dc)\\\" : sourceDc,\\n                keyspace == null ? \\\"(All keyspaces)\\\" : keyspace,\\n                tokens == null ? \\\"(All tokens)\\\" : tokens);\\n\\n    try\\n    {\\n        RangeStreamer streamer = new RangeStreamer(tokenMetadata,\\n                                                   null,\\n                                                   FBUtilities.getBroadcastAddressAndPort(),\\n                                                   StreamOperation.REBUILD,\\n                                                   useStrictConsistency && !replacing,\\n                                                   DatabaseDescriptor.getEndpointSnitch(),\\n                                                   streamStateStore,\\n                                                   false,\\n                                                   DatabaseDescriptor.getStreamingConnectionsPerHost());\\n        if (sourceDc != null)\\n            streamer.addSourceFilter(new RangeStreamer.SingleDatacenterFilter(DatabaseDescriptor.getEndpointSnitch(), sourceDc));\\n\\n        if (keyspace == null)\\n        {\\n            for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())\\n                streamer.addRanges(keyspaceName, getLocalReplicas(keyspaceName));\\n        }\\n        else if (tokens == null)\\n        {\\n            streamer.addRanges(keyspace, getLocalReplicas(keyspace));\\n        }\\n        else\\n        {\\n            Token.TokenFactory factory = getTokenFactory();\\n            List<Range<Token>> ranges = new ArrayList<>();\\n            Pattern rangePattern = Pattern.compile(\\\"\\\\\\\\(\\\\\\\\s*(-?\\\\\\\\w+)\\\\\\\\s*,\\\\\\\\s*(-?\\\\\\\\w+)\\\\\\\\s*\\\\\\\\]\\\");\\n            try (Scanner tokenScanner = new Scanner(tokens))\\n            {\\n                while (tokenScanner.findInLine(rangePattern) != null)\\n                {\\n                    MatchResult range = tokenScanner.match();\\n                    Token startToken = factory.fromString(range.group(1));\\n                    Token endToken = factory.fromString(range.group(2));\\n                    logger.info(\\\"adding range: ({},{}]\\\", startToken, endToken);\\n                    ranges.add(new Range<>(startToken, endToken));\\n                }\\n                if (tokenScanner.hasNext())\\n                    throw new IllegalArgumentException(\\\"Unexpected string: \\\" + tokenScanner.next());\\n            }\\n\\n            // Ensure all specified ranges are actually ranges owned by this host\\n            RangesAtEndpoint localReplicas = getLocalReplicas(keyspace);\\n            RangesAtEndpoint.Builder streamRanges = new RangesAtEndpoint.Builder(FBUtilities.getBroadcastAddressAndPort(), ranges.size());\\n            for (Range<Token> specifiedRange : ranges)\\n            {\\n                boolean foundParentRange = false;\\n                for (Replica localReplica : localReplicas)\\n                {\\n                    if (localReplica.contains(specifiedRange))\\n                    {\\n                        streamRanges.add(localReplica.decorateSubrange(specifiedRange));\\n                        foundParentRange = true;\\n                        break;\\n                    }\\n                }\\n                if (!foundParentRange)\\n                {\\n                    throw new IllegalArgumentException(String.format(\\\"The specified range %s is not a range that is owned by this node. Please ensure that all token ranges specified to be rebuilt belong to this node.\\\", specifiedRange.toString()));\\n                }\\n            }\\n\\n            if (specificSources != null)\\n            {\\n                String[] stringHosts = specificSources.split(\\\",\\\");\\n                Set<InetAddressAndPort> sources = new HashSet<>(stringHosts.length);\\n                for (String stringHost : stringHosts)\\n                {\\n                    try\\n                    {\\n                        InetAddressAndPort endpoint = InetAddressAndPort.getByName(stringHost);\\n                        if (FBUtilities.getBroadcastAddressAndPort().equals(endpoint))\\n                        {\\n                            throw new IllegalArgumentException(\\\"This host was specified as a source for rebuilding. Sources for a rebuild can only be other nodes in the cluster.\\\");\\n                        }\\n                        sources.add(endpoint);\\n                    }\\n                    catch (UnknownHostException ex)\\n                    {\\n                        throw new IllegalArgumentException(\\\"Unknown host specified \\\" + stringHost, ex);\\n                    }\\n                }\\n                streamer.addSourceFilter(new RangeStreamer.AllowedSourcesFilter(sources));\\n            }\\n\\n            streamer.addRanges(keyspace, streamRanges.build());\\n        }\\n\\n        StreamResultFuture resultFuture = streamer.fetchAsync();\\n        // wait for result\\n        resultFuture.get();\\n    }\\n    catch (InterruptedException e)\\n    {\\n        throw new RuntimeException(\\\"Interrupted while waiting on rebuild streaming\\\");\\n    }\\n    catch (ExecutionException e)\\n    {\\n        // This is used exclusively through JMX, so log the full trace but only throw a simple RTE\\n        logger.error(\\\"Error while rebuilding node\\\", e.getCause());\\n        throw new RuntimeException(\\\"Error while rebuilding node: \\\" + e.getCause().getMessage());\\n    }\\n    finally\\n    {\\n        // rebuild is done (successfully or not)\\n        isRebuilding.set(false);\\n    }\\n}\\n```\\n\\n--- Summary by Developer ---\\n### Summary of Configuration: `streaming_connections_per_host`\\n\\nThe `streaming_connections_per_host` configuration parameter plays a crucial role in managing the streaming operations within the system, specifically during the bootstrap and rebuild processes of a distributed data store. This parameter dictates the number of concurrent streaming connections that can be established to other nodes in the cluster during these operations.\\n\\n#### Purpose and Functionality\\n- **Bootstrap Process**: In the `bootstrap` method, the `streaming_connections_per_host` value is passed to the `RangeStreamer` constructor. This indicates how many simultaneous connections can be made to other nodes while streaming data to initialize the state of a new or recovering node. The bootstrap process involves gathering data from non-local keyspaces and requires efficient data transfer to ensure that the new node can quickly become operational.\\n\\n- **Rebuild Process**: Similarly, in the `rebuild` method, the same configuration is utilized when creating a `RangeStreamer` instance. This method is invoked when a node needs to rebuild its data from a specified data center or set of sources. The `streaming_connections_per_host` parameter ensures that the node can establish multiple connections to fetch the required data concurrently, thereby enhancing the efficiency of the rebuild operation.\\n\\n#### Key Components and Dependencies\\n- **RangeStreamer**: This is the primary component that utilizes the `streaming_connections_per_host` configuration. It orchestrates the streaming of data between nodes, managing the connections and the data transfer process.\\n\\n- **DatabaseDescriptor**: This class is responsible for retrieving the configuration values, including `streaming_connections_per_host`. It acts as a central repository for various configuration settings that influence the behavior of the data store.\\n\\n- **StreamStateStore**: This component is involved in maintaining the state of the streaming operation, ensuring that the progress can be tracked and managed effectively during both bootstrap and rebuild processes.\\n\\n#### Interaction with Other Parts of the System\\n- The `streaming_connections_per_host` configuration interacts with the overall data streaming mechanism, influencing how data is transferred between nodes. It is essential for ensuring that the system can handle multiple connections efficiently, which is vital for maintaining data consistency and availability during operations that involve significant data movement.\\n\\n- Additionally, the configuration affects how the system responds to network conditions and the load on individual nodes, as it determines the maximum number of simultaneous connections that can be utilized for streaming operations.\\n\\nIn summary, the `streaming_connections_per_host` configuration is a fundamental parameter that governs the concurrency of data streaming operations in the system, facilitating efficient data transfer during critical processes such as bootstrapping and rebuilding nodes in a distributed environment.\"}"
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `streaming_connections_per_host` parameter directly influences the number of concurrent streaming connections during critical operations like bootstrap and rebuild. This can significantly affect the performance of data transfer between nodes, especially in large distributed systems where efficient data movement is crucial for maintaining operational speed and consistency. If set too low, it can lead to bottlenecks and increased latency, while setting it too high may overwhelm network resources. Thus, it has a substantial impact on system-level performance during time-intensive operations."
        }
    ]
}