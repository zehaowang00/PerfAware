{
    "performance_sensitive": "No",
    "config_name": "enable_materialized_views",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "public Keyspaces apply(Keyspaces schema)\n    {\n        if (!DatabaseDescriptor.getEnableMaterializedViews())\n            throw ire(\"Materialized views are disabled. Enable in cassandra.yaml to use.\");\n\n        /*\n         * Basic dependency validations\n         */\n\n        KeyspaceMetadata keyspace = schema.getNullable(keyspaceName);\n        if (null == keyspace)\n            throw ire(\"Keyspace '%s' doesn't exist\", keyspaceName);\n\n        if (keyspace.createReplicationStrategy().hasTransientReplicas())\n            throw new InvalidRequestException(\"Materialized views are not supported on transiently replicated keyspaces\");\n\n        TableMetadata table = keyspace.tables.getNullable(tableName);\n        if (null == table)\n            throw ire(\"Base table '%s' doesn't exist\", tableName);\n\n        if (keyspace.hasTable(viewName))\n            throw ire(\"Cannot create materialized view '%s' - a table with the same name already exists\", viewName);\n\n        if (keyspace.hasView(viewName))\n        {\n            if (ifNotExists)\n                return schema;\n\n            throw new AlreadyExistsException(keyspaceName, viewName);\n        }\n\n        /*\n         * Base table validation\n         */\n\n        if (table.isCounter())\n            throw ire(\"Materialized views are not supported on counter tables\");\n\n        if (table.isView())\n            throw ire(\"Materialized views cannot be created against other materialized views\");\n\n        if (table.params.gcGraceSeconds == 0)\n        {\n            throw ire(\"Cannot create materialized view '%s' for base table \" +\n                      \"'%s' with gc_grace_seconds of 0, since this value is \" +\n                      \"used to TTL undelivered updates. Setting gc_grace_seconds\" +\n                      \" too low might cause undelivered updates to expire \" +\n                      \"before being replayed.\",\n                      viewName, tableName);\n        }\n\n        /*\n         * Process SELECT clause\n         */\n\n        Set<ColumnIdentifier> selectedColumns = new HashSet<>();\n\n        if (rawColumns.isEmpty()) // SELECT *\n            table.columns().forEach(c -> selectedColumns.add(c.name));\n\n        rawColumns.forEach(selector ->\n        {\n            if (null != selector.alias)\n                throw ire(\"Cannot use aliases when defining a materialized view (got %s)\", selector);\n\n            if (!(selector.selectable instanceof Selectable.RawIdentifier))\n                throw ire(\"Can only select columns by name when defining a materialized view (got %s)\", selector.selectable);\n\n            // will throw IRE if the column doesn't exist in the base table\n            ColumnMetadata column = (ColumnMetadata) selector.selectable.prepare(table);\n\n            selectedColumns.add(column.name);\n        });\n\n        selectedColumns.stream()\n                       .map(table::getColumn)\n                       .filter(ColumnMetadata::isStatic)\n                       .findAny()\n                       .ifPresent(c -> { throw ire(\"Cannot include static column '%s' in materialized view '%s'\", c, viewName); });\n\n        /*\n         * Process PRIMARY KEY columns and CLUSTERING ORDER BY clause\n         */\n\n        if (partitionKeyColumns.isEmpty())\n            throw ire(\"Must provide at least one partition key column for materialized view '%s'\", viewName);\n\n        HashSet<ColumnIdentifier> primaryKeyColumns = new HashSet<>();\n\n        concat(partitionKeyColumns, clusteringColumns).forEach(name ->\n        {\n            ColumnMetadata column = table.getColumn(name);\n            if (null == column || !selectedColumns.contains(name))\n                throw ire(\"Unknown column '%s' referenced in PRIMARY KEY for materialized view '%s'\", name, viewName);\n\n            if (!primaryKeyColumns.add(name))\n                throw ire(\"Duplicate column '%s' in PRIMARY KEY clause for materialized view '%s'\", name, viewName);\n\n            AbstractType<?> type = column.type;\n\n            if (type.isMultiCell())\n            {\n                if (type.isCollection())\n                    throw ire(\"Invalid non-frozen collection type '%s' for PRIMARY KEY column '%s'\", type, name);\n                else\n                    throw ire(\"Invalid non-frozen user-defined type '%s' for PRIMARY KEY column '%s'\", type, name);\n            }\n\n            if (type.isCounter())\n                throw ire(\"counter type is not supported for PRIMARY KEY column '%s'\", name);\n\n            if (type.referencesDuration())\n                throw ire(\"duration type is not supported for PRIMARY KEY column '%s'\", name);\n        });\n\n        // If we give a clustering order, we must explicitly do so for all aliases and in the order of the PK\n        if (!clusteringOrder.isEmpty() && !clusteringColumns.equals(new ArrayList<>(clusteringOrder.keySet())))\n            throw ire(\"Clustering key columns must exactly match columns in CLUSTERING ORDER BY directive\");\n\n        /*\n         * We need to include all of the primary key columns from the base table in order to make sure that we do not\n         * overwrite values in the view. We cannot support \"collapsing\" the base table into a smaller number of rows in\n         * the view because if we need to generate a tombstone, we have no way of knowing which value is currently being\n         * used in the view and whether or not to generate a tombstone. In order to not surprise our users, we require\n         * that they include all of the columns. We provide them with a list of all of the columns left to include.\n         */\n        List<ColumnIdentifier> missingPrimaryKeyColumns =\n            Lists.newArrayList(filter(transform(table.primaryKeyColumns(), c -> c.name), c -> !primaryKeyColumns.contains(c)));\n\n        if (!missingPrimaryKeyColumns.isEmpty())\n        {\n            throw ire(\"Cannot create materialized view '%s' without primary key columns %s from base table '%s'\",\n                      viewName, join(\", \", transform(missingPrimaryKeyColumns, ColumnIdentifier::toString)), tableName);\n        }\n\n        Set<ColumnIdentifier> regularBaseTableColumnsInViewPrimaryKey = new HashSet<>(primaryKeyColumns);\n        transform(table.primaryKeyColumns(), c -> c.name).forEach(regularBaseTableColumnsInViewPrimaryKey::remove);\n        if (regularBaseTableColumnsInViewPrimaryKey.size() > 1)\n        {\n            throw ire(\"Cannot include more than one non-primary key column in materialized view primary key (got %s)\",\n                      join(\", \", transform(regularBaseTableColumnsInViewPrimaryKey, ColumnIdentifier::toString)));\n        }\n\n        /*\n         * Process WHERE clause\n         */\n        if (whereClause.containsTokenRelations())\n            throw new InvalidRequestException(\"Cannot use token relation when defining a materialized view\");\n\n        if (whereClause.containsCustomExpressions())\n            throw ire(\"WHERE clause for materialized view '%s' cannot contain custom index expressions\", viewName);\n\n        StatementRestrictions restrictions =\n            new StatementRestrictions(StatementType.SELECT,\n                                      table,\n                                      whereClause,\n                                      VariableSpecifications.empty(),\n                                      false,\n                                      false,\n                                      true,\n                                      true);\n\n        List<ColumnIdentifier> nonRestrictedPrimaryKeyColumns =\n            Lists.newArrayList(filter(primaryKeyColumns, name -> !restrictions.isRestricted(table.getColumn(name))));\n\n        if (!nonRestrictedPrimaryKeyColumns.isEmpty())\n        {\n            throw ire(\"Primary key columns %s must be restricted with 'IS NOT NULL' or otherwise\",\n                      join(\", \", transform(nonRestrictedPrimaryKeyColumns, ColumnIdentifier::toString)));\n        }\n\n        // See CASSANDRA-13798\n        Set<ColumnMetadata> restrictedNonPrimaryKeyColumns = restrictions.nonPKRestrictedColumns(false);\n        if (!restrictedNonPrimaryKeyColumns.isEmpty() && !Boolean.getBoolean(\"cassandra.mv.allow_filtering_nonkey_columns_unsafe\"))\n        {\n            throw ire(\"Non-primary key columns can only be restricted with 'IS NOT NULL' (got: %s restricted illegally)\",\n                      join(\",\", transform(restrictedNonPrimaryKeyColumns, ColumnMetadata::toString)));\n        }\n\n        /*\n         * Validate WITH params\n         */\n\n        attrs.validate();\n\n        if (attrs.hasOption(TableParams.Option.DEFAULT_TIME_TO_LIVE)\n            && attrs.getInt(TableParams.Option.DEFAULT_TIME_TO_LIVE.toString(), 0) != 0)\n        {\n            throw ire(\"Cannot set default_time_to_live for a materialized view. \" +\n                      \"Data in a materialized view always expire at the same time than \" +\n                      \"the corresponding data in the parent table.\");\n        }\n\n        /*\n         * Build the thing\n         */\n\n        TableMetadata.Builder builder = TableMetadata.builder(keyspaceName, viewName);\n\n        if (attrs.hasProperty(TableAttributes.ID))\n            builder.id(attrs.getId());\n\n        builder.params(attrs.asNewTableParams())\n               .kind(TableMetadata.Kind.VIEW);\n\n        partitionKeyColumns.forEach(name -> builder.addPartitionKeyColumn(name, getType(table, name)));\n        clusteringColumns.forEach(name -> builder.addClusteringColumn(name, getType(table, name)));\n\n        selectedColumns.stream()\n                       .filter(name -> !primaryKeyColumns.contains(name))\n                       .forEach(name -> builder.addRegularColumn(name, getType(table, name)));\n\n        ViewMetadata view = new ViewMetadata(table.id, table.name, rawColumns.isEmpty(), whereClause, builder.build());\n        view.metadata.validate();\n\n        return schema.withAddedOrUpdated(keyspace.withSwapped(keyspace.views.with(view)));\n    }\n\n    "
        },
        {
            "sender": "Developer Filter",
            "content": "Filter of the code context that is related to configuration: ```java\npublic Keyspaces apply(Keyspaces schema)\n{\n    if (!DatabaseDescriptor.getEnableMaterializedViews())\n        throw ire(\"Materialized views are disabled. Enable in cassandra.yaml to use.\");\n\n    /*\n     * Basic dependency validations\n     */\n\n    KeyspaceMetadata keyspace = schema.getNullable(keyspaceName);\n    if (null == keyspace)\n        throw ire(\"Keyspace '%s' doesn't exist\", keyspaceName);\n\n    if (keyspace.createReplicationStrategy().hasTransientReplicas())\n        throw new InvalidRequestException(\"Materialized views are not supported on transiently replicated keyspaces\");\n\n    TableMetadata table = keyspace.tables.getNullable(tableName);\n    if (null == table)\n        throw ire(\"Base table '%s' doesn't exist\", tableName);\n\n    if (keyspace.hasTable(viewName))\n        throw ire(\"Cannot create materialized view '%s' - a table with the same name already exists\", viewName);\n\n    if (keyspace.hasView(viewName))\n    {\n        if (ifNotExists)\n            return schema;\n\n        throw new AlreadyExistsException(keyspaceName, viewName);\n    }\n\n    /*\n     * Base table validation\n     */\n\n    if (table.isCounter())\n        throw ire(\"Materialized views are not supported on counter tables\");\n\n    if (table.isView())\n        throw ire(\"Materialized views cannot be created against other materialized views\");\n\n    if (table.params.gcGraceSeconds == 0)\n    {\n        throw ire(\"Cannot create materialized view '%s' for base table \" +\n                  \"'%s' with gc_grace_seconds of 0, since this value is \" +\n                  \"used to TTL undelivered updates. Setting gc_grace_seconds\" +\n                  \" too low might cause undelivered updates to expire \" +\n                  \"before being replayed.\",\n                  viewName, tableName);\n    }\n\n    /*\n     * Process WHERE clause\n     */\n    if (whereClause.containsTokenRelations())\n        throw new InvalidRequestException(\"Cannot use token relation when defining a materialized view\");\n\n    if (whereClause.containsCustomExpressions())\n        throw ire(\"WHERE clause for materialized view '%s' cannot contain custom index expressions\", viewName);\n\n    /*\n     * Validate WITH params\n     */\n\n    attrs.validate();\n\n    if (attrs.hasOption(TableParams.Option.DEFAULT_TIME_TO_LIVE)\n        && attrs.getInt(TableParams.Option.DEFAULT_TIME_TO_LIVE.toString(), 0) != 0)\n    {\n        throw ire(\"Cannot set default_time_to_live for a materialized view. \" +\n                  \"Data in a materialized view always expire at the same time than \" +\n                  \"the corresponding data in the parent table.\");\n    }\n\n    /*\n     * Build the thing\n     */\n\n    TableMetadata.Builder builder = TableMetadata.builder(keyspaceName, viewName);\n\n    if (attrs.hasProperty(TableAttributes.ID))\n        builder.id(attrs.getId());\n\n    builder.params(attrs.asNewTableParams())\n           .kind(TableMetadata.Kind.VIEW);\n\n    partitionKeyColumns.forEach(name -> builder.addPartitionKeyColumn(name, getType(table, name)));\n    clusteringColumns.forEach(name -> builder.addClusteringColumn(name, getType(table, name)));\n\n    selectedColumns.stream()\n                   .filter(name -> !primaryKeyColumns.contains(name))\n                   .forEach(name -> builder.addRegularColumn(name, getType(table, name)));\n\n    ViewMetadata view = new ViewMetadata(table.id, table.name, rawColumns.isEmpty(), whereClause, builder.build());\n    view.metadata.validate();\n\n    return schema.withAddedOrUpdated(keyspace.withSwapped(keyspace.views.with(view)));\n}\n```"
        },
        {
            "sender": "Developer summary",
            "content": "Summary of the extracted code context: ### Configuration Summary for `enable_materialized_views`\n\nThe `enable_materialized_views` configuration plays a crucial role in determining whether materialized views can be created and utilized within the Cassandra database system. This configuration is accessed through the `DatabaseDescriptor.getEnableMaterializedViews()` method, which checks its status before allowing any operations related to materialized views.\n\n#### Purpose and Functionality\n1. **Enabling Materialized Views**: The primary purpose of this configuration is to enable or disable the functionality of materialized views in the database. If materialized views are disabled, any attempt to create or manipulate them will result in an error, prompting the user to enable this feature in the `cassandra.yaml` configuration file.\n\n2. **Dependency Validation**: The code includes several validation checks that depend on this configuration:\n   - If materialized views are disabled, an exception is thrown immediately, preventing further execution.\n   - The existence of the keyspace and base table is validated, ensuring that the necessary components are present to create a materialized view.\n\n3. **Interaction with Keyspace and Table Metadata**: The configuration interacts with keyspace and table metadata to ensure that:\n   - Materialized views cannot be created on keyspaces that have transient replicas.\n   - Materialized views cannot be created on counter tables or other materialized views, enforcing strict rules regarding their usage.\n\n4. **Validation of Attributes**: The configuration also influences the validation of attributes associated with the materialized view, such as ensuring that certain parameters (like `DEFAULT_TIME_TO_LIVE`) are not set, as they are managed by the parent table.\n\n5. **Building the Materialized View**: If all validations pass, the configuration allows the construction of the materialized view using a builder pattern, where partition key columns, clustering columns, and selected columns are defined based on the base table's schema.\n\n#### Key Components Involved\n- **KeyspaceMetadata**: Represents the metadata of the keyspace where the materialized view is being created.\n- **TableMetadata**: Represents the metadata of the base table from which the materialized view is derived.\n- **ViewMetadata**: Represents the metadata of the materialized view itself, including its structure and attributes.\n\n#### Interactions with Other Parts of the System\nThe `enable_materialized_views` configuration interacts with various components of the Cassandra system, including:\n- **Database Descriptor**: Centralized configuration management that retrieves the status of the `enable_materialized_views` setting.\n- **Schema Management**: The configuration influences how schemas are validated and modified when creating or updating materialized views.\n- **Error Handling**: The configuration is integral to the error handling mechanism, ensuring that users receive appropriate feedback when attempting to create materialized views under unsupported conditions.\n\nIn summary, the `enable_materialized_views` configuration is essential for controlling the use of materialized views in Cassandra, enforcing strict validation rules, and ensuring that the necessary dependencies are met before any operations can proceed."
        },
        {
            "sender": "performance agent sensitivity",
            "content": "{\"Role\": \"You are a Performance Sensitivity Agent responsible for determining if a configuration is performance-sensitive within a software system.\", \"Requirement\": \"Using developer-provided information as a secondary reference, analyze the configuration-related code to determine if it is performance-sensitive. Focus exclusively on configurations with substantial system-level performance impact due to time-intensive or memory-intensive operations. Only configurations that directly cause significant performance variations through extremely time-consuming or memory-heavy operations should be classified as performance-sensitive. Minor or moderate impacts should not be considered.\", \"Output Format\": \"Respond strictly in one of the following formats: 'The configuration is Performance Sensitive: reason' or 'The configuration is Performance Insensitive: reason'. No other response format is acceptable. Provide a concise yet clear and detailed reason for your classification.\", \"configuration_name\": \"enable_materialized_views\", \"code_context\": \"```java\\npublic Keyspaces apply(Keyspaces schema)\\n{\\n    if (!DatabaseDescriptor.getEnableMaterializedViews())\\n        throw ire(\\\"Materialized views are disabled. Enable in cassandra.yaml to use.\\\");\\n\\n    /*\\n     * Basic dependency validations\\n     */\\n\\n    KeyspaceMetadata keyspace = schema.getNullable(keyspaceName);\\n    if (null == keyspace)\\n        throw ire(\\\"Keyspace '%s' doesn't exist\\\", keyspaceName);\\n\\n    if (keyspace.createReplicationStrategy().hasTransientReplicas())\\n        throw new InvalidRequestException(\\\"Materialized views are not supported on transiently replicated keyspaces\\\");\\n\\n    TableMetadata table = keyspace.tables.getNullable(tableName);\\n    if (null == table)\\n        throw ire(\\\"Base table '%s' doesn't exist\\\", tableName);\\n\\n    if (keyspace.hasTable(viewName))\\n        throw ire(\\\"Cannot create materialized view '%s' - a table with the same name already exists\\\", viewName);\\n\\n    if (keyspace.hasView(viewName))\\n    {\\n        if (ifNotExists)\\n            return schema;\\n\\n        throw new AlreadyExistsException(keyspaceName, viewName);\\n    }\\n\\n    /*\\n     * Base table validation\\n     */\\n\\n    if (table.isCounter())\\n        throw ire(\\\"Materialized views are not supported on counter tables\\\");\\n\\n    if (table.isView())\\n        throw ire(\\\"Materialized views cannot be created against other materialized views\\\");\\n\\n    if (table.params.gcGraceSeconds == 0)\\n    {\\n        throw ire(\\\"Cannot create materialized view '%s' for base table \\\" +\\n                  \\\"'%s' with gc_grace_seconds of 0, since this value is \\\" +\\n                  \\\"used to TTL undelivered updates. Setting gc_grace_seconds\\\" +\\n                  \\\" too low might cause undelivered updates to expire \\\" +\\n                  \\\"before being replayed.\\\",\\n                  viewName, tableName);\\n    }\\n\\n    /*\\n     * Process WHERE clause\\n     */\\n    if (whereClause.containsTokenRelations())\\n        throw new InvalidRequestException(\\\"Cannot use token relation when defining a materialized view\\\");\\n\\n    if (whereClause.containsCustomExpressions())\\n        throw ire(\\\"WHERE clause for materialized view '%s' cannot contain custom index expressions\\\", viewName);\\n\\n    /*\\n     * Validate WITH params\\n     */\\n\\n    attrs.validate();\\n\\n    if (attrs.hasOption(TableParams.Option.DEFAULT_TIME_TO_LIVE)\\n        && attrs.getInt(TableParams.Option.DEFAULT_TIME_TO_LIVE.toString(), 0) != 0)\\n    {\\n        throw ire(\\\"Cannot set default_time_to_live for a materialized view. \\\" +\\n                  \\\"Data in a materialized view always expire at the same time than \\\" +\\n                  \\\"the corresponding data in the parent table.\\\");\\n    }\\n\\n    /*\\n     * Build the thing\\n     */\\n\\n    TableMetadata.Builder builder = TableMetadata.builder(keyspaceName, viewName);\\n\\n    if (attrs.hasProperty(TableAttributes.ID))\\n        builder.id(attrs.getId());\\n\\n    builder.params(attrs.asNewTableParams())\\n           .kind(TableMetadata.Kind.VIEW);\\n\\n    partitionKeyColumns.forEach(name -> builder.addPartitionKeyColumn(name, getType(table, name)));\\n    clusteringColumns.forEach(name -> builder.addClusteringColumn(name, getType(table, name)));\\n\\n    selectedColumns.stream()\\n                   .filter(name -> !primaryKeyColumns.contains(name))\\n                   .forEach(name -> builder.addRegularColumn(name, getType(table, name)));\\n\\n    ViewMetadata view = new ViewMetadata(table.id, table.name, rawColumns.isEmpty(), whereClause, builder.build());\\n    view.metadata.validate();\\n\\n    return schema.withAddedOrUpdated(keyspace.withSwapped(keyspace.views.with(view)));\\n}\\n```\\n\\n--- Summary by Developer ---\\n### Configuration Summary for `enable_materialized_views`\\n\\nThe `enable_materialized_views` configuration plays a crucial role in determining whether materialized views can be created and utilized within the Cassandra database system. This configuration is accessed through the `DatabaseDescriptor.getEnableMaterializedViews()` method, which checks its status before allowing any operations related to materialized views.\\n\\n#### Purpose and Functionality\\n1. **Enabling Materialized Views**: The primary purpose of this configuration is to enable or disable the functionality of materialized views in the database. If materialized views are disabled, any attempt to create or manipulate them will result in an error, prompting the user to enable this feature in the `cassandra.yaml` configuration file.\\n\\n2. **Dependency Validation**: The code includes several validation checks that depend on this configuration:\\n   - If materialized views are disabled, an exception is thrown immediately, preventing further execution.\\n   - The existence of the keyspace and base table is validated, ensuring that the necessary components are present to create a materialized view.\\n\\n3. **Interaction with Keyspace and Table Metadata**: The configuration interacts with keyspace and table metadata to ensure that:\\n   - Materialized views cannot be created on keyspaces that have transient replicas.\\n   - Materialized views cannot be created on counter tables or other materialized views, enforcing strict rules regarding their usage.\\n\\n4. **Validation of Attributes**: The configuration also influences the validation of attributes associated with the materialized view, such as ensuring that certain parameters (like `DEFAULT_TIME_TO_LIVE`) are not set, as they are managed by the parent table.\\n\\n5. **Building the Materialized View**: If all validations pass, the configuration allows the construction of the materialized view using a builder pattern, where partition key columns, clustering columns, and selected columns are defined based on the base table's schema.\\n\\n#### Key Components Involved\\n- **KeyspaceMetadata**: Represents the metadata of the keyspace where the materialized view is being created.\\n- **TableMetadata**: Represents the metadata of the base table from which the materialized view is derived.\\n- **ViewMetadata**: Represents the metadata of the materialized view itself, including its structure and attributes.\\n\\n#### Interactions with Other Parts of the System\\nThe `enable_materialized_views` configuration interacts with various components of the Cassandra system, including:\\n- **Database Descriptor**: Centralized configuration management that retrieves the status of the `enable_materialized_views` setting.\\n- **Schema Management**: The configuration influences how schemas are validated and modified when creating or updating materialized views.\\n- **Error Handling**: The configuration is integral to the error handling mechanism, ensuring that users receive appropriate feedback when attempting to create materialized views under unsupported conditions.\\n\\nIn summary, the `enable_materialized_views` configuration is essential for controlling the use of materialized views in Cassandra, enforcing strict validation rules, and ensuring that the necessary dependencies are met before any operations can proceed.\"}"
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Insensitive: While the `enable_materialized_views` configuration is important for controlling the functionality of materialized views, it does not directly cause significant performance variations through time-consuming or memory-heavy operations. The checks performed are primarily validation steps that prevent operations from proceeding under unsupported conditions, rather than operations that would consume substantial system resources."
        }
    ]
}