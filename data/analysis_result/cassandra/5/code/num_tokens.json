{
    "performance_sensitive": "Yes",
    "config_name": "num_tokens",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "private void validateTransientReplication(AbstractReplicationStrategy oldStrategy, AbstractReplicationStrategy newStrategy)\n    {\n        //If there is no read traffic there are some extra alterations you can safely make, but this is so atypical\n        //that a good default is to not allow unsafe changes\n        if (allow_unsafe_transient_changes)\n            return;\n\n        ReplicationFactor oldRF = oldStrategy.getReplicationFactor();\n        ReplicationFactor newRF = newStrategy.getReplicationFactor();\n\n        int oldTrans = oldRF.transientReplicas();\n        int oldFull = oldRF.fullReplicas;\n        int newTrans = newRF.transientReplicas();\n        int newFull = newRF.fullReplicas;\n\n        if (newTrans > 0)\n        {\n            if (DatabaseDescriptor.getNumTokens() > 1)\n                throw new ConfigurationException(String.format(\"Transient replication is not supported with vnodes yet\"));\n\n            Keyspace ks = Keyspace.open(keyspaceName);\n            for (ColumnFamilyStore cfs : ks.getColumnFamilyStores())\n            {\n                if (cfs.viewManager.hasViews())\n                {\n                    throw new ConfigurationException(\"Cannot use transient replication on keyspaces using materialized views\");\n                }\n\n                if (cfs.indexManager.hasIndexes())\n                {\n                    throw new ConfigurationException(\"Cannot use transient replication on keyspaces using secondary indexes\");\n                }\n            }\n        }\n\n        //This is true right now because the transition from transient -> full lacks the pending state\n        //necessary for correctness. What would happen if we allowed this is that we would attempt\n        //to read from a transient replica as if it were a full replica.\n        if (oldFull > newFull && oldTrans > 0)\n            throw new ConfigurationException(\"Can't add full replicas if there are any transient replicas. You must first remove all transient replicas, then change the # of full replicas, then add back the transient replicas\");\n\n        //Don't increase transient replication factor by more than one at a time if changing number of replicas\n        //Just like with changing full replicas it's not safe to do this as you could read from too many replicas\n        //that don't have the necessary data. W/O transient replication this alteration was allowed and it's not clear\n        //if it should be.\n        //This is structured so you can convert as many full replicas to transient replicas as you want.\n        boolean numReplicasChanged = oldTrans + oldFull != newTrans + newFull;\n        if (numReplicasChanged && (newTrans > oldTrans && newTrans != oldTrans + 1))\n            throw new ConfigurationException(\"Can only safely increase number of transients one at a time with incremental repair run in between each time\");\n    }\n\n    \n/**\n     * Returns a list of disk boundaries, the result will differ depending on whether vnodes are enabled or not.\n     *\n     * What is returned are upper bounds for the disks, meaning everything from partitioner.minToken up to\n     * getDiskBoundaries(..).get(0) should be on the first disk, everything between 0 to 1 should be on the second disk\n     * etc.\n     *\n     * The final entry in the returned list will always be the partitioner maximum tokens upper key bound\n     */\nprivate static List<PartitionPosition> getDiskBoundaries(RangesAtEndpoint replicas, IPartitioner partitioner, Directories.DataDirectory[] dataDirectories)\n    {\n        assert partitioner.splitter().isPresent();\n\n        Splitter splitter = partitioner.splitter().get();\n        boolean dontSplitRanges = DatabaseDescriptor.getNumTokens() > 1;\n\n        List<Splitter.WeightedRange> weightedRanges = new ArrayList<>(replicas.size());\n        // note that Range.sort unwraps any wraparound ranges, so we need to sort them here\n        for (Range<Token> r : Range.sort(replicas.onlyFull().ranges()))\n            weightedRanges.add(new Splitter.WeightedRange(1.0, r));\n\n        for (Range<Token> r : Range.sort(replicas.onlyTransient().ranges()))\n            weightedRanges.add(new Splitter.WeightedRange(0.1, r));\n\n        weightedRanges.sort(Comparator.comparing(Splitter.WeightedRange::left));\n\n        List<Token> boundaries = splitter.splitOwnedRanges(dataDirectories.length, weightedRanges, dontSplitRanges);\n        // If we can't split by ranges, split evenly to ensure utilisation of all disks\n        if (dontSplitRanges && boundaries.size() < dataDirectories.length)\n            boundaries = splitter.splitOwnedRanges(dataDirectories.length, weightedRanges, false);\n\n        List<PartitionPosition> diskBoundaries = new ArrayList<>();\n        for (int i = 0; i < boundaries.size() - 1; i++)\n            diskBoundaries.add(boundaries.get(i).maxKeyBound());\n        diskBoundaries.add(partitioner.getMaximumToken().maxKeyBound());\n        return diskBoundaries;\n    }\n}\n/**\n     * if initialtoken was specified, use that (split on comma).\n     * otherwise, if allocationKeyspace is specified use the token allocation algorithm to generate suitable tokens\n     * else choose num_tokens tokens at random\n     */\npublic static Collection<Token> getBootstrapTokens(final TokenMetadata metadata, InetAddressAndPort address, long schemaWaitDelay) throws ConfigurationException\n    {\n        String allocationKeyspace = DatabaseDescriptor.getAllocateTokensForKeyspace();\n        Integer allocationLocalRf = DatabaseDescriptor.getAllocateTokensForLocalRf();\n        Collection<String> initialTokens = DatabaseDescriptor.getInitialTokens();\n        if (initialTokens.size() > 0 && allocationKeyspace != null)\n            logger.warn(\"manually specified tokens override automatic allocation\");\n\n        // if user specified tokens, use those\n        if (initialTokens.size() > 0)\n        {\n            Collection<Token> tokens = getSpecifiedTokens(metadata, initialTokens);\n            BootstrapDiagnostics.useSpecifiedTokens(address, allocationKeyspace, tokens, DatabaseDescriptor.getNumTokens());\n            return tokens;\n        }\n\n        int numTokens = DatabaseDescriptor.getNumTokens();\n        if (numTokens < 1)\n            throw new ConfigurationException(\"num_tokens must be >= 1\");\n\n        if (allocationKeyspace != null)\n            return allocateTokens(metadata, address, allocationKeyspace, numTokens, schemaWaitDelay);\n\n        if (allocationLocalRf != null)\n            return allocateTokens(metadata, address, allocationLocalRf, numTokens, schemaWaitDelay);\n\n        if (numTokens == 1)\n            logger.warn(\"Picking random token for a single vnode.  You should probably add more vnodes and/or use the automatic token allocation mechanism.\");\n\n        Collection<Token> tokens = getRandomTokens(metadata, numTokens);\n        BootstrapDiagnostics.useRandomTokens(address, metadata, numTokens, tokens);\n        return tokens;\n    }\n\n    \nprotected void validateReplicationFactor(String s) throws ConfigurationException\n    {\n        try\n        {\n            ReplicationFactor rf = ReplicationFactor.fromString(s);\n            if (rf.hasTransientReplicas())\n            {\n                if (DatabaseDescriptor.getNumTokens() > 1)\n                    throw new ConfigurationException(\"Transient replication is not supported with vnodes yet\");\n            }\n        }\n        catch (IllegalArgumentException e)\n        {\n            throw new ConfigurationException(e.getMessage());\n        }\n    }\n\n    \nstatic void validate(int totalRF, int transientRF)\n    {\n        Preconditions.checkArgument(transientRF == 0 || DatabaseDescriptor.isTransientReplicationEnabled(),\n                                    \"Transient replication is not enabled on this node\");\n        Preconditions.checkArgument(totalRF >= 0,\n                                    \"Replication factor must be non-negative, found %s\", totalRF);\n        Preconditions.checkArgument(transientRF == 0 || transientRF < totalRF,\n                                    \"Transient replicas must be zero, or less than total replication factor. For %s/%s\", totalRF, transientRF);\n        if (transientRF > 0)\n        {\n            Preconditions.checkArgument(DatabaseDescriptor.getNumTokens() == 1,\n                                        \"Transient nodes are not allowed with multiple tokens\");\n            Stream<InetAddressAndPort> endpoints = Stream.concat(Gossiper.instance.getLiveMembers().stream(), Gossiper.instance.getUnreachableMembers().stream());\n            List<InetAddressAndPort> badVersionEndpoints = endpoints.filter(Predicates.not(FBUtilities.getBroadcastAddressAndPort()::equals))\n                                                                    .filter(endpoint -> Gossiper.instance.getReleaseVersion(endpoint) != null && Gossiper.instance.getReleaseVersion(endpoint).major < 4)\n                                                                    .collect(Collectors.toList());\n            if (!badVersionEndpoints.isEmpty())\n                throw new IllegalArgumentException(\"Transient replication is not supported in mixed version clusters with nodes < 4.0. Bad nodes: \" + badVersionEndpoints);\n        }\n        else if (transientRF < 0)\n        {\n            throw new IllegalArgumentException(String.format(\"Amount of transient nodes should be strictly positive, but was: '%d'\", transientRF));\n        }\n    }\n\n    \nprivate boolean allowSimultaneousMoves()\n    {\n        return allowSimultaneousMoves && DatabaseDescriptor.getNumTokens() == 1;\n    }\n\n    \n@VisibleForTesting\n    public void joinTokenRing(boolean finishJoiningRing,\n                              boolean shouldBootstrap,\n                              long schemaTimeoutMillis,\n                              long bootstrapTimeoutMillis) throws ConfigurationException\n    {\n        joined = true;\n\n        // We bootstrap if we haven't successfully bootstrapped before, as long as we are not a seed.\n        // If we are a seed, or if the user manually sets auto_bootstrap to false,\n        // we'll skip streaming data from other nodes and jump directly into the ring.\n        //\n        // The seed check allows us to skip the RING_DELAY sleep for the single-node cluster case,\n        // which is useful for both new users and testing.\n        //\n        // We attempted to replace this with a schema-presence check, but you need a meaningful sleep\n        // to get schema info from gossip which defeats the purpose.  See CASSANDRA-4427 for the gory details.\n        Set<InetAddressAndPort> current = new HashSet<>();\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Bootstrap variables: {} {} {} {}\",\n                         DatabaseDescriptor.isAutoBootstrap(),\n                         SystemKeyspace.bootstrapInProgress(),\n                         SystemKeyspace.bootstrapComplete(),\n                         DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddressAndPort()));\n        }\n        if (DatabaseDescriptor.isAutoBootstrap() && !SystemKeyspace.bootstrapComplete() && DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddressAndPort()))\n        {\n            logger.info(\"This node will not auto bootstrap because it is configured to be a seed node.\");\n        }\n\n        boolean dataAvailable = true; // make this to false when bootstrap streaming failed\n\n        if (shouldBootstrap)\n        {\n            current.addAll(prepareForBootstrap(schemaTimeoutMillis));\n            dataAvailable = bootstrap(bootstrapTokens, bootstrapTimeoutMillis);\n        }\n        else\n        {\n            bootstrapTokens = SystemKeyspace.getSavedTokens();\n            if (bootstrapTokens.isEmpty())\n            {\n                bootstrapTokens = BootStrapper.getBootstrapTokens(tokenMetadata, FBUtilities.getBroadcastAddressAndPort(), schemaTimeoutMillis);\n            }\n            else\n            {\n                if (bootstrapTokens.size() != DatabaseDescriptor.getNumTokens())\n                    throw new ConfigurationException(\"Cannot change the number of tokens from \" + bootstrapTokens.size() + \" to \" + DatabaseDescriptor.getNumTokens());\n                else\n                    logger.info(\"Using saved tokens {}\", bootstrapTokens);\n            }\n        }\n\n        setUpDistributedSystemKeyspaces();\n\n        if (finishJoiningRing)\n        {\n            if (dataAvailable)\n            {\n                finishJoiningRing(shouldBootstrap, bootstrapTokens);\n                // remove the existing info about the replaced node.\n                if (!current.isEmpty())\n                {\n                    Gossiper.runInGossipStageBlocking(() -> {\n                        for (InetAddressAndPort existing : current)\n                            Gossiper.instance.replacedEndpoint(existing);\n                    });\n                }\n            }\n            else\n            {\n                logger.warn(\"Some data streaming failed. Use nodetool to check bootstrap state and resume. For more, see `nodetool help bootstrap`. {}\", SystemKeyspace.getBootstrapState());\n            }\n        }\n        else\n        {\n            if (dataAvailable)\n                logger.info(\"Startup complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService->joinRing()) to finalize ring joining.\");\n            else\n                logger.warn(\"Some data streaming failed. Use nodetool to check bootstrap state and resume. For more, see `nodetool help bootstrap`. {}\", SystemKeyspace.getBootstrapState());\n        }\n    }\n\n    \n/**\n     * Estimate the number of result rows per range in the ring based on our local data.\n     * <p>\n     * This assumes that ranges are uniformly distributed across the cluster and\n     * that the queried data is also uniformly distributed.\n     */\n@VisibleForTesting\n    static float estimateResultsPerRange(PartitionRangeReadCommand command, Keyspace keyspace)\n    {\n        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(command.metadata().id);\n        Index index = command.getIndex(cfs);\n        float maxExpectedResults = index == null\n                                   ? command.limits().estimateTotalResults(cfs)\n                                   : index.getEstimatedResultRows();\n\n        // adjust maxExpectedResults by the number of tokens this node has and the replication factor for this ks\n        return (maxExpectedResults / DatabaseDescriptor.getNumTokens())\n               / keyspace.getReplicationStrategy().getReplicationFactor().allReplicas;\n    }\n}"
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `num_tokens` configuration directly impacts the distribution of data across nodes in a distributed system. A higher number of tokens can lead to better load balancing and improved read/write performance, while a lower number may cause hotspots and increased latency. Additionally, the validation logic in the code indicates that improper configurations (e.g., using transient replication with multiple tokens) can lead to significant operational issues, which could result in time-intensive recovery processes. Therefore, changes to `num_tokens` can have substantial implications for system performance."
        }
    ]
}