{
    "performance_sensitive": "Yes",
    "config_name": "client_encryption_options",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "@Override\n    public void reloadSslCertificates() throws IOException\n    {\n        final EncryptionOptions.ServerEncryptionOptions serverOpts = DatabaseDescriptor.getInternodeMessagingEncyptionOptions();\n        final EncryptionOptions clientOpts = DatabaseDescriptor.getNativeProtocolEncryptionOptions();\n        SSLFactory.validateSslCerts(serverOpts, clientOpts);\n        SSLFactory.checkCertFilesForHotReloading(serverOpts, clientOpts);\n    }\n\n    \n/**\n * A Factory for providing and setting up client {@link SSLSocket}s. Also provides\n * methods for creating both JSSE {@link SSLContext} instances as well as netty {@link SslContext} instances.\n * <p>\n * Netty {@link SslContext} instances are expensive to create (as well as to destroy) and consume a lof of resources\n * (especially direct memory), but instances can be reused across connections (assuming the SSL params are the same).\n * Hence we cache created instances in {@link #cachedSslContexts}.\n */\npublic final class SSLFactory\n{\n    private static final Logger logger = LoggerFactory.getLogger(SSLFactory.class);\n\n    /**\n     * Indicates if the process holds the inbound/listening end of the socket ({@link SocketType#SERVER})), or the\n     * outbound side ({@link SocketType#CLIENT}).\n     */\n    public enum SocketType\n    {\n        SERVER, CLIENT\n    }\n\n    @VisibleForTesting\n    static volatile boolean checkedExpiry = false;\n\n    // Isolate calls to OpenSsl.isAvailable to allow in-jvm dtests to disable tcnative openssl\n    // support.  It creates a circular reference that prevents the instance class loader from being\n    // garbage collected.\n    static private final boolean openSslIsAvailable;\n    static\n    {\n        if (Boolean.getBoolean(Config.PROPERTY_PREFIX + \"disable_tcactive_openssl\"))\n        {\n            openSslIsAvailable = false;\n        }\n        else\n        {\n            openSslIsAvailable = OpenSsl.isAvailable();\n        }\n    }\n    public static boolean openSslIsAvailable()\n    {\n        return openSslIsAvailable;\n    }\n\n    /**\n     * Cached references of SSL Contexts\n     */\n    private static final ConcurrentHashMap<CacheKey, SslContext> cachedSslContexts = new ConcurrentHashMap<>();\n\n    /**\n     * List of files that trigger hot reloading of SSL certificates\n     */\n    private static volatile List<HotReloadableFile> hotReloadableFiles = ImmutableList.of();\n\n    /**\n     * Default initial delay for hot reloading\n     */\n    public static final int DEFAULT_HOT_RELOAD_INITIAL_DELAY_SEC = 600;\n\n    /**\n     * Default periodic check delay for hot reloading\n     */\n    public static final int DEFAULT_HOT_RELOAD_PERIOD_SEC = 600;\n\n    /**\n     * State variable to maintain initialization invariant\n     */\n    private static boolean isHotReloadingInitialized = false;\n\n    /**\n     * Helper class for hot reloading SSL Contexts\n     */\n    private static class HotReloadableFile\n    {\n        private final File file;\n        private volatile long lastModTime;\n\n        HotReloadableFile(String path)\n        {\n            file = new File(path);\n            lastModTime = file.lastModified();\n        }\n\n        boolean shouldReload()\n        {\n            long curModTime = file.lastModified();\n            boolean result = curModTime != lastModTime;\n            lastModTime = curModTime;\n            return result;\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"HotReloadableFile{\" +\n                       \"file=\" + file +\n                       \", lastModTime=\" + lastModTime +\n                       '}';\n        }\n    }\n\n    /** Provides the list of protocols that would have been supported if \"TLS\" was selected as the\n     * protocol before the change for CASSANDRA-13325 that expects explicit protocol versions.\n     * @return list of enabled protocol names\n     */\n    public static List<String> tlsInstanceProtocolSubstitution()\n    {\n        try\n        {\n            SSLContext ctx = SSLContext.getInstance(\"TLS\");\n            ctx.init(null, null, null);\n            SSLParameters params = ctx.getDefaultSSLParameters();\n            String[] protocols = params.getProtocols();\n            return Arrays.asList(protocols);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(\"Error finding supported TLS Protocols\", e);\n        }\n    }\n\n    /**\n     * Create a JSSE {@link SSLContext}.\n     */\n    public static SSLContext createSSLContext(EncryptionOptions options, boolean buildTruststore) throws IOException\n    {\n        TrustManager[] trustManagers = null;\n        if (buildTruststore)\n            trustManagers = buildTrustManagerFactory(options).getTrustManagers();\n\n        KeyManagerFactory kmf = buildKeyManagerFactory(options);\n\n        try\n        {\n            SSLContext ctx = SSLContext.getInstance(\"TLS\");\n            ctx.init(kmf.getKeyManagers(), trustManagers, null);\n            return ctx;\n        }\n        catch (Exception e)\n        {\n            throw new IOException(\"Error creating/initializing the SSL Context\", e);\n        }\n    }\n\n    static TrustManagerFactory buildTrustManagerFactory(EncryptionOptions options) throws IOException\n    {\n        try (InputStream tsf = Files.newInputStream(Paths.get(options.truststore)))\n        {\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(\n            options.algorithm == null ? TrustManagerFactory.getDefaultAlgorithm() : options.algorithm);\n            KeyStore ts = KeyStore.getInstance(options.store_type);\n            ts.load(tsf, options.truststore_password.toCharArray());\n            tmf.init(ts);\n            return tmf;\n        }\n        catch (Exception e)\n        {\n            throw new IOException(\"failed to build trust manager store for secure connections\", e);\n        }\n    }\n\n    static KeyManagerFactory buildKeyManagerFactory(EncryptionOptions options) throws IOException\n    {\n        try (InputStream ksf = Files.newInputStream(Paths.get(options.keystore)))\n        {\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\n            options.algorithm == null ? KeyManagerFactory.getDefaultAlgorithm() : options.algorithm);\n            KeyStore ks = KeyStore.getInstance(options.store_type);\n            ks.load(ksf, options.keystore_password.toCharArray());\n            if (!checkedExpiry)\n            {\n                for (Enumeration<String> aliases = ks.aliases(); aliases.hasMoreElements(); )\n                {\n                    String alias = aliases.nextElement();\n                    if (ks.getCertificate(alias).getType().equals(\"X.509\"))\n                    {\n                        Date expires = ((X509Certificate) ks.getCertificate(alias)).getNotAfter();\n                        if (expires.before(new Date()))\n                            logger.warn(\"Certificate for {} expired on {}\", alias, expires);\n                    }\n                }\n                checkedExpiry = true;\n            }\n            kmf.init(ks, options.keystore_password.toCharArray());\n            return kmf;\n        }\n        catch (Exception e)\n        {\n            throw new IOException(\"failed to build key manager store for secure connections\", e);\n        }\n    }\n\n    /**\n     * get a netty {@link SslContext} instance\n     */\n    public static SslContext getOrCreateSslContext(EncryptionOptions options, boolean buildTruststore,\n                                                   SocketType socketType) throws IOException\n    {\n        return getOrCreateSslContext(options, buildTruststore, socketType, openSslIsAvailable());\n    }\n\n    /**\n     * Get a netty {@link SslContext} instance.\n     */\n    @VisibleForTesting\n    static SslContext getOrCreateSslContext(EncryptionOptions options,\n                                            boolean buildTruststore,\n                                            SocketType socketType,\n                                            boolean useOpenSsl) throws IOException\n    {\n        CacheKey key = new CacheKey(options, socketType, useOpenSsl);\n        SslContext sslContext;\n\n        sslContext = cachedSslContexts.get(key);\n        if (sslContext != null)\n            return sslContext;\n\n        sslContext = createNettySslContext(options, buildTruststore, socketType, useOpenSsl);\n\n        SslContext previous = cachedSslContexts.putIfAbsent(key, sslContext);\n        if (previous == null)\n            return sslContext;\n\n        ReferenceCountUtil.release(sslContext);\n        return previous;\n    }\n\n    /**\n     * Create a Netty {@link SslContext}\n     */\n    static SslContext createNettySslContext(EncryptionOptions options, boolean buildTruststore,\n                                            SocketType socketType, boolean useOpenSsl) throws IOException\n    {\n        return createNettySslContext(options, buildTruststore, socketType, useOpenSsl,\n                                     LoggingCipherSuiteFilter.QUIET_FILTER);\n    }\n\n    /**\n     * Create a Netty {@link SslContext} with a supplied cipherFilter\n     */\n    static SslContext createNettySslContext(EncryptionOptions options, boolean buildTruststore,\n                                            SocketType socketType, boolean useOpenSsl, CipherSuiteFilter cipherFilter) throws IOException\n    {\n        /*\n            There is a case where the netty/openssl combo might not support using KeyManagerFactory. specifically,\n            I've seen this with the netty-tcnative dynamic openssl implementation. using the netty-tcnative static-boringssl\n            works fine with KeyManagerFactory. If we want to support all of the netty-tcnative options, we would need\n            to fall back to passing in a file reference for both a x509 and PKCS#8 private key file in PEM format (see\n            {@link SslContextBuilder#forServer(File, File, String)}). However, we are not supporting that now to keep\n            the config/yaml API simple.\n         */\n        KeyManagerFactory kmf = buildKeyManagerFactory(options);\n        SslContextBuilder builder;\n        if (socketType == SocketType.SERVER)\n        {\n            builder = SslContextBuilder.forServer(kmf);\n            builder.clientAuth(options.require_client_auth ? ClientAuth.REQUIRE : ClientAuth.NONE);\n        }\n        else\n        {\n            builder = SslContextBuilder.forClient().keyManager(kmf);\n        }\n\n        builder.sslProvider(useOpenSsl ? SslProvider.OPENSSL : SslProvider.JDK);\n\n        builder.protocols(options.acceptedProtocols());\n\n        // only set the cipher suites if the opertor has explicity configured values for it; else, use the default\n        // for each ssl implemention (jdk or openssl)\n        if (options.cipher_suites != null && !options.cipher_suites.isEmpty())\n            builder.ciphers(options.cipher_suites, cipherFilter);\n\n        if (buildTruststore)\n            builder.trustManager(buildTrustManagerFactory(options));\n\n        return builder.build();\n    }\n\n    /**\n     * Performs a lightweight check whether the certificate files have been refreshed.\n     *\n     * @throws IllegalStateException if {@link #initHotReloading(EncryptionOptions.ServerEncryptionOptions, EncryptionOptions, boolean)}\n     *                               is not called first\n     */\n    public static void checkCertFilesForHotReloading(EncryptionOptions.ServerEncryptionOptions serverOpts,\n                                                     EncryptionOptions clientOpts)\n    {\n        if (!isHotReloadingInitialized)\n            throw new IllegalStateException(\"Hot reloading functionality has not been initialized.\");\n\n        logger.debug(\"Checking whether certificates have been updated {}\", hotReloadableFiles);\n\n        if (hotReloadableFiles.stream().anyMatch(HotReloadableFile::shouldReload))\n        {\n            logger.info(\"SSL certificates have been updated. Reseting the ssl contexts for new connections.\");\n            try\n            {\n                validateSslCerts(serverOpts, clientOpts);\n                cachedSslContexts.clear();\n            }\n            catch(Exception e)\n            {\n                logger.error(\"Failed to hot reload the SSL Certificates! Please check the certificate files.\", e);\n            }\n        }\n    }\n\n    /**\n     * Determines whether to hot reload certificates and schedules a periodic task for it.\n     *\n     * @param serverOpts Server encryption options (Internode)\n     * @param clientOpts Client encryption options (Native Protocol)\n     */\n    public static synchronized void initHotReloading(EncryptionOptions.ServerEncryptionOptions serverOpts,\n                                                     EncryptionOptions clientOpts,\n                                                     boolean force) throws IOException\n    {\n        if (isHotReloadingInitialized && !force)\n            return;\n\n        logger.debug(\"Initializing hot reloading SSLContext\");\n\n        List<HotReloadableFile> fileList = new ArrayList<>();\n\n        if (serverOpts != null && serverOpts.tlsEncryptionPolicy() != EncryptionOptions.TlsEncryptionPolicy.UNENCRYPTED)\n        {\n            fileList.add(new HotReloadableFile(serverOpts.keystore));\n            fileList.add(new HotReloadableFile(serverOpts.truststore));\n        }\n\n        if (clientOpts != null && clientOpts.tlsEncryptionPolicy() != EncryptionOptions.TlsEncryptionPolicy.UNENCRYPTED)\n        {\n            fileList.add(new HotReloadableFile(clientOpts.keystore));\n            fileList.add(new HotReloadableFile(clientOpts.truststore));\n        }\n\n        hotReloadableFiles = ImmutableList.copyOf(fileList);\n\n        if (!isHotReloadingInitialized)\n        {\n            ScheduledExecutors.scheduledTasks\n                .scheduleWithFixedDelay(() -> checkCertFilesForHotReloading(\n                                                DatabaseDescriptor.getInternodeMessagingEncyptionOptions(),\n                                                DatabaseDescriptor.getNativeProtocolEncryptionOptions()),\n                                        DEFAULT_HOT_RELOAD_INITIAL_DELAY_SEC,\n                                        DEFAULT_HOT_RELOAD_PERIOD_SEC, TimeUnit.SECONDS);\n        }\n\n        isHotReloadingInitialized = true;\n    }\n\n    // Non-logging\n    /*\n     * This class will filter all requested ciphers out that are not supported by the current {@link SSLEngine},\n     * logging messages for all dropped ciphers, and throws an exception if no ciphers are supported\n     */\n    public static final class LoggingCipherSuiteFilter implements CipherSuiteFilter\n    {\n        // Version without logging the ciphers, make sure same filtering logic is used\n        // all the time, regardless of user output.\n        public static final CipherSuiteFilter QUIET_FILTER = new LoggingCipherSuiteFilter();\n        final String settingDescription;\n\n        private LoggingCipherSuiteFilter()\n        {\n            this.settingDescription = null;\n        }\n\n        public LoggingCipherSuiteFilter(String settingDescription)\n        {\n            this.settingDescription = settingDescription;\n        }\n\n\n        @Override\n        public String[] filterCipherSuites(Iterable<String> ciphers, List<String> defaultCiphers,\n                                           Set<String> supportedCiphers)\n        {\n            Objects.requireNonNull(defaultCiphers, \"defaultCiphers\");\n            Objects.requireNonNull(supportedCiphers, \"supportedCiphers\");\n\n            final List<String> newCiphers;\n            if (ciphers == null)\n            {\n                newCiphers = new ArrayList<>(defaultCiphers.size());\n                ciphers = defaultCiphers;\n            }\n            else\n            {\n                newCiphers = new ArrayList<>(supportedCiphers.size());\n            }\n            for (String c : ciphers)\n            {\n                if (c == null)\n                {\n                    break;\n                }\n                if (supportedCiphers.contains(c))\n                {\n                    newCiphers.add(c);\n                }\n                else\n                {\n                    if (settingDescription != null)\n                    {\n                        logger.warn(\"Dropping unsupported cipher_suite {} from {} configuration\",\n                                    c, settingDescription.toLowerCase());\n                    }\n                }\n            }\n            if (newCiphers.isEmpty())\n            {\n                throw new IllegalStateException(\"No ciphers left after filtering supported cipher suite\");\n            }\n\n            return newCiphers.toArray(new String[0]);\n        }\n    }\n\n    private static boolean filterOutSSLv2Hello(String string)\n    {\n        return !string.equals(\"SSLv2Hello\");\n    }\n\n    public static void validateSslContext(String contextDescription, EncryptionOptions options, boolean buildTrustStore, boolean logProtocolAndCiphers) throws IOException\n    {\n        if (options != null && options.tlsEncryptionPolicy() != EncryptionOptions.TlsEncryptionPolicy.UNENCRYPTED)\n        {\n            try\n            {\n                CipherSuiteFilter loggingCipherSuiteFilter = logProtocolAndCiphers ? new LoggingCipherSuiteFilter(contextDescription)\n                                                                                   : LoggingCipherSuiteFilter.QUIET_FILTER;\n                SslContext serverSslContext = createNettySslContext(options, buildTrustStore, SocketType.SERVER, openSslIsAvailable(), loggingCipherSuiteFilter);\n                try\n                {\n                    SSLEngine engine = serverSslContext.newEngine(ByteBufAllocator.DEFAULT);\n                    try\n                    {\n                        if (logProtocolAndCiphers)\n                        {\n                            String[] supportedProtocols = engine.getSupportedProtocols();\n                            String[] supportedCiphers = engine.getSupportedCipherSuites();\n                            // Netty always adds the SSLv2Hello pseudo-protocol.  (Netty commit 7a39afd031accea9ee38653afbd58eb1c466deda)\n                            // To avoid triggering any log scanners that are concerned about SSL2 references, filter\n                            // it from the output.\n                            String[] enabledProtocols = engine.getEnabledProtocols();\n                            String filteredEnabledProtocols =\n                                supportedProtocols == null ? \"system default\"\n                                                           : Arrays.stream(engine.getEnabledProtocols())\n                                                            .filter(SSLFactory::filterOutSSLv2Hello)\n                                                            .collect(Collectors.joining(\", \"));\n                            String[] enabledCiphers = engine.getEnabledCipherSuites();\n\n                            logger.debug(\"{} supported TLS protocols: {}\", contextDescription,\n                                         supportedProtocols == null ? \"system default\" : String.join(\", \", supportedProtocols));\n                            logger.debug(\"{} unfiltered enabled TLS protocols: {}\", contextDescription,\n                                        enabledProtocols == null ? \"system default\" : String.join(\", \", enabledProtocols));\n                            logger.info(\"{} enabled TLS protocols: {}\", contextDescription, filteredEnabledProtocols);\n                            logger.debug(\"{} supported cipher suites: {}\", contextDescription,\n                                         supportedCiphers == null ? \"system default\" : String.join(\", \", supportedCiphers));\n                            logger.info(\"{} enabled cipher suites: {}\", contextDescription,\n                                        enabledCiphers == null ? \"system default\" : String.join(\", \", enabledCiphers));\n                        }\n                    }\n                    finally\n                    {\n                        engine.closeInbound();\n                        engine.closeOutbound();\n                        ReferenceCountUtil.release(engine);\n                    }\n                }\n                finally\n                {\n                    ReferenceCountUtil.release(serverSslContext);\n                }\n\n                // Make sure it is possible to build the client context too\n                SslContext clientSslContext = createNettySslContext(options, buildTrustStore, SocketType.CLIENT, openSslIsAvailable());\n                ReferenceCountUtil.release(clientSslContext);\n            }\n            catch (Exception e)\n            {\n                throw new IOException(\"Failed to create SSL context using \" + contextDescription, e);\n            }\n        }\n    }\n\n    /**\n     * Sanity checks all certificates to ensure we can actually load them\n     */\n    public static void validateSslCerts(EncryptionOptions.ServerEncryptionOptions serverOpts, EncryptionOptions clientOpts) throws IOException\n    {\n        validateSslContext(\"server_encryption_options\", serverOpts, true, false);\n        validateSslContext(\"client_encryption_options\", clientOpts, clientOpts.require_client_auth, false);\n    }\n\n    static class CacheKey\n    {\n        private final EncryptionOptions encryptionOptions;\n        private final SocketType socketType;\n        private final boolean useOpenSSL;\n\n        public CacheKey(EncryptionOptions encryptionOptions, SocketType socketType, boolean useOpenSSL)\n        {\n            this.encryptionOptions = encryptionOptions;\n            this.socketType = socketType;\n            this.useOpenSSL = useOpenSSL;\n        }\n\n        public boolean equals(Object o)\n        {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            CacheKey cacheKey = (CacheKey) o;\n            return (socketType == cacheKey.socketType &&\n                    useOpenSSL == cacheKey.useOpenSSL &&\n                    Objects.equals(encryptionOptions, cacheKey.encryptionOptions));\n        }\n\n        public int hashCode()\n        {\n            int result = 0;\n            result += 31 * socketType.hashCode();\n            result += 31 * encryptionOptions.hashCode();\n            result += 31 * Boolean.hashCode(useOpenSSL);\n            return result;\n        }\n    }\n}\n\n/**\n     * Creates netty thread pools and event loops.\n     */\n@VisibleForTesting\n    synchronized void initialize()\n    {\n        if (initialized)\n            return;\n\n        if (useEpoll())\n        {\n            workerGroup = new EpollEventLoopGroup();\n            logger.info(\"Netty using native Epoll event loop\");\n        }\n        else\n        {\n            workerGroup = new NioEventLoopGroup();\n            logger.info(\"Netty using Java NIO event loop\");\n        }\n\n        int nativePort = DatabaseDescriptor.getNativeTransportPort();\n        int nativePortSSL = DatabaseDescriptor.getNativeTransportPortSSL();\n        InetAddress nativeAddr = DatabaseDescriptor.getRpcAddress();\n\n        org.apache.cassandra.transport.Server.Builder builder = new org.apache.cassandra.transport.Server.Builder()\n                                                                .withEventLoopGroup(workerGroup)\n                                                                .withHost(nativeAddr);\n\n        EncryptionOptions.TlsEncryptionPolicy encryptionPolicy = DatabaseDescriptor.getNativeProtocolEncryptionOptions().tlsEncryptionPolicy();\n        Server regularPortServer;\n        Server tlsPortServer = null;\n\n        // If an SSL port is separately supplied for the native transport, listen for unencrypted connections on the\n        // regular port, and encryption / optionally encrypted connections on the ssl port.\n        if (nativePort != nativePortSSL)\n        {\n            regularPortServer = builder.withTlsEncryptionPolicy(EncryptionOptions.TlsEncryptionPolicy.UNENCRYPTED).withPort(nativePort).build();\n            switch(encryptionPolicy)\n            {\n                case OPTIONAL: // FALLTHRU - encryption is optional on the regular port, but encrypted on the tls port.\n                case ENCRYPTED:\n                    tlsPortServer = builder.withTlsEncryptionPolicy(encryptionPolicy).withPort(nativePortSSL).build();\n                    break;\n                case UNENCRYPTED: // Should have been caught by DatabaseDescriptor.applySimpleConfig\n                    throw new IllegalStateException(\"Encryption must be enabled in client_encryption_options for native_transport_port_ssl\");\n                default:\n                    throw new IllegalStateException(\"Unrecognized TLS encryption policy: \" + encryptionPolicy);\n            }\n        }\n        // Otherwise, if only the regular port is supplied, listen as the encryption policy specifies\n        else\n        {\n            regularPortServer = builder.withTlsEncryptionPolicy(encryptionPolicy).withPort(nativePort).build();\n        }\n\n        if (tlsPortServer == null)\n        {\n            servers = Collections.singleton(regularPortServer);\n        }\n        else\n        {\n            servers = Collections.unmodifiableList(Arrays.asList(regularPortServer, tlsPortServer));\n        }\n\n        ClientMetrics.instance.init(servers);\n\n        initialized = true;\n    }\n\n    \nprotected EncryptionConfig encryptionConfig()\n    {\n        final EncryptionOptions encryptionOptions = DatabaseDescriptor.getNativeProtocolEncryptionOptions();\n        switch (tlsEncryptionPolicy)\n        {\n            case UNENCRYPTED:\n                // if encryption is not enabled, no further steps are required after the initial setup\n                return channel -> {};\n            case OPTIONAL:\n                // If optional, install a handler which detects whether or not the client is sending\n                // encrypted bytes. If so, on receipt of the next bytes, replace that handler with\n                // an SSL Handler, otherwise just remove it and proceed with an unencrypted channel.\n                logger.debug(\"Enabling optionally encrypted CQL connections between client and server\");\n                return channel -> {\n                    SslContext sslContext = SSLFactory.getOrCreateSslContext(encryptionOptions,\n                                                                             encryptionOptions.require_client_auth,\n                                                                             SSLFactory.SocketType.SERVER);\n\n                    channel.pipeline().addFirst(SSL_HANDLER, new ByteToMessageDecoder()\n                    {\n                        @Override\n                        protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception\n                        {\n                            if (byteBuf.readableBytes() < 5)\n                            {\n                                // To detect if SSL must be used we need to have at least 5 bytes, so return here and try again\n                                // once more bytes a ready.\n                                return;\n                            }\n                            if (SslHandler.isEncrypted(byteBuf))\n                            {\n                                // Connection uses SSL/TLS, replace the detection handler with a SslHandler and so use\n                                // encryption.\n                                SslHandler sslHandler = sslContext.newHandler(channel.alloc());\n                                channelHandlerContext.pipeline().replace(SSL_HANDLER, SSL_HANDLER, sslHandler);\n                            }\n                            else\n                            {\n                                // Connection use no TLS/SSL encryption, just remove the detection handler and continue without\n                                // SslHandler in the pipeline.\n                                channelHandlerContext.pipeline().remove(SSL_HANDLER);\n                            }\n                        }\n                    });\n                };\n            case ENCRYPTED:\n                logger.debug(\"Enabling encrypted CQL connections between client and server\");\n                return channel -> {\n                    SslContext sslContext = SSLFactory.getOrCreateSslContext(encryptionOptions,\n                                                                             encryptionOptions.require_client_auth,\n                                                                             SSLFactory.SocketType.SERVER);\n                    channel.pipeline().addFirst(SSL_HANDLER, sslContext.newHandler(channel.alloc()));\n                };\n            default:\n                throw new IllegalStateException(\"Unrecognized TLS encryption policy: \" + this.tlsEncryptionPolicy);\n        }\n    }\n\n    "
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `client_encryption_options` directly influences the creation of SSL contexts, which are expensive to create and consume significant resources, particularly memory. The operations involved in validating SSL certificates and managing SSL contexts can lead to substantial performance impacts, especially under high load or frequent connection requests. The caching mechanism for SSL contexts indicates that repeated creation of these contexts can be avoided, but the initial setup and validation processes are inherently time-intensive and memory-heavy, making this configuration critical for overall system performance."
        }
    ]
}