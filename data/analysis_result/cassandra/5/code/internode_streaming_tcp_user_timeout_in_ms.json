{
    "performance_sensitive": "Yes",
    "config_name": "internode_streaming_tcp_user_timeout_in_ms",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "public int tcpUserTimeoutInMS(ConnectionCategory category)\n    {\n        // Reusing tcpUserTimeoutInMS for both messaging and streaming, since the connection is created for either one of them.\n        if (tcpUserTimeoutInMS != null)\n            return tcpUserTimeoutInMS;\n\n        switch (category)\n        {\n            case MESSAGING: return DatabaseDescriptor.getInternodeTcpUserTimeoutInMS();\n            case STREAMING: return DatabaseDescriptor.getInternodeStreamingTcpUserTimeoutInMS();\n            default: throw new IllegalArgumentException(\"Unknown connection category: \" + category);\n        }\n    }\n\n    \npublic int getInternodeStreamingTcpUserTimeoutInMS()\n    {\n        return DatabaseDescriptor.getInternodeStreamingTcpUserTimeoutInMS();\n    }\n\n    \n/**\n     * Call back after receiving a stream.\n     *\n     * @param message received stream\n     */\npublic void receive(IncomingStreamMessage message)\n    {\n        if (isPreview())\n        {\n            throw new RuntimeException(String.format(\"[Stream #%s] Cannot receive files for preview session\", planId()));\n        }\n\n        long headerSize = message.stream.getSize();\n        StreamingMetrics.totalIncomingBytes.inc(headerSize);\n        metrics.incomingBytes.inc(headerSize);\n        // send back file received message\n        messageSender.sendMessage(new ReceivedMessage(message.header.tableId, message.header.sequenceNumber));\n        StreamHook.instance.reportIncomingStream(message.header.tableId, message.stream, this, message.header.sequenceNumber);\n        long receivedStartNanos = System.nanoTime();\n        try\n        {\n            receivers.get(message.header.tableId).received(message.stream);\n        }\n        finally\n        {\n            long latencyNanos = System.nanoTime() - receivedStartNanos;\n            metrics.incomingProcessTime.update(latencyNanos, TimeUnit.NANOSECONDS);\n            long latencyMs = TimeUnit.NANOSECONDS.toMillis(latencyNanos);\n            int timeout = DatabaseDescriptor.getInternodeStreamingTcpUserTimeoutInMS();\n            if (timeout > 0 && latencyMs > timeout)\n                NoSpamLogger.log(logger, NoSpamLogger.Level.WARN,\n                                 1, TimeUnit.MINUTES,\n                                 \"The time taken ({} ms) for processing the incoming stream message ({})\" +\n                                 \" exceeded internode streaming TCP user timeout ({} ms).\\n\" +\n                                 \"The streaming connection might be closed due to tcp user timeout.\\n\" +\n                                 \"Try to increase the internode_streaming_tcp_user_timeout_in_ms\" +\n                                 \" or set it to 0 to use system defaults.\",\n                                 latencyMs, message, timeout);\n        }\n    }\n\n    "
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `internode_streaming_tcp_user_timeout_in_ms` directly impacts the processing of incoming stream messages. If the processing time exceeds this timeout, it can lead to the closure of the streaming connection, which can significantly affect system performance during high-load scenarios. The timeout value is crucial for managing latency and ensuring that the system can handle time-intensive operations efficiently, making it a key configuration for performance optimization."
        }
    ]
}