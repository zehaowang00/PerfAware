{
    "performance_sensitive": "Yes",
    "config_name": "transparent_data_encryption_options",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "@VisibleForTesting\n    CommitLog(CommitLogArchiver archiver, Function<CommitLog, AbstractCommitLogSegmentManager> segmentManagerProvider)\n    {\n        this.configuration = new Configuration(DatabaseDescriptor.getCommitLogCompression(),\n                                               DatabaseDescriptor.getEncryptionContext());\n        DatabaseDescriptor.createAllDirectories();\n\n        this.archiver = archiver;\n        metrics = new CommitLogMetrics();\n\n        switch (DatabaseDescriptor.getCommitLogSync())\n        {\n            case periodic:\n                executor = new PeriodicCommitLogService(this);\n                break;\n            case batch:\n                executor = new BatchCommitLogService(this);\n                break;\n            case group:\n                executor = new GroupCommitLogService(this);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown commitlog service type: \" + DatabaseDescriptor.getCommitLogSync());\n        }\n\n        segmentManager = segmentManagerProvider.apply(this);\n\n        // register metrics\n        metrics.attach(executor, segmentManager);\n    }\n\n    \n/**\n     * FOR TESTING PURPOSES.\n     */\n@VisibleForTesting\n    synchronized public void resetConfiguration()\n    {\n        configuration = new Configuration(DatabaseDescriptor.getCommitLogCompression(),\n                                          DatabaseDescriptor.getEncryptionContext());\n    }\n\n    \npublic void maybeRestoreArchive()\n    {\n        if (Strings.isNullOrEmpty(restoreDirectories))\n            return;\n\n        for (String dir : restoreDirectories.split(DELIMITER))\n        {\n            File[] files = new File(dir).listFiles();\n            if (files == null)\n            {\n                throw new RuntimeException(\"Unable to list directory \" + dir);\n            }\n            for (File fromFile : files)\n            {\n                CommitLogDescriptor fromHeader = CommitLogDescriptor.fromHeader(fromFile, DatabaseDescriptor.getEncryptionContext());\n                CommitLogDescriptor fromName = CommitLogDescriptor.isValid(fromFile.getName()) ? CommitLogDescriptor.fromFileName(fromFile.getName()) : null;\n                CommitLogDescriptor descriptor;\n                if (fromHeader == null && fromName == null)\n                    throw new IllegalStateException(\"Cannot safely construct descriptor for segment, either from its name or its header: \" + fromFile.getPath());\n                else if (fromHeader != null && fromName != null && !fromHeader.equalsIgnoringCompression(fromName))\n                    throw new IllegalStateException(String.format(\"Cannot safely construct descriptor for segment, as name and header descriptors do not match (%s vs %s): %s\", fromHeader, fromName, fromFile.getPath()));\n                else if (fromName != null && fromHeader == null)\n                    throw new IllegalStateException(\"Cannot safely construct descriptor for segment, as name descriptor implies a version that should contain a header descriptor, but that descriptor could not be read: \" + fromFile.getPath());\n                else if (fromHeader != null)\n                    descriptor = fromHeader;\n                else descriptor = fromName;\n\n                if (descriptor.version > CommitLogDescriptor.current_version)\n                    throw new IllegalStateException(\"Unsupported commit log version: \" + descriptor.version);\n\n                if (descriptor.compression != null)\n                {\n                    try\n                    {\n                        CompressionParams.createCompressor(descriptor.compression);\n                    }\n                    catch (ConfigurationException e)\n                    {\n                        throw new IllegalStateException(\"Unknown compression\", e);\n                    }\n                }\n\n                File toFile = new File(DatabaseDescriptor.getCommitLogLocation(), descriptor.fileName());\n                if (toFile.exists())\n                {\n                    logger.trace(\"Skipping restore of archive {} as the segment already exists in the restore location {}\",\n                                 fromFile.getPath(), toFile.getPath());\n                    continue;\n                }\n\n                String command = FROM.matcher(restoreCommand).replaceAll(Matcher.quoteReplacement(fromFile.getPath()));\n                command = TO.matcher(command).replaceAll(Matcher.quoteReplacement(toFile.getPath()));\n                try\n                {\n                    exec(command);\n                }\n                catch (IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n    }\n\n    \nprivate static boolean shouldSkip(File file) throws IOException, ConfigurationException\n    {\n        try(RandomAccessReader reader = RandomAccessReader.open(file))\n        {\n            CommitLogDescriptor.readHeader(reader, DatabaseDescriptor.getEncryptionContext());\n            int end = reader.readInt();\n            long filecrc = reader.readInt() & 0xffffffffL;\n            return end == 0 && filecrc == 0;\n        }\n    }\n\n    \n/**\n     * Reads passed in file fully, up to mutationLimit count\n     */\n@VisibleForTesting\n    public void readCommitLogSegment(CommitLogReadHandler handler, File file, int mutationLimit, boolean tolerateTruncation) throws IOException\n    {\n        readCommitLogSegment(handler, file, CommitLogPosition.NONE, mutationLimit, tolerateTruncation);\n    }\n\n    \n/**\n     * Reads mutations from file, handing them off to handler\n     * @param handler Handler that will take action based on deserialized Mutations\n     * @param file CommitLogSegment file to read\n     * @param minPosition Optional minimum CommitLogPosition - all segments with id larger or matching w/greater position will be read\n     * @param mutationLimit Optional limit on # of mutations to replay. Local ALL_MUTATIONS serves as marker to play all.\n     * @param tolerateTruncation Whether or not we should allow truncation of this file or throw if EOF found\n     *\n     * @throws IOException\n     */\npublic void readCommitLogSegment(CommitLogReadHandler handler,\n                                     File file,\n                                     CommitLogPosition minPosition,\n                                     int mutationLimit,\n                                     boolean tolerateTruncation) throws IOException\n    {\n        // just transform from the file name (no reading of headers) to determine version\n        CommitLogDescriptor desc = CommitLogDescriptor.fromFileName(file.getName());\n\n        try(RandomAccessReader reader = RandomAccessReader.open(file))\n        {\n            final long segmentIdFromFilename = desc.id;\n            try\n            {\n                // The following call can either throw or legitimately return null. For either case, we need to check\n                // desc outside this block and set it to null in the exception case.\n                desc = CommitLogDescriptor.readHeader(reader, DatabaseDescriptor.getEncryptionContext());\n            }\n            catch (Exception e)\n            {\n                desc = null;\n            }\n            if (desc == null)\n            {\n                // don't care about whether or not the handler thinks we can continue. We can't w/out descriptor.\n                // whether or not we can continue depends on whether this is the last segment\n                handler.handleUnrecoverableError(new CommitLogReadException(\n                    String.format(\"Could not read commit log descriptor in file %s\", file),\n                    CommitLogReadErrorReason.UNRECOVERABLE_DESCRIPTOR_ERROR,\n                    tolerateTruncation));\n                return;\n            }\n\n            if (segmentIdFromFilename != desc.id)\n            {\n                if (handler.shouldSkipSegmentOnError(new CommitLogReadException(String.format(\n                    \"Segment id mismatch (filename %d, descriptor %d) in file %s\", segmentIdFromFilename, desc.id, file),\n                                                                                CommitLogReadErrorReason.RECOVERABLE_DESCRIPTOR_ERROR,\n                                                                                false)))\n                {\n                    return;\n                }\n            }\n\n            if (shouldSkipSegmentId(file, desc, minPosition))\n                return;\n\n            CommitLogSegmentReader segmentReader;\n            try\n            {\n                segmentReader = new CommitLogSegmentReader(handler, desc, reader, tolerateTruncation);\n            }\n            catch(Exception e)\n            {\n                handler.handleUnrecoverableError(new CommitLogReadException(\n                    String.format(\"Unable to create segment reader for commit log file: %s\", e),\n                    CommitLogReadErrorReason.UNRECOVERABLE_UNKNOWN_ERROR,\n                    tolerateTruncation));\n                return;\n            }\n\n            try\n            {\n                ReadStatusTracker statusTracker = new ReadStatusTracker(mutationLimit, tolerateTruncation);\n                for (CommitLogSegmentReader.SyncSegment syncSegment : segmentReader)\n                {\n                    // Only tolerate truncation if we allow in both global and segment\n                    statusTracker.tolerateErrorsInSection = tolerateTruncation & syncSegment.toleratesErrorsInSection;\n\n                    // Skip segments that are completely behind the desired minPosition\n                    if (desc.id == minPosition.segmentId && syncSegment.endPosition < minPosition.position)\n                        continue;\n\n                    statusTracker.errorContext = String.format(\"Next section at %d in %s\", syncSegment.fileStartPosition, desc.fileName());\n\n                    readSection(handler, syncSegment.input, minPosition, syncSegment.endPosition, statusTracker, desc);\n                    if (!statusTracker.shouldContinue())\n                        break;\n                }\n            }\n            // Unfortunately AbstractIterator cannot throw a checked exception, so we check to see if a RuntimeException\n            // is wrapping an IOException.\n            catch (RuntimeException re)\n            {\n                if (re.getCause() instanceof IOException)\n                    throw (IOException) re.getCause();\n                throw re;\n            }\n            logger.info(\"Finished reading {}\", file);\n        }\n    }\n\n    \n/**\n     * Upon replay completion, CDC needs to hard-link files in the CDC folder and calculate index files so consumers can\n     * begin their work.\n     */\nprivate void handleCDCReplayCompletion(File f) throws IOException\n    {\n        // Can only reach this point if CDC is enabled, thus we have a CDCSegmentManager\n        ((CommitLogSegmentManagerCDC)CommitLog.instance.segmentManager).addCDCSize(f.length());\n\n        File dest = new File(DatabaseDescriptor.getCDCLogLocation(), f.getName());\n\n        // If hard link already exists, assume it's from a previous node run. If people are mucking around in the cdc_raw\n        // directory that's on them.\n        if (!dest.exists())\n            FileUtils.createHardLink(f, dest);\n\n        // The reader has already verified we can deserialize the descriptor.\n        CommitLogDescriptor desc;\n        try(RandomAccessReader reader = RandomAccessReader.open(f))\n        {\n            desc = CommitLogDescriptor.readHeader(reader, DatabaseDescriptor.getEncryptionContext());\n            assert desc != null;\n            assert f.length() < Integer.MAX_VALUE;\n            CommitLogSegment.writeCDCIndexFile(desc, (int)f.length(), true);\n        }\n    }\n\n\n    \n/**\n     * Create, if necessary, the required encryption components (for either decrpyt or encrypt operations).\n     * Note that in the case of encyption (this is, when writing out a new hints file), we need to write\n     * the cipher's IV out to the header so it can be used when decrypting. Thus, we need to add an additional\n     * entry to the {@code params} map.\n     *\n     * @param params the base parameters into the descriptor.\n     * @return null if not using encryption; else, the initialized {@link Cipher} and a possibly updated version\n     * of the {@code params} map.\n     */\n@SuppressWarnings(\"unchecked\")\n    static EncryptionData createEncryption(ImmutableMap<String, Object> params)\n    {\n        if (params.containsKey(ENCRYPTION))\n        {\n            Map<?, ?> encryptionConfig = (Map<?, ?>) params.get(ENCRYPTION);\n            EncryptionContext encryptionContext = EncryptionContext.createFromMap(encryptionConfig, DatabaseDescriptor.getEncryptionContext());\n\n            try\n            {\n                Cipher cipher;\n                if (encryptionConfig.containsKey(EncryptionContext.ENCRYPTION_IV))\n                {\n                    cipher = encryptionContext.getDecryptor();\n                }\n                else\n                {\n                    cipher = encryptionContext.getEncryptor();\n                    ImmutableMap<String, Object> encParams = ImmutableMap.<String, Object>builder()\n                                                                 .putAll(encryptionContext.toHeaderParameters())\n                                                                 .put(EncryptionContext.ENCRYPTION_IV, Hex.bytesToHex(cipher.getIV()))\n                                                                 .build();\n\n                    Map<String, Object> map = new HashMap<>(params);\n                    map.put(ENCRYPTION, encParams);\n                    params = ImmutableMap.<String, Object>builder().putAll(map).build();\n                }\n                return new EncryptionData(cipher, encryptionContext.getCompressor(), params);\n            }\n            catch (IOException ioe)\n            {\n                logger.warn(\"failed to create encyption context for hints file. ignoring encryption for hints.\", ioe);\n                return null;\n            }\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    "
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The use of encryption in the commit log process can significantly impact performance due to the computational overhead associated with encryption and decryption operations. The configuration involves creating encryption contexts and managing cipher operations, which are inherently time-intensive. Additionally, the handling of commit logs and their restoration can involve substantial memory usage, especially when dealing with large files or numerous segments. Therefore, any misconfiguration or inefficiency in this area can lead to considerable performance degradation in the system."
        }
    ]
}