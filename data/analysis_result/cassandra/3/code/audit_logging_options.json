{
    "performance_sensitive": "Yes",
    "config_name": "audit_logging_options",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "private AuditLogManager()\n    {\n        final AuditLogOptions auditLogOptions = DatabaseDescriptor.getAuditLoggingOptions();\n\n        if (auditLogOptions.enabled)\n        {\n            logger.info(\"Audit logging is enabled.\");\n            auditLogger = getAuditLogger(auditLogOptions.logger);\n        }\n        else\n        {\n            logger.debug(\"Audit logging is disabled.\");\n            auditLogger = new NoOpAuditLogger(Collections.emptyMap());\n        }\n\n        filter = AuditLogFilter.create(auditLogOptions);\n    }\n\n    \npublic void initialize()\n    {\n        if (DatabaseDescriptor.getAuditLoggingOptions().enabled)\n            registerAsListener();\n    }\n\n    \npublic BinAuditLogger(Map<String, String> params)\n    {\n        AuditLogOptions auditLoggingOptions = DatabaseDescriptor.getAuditLoggingOptions();\n\n        this.binLog = new BinLog.Builder().path(Paths.get(auditLoggingOptions.audit_logs_dir))\n                                          .rollCycle(auditLoggingOptions.roll_cycle)\n                                          .blocking(auditLoggingOptions.block)\n                                          .maxQueueWeight(auditLoggingOptions.max_queue_weight)\n                                          .maxLogSize(auditLoggingOptions.max_log_size)\n                                          .archiveCommand(auditLoggingOptions.archive_command)\n                                          .maxArchiveRetries(auditLoggingOptions.max_archive_retries)\n                                          .build(false);\n    }\n\n    \npublic void enableAuditLog(String loggerName, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,\n                               String includedUsers, String excludedUsers) throws ConfigurationException, IllegalStateException\n    {\n        enableAuditLog(loggerName, Collections.emptyMap(), includedKeyspaces, excludedKeyspaces, includedCategories, excludedCategories, includedUsers, excludedUsers);\n    }\n\n    \npublic void enableAuditLog(String loggerName, Map<String, String> parameters, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,\n                               String includedUsers, String excludedUsers) throws ConfigurationException, IllegalStateException\n    {\n        loggerName = loggerName != null ? loggerName : DatabaseDescriptor.getAuditLoggingOptions().logger.class_name;\n\n        Preconditions.checkNotNull(loggerName, \"cassandra.yaml did not have logger in audit_logging_option and not set as parameter\");\n        Preconditions.checkState(FBUtilities.isAuditLoggerClassExists(loggerName), \"Unable to find AuditLogger class: \"+loggerName);\n\n        AuditLogOptions auditLogOptions = new AuditLogOptions();\n        auditLogOptions.enabled = true;\n        auditLogOptions.logger = new ParameterizedClass(loggerName, parameters);\n        auditLogOptions.included_keyspaces = includedKeyspaces != null ? includedKeyspaces : DatabaseDescriptor.getAuditLoggingOptions().included_keyspaces;\n        auditLogOptions.excluded_keyspaces = excludedKeyspaces != null ? excludedKeyspaces : DatabaseDescriptor.getAuditLoggingOptions().excluded_keyspaces;\n        auditLogOptions.included_categories = includedCategories != null ? includedCategories : DatabaseDescriptor.getAuditLoggingOptions().included_categories;\n        auditLogOptions.excluded_categories = excludedCategories != null ? excludedCategories : DatabaseDescriptor.getAuditLoggingOptions().excluded_categories;\n        auditLogOptions.included_users = includedUsers != null ? includedUsers : DatabaseDescriptor.getAuditLoggingOptions().included_users;\n        auditLogOptions.excluded_users = excludedUsers != null ? excludedUsers : DatabaseDescriptor.getAuditLoggingOptions().excluded_users;\n\n        AuditLogManager.instance.enable(auditLogOptions);\n\n        logger.info(\"AuditLog is enabled with logger: [{}], included_keyspaces: [{}], excluded_keyspaces: [{}], \" +\n                    \"included_categories: [{}], excluded_categories: [{}], included_users: [{}], \"\n                    + \"excluded_users: [{}], archive_command: [{}]\", auditLogOptions.logger, auditLogOptions.included_keyspaces, auditLogOptions.excluded_keyspaces,\n                    auditLogOptions.included_categories, auditLogOptions.excluded_categories, auditLogOptions.included_users, auditLogOptions.excluded_users,\n                    auditLogOptions.archive_command);\n\n    }\n\n    "
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The audit logging options can significantly impact system performance due to their potential for high memory usage and time-intensive operations, especially when logging extensive data or handling large volumes of audit logs. The configuration parameters such as `maxLogSize`, `maxQueueWeight`, and `archiveCommand` can lead to substantial variations in performance depending on their values and how they interact with the system's logging and archiving processes. If audit logging is enabled, it can introduce overhead that may affect the overall system responsiveness and resource utilization, making it a critical area for performance consideration."
        }
    ]
}