{
    "performance_sensitive": "Yes",
    "config_name": "file_cache_enabled",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "public class ChunkCache\n        implements CacheLoader<ChunkCache.Key, ChunkCache.Buffer>, RemovalListener<ChunkCache.Key, ChunkCache.Buffer>, CacheSize\n{\n    public static final int RESERVED_POOL_SPACE_IN_MB = 32;\n    public static final long cacheSize = 1024L * 1024L * Math.max(0, DatabaseDescriptor.getFileCacheSizeInMB() - RESERVED_POOL_SPACE_IN_MB);\n    public static final boolean roundUp = DatabaseDescriptor.getFileCacheRoundUp();\n\n    private static boolean enabled = DatabaseDescriptor.getFileCacheEnabled() && cacheSize > 0;\n    public static final ChunkCache instance = enabled ? new ChunkCache(BufferPools.forChunkCache()) : null;\n\n    private final BufferPool bufferPool;\n\n    private final LoadingCache<Key, Buffer> cache;\n    public final ChunkCacheMetrics metrics;\n\n    static class Key\n    {\n        final ChunkReader file;\n        final String path;\n        final long position;\n\n        public Key(ChunkReader file, long position)\n        {\n            super();\n            this.file = file;\n            this.position = position;\n            this.path = file.channel().filePath();\n        }\n\n        public int hashCode()\n        {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + path.hashCode();\n            result = prime * result + file.getClass().hashCode();\n            result = prime * result + Long.hashCode(position);\n            return result;\n        }\n\n        public boolean equals(Object obj)\n        {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n\n            Key other = (Key) obj;\n            return (position == other.position)\n                    && file.getClass() == other.file.getClass()\n                    && path.equals(other.path);\n        }\n    }\n\n    class Buffer implements Rebufferer.BufferHolder\n    {\n        private final ByteBuffer buffer;\n        private final long offset;\n        private final AtomicInteger references;\n\n        public Buffer(ByteBuffer buffer, long offset)\n        {\n            this.buffer = buffer;\n            this.offset = offset;\n            references = new AtomicInteger(1);  // start referenced.\n        }\n\n        Buffer reference()\n        {\n            int refCount;\n            do\n            {\n                refCount = references.get();\n                if (refCount == 0)\n                    // Buffer was released before we managed to reference it.\n                    return null;\n            } while (!references.compareAndSet(refCount, refCount + 1));\n\n            return this;\n        }\n\n        @Override\n        public ByteBuffer buffer()\n        {\n            assert references.get() > 0;\n            return buffer.duplicate();\n        }\n\n        @Override\n        public long offset()\n        {\n            return offset;\n        }\n\n        @Override\n        public void release()\n        {\n            if (references.decrementAndGet() == 0)\n                bufferPool.put(buffer);\n        }\n    }\n\n    private ChunkCache(BufferPool pool)\n    {\n        bufferPool = pool;\n        metrics = new ChunkCacheMetrics(this);\n        cache = Caffeine.newBuilder()\n                        .maximumWeight(cacheSize)\n                        .executor(MoreExecutors.directExecutor())\n                        .weigher((key, buffer) -> ((Buffer) buffer).buffer.capacity())\n                        .removalListener(this)\n                        .recordStats(() -> metrics)\n                        .build(this);\n    }\n\n    @Override\n    public Buffer load(Key key)\n    {\n        ByteBuffer buffer = bufferPool.get(key.file.chunkSize(), key.file.preferredBufferType());\n        assert buffer != null;\n        key.file.readChunk(key.position, buffer);\n        return new Buffer(buffer, key.position);\n    }\n\n    @Override\n    public void onRemoval(Key key, Buffer buffer, RemovalCause cause)\n    {\n        buffer.release();\n    }\n\n    public void close()\n    {\n        cache.invalidateAll();\n    }\n\n    private RebuffererFactory wrap(ChunkReader file)\n    {\n        return new CachingRebufferer(file);\n    }\n\n    public static RebuffererFactory maybeWrap(ChunkReader file)\n    {\n        if (!enabled)\n            return file;\n\n        return instance.wrap(file);\n    }\n\n    public void invalidatePosition(FileHandle dfile, long position)\n    {\n        if (!(dfile.rebuffererFactory() instanceof CachingRebufferer))\n            return;\n\n        ((CachingRebufferer) dfile.rebuffererFactory()).invalidate(position);\n    }\n\n    public void invalidateFile(String fileName)\n    {\n        cache.invalidateAll(Iterables.filter(cache.asMap().keySet(), x -> x.path.equals(fileName)));\n    }\n\n    @VisibleForTesting\n    public void enable(boolean enabled)\n    {\n        ChunkCache.enabled = enabled;\n        cache.invalidateAll();\n        metrics.reset();\n    }\n\n    // TODO: Invalidate caches for obsoleted/MOVED_START tables?\n\n    /**\n     * Rebufferer providing cached chunks where data is obtained from the specified ChunkReader.\n     * Thread-safe. One instance per SegmentedFile, created by ChunkCache.maybeWrap if the cache is enabled.\n     */\n    class CachingRebufferer implements Rebufferer, RebuffererFactory\n    {\n        private final ChunkReader source;\n        final long alignmentMask;\n\n        public CachingRebufferer(ChunkReader file)\n        {\n            source = file;\n            int chunkSize = file.chunkSize();\n            assert Integer.bitCount(chunkSize) == 1 : String.format(\"%d must be a power of two\", chunkSize);\n            alignmentMask = -chunkSize;\n        }\n\n        @Override\n        public Buffer rebuffer(long position)\n        {\n            try\n            {\n                long pageAlignedPos = position & alignmentMask;\n                Buffer buf;\n                do\n                    buf = cache.get(new Key(source, pageAlignedPos)).reference();\n                while (buf == null);\n\n                return buf;\n            }\n            catch (Throwable t)\n            {\n                Throwables.propagateIfInstanceOf(t.getCause(), CorruptSSTableException.class);\n                throw Throwables.propagate(t);\n            }\n        }\n\n        public void invalidate(long position)\n        {\n            long pageAlignedPos = position & alignmentMask;\n            cache.invalidate(new Key(source, pageAlignedPos));\n        }\n\n        @Override\n        public Rebufferer instantiateRebufferer()\n        {\n            return this;\n        }\n\n        @Override\n        public void close()\n        {\n            source.close();\n        }\n\n        @Override\n        public void closeReader()\n        {\n            // Instance is shared among readers. Nothing to release.\n        }\n\n        @Override\n        public ChannelProxy channel()\n        {\n            return source.channel();\n        }\n\n        @Override\n        public long fileLength()\n        {\n            return source.fileLength();\n        }\n\n        @Override\n        public double getCrcCheckChance()\n        {\n            return source.getCrcCheckChance();\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"CachingRebufferer:\" + source;\n        }\n    }\n\n    @Override\n    public long capacity()\n    {\n        return cacheSize;\n    }\n\n    @Override\n    public void setCapacity(long capacity)\n    {\n        throw new UnsupportedOperationException(\"Chunk cache size cannot be changed.\");\n    }\n\n    @Override\n    public int size()\n    {\n        return cache.asMap().size();\n    }\n\n    @Override\n    public long weightedSize()\n    {\n        return cache.policy().eviction()\n                .map(policy -> policy.weightedSize().orElseGet(cache::estimatedSize))\n                .orElseGet(cache::estimatedSize);\n    }\n}\n"
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `file_cache_enabled` configuration directly affects the instantiation of the `ChunkCache`, which manages a cache for chunk data. If caching is enabled, it significantly impacts performance by reducing the time spent on I/O operations when reading chunks from disk, as cached data can be accessed much faster than retrieving it from storage. This can lead to substantial performance variations, especially in systems with high data throughput or frequent access to large files, making it critical for overall system performance."
        }
    ]
}