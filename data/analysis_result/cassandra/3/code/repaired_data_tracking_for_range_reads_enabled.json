{
    "performance_sensitive": "Yes",
    "config_name": "repaired_data_tracking_for_range_reads_enabled",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "@Override\n    public boolean getRepairedDataTrackingEnabledForRangeReads()\n    {\n        return DatabaseDescriptor.getRepairedDataTrackingForRangeReadsEnabled();\n    }\n\n    \n/**\n     * Queries the provided sub-range.\n     *\n     * @param replicaPlan the subRange to query.\n     * @param isFirst in the case where multiple queries are sent in parallel, whether that's the first query on\n     * that batch or not. The reason it matters is that whe paging queries, the command (more specifically the\n     * {@code DataLimits}) may have \"state\" information and that state may only be valid for the first query (in\n     * that it's the query that \"continues\" whatever we're previously queried).\n     */\nprivate SingleRangeResponse query(ReplicaPlan.ForRangeRead replicaPlan, boolean isFirst)\n    {\n        PartitionRangeReadCommand rangeCommand = command.forSubRange(replicaPlan.range(), isFirst);\n        \n        // If enabled, request repaired data tracking info from full replicas, but\n        // only if there are multiple full replicas to compare results from.\n        boolean trackRepairedStatus = DatabaseDescriptor.getRepairedDataTrackingForRangeReadsEnabled()\n                                      && replicaPlan.contacts().filter(Replica::isFull).size() > 1;\n\n        ReplicaPlan.SharedForRangeRead sharedReplicaPlan = ReplicaPlan.shared(replicaPlan);\n        ReadRepair<EndpointsForRange, ReplicaPlan.ForRangeRead> readRepair =\n                ReadRepair.create(command, sharedReplicaPlan, queryStartNanoTime);\n        DataResolver<EndpointsForRange, ReplicaPlan.ForRangeRead> resolver =\n                new DataResolver<>(rangeCommand, sharedReplicaPlan, readRepair, queryStartNanoTime, trackRepairedStatus);\n        ReadCallback<EndpointsForRange, ReplicaPlan.ForRangeRead> handler =\n                new ReadCallback<>(resolver, rangeCommand, sharedReplicaPlan, queryStartNanoTime);\n\n        if (replicaPlan.contacts().size() == 1 && replicaPlan.contacts().get(0).isSelf())\n        {\n            Stage.READ.execute(new StorageProxy.LocalReadRunnable(rangeCommand, handler, trackRepairedStatus));\n        }\n        else\n        {\n            for (Replica replica : replicaPlan.contacts())\n            {\n                Tracing.trace(\"Enqueuing request to {}\", replica);\n                ReadCommand command = replica.isFull() ? rangeCommand : rangeCommand.copyAsTransientQuery(replica);\n                Message<ReadCommand> message = command.createMessage(trackRepairedStatus && replica.isFull());\n                MessagingService.instance().sendWithCallback(message, replica.endpoint(), handler);\n            }\n        }\n\n        return new SingleRangeResponse(resolver, handler, readRepair);\n    }\n\n    "
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Sensitive: The `repaired_data_tracking_for_range_reads_enabled` configuration directly influences whether repaired data tracking is requested from replicas during range reads. This can lead to significant performance variations, especially when multiple full replicas are involved, as it may trigger additional data retrieval and processing operations that are time-intensive. The presence of multiple full replicas can amplify the performance impact, making this configuration critical for overall system performance during read operations."
        }
    ]
}