{
    "performance_sensitive": "No",
    "config_name": "enable_drop_compact_storage",
    "messages": [
        {
            "sender": "System",
            "content": "Initialize the analysis for the target system and configuration."
        },
        {
            "sender": "Developer",
            "content": "public Keyspaces apply(Keyspaces schema) throws UnknownHostException\n    {\n        KeyspaceMetadata keyspace = schema.getNullable(keyspaceName);\n\n        TableMetadata table = null == keyspace\n                            ? null\n                            : keyspace.getTableOrViewNullable(tableName);\n\n        if (null == table)\n            throw ire(\"Table '%s.%s' doesn't exist\", keyspaceName, tableName);\n\n        if (table.isView())\n            throw ire(\"Cannot use ALTER TABLE on a materialized view; use ALTER MATERIALIZED VIEW instead\");\n\n        return schema.withAddedOrUpdated(apply(keyspace, table));\n    }\n\n    \npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            throw ire(\"Altering column types is no longer supported\");\n        }\n    }\npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            TableMetadata.Builder tableBuilder = table.unbuild();\n            Views.Builder viewsBuilder = keyspace.views.unbuild();\n            newColumns.forEach(c -> addColumn(keyspace, table, c, tableBuilder, viewsBuilder));\n            TableMetadata tableMetadata = tableBuilder.build();\n            tableMetadata.validate();\n\n            return keyspace.withSwapped(keyspace.tables.withSwapped(tableMetadata))\n                           .withSwapped(viewsBuilder.build());\n        }\n\n        \npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            TableMetadata.Builder builder = table.unbuild();\n            removedColumns.forEach(c -> dropColumn(keyspace, table, c, builder));\n            return keyspace.withSwapped(keyspace.tables.withSwapped(builder.build()));\n        }\n\n        \npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            TableMetadata.Builder tableBuilder = table.unbuild();\n            Views.Builder viewsBuilder = keyspace.views.unbuild();\n            renamedColumns.forEach((o, n) -> renameColumn(keyspace, table, o, n, tableBuilder, viewsBuilder));\n\n            return keyspace.withSwapped(keyspace.tables.withSwapped(tableBuilder.build()))\n                           .withSwapped(viewsBuilder.build());\n        }\n\n        \npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            attrs.validate();\n\n            TableParams params = attrs.asAlteredTableParams(table.params);\n\n            if (table.isCounter() && params.defaultTimeToLive > 0)\n                throw ire(\"Cannot set default_time_to_live on a table with counters\");\n\n            if (!isEmpty(keyspace.views.forTable(table.id)) && params.gcGraceSeconds == 0)\n            {\n                throw ire(\"Cannot alter gc_grace_seconds of the base table of a \" +\n                          \"materialized view to 0, since this value is used to TTL \" +\n                          \"undelivered updates. Setting gc_grace_seconds too low might \" +\n                          \"cause undelivered updates to expire \" +\n                          \"before being replayed.\");\n            }\n\n            if (keyspace.createReplicationStrategy().hasTransientReplicas()\n                && params.readRepair != ReadRepairStrategy.NONE)\n            {\n                throw ire(\"read_repair must be set to 'NONE' for transiently replicated keyspaces\");\n            }\n\n            return keyspace.withSwapped(keyspace.tables.withSwapped(table.withSwapped(params)));\n        }\n    }\npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n        {\n            if (!DatabaseDescriptor.enableDropCompactStorage())\n                throw new InvalidRequestException(\"DROP COMPACT STORAGE is disabled. Enable in cassandra.yaml to use.\");\n\n            if (!table.isCompactTable())\n                throw AlterTableStatement.ire(\"Cannot DROP COMPACT STORAGE on table without COMPACT STORAGE\");\n\n            validateCanDropCompactStorage();\n\n            Set<Flag> flags = table.isCounter()\n                            ? ImmutableSet.of(Flag.COMPOUND, Flag.COUNTER)\n                            : ImmutableSet.of(Flag.COMPOUND);\n\n            return keyspace.withSwapped(keyspace.tables.withSwapped(table.withSwapped(flags)));\n        }\n\n        "
        },
        {
            "sender": "Developer Filter",
            "content": "Filter of the code context that is related to configuration: ```java\npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\n{\n    if (!DatabaseDescriptor.enableDropCompactStorage())\n        throw new InvalidRequestException(\"DROP COMPACT STORAGE is disabled. Enable in cassandra.yaml to use.\");\n\n    if (!table.isCompactTable())\n        throw AlterTableStatement.ire(\"Cannot DROP COMPACT STORAGE on table without COMPACT STORAGE\");\n\n    validateCanDropCompactStorage();\n\n    Set<Flag> flags = table.isCounter()\n                    ? ImmutableSet.of(Flag.COMPOUND, Flag.COUNTER)\n                    : ImmutableSet.of(Flag.COMPOUND);\n\n    return keyspace.withSwapped(keyspace.tables.withSwapped(table.withSwapped(flags)));\n}\n```"
        },
        {
            "sender": "Developer summary",
            "content": "Summary of the extracted code context: ### Configuration Summary: `enable_drop_compact_storage`\n\nThe `enable_drop_compact_storage` configuration plays a critical role in managing the storage format of tables within the system, specifically in the context of Apache Cassandra. This configuration determines whether the operation to drop compact storage is permitted for tables in the database.\n\n#### Purpose:\nThe primary purpose of this configuration is to control the ability to alter the storage format of tables that utilize compact storage. When enabled, it allows users to execute the `DROP COMPACT STORAGE` command, which can change how data is stored and accessed.\n\n#### Functionality:\n- The configuration is checked at runtime using `DatabaseDescriptor.enableDropCompactStorage()`. If the configuration is disabled, an `InvalidRequestException` is thrown, preventing the operation from proceeding.\n- The method also verifies that the table on which the operation is being attempted is indeed a compact table. If not, another exception is raised, ensuring that the operation is only applied to appropriate tables.\n\n#### Dependencies and Interactions:\n- **Key Components**: The key components involved include `KeyspaceMetadata`, `TableMetadata`, and the `DatabaseDescriptor` class, which holds the configuration settings.\n- **Interactions**: This configuration interacts with the table's metadata to determine if it can be altered. It also checks for specific flags associated with the table (e.g., whether it is a counter table) and adjusts the table's metadata accordingly.\n- The method ultimately returns an updated `KeyspaceMetadata` object that reflects the changes made to the table's metadata based on the configuration and the operation performed.\n\nIn summary, the `enable_drop_compact_storage` configuration is essential for controlling the alteration of table storage formats in Cassandra, ensuring that operations are only performed under valid conditions and maintaining the integrity of the database structure."
        },
        {
            "sender": "performance agent sensitivity",
            "content": "{\"Role\": \"You are a Performance Sensitivity Agent responsible for determining if a configuration is performance-sensitive within a software system.\", \"Requirement\": \"Using developer-provided information as a secondary reference, analyze the configuration-related code to determine if it is performance-sensitive. Focus exclusively on configurations with substantial system-level performance impact due to time-intensive or memory-intensive operations. Only configurations that directly cause significant performance variations through extremely time-consuming or memory-heavy operations should be classified as performance-sensitive. Minor or moderate impacts should not be considered.\", \"Output Format\": \"Respond strictly in one of the following formats: 'The configuration is Performance Sensitive: reason' or 'The configuration is Performance Insensitive: reason'. No other response format is acceptable. Provide a concise yet clear and detailed reason for your classification.\", \"configuration_name\": \"enable_drop_compact_storage\", \"code_context\": \"```java\\npublic KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)\\n{\\n    if (!DatabaseDescriptor.enableDropCompactStorage())\\n        throw new InvalidRequestException(\\\"DROP COMPACT STORAGE is disabled. Enable in cassandra.yaml to use.\\\");\\n\\n    if (!table.isCompactTable())\\n        throw AlterTableStatement.ire(\\\"Cannot DROP COMPACT STORAGE on table without COMPACT STORAGE\\\");\\n\\n    validateCanDropCompactStorage();\\n\\n    Set<Flag> flags = table.isCounter()\\n                    ? ImmutableSet.of(Flag.COMPOUND, Flag.COUNTER)\\n                    : ImmutableSet.of(Flag.COMPOUND);\\n\\n    return keyspace.withSwapped(keyspace.tables.withSwapped(table.withSwapped(flags)));\\n}\\n```\\n\\n--- Summary by Developer ---\\n### Configuration Summary: `enable_drop_compact_storage`\\n\\nThe `enable_drop_compact_storage` configuration plays a critical role in managing the storage format of tables within the system, specifically in the context of Apache Cassandra. This configuration determines whether the operation to drop compact storage is permitted for tables in the database.\\n\\n#### Purpose:\\nThe primary purpose of this configuration is to control the ability to alter the storage format of tables that utilize compact storage. When enabled, it allows users to execute the `DROP COMPACT STORAGE` command, which can change how data is stored and accessed.\\n\\n#### Functionality:\\n- The configuration is checked at runtime using `DatabaseDescriptor.enableDropCompactStorage()`. If the configuration is disabled, an `InvalidRequestException` is thrown, preventing the operation from proceeding.\\n- The method also verifies that the table on which the operation is being attempted is indeed a compact table. If not, another exception is raised, ensuring that the operation is only applied to appropriate tables.\\n\\n#### Dependencies and Interactions:\\n- **Key Components**: The key components involved include `KeyspaceMetadata`, `TableMetadata`, and the `DatabaseDescriptor` class, which holds the configuration settings.\\n- **Interactions**: This configuration interacts with the table's metadata to determine if it can be altered. It also checks for specific flags associated with the table (e.g., whether it is a counter table) and adjusts the table's metadata accordingly.\\n- The method ultimately returns an updated `KeyspaceMetadata` object that reflects the changes made to the table's metadata based on the configuration and the operation performed.\\n\\nIn summary, the `enable_drop_compact_storage` configuration is essential for controlling the alteration of table storage formats in Cassandra, ensuring that operations are only performed under valid conditions and maintaining the integrity of the database structure.\"}"
        },
        {
            "sender": "PerformanceSensitivity",
            "content": "The configuration is Performance Insensitive: While the `enable_drop_compact_storage` configuration controls the ability to alter the storage format of tables, the operations associated with this configuration do not involve time-intensive or memory-intensive processes that would significantly impact system performance. The checks performed are primarily validation steps that do not lead to substantial performance variations."
        }
    ]
}